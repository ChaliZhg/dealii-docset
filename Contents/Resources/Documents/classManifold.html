<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Manifold&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classManifold-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Manifold&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a> &raquo; <a class="el" href="group__manifold.html">Manifold description for triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">deal.II/grid/manifold.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Manifold&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classManifold__inherit__graph.svg" width="1968" height="1150"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a19ac29d8115569ec4ab6971a69222c22"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a19ac29d8115569ec4ab6971a69222c22">FaceVertexNormals</a>[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face]</td></tr>
<tr class="separator:a19ac29d8115569ec4ab6971a69222c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa26f10da4ffbb77db135fd61e9e1ff2c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#aa26f10da4ffbb77db135fd61e9e1ff2c">~Manifold</a> ()</td></tr>
<tr class="separator:aa26f10da4ffbb77db135fd61e9e1ff2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing the location of points.</div></td></tr>
<tr class="memitem:aace84e99db1f4767ce9e524170a1de2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const double w) const</td></tr>
<tr class="separator:aace84e99db1f4767ce9e524170a1de2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92f2144d52c79c8bb5d454c3640f04e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">get_new_point</a> (const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; spacedim &gt; &amp;quad) const 1</td></tr>
<tr class="separator:ae92f2144d52c79c8bb5d454c3640f04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a238181b2c3596b8d370b83aa5999a0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a3a238181b2c3596b8d370b83aa5999a0">get_new_point</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;surrounding_points, const std::vector&lt; double &gt; &amp;weights) const</td></tr>
<tr class="separator:a3a238181b2c3596b8d370b83aa5999a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab039ce4b6d15ab59f36fbd7923467faa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ab039ce4b6d15ab59f36fbd7923467faa">add_new_points</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, double &gt; &amp;weights, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;new_points) const</td></tr>
<tr class="separator:ab039ce4b6d15ab59f36fbd7923467faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01387e605d9c92c4486cd734da86e71"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">project_to_manifold</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;surrounding_points, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;candidate) const</td></tr>
<tr class="separator:ab01387e605d9c92c4486cd734da86e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af518522b81bdfe059b88bb557f7a60ba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af518522b81bdfe059b88bb557f7a60ba">get_new_point_on_line</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;line) const</td></tr>
<tr class="separator:af518522b81bdfe059b88bb557f7a60ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a7a18b04151504883074c24108266f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a59a7a18b04151504883074c24108266f">get_new_point_on_quad</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;quad) const</td></tr>
<tr class="separator:a59a7a18b04151504883074c24108266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8365135405a1f057020d84a315ffa6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a8d8365135405a1f057020d84a315ffa6">get_new_point_on_hex</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:a8d8365135405a1f057020d84a315ffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79c3a0f002136b483b50722ea6690d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#ab79c3a0f002136b483b50722ea6690d9">get_new_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face) const</td></tr>
<tr class="separator:ab79c3a0f002136b483b50722ea6690d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b25e230fefc6eb32d53cb6e69cbba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af36b25e230fefc6eb32d53cb6e69cbba">get_new_point_on_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:af36b25e230fefc6eb32d53cb6e69cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing tangent vectors</div></td></tr>
<tr class="memitem:adff3c7c6851d64d1839964f7ebbfc787"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x2) const</td></tr>
<tr class="separator:adff3c7c6851d64d1839964f7ebbfc787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing normal vectors</div></td></tr>
<tr class="memitem:a8f737627dc946fb68c097d6ec83419d4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:a8f737627dc946fb68c097d6ec83419d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8317a03ab0c13971ff53bcb38b49e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a2f8317a03ab0c13971ff53bcb38b49e9">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a19ac29d8115569ec4ab6971a69222c22">FaceVertexNormals</a> &amp;face_vertex_normals) const</td></tr>
<tr class="separator:a2f8317a03ab0c13971ff53bcb38b49e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class Manifold&lt; dim, spacedim &gt;</h3>

<p><a class="el" href="namespaceManifolds.html">Manifolds</a> are used to describe the geometry of boundaries of domains as well as the geometry of the interior. <a class="el" href="classManifold.html">Manifold</a> objects are therefore associated with cells, faces, and/or edges, either by direct user action or, if a user program does not do this explicitly, a default manifold object is used.</p>
<p><a class="el" href="namespaceManifolds.html">Manifolds</a> are best understood by using the language of differential geometry, but their common uses can be easily described simply through examples.</p>
<h3>Common use case: Creating a new vertex</h3>
<p>In the most essential use of manifolds, manifold descriptions are used to create a "point between other points". For example, when a triangulation creates a new vertex on a cell, face, or edge, it determines the new vertex' coordinates through the following function call: </p><div class="fragment"><div class="line">...</div><div class="line">Point&lt;spacedim&gt; new_vertex = manifold.get_new_point (points,weights);</div><div class="line">...</div></div><!-- fragment --><p> Here, <code>points</code> is a collection of points in <code>spacedim</code> dimension, and <code>a</code> collection of corresponding weights. The points in this context will then be the vertices of the cell, face, or edge, and the weights are typically one over the number of points when a new midpoint of the cell, face, or edge is needed. Derived classes then will implement the <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold::get_new_point()</a> function in a way that computes the location of this new point. In the simplest case, for example in the <a class="el" href="classFlatManifold.html">FlatManifold</a> class, the function simply computes the arithmetic average (with given weights) of the given points. However, other classes do something differently; for example, the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> class, which is used to describe domains that form (part of) the sphere, will ensure that, given the two vertices of an edge at the boundary, the new returned point will lie on the grand circle that connects the two points, rather than choosing a point that is half-way between the two points in <img class="formulaInl" alt="${\mathbb R}^d$" src="form_842.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>Unlike almost all other cases in the library, we here interpret the points to be in real space, not on the reference cell.</dd></dl>
<p><a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold::get_new_point()</a> has a default implementation that can simplify this process somewhat: Internally, the function calls the <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold::get_intermediate_point()</a> to compute pair-wise intermediate points. Internally the <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold::get_intermediate_point()</a> calls the <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">Manifold::project_to_manifold()</a> function after computing the convex conbination of the given points. This allows derived classes to only overload <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">Manifold::project_to_manifold()</a> for simple situations. This is often useful when describing manifolds that are embedded in higher dimensional space, e.g., the surface of a sphere. In those cases, the desired new point may be computed simply by the (weighted) average of the provided points, projected back out onto the sphere.</p>
<h3>Common use case: Computing tangent vectors</h3>
<p>The second use of this class is in computing directions on domains and boundaries. For example, we may need to compute the normal vector to a face in order to impose the no-flow boundary condition <img class="formulaInl" alt="$\mathbf u \cdot \mathbf n = 0$" src="form_843.png"/> (see the <a class="el" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">VectorTools::compute_no_normal_flux_constraints()</a> as an example). Similarly, we may need normal vectors in the computation of the normal component of the gradient of the numerical solution in order to compute the jump in the gradient of the solution in error estimators (see, for example, the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class).</p>
<p>To make this possible, the <a class="el" href="classManifold.html">Manifold</a> class provides a member function (to be implemented by derived classes) that computes a "vector tangent
to the manifold at one point, in direction of another point" via the <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold::get_tangent_vector()</a> function. For example, in 2d, one would use this function with the two vertices of an edge at the boundary to compute a "tangential" vector along the edge, and then get the normal vector by rotation by 90 degrees. In 3d, one would compute the two vectors "tangential" to the two edges of a boundary face adjacent to a boundary vertex, and then take the cross product of these two to obtain a vector normal to the boundary.</p>
<p>For reasons that are more difficult to understand, these direction vectors are normalized in a very specific way, rather than to have unit norm. See the documentation of <a class="el" href="classManifold.html#adff3c7c6851d64d1839964f7ebbfc787">Manifold::get_tangent_vector()</a>, as well as below, for more information.</p>
<p>In the simplest case (namely, the <a class="el" href="classFlatManifold.html">FlatManifold</a> class), these tangent vectors are just the difference vector between the two given points. However, in more complicated (and more interesting) cases, the direction may be different. For example, for the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> case, if the two given points lie on a common grand circle around the origin, then the tangent vector will be tangential to the grand circle, rather than pointing straight from one point to the other.</p>
<h3>A unified description</h3>
<p>The "real" way to understand what this class does is to see it in the framework of differential geometry. More specifically, differential geometry is fundamentally based on the assumption that two sufficiently close points are connected via a line of "shortest distance". This line is called a "geodesic", and it is selected from all other lines that connect the two points by the property that it is shortest if distances are measured in terms of the "metric" that describes a manifold. To give examples, recall that the geodesics of a flat manifold (implemented in the <a class="el" href="classFlatManifold.html">FlatManifold</a> class) are simply the straight lines connecting two points, whereas for spherical manifolds (see the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> class) geodesics between two points of same distance are the grand circles, and are in general curved lines when connecting two lines of different distance from the origin.</p>
<p>In the following discussion, and for the purposes of implementing the current class, the concept of "metrics" that is so fundamental to differential geometry is no longer of great importance to us. Rather, everything can simply be described by postulating the existence of geodesics connecting points on a manifold.</p>
<p>Given geodesics, the operations discussed in the previous two sections can be described in a more formal way. In essence, they rely on the fact that we can assume that a geodesic is parameterized by a "time" like variable <img class="formulaInl" alt="$t$" src="form_844.png"/> so that <img class="formulaInl" alt="$\mathbf s(t)$" src="form_845.png"/> describes the curve and so that <img class="formulaInl" alt="$\mathbf s(0)$" src="form_846.png"/> is the location of the first and <img class="formulaInl" alt="$\mathbf s(1)$" src="form_847.png"/> the location of the second point. Furthermore, <img class="formulaInl" alt="$\mathbf s(t)$" src="form_845.png"/> traces out the geodesic at constant speed, covering equal distance in equal time (as measured by the metric). Note that this parameterization uses time, not arc length to denote progress along the geodesic.</p>
<p>In this picture, computing a mid-point between points <img class="formulaInl" alt="$\mathbf x_1$" src="form_848.png"/> and <img class="formulaInl" alt="$\mathbf x_2$" src="form_849.png"/>, with weights <img class="formulaInl" alt="$w_1$" src="form_850.png"/> and <img class="formulaInl" alt="$w_2=1-w_1$" src="form_851.png"/>, simply requires computing the point <img class="formulaInl" alt="$\mathbf s(w_1)$" src="form_852.png"/>. Computing a new point as a weighted average of more than two points can be done by considering pairwise geodetics, finding suitable points on the geodetic between the first two points, then on the geodetic between this new point and the third given point, etc.</p>
<p>Likewise, the "tangential" vector described above is simply the velocity vector, <img class="formulaInl" alt="$\mathbf s'(t)$" src="form_853.png"/>, evaluated at one of the end points of a geodesic (i.e., at <img class="formulaInl" alt="$t=0$" src="form_854.png"/> or <img class="formulaInl" alt="$t=1$" src="form_855.png"/>). In the case of a flat manifold, the geodesic is simply the straight line connecting two points, and the velocity vector is just the connecting vector in that case. On the other hand, for two points on a spherical manifold, the geodesic is a grand circle, and the velocity vector is tangent to the spherical surface.</p>
<p>Note that if we wanted to, we could use this to compute the length of the geodesic that connects two points <img class="formulaInl" alt="$\mathbf x_1$" src="form_848.png"/> and <img class="formulaInl" alt="$\mathbf x_2$" src="form_849.png"/> by computing <img class="formulaInl" alt="$\int_0^1 \|\mathbf s'(t)\| dt$" src="form_856.png"/> along the geodesic that connects them, but this operation will not be of use to us in practice. One could also conceive computing the direction vector using the "new point" operation above, using the formula <img class="formulaInl" alt="$\mathbf s'(0)=\lim_{w\rightarrow 0} \frac{\mathbf s(w)-\mathbf s(0)}{w}$" src="form_857.png"/> where all we need to do is compute the new point <img class="formulaInl" alt="$\mathbf s(w)$" src="form_858.png"/> with weights <img class="formulaInl" alt="$w$" src="form_859.png"/> and <img class="formulaInl" alt="$1-w$" src="form_860.png"/> along the geodesic connecting <img class="formulaInl" alt="$\mathbf x_1$" src="form_848.png"/> and <img class="formulaInl" alt="$\mathbf x_2$" src="form_849.png"/>. The default implementation of the function does this, by evaluating the quotient for a small but finite weight <img class="formulaInl" alt="$w$" src="form_859.png"/>. In practice, however, it is almost always possible to explicitly compute the direction vector, i.e., without the need to numerically approximate the limit process, and derived classes should do so.</p>
<dl class="section author"><dt>Author</dt><dd>Luca Heltai, Wolfgang Bangerth, 2014, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00300">300</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a19ac29d8115569ec4ab6971a69222c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ac29d8115569ec4ab6971a69222c22">&#9670;&nbsp;</a></span>FaceVertexNormals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTensor.html">Tensor</a>&lt;1,spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::FaceVertexNormals[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#a679ee182f7a3e9c546fa5f6e7f029fb3">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself.</p>
<p>For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00307">307</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa26f10da4ffbb77db135fd61e9e1ff2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26f10da4ffbb77db135fd61e9e1ff2c">&#9670;&nbsp;</a></span>~Manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::~<a class="el" href="classManifold.html">Manifold</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Does nothing here, but needs to be declared virtual to make class hierarchies derived from this class possible. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00051">51</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aace84e99db1f4767ce9e524170a1de2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace84e99db1f4767ce9e524170a1de2c">&#9670;&nbsp;</a></span>get_intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an intermediate point between two given points. Overloading this function allows the default pair-wise reduction implementation of the method <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">get_new_point()</a> that takes a <a class="el" href="classQuadrature.html">Quadrature</a> object as input to work properly.</p>
<p>An implementation of this function should returns a parametric curve on the manifold, joining the points <code>p1</code> and <code>p2</code>, with parameter <code>w</code> in the interval [0,1]. In particular <code>get_intermediate_point(p1, p2, 0.0)</code> should return <code>p1</code> and <code>get_intermediate_point(p1, p2, 1.0)</code> should return <code>p2</code>.</p>
<p>In its default implementation, this function calls the <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">project_to_manifold()</a> method with the convex combination of <code>p1</code> and <code>p2</code>. User classes can get away by simply implementing the <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">project_to_manifold()</a> method. </p>

<p>Reimplemented in <a class="el" href="classSphericalManifold.html#a3fb5c6ede179c08ebc9d7171a81b9c92">SphericalManifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00071">71</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ae92f2144d52c79c8bb5d454c3640f04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92f2144d52c79c8bb5d454c3640f04e">&#9670;&nbsp;</a></span>get_new_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the point which shall become the new vertex surrounded by the given points which make up the quadrature. We use a quadrature object, which should be filled with the surrounding points together with appropriate weights.</p>
<p>In its default implementation it uses a pair-wise reduction of the points in the quadrature formula by calling the function <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">get_intermediate_point()</a> on the first two points, then on the resulting point and the next, until all points in the quadrature have been taken into account. User classes can get away by simply implementing the <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">get_intermediate_point()</a> function. Notice that by default the <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">get_intermediate_point()</a> function calls the <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">project_to_manifold()</a> function with the convex combination of its arguments. For simple situations you may get away by implementing only the <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">project_to_manifold()</a> function. </p>

<p>Reimplemented in <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim_A, spacedim_A, chartdim_A &gt;</a>, <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim1, intermediate_dim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim, spacedim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim2, spacedim, intermediate_dim &gt;</a>, <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim, 3, 3 &gt;</a>, <a class="el" href="classChartManifold.html#a18df7c16908ad4d37b67e44c5a42920b">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>, <a class="el" href="classFlatManifold.html#ac015bd72debfd242aee9ac717d3804fb">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#ac015bd72debfd242aee9ac717d3804fb">FlatManifold&lt; chartdim, chartdim &gt;</a>, and <a class="el" href="classCylindricalManifold.html#ab7163d20b980c48885e3e6a8dec14072">CylindricalManifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00086">86</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a3a238181b2c3596b8d370b83aa5999a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a238181b2c3596b8d370b83aa5999a0">&#9670;&nbsp;</a></span>get_new_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the point which shall become the new vertex surrounded by the given points <code>surrounding_points</code>. <code>weights</code> contains appropriate weights for the surrounding points according to which the manifold determines the new point's position.</p>
<p>In its default implementation it uses a pair-wise reduction of the points by calling the function <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">get_intermediate_point()</a> on the first two points, then on the resulting point and the next, until all points in the vector have been taken into account. User classes can get away by simply implementing the <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">get_intermediate_point()</a> function. Notice that by default the <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">get_intermediate_point()</a> function calls the <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">project_to_manifold()</a> function with the convex combination of its arguments. For simple situations you may get away by implementing only the <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">project_to_manifold()</a> function. </p>

<p>Reimplemented in <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim_A, spacedim_A, chartdim_A &gt;</a>, <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim1, intermediate_dim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim, spacedim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim2, spacedim, intermediate_dim &gt;</a>, <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim, 3, 3 &gt;</a>, <a class="el" href="classChartManifold.html#ad65cc150e82a4268fe8e4c7ef5a6914d">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>, <a class="el" href="classFlatManifold.html#a3a8e43d9e10d294971cf958f957f0269">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a3a8e43d9e10d294971cf958f957f0269">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classCylindricalManifold.html#a1d9aa47bd186f41a8c2d4d74ac4a3b78">CylindricalManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classSphericalManifold.html#ab69ae49e17ab585cbb293939429da472">SphericalManifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00096">96</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ab039ce4b6d15ab59f36fbd7923467faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab039ce4b6d15ab59f36fbd7923467faa">&#9670;&nbsp;</a></span>add_new_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::add_new_points </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of rows in <code>weights</code> determines how many new points will be computed and appended to the last input argument <code>new_points</code>. After exit of this function, the size of <code>new_points</code> equals the size at entry plus the number of rows in <code>weights</code>.</p>
<p>In its default implementation, this function simply calls <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">get_new_point()</a> on each row of <code>weights</code> and appends those points to the output vector <code>new_points</code>. However, this function is more efficient if multiple new points need to be generated like in <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> and the manifold does expensive transformations between a chart space and the physical space, such as <a class="el" href="classChartManifold.html">ChartManifold</a>. For this function, the surrounding points need to be transformed back to the chart sparse only once, rather than for every call to <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">get_new_point()</a>. If efficiency is not important, you may get away by implementing only the <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">get_new_point()</a> function.</p>
<p>The implementation does not allow for <code>surrounding_points</code> and <code>new_points</code> to point to the same vector, so make sure to pass different objects into the function. </p>

<p>Reimplemented in <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim_A, spacedim_A, chartdim_A &gt;</a>, <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim1, intermediate_dim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim, spacedim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim2, spacedim, intermediate_dim &gt;</a>, <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim, 3, 3 &gt;</a>, <a class="el" href="classChartManifold.html#a940f6d0e472f658c2c5b3b4af6dbe29d">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>, <a class="el" href="classFlatManifold.html#a1f9effb2c3a43d442d0968e4c03e7f20">FlatManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFlatManifold.html#a1f9effb2c3a43d442d0968e4c03e7f20">FlatManifold&lt; chartdim, chartdim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00157">157</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ab01387e605d9c92c4486cd734da86e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01387e605d9c92c4486cd734da86e71">&#9670;&nbsp;</a></span>project_to_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::project_to_manifold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point which lies close to the given manifold, it modifies it and projects it to manifold itself.</p>
<p>This class is used by the default implementation of the function <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">get_new_point()</a>. It should be made pure virtual, but for historical reason, derived classes like Boundary&lt;dim, spacedim&gt; do not implement it. The default behavior of this class, however, is to throw an exception when called.</p>
<p>If your manifold is simple, you could implement this function only, and the default behavior should work out of the box. </p>

<p>Reimplemented in <a class="el" href="classFlatManifold.html#a5f621468193f1b1bcbe42ad437644b7c">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a5f621468193f1b1bcbe42ad437644b7c">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionBoundary.html#a728e66ac943c42f7a1668e284797cf96">OpenCASCADE::NormalToMeshProjectionBoundary&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionBoundary.html#a63902ab91d215826294634baea2752e2">OpenCASCADE::DirectionalProjectionBoundary&lt; dim, spacedim &gt;</a>, and <a class="el" href="classOpenCASCADE_1_1NormalProjectionBoundary.html#a1e664e0d0a3d56255edf2d7a64238f57">OpenCASCADE::NormalProjectionBoundary&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00059">59</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af518522b81bdfe059b88bb557f7a60ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af518522b81bdfe059b88bb557f7a60ba">&#9670;&nbsp;</a></span>get_new_point_on_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary).</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a815f2c7c51feec7c4b38f75191da9d7c">Manifolds::get_default_quadrature()</a> function, and then calls the <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p>Reimplemented in <a class="el" href="classTorusBoundary.html#ac61ecbc1100d2b47ae70a3f989885db1">TorusBoundary&lt; dim, spacedim &gt;</a>, <a class="el" href="classHyperBallBoundary.html#a2ab289974b29ac11c4595ea48595eb0a">HyperBallBoundary&lt; dim, spacedim &gt;</a>, <a class="el" href="classStraightBoundary.html#a2ccb7642cd3bbea854c0dd6fa6eaefe3">StraightBoundary&lt; dim, spacedim &gt;</a>, <a class="el" href="classStraightBoundary.html#a2ccb7642cd3bbea854c0dd6fa6eaefe3">StraightBoundary&lt; dim, dim &gt;</a>, and <a class="el" href="classCylinderBoundary.html#a8548bb36256aa2fa97c2c3f4d89377ea">CylinderBoundary&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00375">375</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a59a7a18b04151504883074c24108266f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a7a18b04151504883074c24108266f">&#9670;&nbsp;</a></span>get_new_point_on_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a815f2c7c51feec7c4b38f75191da9d7c">Manifolds::get_default_quadrature()</a> function, and then calls the <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p>Reimplemented in <a class="el" href="classTorusBoundary.html#a582fdc37fa33cb17b0c8fd27ccd0fe3a">TorusBoundary&lt; dim, spacedim &gt;</a>, <a class="el" href="classHyperBallBoundary.html#a858605cb3976c22e6449f1cdb60c76d0">HyperBallBoundary&lt; dim, spacedim &gt;</a>, <a class="el" href="classStraightBoundary.html#a2cbe4aa4fc18708a763c2ab97e0e7336">StraightBoundary&lt; dim, spacedim &gt;</a>, <a class="el" href="classStraightBoundary.html#a2cbe4aa4fc18708a763c2ab97e0e7336">StraightBoundary&lt; dim, dim &gt;</a>, and <a class="el" href="classCylinderBoundary.html#a45d60a8c504bb8f29447b0c56a231e56">CylinderBoundary&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00386">386</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a8d8365135405a1f057020d84a315ffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8365135405a1f057020d84a315ffa6">&#9670;&nbsp;</a></span>get_new_point_on_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#a815f2c7c51feec7c4b38f75191da9d7c">Manifolds::get_default_quadrature()</a> function, and then calls the <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#ab01387e605d9c92c4486cd734da86e71">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00503">503</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="ab79c3a0f002136b483b50722ea6690d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79c3a0f002136b483b50722ea6690d9">&#9670;&nbsp;</a></span>get_new_point_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00397">397</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="af36b25e230fefc6eb32d53cb6e69cbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36b25e230fefc6eb32d53cb6e69cbba">&#9670;&nbsp;</a></span>get_new_point_on_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00417">417</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="adff3c7c6851d64d1839964f7ebbfc787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff3c7c6851d64d1839964f7ebbfc787">&#9670;&nbsp;</a></span>get_tangent_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector that, at <img class="formulaInl" alt="$\mathbf x_1$" src="form_848.png"/>, is tangential to the geodesic that connects two points <img class="formulaInl" alt="$\mathbf x_1,\mathbf x_2$" src="form_872.png"/>. The geodesic is the shortest line between these two points, where "shortest" is defined via a metric specific to a particular implementation of this class in a derived class. For example, in the case of a <a class="el" href="classFlatManifold.html">FlatManifold</a>, the shortest line between two points is just the straight line, and in this case the tangent vector is just the difference <img class="formulaInl" alt="$\mathbf d=\mathbf x_2-\mathbf x_1$" src="form_873.png"/>. On the other hand, for a manifold that describes a surface embedded in a higher dimensional space (e.g., the surface of a sphere), then the tangent vector is tangential to the surface, and consequently may point in a different direction than the straight line that connects the two points.</p>
<p>While tangent vectors are often normalized to unit length, the vectors returned by this function are normalized as described in the introduction of this class. Specifically, if <img class="formulaInl" alt="$\mathbf s(t)$" src="form_845.png"/> traces out the geodesic between the two points where <img class="formulaInl" alt="$\mathbf x_1 = \mathbf s(0)$" src="form_874.png"/> and <img class="formulaInl" alt="$\mathbf x_2 = \mathbf s(1)$" src="form_875.png"/>, then the returned vector must equal <img class="formulaInl" alt="$\mathbf s'(0)$" src="form_876.png"/>. In other words, the norm of the returned vector also encodes, in some sense, the <em>length</em> of the geodesic because a curve <img class="formulaInl" alt="$\mathbf s(t)$" src="form_845.png"/> must move "faster" if the two points it connects between arguments <img class="formulaInl" alt="$t=0$" src="form_854.png"/> and <img class="formulaInl" alt="$t=1$" src="form_855.png"/> are farther apart.</p>
<p>The default implementation of this function approximates <img class="formulaInl" alt="$\mathbf s'(0) \approx \frac{\mathbf s(\epsilon)-\mathbf x_1}{\epsilon}$" src="form_877.png"/> for a small value of <img class="formulaInl" alt="$\epsilon$" src="form_878.png"/>, and the evaluation of <img class="formulaInl" alt="$\mathbf s(\epsilon)$" src="form_879.png"/> is done by calling <a class="el" href="classManifold.html#ae92f2144d52c79c8bb5d454c3640f04e">get_new_point()</a>. If possible, derived classes should override this function by an implemention of the exact derivative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The first point that describes the geodesic, and the one at which the "direction" is to be evaluated. </td></tr>
    <tr><td class="paramname">x2</td><td>The second point that describes the geodesic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "direction" vector tangential to the geodesic. </dd></dl>

<p>Reimplemented in <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim_A, spacedim_A, chartdim_A &gt;</a>, <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim1, intermediate_dim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim, spacedim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim2, spacedim, intermediate_dim &gt;</a>, <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim, 3, 3 &gt;</a>, <a class="el" href="classChartManifold.html#a2788f8af27de76e68139dea10d49a3a5">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>, <a class="el" href="classFlatManifold.html#af9687ca45318ba2e8367a3769afcda92">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#af9687ca45318ba2e8367a3769afcda92">FlatManifold&lt; chartdim, chartdim &gt;</a>, and <a class="el" href="classSphericalManifold.html#aeffc1e029814befd65f6c0e51e9eeff1">SphericalManifold&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00524">524</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a8f737627dc946fb68c097d6ec83419d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f737627dc946fb68c097d6ec83419d4">&#9670;&nbsp;</a></span>normal_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector to a face embedded in this manifold, at the point p. If p is not in fact on the surface, but only close-by, try to return something reasonable, for example the normal vector at the surface point closest to p. (The point p will in fact not normally lie on the actual surface, but rather be a quadrature point mapped by some polynomial mapping; the mapped surface, however, will not usually coincide with the actual surface.)</p>
<p>This function only makes sense if dim==spacedim because otherwise there is no unique normal vector but in fact a (spacedim-dim+1)-dimensional tangent space of vectors that are all both normal to the face and normal to the dim-dimensional surface that lives in spacedim-dimensional space. For example, think of a two-dimensional mesh that covers a two-dimensional surface in three-dimensional space. In that case, each face (edge) is one-dimensional, and there are two linearly independent vectors that are both normal to the edge: one is normal to the edge and tangent to the surface (intuitively, that would be the one that points from the current cell to the neighboring one, if the surface was locally flat), and the other one is rooted in the edge but points perpendicular to the surface (which is also perpendicular to the edge that lives within the surface). Thus, because there are no obviously correct semantics for this function if spacedim is greater than dim, the function will simply throw an error in that situation.</p>
<p>The face iterator gives an indication which face this function is supposed to compute the normal vector for. This is useful if the boundary of the domain is composed of different nondifferential pieces (for example when using the <a class="el" href="classStraightBoundary.html">StraightBoundary</a> class to approximate a geometry that is completely described by the coarse mesh, with piecewise (bi-)linear components between the vertices, but where the boundary may have a kink at the vertices itself).</p>
<dl class="section note"><dt>Note</dt><dd>In 2d, the default implementation of this function computes the normal vector by taking the tangent direction from p to the further one of the two vertices that make up an edge, and then rotates it outward (with respect to the coordinate system of the edge) by 90 degrees. In 3d, the default implementation is more complicated, aiming at avoiding problems with numerical round-off for points close to one of the vertices. If the point p is closer to the center of the face than to any of the vertices, the normal vector is computed by the cross product of the tangent vectors from p to either vertex zero and one of the face (if the closest vertex is either vertex two or three), or of the tangent vectors from p to vertices two and three (if the closest vertex is either vertex zero or one). On the other hand, if the point p is closer to one of the vertices than to the center of the face, then we take the cross product of the tangent vectors from p to the two vertices that are adjacent to the closest one. </dd></dl>

<p>Reimplemented in <a class="el" href="classHyperBallBoundary.html#ad1febd81207accad359f10acf7c21d3a">HyperBallBoundary&lt; dim, spacedim &gt;</a>, <a class="el" href="classStraightBoundary.html#ac2ab45919910bed7b9c9e28da4f835ae">StraightBoundary&lt; dim, spacedim &gt;</a>, and <a class="el" href="classStraightBoundary.html#ac2ab45919910bed7b9c9e28da4f835ae">StraightBoundary&lt; dim, dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00295">295</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<a id="a2f8317a03ab0c13971ff53bcb38b49e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8317a03ab0c13971ff53bcb38b49e9">&#9670;&nbsp;</a></span>get_normals_at_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a19ac29d8115569ec4ab6971a69222c22">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward.</p>
<p>This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector()</a> on each vertex.</p>
<p>Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

<p class="definition">Definition at line <a class="el" href="manifold_8cc_source.html#l00360">360</a> of file <a class="el" href="manifold_8cc_source.html">manifold.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/grid/<a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/grid/<a class="el" href="manifold_8cc_source.html">manifold.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
