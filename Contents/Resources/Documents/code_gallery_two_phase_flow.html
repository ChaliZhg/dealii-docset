<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The &#39;Two phase flow interaction &#39; code gallery program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The 'Two phase flow interaction ' code gallery program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<p align="center"> 
  This program was contributed by Manuel Quezada de Luna &lt;manuel.quezada.dl@gmail.com&gt;.
  <br>
  It comes without any warranty or support by its authors or the authors of deal.II.
</p>

</p>
<p>This program is part of the <a class="el" href="CodeGallery.html">deal.II code gallery</a> and consists of the following files (click to inspect):</p><ul>
<li><a href="../code-gallery/two_phase_flow/Readme.md">Readme.md</a> (<a href="#ann-Readme.md">annotated version</a>)</li>
<li><a href="../code-gallery/two_phase_flow/CMakeLists.txt">CMakeLists.txt</a></li>
<li><a href="../code-gallery/two_phase_flow/LevelSetSolver.cc">LevelSetSolver.cc</a> (<a href="#ann-LevelSetSolver.cc">annotated version</a>)</li>
<li><a href="../code-gallery/two_phase_flow/MultiPhase.cc">MultiPhase.cc</a> (<a href="#ann-MultiPhase.cc">annotated version</a>)</li>
<li><a href="../code-gallery/two_phase_flow/NavierStokesSolver.cc">NavierStokesSolver.cc</a> (<a href="#ann-NavierStokesSolver.cc">annotated version</a>)</li>
<li><a href="../code-gallery/two_phase_flow/TestLevelSet.cc">TestLevelSet.cc</a> (<a href="#ann-TestLevelSet.cc">annotated version</a>)</li>
<li><a href="../code-gallery/two_phase_flow/TestNavierStokes.cc">TestNavierStokes.cc</a> (<a href="#ann-TestNavierStokes.cc">annotated version</a>)</li>
<li><a href="../code-gallery/two_phase_flow/clean.sh">clean.sh</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/entry-name">doc/entry-name</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/animations/breaking_dam_2D_contour_plots.mp4">doc/results/animations/breaking_dam_2D_contour_plots.mp4</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/animations/falling_drop_contour_plots.mp4">doc/results/animations/falling_drop_contour_plots.mp4</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/animations/filling_tank_2D_contour_plots.mp4">doc/results/animations/filling_tank_2D_contour_plots.mp4</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t00.png">doc/results/figures/breaking_dam/breaking_dam_t00.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t05.png">doc/results/figures/breaking_dam/breaking_dam_t05.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t10.png">doc/results/figures/breaking_dam/breaking_dam_t10.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t20.png">doc/results/figures/breaking_dam/breaking_dam_t20.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t35.png">doc/results/figures/breaking_dam/breaking_dam_t35.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t45.png">doc/results/figures/breaking_dam/breaking_dam_t45.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t60.png">doc/results/figures/breaking_dam/breaking_dam_t60.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t00.png">doc/results/figures/falling_drop/falling_drop_t00.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t10.png">doc/results/figures/falling_drop/falling_drop_t10.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t21.png">doc/results/figures/falling_drop/falling_drop_t21.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t22.png">doc/results/figures/falling_drop/falling_drop_t22.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t25.png">doc/results/figures/falling_drop/falling_drop_t25.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t45.png">doc/results/figures/falling_drop/falling_drop_t45.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t85.png">doc/results/figures/falling_drop/falling_drop_t85.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t00.png">doc/results/figures/filling_tank/filling_tank_t00.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t10.png">doc/results/figures/filling_tank/filling_tank_t10.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t15.png">doc/results/figures/filling_tank/filling_tank_t15.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t20.png">doc/results/figures/filling_tank/filling_tank_t20.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t30.png">doc/results/figures/filling_tank/filling_tank_t30.png</a></li>
<li><a href="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t40.png">doc/results/figures/filling_tank/filling_tank_t40.png</a></li>
<li><a href="../code-gallery/two_phase_flow/utilities.cc">utilities.cc</a> (<a href="#ann-utilities.cc">annotated version</a>)</li>
<li><a href="../code-gallery/two_phase_flow/utilities_test_LS.cc">utilities_test_LS.cc</a> (<a href="#ann-utilities_test_LS.cc">annotated version</a>)</li>
<li><a href="../code-gallery/two_phase_flow/utilities_test_NS.cc">utilities_test_NS.cc</a> (<a href="#ann-utilities_test_NS.cc">annotated version</a>)</li>
</ul>
<h1>Pictures from this code gallery program</h1>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t40.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t30.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t20.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t15.png" width="250"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t10.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/filling_tank/filling_tank_t00.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t85.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t45.png" width="250"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t25.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t22.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t21.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t10.png" width="250"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/falling_drop/falling_drop_t00.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t60.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t45.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t35.png" width="250"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t20.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t10.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t05.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/two_phase_flow/doc/results/figures/breaking_dam/breaking_dam_t00.png" width="250"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="ann-Readme.md"></a> </p><h1>Annotated version of Readme.md</h1>
<h2>Two Phase Flow </h2>
<h3>General description of the problem</h3>
<p>We consider the problem of two-phase incompressible flow. We start with an initial state of two phases (fluids) that define density and viscosity fields. Using these fields we solve the incompressible Navier-Stokes equations to obtain a velocity field.</p>
<p>We use the initial state to define a representation of the interface via a Level Set function <img class="formulaInl" alt="$\phi\in[-1, 1]$" src="form_4346.png"/>. The zero level set <img class="formulaInl" alt="$\{\phi=0\}$" src="form_4347.png"/> defines the interface of the phases. Positive values of the level set function represent water while negative values represent air.</p>
<p>Using the velocity field from the Navier-Stokes equations we transport the level set function. To do this we assume the velocity is divergence free and write the transport equation in conservation form.</p>
<p>Using the advected level set function we reconstruct density and viscosity fields. We repeat the process until the final desired time.</p>
<p>The Navier-Stokes equations are solved using a projection scheme based on [1]. To solve the level set we use continuous Galerkin Finite Elements with high-order stabilization based on the entropy residual of the solution [2] and artificial compression inspired by [3] and [4]. </p><hr/>
 <h3>General description of the code</h3>
<h5>Driver code: MultiPhase</h5>
<p>The driver code of the simulation is the run function within MultiPhase.cc. The general idea is to define here everything that has to do with the problem, set all the (physical and numerical) parameters and perform the time loop. The run function does the following: Set some physical parameters like final time, density and viscosity coefficients, etc. and numerical parameters like cfl, numerical constants, algorithms to be used, etc. Creates the geometry for the specified problem. Currently we have the following problems: Breaking Dam problem in 2D. Filling a tank in 2D. Small wave perturbation in 2D. Falling drop in 2D. Creates an object of the class <b>NavierStokesSolver</b> and an object of the class <b>LevelSetSolver</b>. Set the initial condition for each of the solvers. Performs the time loop. Within the time loop we do the following: Pass the current level set function to the Navier Stokes <a class="el" href="classSolver.html">Solver</a>. Ask the Navier Stokes <a class="el" href="classSolver.html">Solver</a> to perform one time step. Get the velocity field from the Navier Stokes <a class="el" href="classSolver.html">Solver</a>. Pass the velocity field to the Level Set <a class="el" href="classSolver.html">Solver</a>. Ask the Level Set <a class="el" href="classSolver.html">Solver</a> to perform one time step. Get the level set function from the Level Set <a class="el" href="classSolver.html">Solver</a>. Repeat until the final time. Output the solution at the requested times.</p>
<h5>Navier Stokes <a class="el" href="classSolver.html">Solver</a></h5>
<p>The NavierStokesSolver class is responsible for solving the Navier Stokes equation for just one time step. It requires density and viscosity information. This information can be passed by either a function or by passing a vector containing the DOFs of the level set function. For this reason the class contains the following two constructors: First constructor. Here we have to pass density and viscosity constants for the two phases. In addition, we have to pass a vector of DOFs defining the level set function. This constructor is meant to be used during the two-phase flow simulations. Second constructor. Here we have to pass functions to define the viscosity and density fields. This is meant to test the convergence properties of the method (and to validate the implementation).</p>
<h5>Level Set <a class="el" href="classSolver.html">Solver</a></h5>
<p>The LevelSetSolver.cc code is responsible for solving the Level Set for just one time step. It requires information about the velocity field and provides the transported level set function. The velocity field can be interpolated (outside of this class) from a given function to test the method (and to validate the implementation). Alternatively, the velocity can be provided from the solution of the Navier-Stokes equations (for the two phase flow simulations).</p>
<h5>Testing the Navier Stokes <a class="el" href="classSolver.html">Solver</a></h5>
<p>The TestNavierStokes.cc code is used to test the convergence (in time) of the Navier-Stokes solver. To run it uncomment the line <b>SET(TARGET "TestNavierStokes")</b> within CMakeLists.txt (and make sure to comment <b>SET(TARGET "TestLevelSet")</b> and <b>SET(TARGET "MultiPhase")</b>. Then cmake and compile. The convergence can be done in 2 or 3 dimensions. Different exact solutions (and force terms) are used in each case. The dimension can be set in the line <b>TestNavierStokes&lt;2&gt; test_navier_stokes(degree_LS, degree_U)</b> within the main function.</p>
<h5>Testing the Level Set <a class="el" href="classSolver.html">Solver</a></h5>
<p>The TestLevelSet.cc code is used to test the level set solver. To run it uncomment the corresponding line within CMakeLists.txt. Then cmake and compile. There are currently just two problems implemented: diagonal advection and circular rotation. If the velocity is independent of time set the flag <b>VARIABLE_VELOCITY</b> to zero to avoid interpolating the velocity field at every time step.</p>
<h5>Utility files</h5>
<p>The files utilities.cc, utilities_test_LS.cc and utilities_test_NS.cc contain functions required in MultiPhase.cc, TestLevelSet.cc and TestNavierStokes.cc respectively. The script clean.sh ereases all files created by cmake, compile and run any example. </p><hr/>
 <h3>References</h3>
<p>[1] J.-L. Guermond and A. Salgado. A splitting method for incompressible flows with variable density based on a pressure Poisson equation. Journal of Computational <a class="el" href="namespacePhysics.html">Physics</a>, 228(8):2834–2846, 2009.</p>
<p>[2] J.-L. Guermond, R. Pasquetti, and B. Popov. Entropy viscosity method for nonlinear conservation laws. Journal of Computational <a class="el" href="namespacePhysics.html">Physics</a>, 230(11):4248– 4267, 2011.</p>
<p>[3] A. Harten. The artificial compression method for computation of shocks and contact discontinuities. I. Single conservation laws. Communications on Pure and Applied Mathematics, 30(5):611–638, 1977.</p>
<p>[4] A. Harten. The artificial compression method for computation of shocks and contact discontinuities. III. Self-adjusting hybrid schemes. Mathematics of Computation, 32:363–389, 1978.</p>
<p><a class="anchor" id="ann-LevelSetSolver.cc"></a> </p><h1>Annotated version of LevelSetSolver.cc</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_simple_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_solver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;mpi.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>FLAGS</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define NUM_ITER 1</span></div><div class="line"><span class="preprocessor">#define CHECK_MAX_PRINCIPLE 0</span></div></div><!-- fragment --><p>LOG FOR LEVEL SET FROM -1 to 1</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ENTROPY(phi) std::log(std::abs(1-phi*phi)+1E-14)</span></div><div class="line"><span class="preprocessor">#define ENTROPY_GRAD(phi,phix) 2*phi*phix*((1-phi*phi&gt;=0) ? -1 : 1)/(std::abs(1-phi*phi)+1E-14)</span></div></div><!-- fragment --><p>//////////////////////////////////////////////////////// ////////////////// TRANSPORT SOLVER //////////////////// //////////////////////////////////////////////////////// This is a solver for the transpor solver. We assume the velocity is divergence free and solve the equation in conservation form. ///////////////////////////////// -------&mdash; NOTATION -------&mdash; // ///////////////////////////////// We use notation popular in the literature of conservation laws. For this reason the solution is denoted as u, unm1, unp1, etc. and the velocity is treated as vx, vy and vz.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LevelSetSolver</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>: </div></div><!-- fragment --><p>////////////////////// INITIAL CONDITIONS // //////////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initial_condition(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy);</div><div class="line"><span class="keywordtype">void</span> initial_condition(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vz);</div></div><!-- fragment --><p>/////////////////////// BOUNDARY CONDITIONS // ///////////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_boundary_conditions(std::vector&lt;unsigned int&gt; boundary_values_id_u,</div><div class="line">                             std::vector&lt;double&gt; boundary_values_u);</div></div><!-- fragment --><p>//////////////// SET VELOCITY // ////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx,</div><div class="line">                  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy);</div><div class="line"><span class="keywordtype">void</span> set_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx,</div><div class="line">                  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy,</div><div class="line">                  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vz);</div></div><!-- fragment --><p>///////////////////// SET AND GET ALPHA // /////////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> get_unp1(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_u);</div></div><!-- fragment --><p>///////////////// NTH TIME STEP // /////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> nth_time_step();</div></div><!-- fragment --><p>///////// SETUP // /////////</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> setup();</div><div class="line"></div><div class="line">  LevelSetSolver (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> cK,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> cE,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose,</div><div class="line">                  std::string ALGORITHM,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TIME_INTEGRATION,</div><div class="line">                  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation,</div><div class="line">                  MPI_Comm &amp;mpi_communicator);</div><div class="line">  ~LevelSetSolver();</div><div class="line">  </div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>////////////////////////////////////// ASSEMBLE MASS (and other) MATRICES // //////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_ML();</div><div class="line"><span class="keywordtype">void</span> invert_ML();</div><div class="line"><span class="keywordtype">void</span> assemble_MC();</div></div><!-- fragment --><p>//////////////////////////////////// LOW ORDER METHOD (DiJ Viscosity) // ////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_C_Matrix();</div><div class="line"><span class="keywordtype">void</span> assemble_K_times_vector(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;solution);</div><div class="line"><span class="keywordtype">void</span> assemble_K_DL_DH_times_vector(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;solution);</div></div><!-- fragment --><p>///////////////////// ENTROPY VISCOSITY // /////////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_EntRes_Matrix(); </div></div><!-- fragment --><p>///////////////////////// FOR MAXIMUM PRINCIPLE // /////////////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compute_bounds(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un_solution);</div><div class="line"><span class="keywordtype">void</span> check_max_principle(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;unp1_solution);</div></div><!-- fragment --><p>///////////////////// COMPUTE SOLUTIONS // /////////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> compute_MPP_uL_and_NMPP_uH(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uL_solution,</div><div class="line">                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;NMPP_uH_solution,</div><div class="line">                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un_solution);</div><div class="line"><span class="keywordtype">void</span> compute_MPP_uH(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uH_solution,</div><div class="line">                    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uL_solution_ghosted,</div><div class="line">                    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;NMPP_uH_solution_ghosted,</div><div class="line">                    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un_solution);</div><div class="line"><span class="keywordtype">void</span> compute_MPP_uH_with_iterated_FCT(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uH_solution,</div><div class="line">                                      <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uL_solution_ghosted,</div><div class="line">                                      <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;NMPP_uH_solution_ghosted,</div><div class="line">                                      <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un_solution);</div><div class="line"><span class="keywordtype">void</span> compute_solution(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;unp1,</div><div class="line">                      <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un,</div><div class="line">                      std::string algorithm);</div><div class="line"><span class="keywordtype">void</span> compute_solution_SSP33(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;unp1,</div><div class="line">                            <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un,</div><div class="line">                            std::string algorithm);</div></div><!-- fragment --><p>///////////// UTILITIES // /////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> get_sparsity_pattern();</div><div class="line"><span class="keywordtype">void</span> get_map_from_Q1_to_Q2();</div><div class="line"><span class="keywordtype">void</span> solve(<span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, </div><div class="line">           <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;Matrix,</div><div class="line">           std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner,</div><div class="line">           <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;completely_distributed_solution,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;rhs);</div><div class="line"><span class="keywordtype">void</span> save_old_solution();</div><div class="line"><span class="keywordtype">void</span> save_old_vel_solution();</div></div><!-- fragment --><p>///////////////////// MY PETSC WRAPPERS // /////////////////////</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> get_vector_values(<a class="code" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;vector, </div><div class="line">                       <span class="keyword">const</span> std::vector&lt;unsigned int&gt; &amp;indices,</div><div class="line">                       std::vector&lt;PetscScalar&gt; &amp;values);</div><div class="line"><span class="keywordtype">void</span> get_vector_values(<a class="code" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;vector, </div><div class="line">                       <span class="keyword">const</span> std::vector&lt;unsigned int&gt; &amp;indices,</div><div class="line">                       std::map&lt;types::global_dof_index, types::global_dof_index&gt; &amp;map_from_Q1_to_Q2,</div><div class="line">                       std::vector&lt;PetscScalar&gt; &amp;values);</div><div class="line">  </div><div class="line">MPI_Comm mpi_communicator;</div></div><!-- fragment --><p>FINITE ELEMENT SPACE</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>                  degree_MAX;</div><div class="line"><span class="keywordtype">int</span>                  degree_LS;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_LS;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_LS;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_LS;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_LS;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span>                  degree_U;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_U;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_U;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_U;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_U;</div></div><!-- fragment --><p>OPERATORS times SOLUTION VECTOR //</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> K_times_solution;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> DL_times_solution;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> DH_times_solution;</div></div><!-- fragment --><p>MASS MATRIX</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> MC_matrix;</div><div class="line">std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; MC_preconditioner;</div></div><!-- fragment --><p>BOUNDARIES</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; boundary_values_id_u;</div><div class="line">std::vector&lt;double&gt; boundary_values_u;</div></div><!-- fragment --><p>//////////// MATRICES // //////////// FOR FIRST ORDER VISCOSITY</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> Cx_matrix, CTx_matrix, Cy_matrix, CTy_matrix, Cz_matrix, CTz_matrix;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> dLij_matrix;</div></div><!-- fragment --><p>FOR ENTROPY VISCOSITY</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> EntRes_matrix, SuppSize_matrix, dCij_matrix;</div></div><!-- fragment --><p>FOR FCT (flux and limited flux)</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> A_matrix, LxA_matrix;</div></div><!-- fragment --><p>FOR ITERATIVE FCT</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> Akp1_matrix, LxAkp1_matrix;</div></div><!-- fragment --><p>GHOSTED VECTORS</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> uStage1, uStage2;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> unm1, un;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> R_pos_vector, R_neg_vector;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> MPP_uL_solution_ghosted, MPP_uLkp1_solution_ghosted, NMPP_uH_solution_ghosted;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vz;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx_old;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy_old;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vz_old;</div></div><!-- fragment --><p>NON-GHOSTED VECTORS</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> uStage1_nonGhosted, uStage2_nonGhosted;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> unp1;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> R_pos_vector_nonGhosted, R_neg_vector_nonGhosted;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> umin_vector, umax_vector;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> MPP_uL_solution, NMPP_uH_solution, MPP_uH_solution;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> RHS;</div></div><!-- fragment --><p>LUMPED MASS MATRIX</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> ML_vector, ones_vector;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> inverse_ML_vector;</div></div><!-- fragment --><p>CONSTRAINTS</p>
<div class="fragment"><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div></div><!-- fragment --><p>TIME STEPPING</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> time_step;</div></div><!-- fragment --><p>SOME PARAMETERS</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> cE, cK; </div><div class="line"><span class="keywordtype">double</span> solver_tolerance;</div><div class="line"><span class="keywordtype">double</span> entropy_normalization_factor;</div></div><!-- fragment --><p>UTILITIES</p>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span> verbose;    </div><div class="line">    std::string ALGORITHM;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TIME_INTEGRATION;</div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a>                pcout;</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, types::global_dof_index&gt; map_from_Q1_to_Q2;</div><div class="line">    std::map&lt;types::global_dof_index, std::vector&lt;types::global_dof_index&gt; &gt; sparsity_pattern;</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LevelSetSolver&lt;dim&gt;::LevelSetSolver (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> time_step,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> cK,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span> cE,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose,</div><div class="line">                                     std::string ALGORITHM,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TIME_INTEGRATION,</div><div class="line">                                     <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation, </div><div class="line">                                     MPI_Comm &amp;mpi_communicator)</div><div class="line">  :</div><div class="line">  mpi_communicator (mpi_communicator),</div><div class="line">  degree_LS(degree_LS),</div><div class="line">  dof_handler_LS (triangulation),</div><div class="line">  fe_LS (degree_LS),</div><div class="line">  degree_U(degree_U),</div><div class="line">  dof_handler_U (triangulation),</div><div class="line">  fe_U (degree_U),</div><div class="line">  time_step(time_step),</div><div class="line">  cE(cE),</div><div class="line">  cK(cK),</div><div class="line">  verbose(verbose),</div><div class="line">  ALGORITHM(ALGORITHM),</div><div class="line">  TIME_INTEGRATION(TIME_INTEGRATION),</div><div class="line">  pcout (<a class="code" href="namespacestd.html">std</a>::cout,(<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::this_mpi_process(mpi_communicator)== 0))</div><div class="line">{</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;********** LEVEL SET SETUP **********&quot;</span> &lt;&lt; std::endl;</div><div class="line">  setup();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LevelSetSolver&lt;dim&gt;::~LevelSetSolver ()</div><div class="line">{</div><div class="line">  dof_handler_LS.clear ();</div><div class="line">  dof_handler_U.clear ();</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////////// /////////////////// PUBLIC FUNCTIONS //////////////////// ///////////////////////////////////////////////////////// ////////////////////////////////////// //////// INITIAL CONDITIONS ////////// //////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::initial_condition (<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> un,</div><div class="line">                                              <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx,</div><div class="line">                                              <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy)</div><div class="line">{</div><div class="line">  this-&gt;un = un;</div><div class="line">  this-&gt;locally_relevant_solution_vx = locally_relevant_solution_vx;</div><div class="line">  this-&gt;locally_relevant_solution_vy = locally_relevant_solution_vy;</div></div><!-- fragment --><p>initialize old vectors with current solution, this just happens the first time</p>
<div class="fragment"><div class="line">  unm1 = un;</div><div class="line">  locally_relevant_solution_vx_old = locally_relevant_solution_vx;</div><div class="line">  locally_relevant_solution_vy_old = locally_relevant_solution_vy;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::initial_condition (<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> un,</div><div class="line">                                              <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx,</div><div class="line">                                              <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy,</div><div class="line">                                              <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vz)</div><div class="line">{</div><div class="line">  this-&gt;un = un;</div><div class="line">  this-&gt;locally_relevant_solution_vx = locally_relevant_solution_vx;</div><div class="line">  this-&gt;locally_relevant_solution_vy = locally_relevant_solution_vy;</div><div class="line">  this-&gt;locally_relevant_solution_vz = locally_relevant_solution_vz;</div></div><!-- fragment --><p>initialize old vectors with current solution, this just happens the first time</p>
<div class="fragment"><div class="line">  unm1 = un;</div><div class="line">  locally_relevant_solution_vx_old = locally_relevant_solution_vx;</div><div class="line">  locally_relevant_solution_vy_old = locally_relevant_solution_vy;</div><div class="line">  locally_relevant_solution_vz_old = locally_relevant_solution_vz;</div><div class="line">}</div></div><!-- fragment --><p>/////////////////////////////////////// //////// BOUNDARY CONDITIONS ////////// ///////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::set_boundary_conditions(std::vector&lt;unsigned int&gt; boundary_values_id_u,</div><div class="line">                                                   std::vector&lt;double&gt; boundary_values_u)</div><div class="line">{</div><div class="line">  this-&gt;boundary_values_id_u = boundary_values_id_u;</div><div class="line">  this-&gt;boundary_values_u = boundary_values_u;</div><div class="line">}</div></div><!-- fragment --><p>//////////////////////////////// //////// SET VELOCITY ////////// ////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::set_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx,</div><div class="line">                                        <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy)</div><div class="line">{</div></div><!-- fragment --><p>SAVE OLD SOLUTION</p>
<div class="fragment"><div class="line">save_old_vel_solution();</div></div><!-- fragment --><p>update velocity</p>
<div class="fragment"><div class="line">  this-&gt;locally_relevant_solution_vx=locally_relevant_solution_vx;</div><div class="line">  this-&gt;locally_relevant_solution_vy=locally_relevant_solution_vy;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::set_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vx,</div><div class="line">                                        <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vy,</div><div class="line">                                        <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_vz)</div><div class="line">{</div></div><!-- fragment --><p>SAVE OLD SOLUTION</p>
<div class="fragment"><div class="line">save_old_vel_solution();</div></div><!-- fragment --><p>update velocity</p>
<div class="fragment"><div class="line">  this-&gt;locally_relevant_solution_vx=locally_relevant_solution_vx;</div><div class="line">  this-&gt;locally_relevant_solution_vy=locally_relevant_solution_vy;</div><div class="line">  this-&gt;locally_relevant_solution_vz=locally_relevant_solution_vz;</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////// //////// SET AND GET U ////////// /////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::get_unp1(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;unp1){unp1=this-&gt;unp1;}</div></div><!-- fragment --><p>----------------------------------------------------------------------------&mdash; // ---------------------------&mdash; COMPUTE SOLUTIONS ---------------------------&mdash; // ----------------------------------------------------------------------------&mdash; //</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::nth_time_step()</div><div class="line">{ </div><div class="line">  assemble_EntRes_Matrix();</div></div><!-- fragment --><p>COMPUTE SOLUTION //</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (TIME_INTEGRATION==FORWARD_EULER)</div><div class="line">  compute_solution(unp1,un,ALGORITHM);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  compute_solution_SSP33(unp1,un,ALGORITHM);</div></div><!-- fragment --><p>BOUNDARY CONDITIONS</p>
<div class="fragment"><div class="line">unp1.set(boundary_values_id_u,boundary_values_u);</div><div class="line">unp1.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);  </div></div><!-- fragment --><p>CHECK MAXIMUM PRINCIPLE</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (CHECK_MAX_PRINCIPLE)</div><div class="line">  {</div><div class="line">    compute_bounds(un);</div><div class="line">    check_max_principle(unp1);</div><div class="line">  }</div></div><!-- fragment --><p>pcout &lt;&lt; "*********************************************************************... " &lt;&lt; unp1.min() &lt;&lt; ", " &lt;&lt; unp1.max() &lt;&lt; std::endl;</p>
<div class="fragment"><div class="line">  save_old_solution();</div><div class="line">}</div></div><!-- fragment --><p>-----------------------------------------------------------------&mdash;// ---------------------------&mdash; SETUP ---------------------------&mdash; // -----------------------------------------------------------------&mdash;//</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::setup()</div><div class="line">{</div><div class="line">  solver_tolerance=1E-6;</div><div class="line">  degree_MAX = std::max(degree_LS,degree_U);</div></div><!-- fragment --><p>////////////////////////// SETUP FOR DOF HANDLERS // ////////////////////////// setup system LS</p>
<div class="fragment"><div class="line">dof_handler_LS.distribute_dofs (fe_LS);</div><div class="line">locally_owned_dofs_LS = dof_handler_LS.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_LS,locally_relevant_dofs_LS);</div></div><!-- fragment --><p>setup system U</p>
<div class="fragment"><div class="line">dof_handler_U.distribute_dofs (fe_U);</div><div class="line">locally_owned_dofs_U = dof_handler_U.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_U,locally_relevant_dofs_U);</div></div><!-- fragment --><p>//////////////////// INIT CONSTRAINTS // ////////////////////</p>
<div class="fragment"><div class="line">constraints.clear ();</div><div class="line">constraints.reinit (locally_relevant_dofs_LS);</div><div class="line"><a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler_LS, constraints);</div><div class="line">constraints.close ();</div></div><!-- fragment --><p>/////////////////////// NON-GHOSTED VECTORS // ///////////////////////</p>
<div class="fragment"><div class="line">MPP_uL_solution.reinit(locally_owned_dofs_LS,mpi_communicator);</div><div class="line">NMPP_uH_solution.reinit(locally_owned_dofs_LS,mpi_communicator);</div><div class="line">RHS.reinit(locally_owned_dofs_LS,mpi_communicator);</div><div class="line">uStage1_nonGhosted.reinit (locally_owned_dofs_LS,mpi_communicator);</div><div class="line">uStage2_nonGhosted.reinit (locally_owned_dofs_LS,mpi_communicator);  </div><div class="line">unp1.reinit (locally_owned_dofs_LS,mpi_communicator);</div><div class="line">MPP_uH_solution.reinit (locally_owned_dofs_LS,mpi_communicator);</div></div><!-- fragment --><p>vectors for lumped mass matrix</p>
<div class="fragment"><div class="line">ML_vector.reinit(locally_owned_dofs_LS,mpi_communicator);</div><div class="line">inverse_ML_vector.reinit(locally_owned_dofs_LS,mpi_communicator);</div><div class="line">ones_vector.reinit(locally_owned_dofs_LS,mpi_communicator);</div><div class="line">ones_vector = 1.;</div></div><!-- fragment --><p>operators times solution</p>
<div class="fragment"><div class="line">K_times_solution.reinit(locally_owned_dofs_LS,mpi_communicator);</div><div class="line">DL_times_solution.reinit(locally_owned_dofs_LS,mpi_communicator);</div><div class="line">DH_times_solution.reinit(locally_owned_dofs_LS,mpi_communicator);</div></div><!-- fragment --><p>LIMITERS (FCT)</p>
<div class="fragment"><div class="line">R_pos_vector_nonGhosted.reinit (locally_owned_dofs_LS,mpi_communicator);</div><div class="line">R_neg_vector_nonGhosted.reinit (locally_owned_dofs_LS,mpi_communicator);</div><div class="line">umin_vector.reinit (locally_owned_dofs_LS,mpi_communicator);</div><div class="line">umax_vector.reinit (locally_owned_dofs_LS,mpi_communicator);</div></div><!-- fragment --><p>/////////////////////////////////////////////////////// GHOSTED VECTORS (used within some assemble process) // ///////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line">uStage1.reinit (locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div><div class="line">uStage2.reinit (locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);  </div><div class="line">unm1.reinit (locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div><div class="line">un.reinit (locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div><div class="line">MPP_uL_solution_ghosted.reinit (locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div><div class="line">MPP_uLkp1_solution_ghosted.reinit (locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div><div class="line">NMPP_uH_solution_ghosted.reinit (locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div></div><!-- fragment --><p>init vectors for vx</p>
<div class="fragment"><div class="line">locally_relevant_solution_vx.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div><div class="line">locally_relevant_solution_vx_old.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for vy</p>
<div class="fragment"><div class="line">locally_relevant_solution_vy.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div><div class="line">locally_relevant_solution_vy_old.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for vz</p>
<div class="fragment"><div class="line">locally_relevant_solution_vz.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div><div class="line">locally_relevant_solution_vz_old.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>LIMITERS (FCT)</p>
<div class="fragment"><div class="line">R_pos_vector.reinit(locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div><div class="line">R_neg_vector.reinit(locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div></div><!-- fragment --><p>////////////////// SETUP MATRICES // ////////////////// MATRICES</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (locally_relevant_dofs_LS);</div><div class="line"><a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler_LS,dsp,constraints,<span class="keyword">false</span>);</div><div class="line"><a class="code" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">SparsityTools::distribute_sparsity_pattern</a> (dsp,</div><div class="line">                                            dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                                            mpi_communicator,</div><div class="line">                                            locally_relevant_dofs_LS);</div><div class="line">MC_matrix.reinit (mpi_communicator,</div><div class="line">                  dsp,</div><div class="line">                  dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                  dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">Cx_matrix.reinit (mpi_communicator,</div><div class="line">                  dsp,</div><div class="line">                  dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                  dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">CTx_matrix.reinit (mpi_communicator,</div><div class="line">                   dsp,</div><div class="line">                   dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                   dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                   <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">Cy_matrix.reinit (mpi_communicator,</div><div class="line">                  dsp,</div><div class="line">                  dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                  dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">CTy_matrix.reinit (mpi_communicator,</div><div class="line">                   dsp,</div><div class="line">                   dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                   dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                   <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line"><span class="keywordflow">if</span> (dim==3)</div><div class="line">  {</div><div class="line">    Cz_matrix.reinit (mpi_communicator,</div><div class="line">                      dsp,</div><div class="line">                      dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                      dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                      <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">    CTz_matrix.reinit (mpi_communicator,</div><div class="line">                       dsp,</div><div class="line">                       dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                       dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                       <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">  }</div><div class="line">dLij_matrix.reinit (mpi_communicator,</div><div class="line">                    dsp,</div><div class="line">                    dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                    dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));  </div><div class="line">EntRes_matrix.reinit (mpi_communicator,</div><div class="line">                      dsp,</div><div class="line">                      dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                      dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                      <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));  </div><div class="line">SuppSize_matrix.reinit (mpi_communicator,</div><div class="line">                        dsp,</div><div class="line">                        dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                        dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                        <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));  </div><div class="line">dCij_matrix.reinit (mpi_communicator,</div><div class="line">                    dsp,</div><div class="line">                    dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                    dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));  </div><div class="line">A_matrix.reinit (mpi_communicator,</div><div class="line">                   dsp,</div><div class="line">                   dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                   dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                   <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));  </div><div class="line">LxA_matrix.reinit (mpi_communicator,</div><div class="line">                   dsp,</div><div class="line">                   dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                   dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                   <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));  </div><div class="line">Akp1_matrix.reinit (mpi_communicator,</div><div class="line">                    dsp,</div><div class="line">                    dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                    dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));  </div><div class="line">LxAkp1_matrix.reinit (mpi_communicator,</div><div class="line">                      dsp,</div><div class="line">                      dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                      dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                      <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));  </div></div><!-- fragment --><p>COMPUTE MASS MATRICES (AND OTHERS) FOR FIRST TIME STEP //</p>
<div class="fragment"><div class="line">assemble_ML(); </div><div class="line">invert_ML();</div><div class="line">assemble_MC(); </div><div class="line">assemble_C_Matrix();</div></div><!-- fragment --><p>get mat for DOFs between Q1 and Q2</p>
<div class="fragment"><div class="line">  get_map_from_Q1_to_Q2();</div><div class="line">  get_sparsity_pattern();</div><div class="line">}</div></div><!-- fragment --><p>-------------------------------------------------------------------------&mdash;// ---------------------------&mdash; MASS MATRICES ---------------------------&mdash; // -------------------------------------------------------------------------&mdash;//</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::assemble_ML()</div><div class="line">{</div><div class="line">  ML_vector=0;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(degree_MAX+1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_LS (fe_LS, quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe_LS.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_ML (dofs_per_cell);</div><div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc_LS = dof_handler_LS.end(); </div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (; cell_LS!=endc_LS; ++cell_LS)</div><div class="line">    <span class="keywordflow">if</span> (cell_LS-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_ML = 0;</div><div class="line">        fe_values_LS.reinit (cell_LS);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = fe_values_LS.JxW(q_point);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">              cell_ML (i) += fe_values_LS.shape_value(i,q_point)*JxW;</div><div class="line">          }</div></div><!-- fragment --><p>distribute</p>
<div class="fragment"><div class="line">  cell_LS-&gt;get_dof_indices (local_dof_indices);</div><div class="line">  constraints.distribute_local_to_global (cell_ML,local_dof_indices,ML_vector);</div><div class="line">}</div></div><!-- fragment --><p>compress</p>
<div class="fragment"><div class="line">  ML_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::invert_ML()</div><div class="line">{</div></div><!-- fragment --><p>loop on locally owned i-DOFs (rows)</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet_1_1ElementIterator.html">IndexSet::ElementIterator</a> idofs_iter = locally_owned_dofs_LS.begin();</div><div class="line">  <span class="keywordflow">for</span> (;idofs_iter!=locally_owned_dofs_LS.end(); idofs_iter++)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">int</span> gi = *idofs_iter;</div><div class="line">      inverse_ML_vector(gi) = 1./ML_vector(gi);</div><div class="line">    }</div><div class="line">  inverse_ML_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::assemble_MC()</div><div class="line">{</div><div class="line">  MC_matrix=0;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(degree_MAX+1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_LS (fe_LS, quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe_LS.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_MC (dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices (dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt; shape_values(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc_LS = dof_handler_LS.end();</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (; cell_LS!=endc_LS; ++cell_LS)</div><div class="line">    <span class="keywordflow">if</span> (cell_LS-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_MC = 0;</div><div class="line">        fe_values_LS.reinit (cell_LS);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = fe_values_LS.JxW(q_point);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">              shape_values[i] = fe_values_LS.shape_value(i,q_point);</div><div class="line">            </div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                cell_MC(i,j) += shape_values[i]*shape_values[j]*JxW;</div><div class="line">          }</div></div><!-- fragment --><p>distribute</p>
<div class="fragment"><div class="line">  cell_LS-&gt;get_dof_indices (local_dof_indices);</div><div class="line">  constraints.distribute_local_to_global (cell_MC,local_dof_indices,MC_matrix);</div><div class="line">}</div></div><!-- fragment --><p>compress</p>
<div class="fragment"><div class="line">  MC_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  MC_preconditioner.reset(<span class="keyword">new</span> <a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html">PETScWrappers::PreconditionBoomerAMG</a>(MC_matrix,<a class="code" href="structPETScWrappers_1_1PreconditionBoomerAMG_1_1AdditionalData.html">PETScWrappers::PreconditionBoomerAMG::AdditionalData</a>(<span class="keyword">true</span>)));</div><div class="line">}</div></div><!-- fragment --><p>------------------------------------------------------------------------------------&mdash; // ---------------------------&mdash; LO METHOD (Dij Viscosity) ---------------------------&mdash; // ------------------------------------------------------------------------------------&mdash; //</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::assemble_C_Matrix ()</div><div class="line">{</div><div class="line">  Cx_matrix=0;</div><div class="line">  CTx_matrix=0;</div><div class="line">  Cy_matrix=0;</div><div class="line">  CTy_matrix=0;</div><div class="line">  Cz_matrix=0;</div><div class="line">  CTz_matrix=0;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(degree_MAX+1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_LS (fe_LS, quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell_LS = fe_LS.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_Cij_x (dofs_per_cell_LS, dofs_per_cell_LS);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_Cij_y (dofs_per_cell_LS, dofs_per_cell_LS);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_Cij_z (dofs_per_cell_LS, dofs_per_cell_LS);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_Cji_x (dofs_per_cell_LS, dofs_per_cell_LS);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_Cji_y (dofs_per_cell_LS, dofs_per_cell_LS);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_Cji_z (dofs_per_cell_LS, dofs_per_cell_LS);</div><div class="line">  </div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt; &gt; shape_grads_LS(dofs_per_cell_LS);</div><div class="line">  std::vector&lt;double&gt; shape_values_LS(dofs_per_cell_LS);</div><div class="line">  </div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices_LS (dofs_per_cell_LS);</div><div class="line">  </div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell_LS, endc_LS;  </div><div class="line">  cell_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  endc_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell_LS!=endc_LS; ++cell_LS)</div><div class="line">    <span class="keywordflow">if</span> (cell_LS-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_Cij_x = 0;</div><div class="line">        cell_Cij_y = 0;</div><div class="line">        cell_Cji_x = 0;</div><div class="line">        cell_Cji_y = 0;</div><div class="line">        <span class="keywordflow">if</span> (dim==3) </div><div class="line">          {</div><div class="line">            cell_Cij_z = 0;</div><div class="line">            cell_Cji_z = 0;</div><div class="line">          }</div><div class="line">        </div><div class="line">        fe_values_LS.reinit (cell_LS);</div><div class="line">        cell_LS-&gt;get_dof_indices (local_dof_indices_LS);</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = fe_values_LS.JxW(q_point);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell_LS; ++i)</div><div class="line">              {</div><div class="line">                shape_values_LS[i] = fe_values_LS.shape_value(i,q_point);</div><div class="line">                shape_grads_LS [i] = fe_values_LS.shape_grad (i,q_point);</div><div class="line">              }</div><div class="line">            </div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell_LS; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; dofs_per_cell_LS; j++)</div><div class="line">                {</div><div class="line">                  cell_Cij_x(i,j) += (shape_grads_LS[j][0])*shape_values_LS[i]*JxW;</div><div class="line">                  cell_Cij_y(i,j) += (shape_grads_LS[j][1])*shape_values_LS[i]*JxW;</div><div class="line">                  cell_Cji_x(i,j) += (shape_grads_LS[i][0])*shape_values_LS[j]*JxW;</div><div class="line">                  cell_Cji_y(i,j) += (shape_grads_LS[i][1])*shape_values_LS[j]*JxW;</div><div class="line">                  <span class="keywordflow">if</span> (dim==3) </div><div class="line">                    {</div><div class="line">                      cell_Cij_z(i,j) += (shape_grads_LS[j][2])*shape_values_LS[i]*JxW;</div><div class="line">                      cell_Cji_z(i,j) += (shape_grads_LS[i][2])*shape_values_LS[j]*JxW;</div><div class="line">                    }</div><div class="line">                }            </div><div class="line">          }</div></div><!-- fragment --><p>Distribute</p>
<div class="fragment"><div class="line">  constraints.distribute_local_to_global(cell_Cij_x,local_dof_indices_LS,Cx_matrix);</div><div class="line">  constraints.distribute_local_to_global(cell_Cji_x,local_dof_indices_LS,CTx_matrix);</div><div class="line">  constraints.distribute_local_to_global(cell_Cij_y,local_dof_indices_LS,Cy_matrix);</div><div class="line">  constraints.distribute_local_to_global(cell_Cji_y,local_dof_indices_LS,CTy_matrix);</div><div class="line">  <span class="keywordflow">if</span> (dim==3) </div><div class="line">    {</div><div class="line">      constraints.distribute_local_to_global(cell_Cij_z,local_dof_indices_LS,Cz_matrix);</div><div class="line">      constraints.distribute_local_to_global(cell_Cji_z,local_dof_indices_LS,CTz_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>COMPRESS</p>
<div class="fragment"><div class="line">  Cx_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  CTx_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  Cy_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  CTy_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  <span class="keywordflow">if</span> (dim==3)</div><div class="line">    {</div><div class="line">      Cz_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">      CTz_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::assemble_K_times_vector(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;solution)</div><div class="line">{</div><div class="line">  K_times_solution = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(degree_MAX+1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_LS (fe_LS, quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_U (fe_U, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe_LS.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_K_times_solution (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; un_grads (n_q_points);</div><div class="line">  std::vector&lt;double&gt;  old_vx_values (n_q_points);</div><div class="line">  std::vector&lt;double&gt;  old_vy_values (n_q_points); </div><div class="line">  std::vector&lt;double&gt;  old_vz_values (n_q_points); </div><div class="line"></div><div class="line">  std::vector&lt;double&gt; shape_values(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; shape_grads(dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> un_dofs(dofs_per_cell);</div><div class="line">  </div><div class="line">  std::vector&lt;unsigned int&gt; indices_LS (dofs_per_cell);</div></div><!-- fragment --><p>loop on cells</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell_U = dof_handler_U.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> v;</div><div class="line"><span class="keywordflow">for</span> (; cell_LS!=endc_LS; ++cell_U, ++cell_LS)</div><div class="line">  <span class="keywordflow">if</span> (cell_LS-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      cell_K_times_solution=0;</div><div class="line">      </div><div class="line">      fe_values_LS.reinit (cell_LS);</div><div class="line">      cell_LS-&gt;get_dof_indices (indices_LS);</div><div class="line">      fe_values_LS.get_function_gradients(solution,un_grads);</div><div class="line">      </div><div class="line">      fe_values_U.reinit (cell_U);</div><div class="line">      fe_values_U.get_function_values(locally_relevant_solution_vx,old_vx_values);</div><div class="line">      fe_values_U.get_function_values(locally_relevant_solution_vy,old_vy_values);</div><div class="line">      <span class="keywordflow">if</span> (dim==3) fe_values_U.get_function_values(locally_relevant_solution_vz,old_vz_values);</div></div><!-- fragment --><p>compute cell_K_times_solution</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    v[0] = old_vx_values[q_point]; v[1] = old_vy_values[q_point];</div><div class="line">    <span class="keywordflow">if</span>(dim==3) v[2] = old_vz_values[q_point]; <span class="comment">//dim=3</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">      cell_K_times_solution(i) += (v*un_grads[q_point])</div><div class="line">        *fe_values_LS.shape_value(i,q_point)*fe_values_LS.JxW(q_point);</div><div class="line">  }</div></div><!-- fragment --><p>distribute</p>
<div class="fragment"><div class="line">        constraints.distribute_local_to_global (cell_K_times_solution, indices_LS, K_times_solution);</div><div class="line">      }</div><div class="line">  K_times_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::assemble_K_DL_DH_times_vector</div><div class="line">(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;solution)</div><div class="line">{</div></div><!-- fragment --><p>K_times_solution=0;</p>
<div class="fragment"><div class="line">DL_times_solution=0;</div><div class="line">DH_times_solution=0;</div><div class="line">dLij_matrix = 0;</div><div class="line">dCij_matrix = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> ncolumns;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> *gj; </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> *Cxi, *Cyi, *Czi, *CTxi, *CTyi, *CTzi;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> *EntResi, *SuppSizei, *MCi;</div><div class="line"><span class="keywordtype">double</span> solni;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> vi,vj;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>, CT;  </div></div><!-- fragment --><p>loop on locally owned i-DOFs (rows)</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet_1_1ElementIterator.html">IndexSet::ElementIterator</a> idofs_iter = locally_owned_dofs_LS.begin();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (;idofs_iter!=locally_owned_dofs_LS.end(); idofs_iter++)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">int</span> gi = *idofs_iter;</div></div><!-- fragment --><p>double ith_K_times_solution = 0;</p>
<p>read velocity of i-th DOF</p>
<div class="fragment"><div class="line">vi[0] = locally_relevant_solution_vx(map_from_Q1_to_Q2[gi]);</div><div class="line">vi[1] = locally_relevant_solution_vy(map_from_Q1_to_Q2[gi]);</div><div class="line"><span class="keywordflow">if</span>(dim==3) vi[2] = locally_relevant_solution_vz(map_from_Q1_to_Q2[gi]);</div><div class="line">solni = solution(gi);</div></div><!-- fragment --><p>get i-th row of C matrices</p>
<div class="fragment"><div class="line">MatGetRow(Cx_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Cxi);</div><div class="line">MatGetRow(Cy_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Cyi);</div><div class="line">MatGetRow(CTx_matrix,gi,&amp;ncolumns,&amp;gj,&amp;CTxi);</div><div class="line">MatGetRow(CTy_matrix,gi,&amp;ncolumns,&amp;gj,&amp;CTyi);</div><div class="line"><span class="keywordflow">if</span> (dim==3)</div><div class="line">  {</div><div class="line">    MatGetRow(Cz_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Czi);</div><div class="line">    MatGetRow(CTz_matrix,gi,&amp;ncolumns,&amp;gj,&amp;CTzi);</div><div class="line">  }</div><div class="line">MatGetRow(EntRes_matrix,gi,&amp;ncolumns,&amp;gj,&amp;EntResi);</div><div class="line">MatGetRow(SuppSize_matrix,gi,&amp;ncolumns,&amp;gj,&amp;SuppSizei);</div><div class="line">MatGetRow(MC_matrix,gi,&amp;ncolumns,&amp;gj,&amp;MCi);</div></div><!-- fragment --><p>get vector values for column indices</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; gj_indices (gj,gj+ncolumns);</div><div class="line">std::vector&lt;double&gt; soln(ncolumns);</div><div class="line">std::vector&lt;double&gt; vx(ncolumns);</div><div class="line">std::vector&lt;double&gt; vy(ncolumns);</div><div class="line">std::vector&lt;double&gt; vz(ncolumns);</div><div class="line">get_vector_values(solution,gj_indices,soln);</div><div class="line">get_vector_values(locally_relevant_solution_vx,gj_indices,map_from_Q1_to_Q2,vx);</div><div class="line">get_vector_values(locally_relevant_solution_vy,gj_indices,map_from_Q1_to_Q2,vy);</div><div class="line"><span class="keywordflow">if</span> (dim==3)</div><div class="line">  get_vector_values(locally_relevant_solution_vz,gj_indices,map_from_Q1_to_Q2,vz);</div></div><!-- fragment --><p>Array for i-th row of matrices</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; dLi(ncolumns), dCi(ncolumns);</div><div class="line"><span class="keywordtype">double</span> dLii = 0, dCii = 0;</div></div><!-- fragment --><p>loop on sparsity pattern of i-th DOF</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> j =0; j &lt; ncolumns; j++)</div><div class="line">  {</div><div class="line">    C[0] = Cxi[j];</div><div class="line">    C[1] = Cyi[j];</div><div class="line">    CT[0]= CTxi[j];</div><div class="line">    CT[1]= CTyi[j];</div><div class="line">    vj[0] = vx[j];</div><div class="line">    vj[1] = vy[j];</div><div class="line">    <span class="keywordflow">if</span> (dim==3)</div><div class="line">      {</div><div class="line">        C[2] = Czi[j];</div><div class="line">        CT[2] = CTzi[j];</div><div class="line">        vj[2] = vz[j];</div><div class="line">      }</div></div><!-- fragment --><p>ith_K_times_solution += soln[j]*(vj*C);</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (gi!=gj[j])</div><div class="line">  {</div></div><!-- fragment --><p>low order dissipative matrix</p>
<div class="fragment"><div class="line">dLi[j] = -std::max(std::abs(vi*C),std::abs(vj*CT));</div><div class="line">dLii -= dLi[j]; </div></div><!-- fragment --><p>high order dissipative matrix (entropy viscosity)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> dEij = -std::min(-dLi[j],</div><div class="line">                        cE*std::abs(EntResi[j])/(entropy_normalization_factor*MCi[j]/SuppSizei[j]));</div></div><!-- fragment --><p>high order compression matrix</p>
<div class="fragment"><div class="line">      <span class="keywordtype">double</span> Compij = cK*std::max(1-std::pow(0.5*(solni+soln[j]),2),0.0)/(std::abs(solni-soln[j])+1E-14);</div><div class="line">      dCi[j] = dEij*std::max(1-Compij,0.0);</div><div class="line">      dCii -= dCi[j];</div><div class="line">    }            </div><div class="line">}</div></div><!-- fragment --><p>save K times solution vector K_times_solution(gi)=ith_K_times_solution; save i-th row of matrices on global matrices</p>
<div class="fragment"><div class="line">MatSetValuesRow(dLij_matrix,gi,&amp;dLi[0]); <span class="comment">// BTW: there is a dealii wrapper for this</span></div><div class="line">dLij_matrix.set(gi,gi,dLii);</div><div class="line">MatSetValuesRow(dCij_matrix,gi,&amp;dCi[0]); <span class="comment">// BTW: there is a dealii wrapper for this</span></div><div class="line">dCij_matrix.set(gi,gi,dCii);</div></div><!-- fragment --><p>Restore matrices after reading rows</p>
<div class="fragment"><div class="line">  MatRestoreRow(Cx_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Cxi);</div><div class="line">  MatRestoreRow(Cy_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Cyi);</div><div class="line">  MatRestoreRow(CTx_matrix,gi,&amp;ncolumns,&amp;gj,&amp;CTxi);</div><div class="line">  MatRestoreRow(CTy_matrix,gi,&amp;ncolumns,&amp;gj,&amp;CTyi);</div><div class="line">  <span class="keywordflow">if</span> (dim==3)</div><div class="line">    {</div><div class="line">      MatRestoreRow(Cz_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Czi);</div><div class="line">      MatRestoreRow(CTz_matrix,gi,&amp;ncolumns,&amp;gj,&amp;CTzi);</div><div class="line">    }</div><div class="line">  MatRestoreRow(EntRes_matrix,gi,&amp;ncolumns,&amp;gj,&amp;EntResi);</div><div class="line">  MatRestoreRow(SuppSize_matrix,gi,&amp;ncolumns,&amp;gj,&amp;SuppSizei);</div><div class="line">  MatRestoreRow(MC_matrix,gi,&amp;ncolumns,&amp;gj,&amp;MCi);</div><div class="line">}</div></div><!-- fragment --><p>compress K_times_solution.compress(VectorOperation::insert);</p>
<div class="fragment"><div class="line">dLij_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">dCij_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div></div><!-- fragment --><p>get matrices times vector</p>
<div class="fragment"><div class="line">  dLij_matrix.vmult(DL_times_solution,solution);</div><div class="line">  dCij_matrix.vmult(DH_times_solution,solution);</div><div class="line">}</div></div><!-- fragment --><p>-----------------------------------------------------------------------------------&mdash; // ---------------------------&mdash; ENTROPY VISCOSITY ---------------------------&mdash; // -----------------------------------------------------------------------------------&mdash; //</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::assemble_EntRes_Matrix ()</div><div class="line">{</div><div class="line">  EntRes_matrix=0;</div><div class="line">  entropy_normalization_factor=0;</div><div class="line">  SuppSize_matrix=0;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(degree_MAX+1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_U (fe_U, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_LS (fe_LS, quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell_LS = fe_LS.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;  uqn (n_q_points); <span class="comment">// un at q point</span></div><div class="line">  std::vector&lt;double&gt;  uqnm1 (n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; guqn (n_q_points); <span class="comment">//grad of uqn</span></div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; guqnm1 (n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;  vxqn (n_q_points);</div><div class="line">  std::vector&lt;double&gt;  vyqn (n_q_points);</div><div class="line">  std::vector&lt;double&gt;  vzqn (n_q_points);</div><div class="line">  std::vector&lt;double&gt;  vxqnm1 (n_q_points);</div><div class="line">  std::vector&lt;double&gt;  vyqnm1 (n_q_points); </div><div class="line">  std::vector&lt;double&gt;  vzqnm1 (n_q_points); </div><div class="line">  </div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_EntRes (dofs_per_cell_LS, dofs_per_cell_LS);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_volume (dofs_per_cell_LS, dofs_per_cell_LS);</div><div class="line">  </div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt; &gt; shape_grads_LS(dofs_per_cell_LS);</div><div class="line">  std::vector&lt;double&gt; shape_values_LS(dofs_per_cell_LS);</div><div class="line">  </div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices_LS (dofs_per_cell_LS);</div><div class="line">  </div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell_LS, endc_LS;  </div><div class="line">  cell_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  endc_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell_U = dof_handler_U.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> Rk;</div><div class="line">  <span class="keywordtype">double</span> max_entropy=-1E10, min_entropy=1E10;</div><div class="line">  <span class="keywordtype">double</span> cell_max_entropy, cell_min_entropy;</div><div class="line">  <span class="keywordtype">double</span> cell_entropy_mass, entropy_mass=0;</div><div class="line">  <span class="keywordtype">double</span> cell_volume_double, <a class="code" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">volume</a>=0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell_LS!=endc_LS; ++cell_LS, ++cell_U)</div><div class="line">    <span class="keywordflow">if</span> (cell_LS-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_entropy_mass = 0;</div><div class="line">        cell_volume_double = 0;</div><div class="line">        cell_max_entropy = -1E10;</div><div class="line">        cell_min_entropy = 1E10;</div><div class="line">        cell_EntRes = 0;</div><div class="line">        cell_volume = 0;</div></div><!-- fragment --><p>get solutions at quadrature points</p>
<div class="fragment"><div class="line">fe_values_LS.reinit(cell_LS);</div><div class="line">cell_LS-&gt;get_dof_indices (local_dof_indices_LS);</div><div class="line">fe_values_LS.get_function_values(un,uqn);</div><div class="line">fe_values_LS.get_function_values(unm1,uqnm1);</div><div class="line">fe_values_LS.get_function_gradients(un,guqn);</div><div class="line">fe_values_LS.get_function_gradients(unm1,guqnm1);</div><div class="line"></div><div class="line">fe_values_U.reinit(cell_U);</div><div class="line">fe_values_U.get_function_values(locally_relevant_solution_vx,vxqn);</div><div class="line">fe_values_U.get_function_values(locally_relevant_solution_vy,vyqn);</div><div class="line"><span class="keywordflow">if</span> (dim==3) fe_values_U.get_function_values(locally_relevant_solution_vz,vzqn);</div><div class="line">fe_values_U.get_function_values(locally_relevant_solution_vx_old,vxqnm1);</div><div class="line">fe_values_U.get_function_values(locally_relevant_solution_vy_old,vyqnm1);</div><div class="line"><span class="keywordflow">if</span> (dim==3) fe_values_U.get_function_values(locally_relevant_solution_vz_old,vzqnm1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">  {</div><div class="line">    Rk = 1./time_step*(ENTROPY(uqn[q])-ENTROPY(uqnm1[q]))</div><div class="line">      +(vxqn[q]*ENTROPY_GRAD(uqn[q],guqn[q][0])+vyqn[q]*ENTROPY_GRAD(uqn[q],guqn[q][1]))/2.</div><div class="line">      +(vxqnm1[q]*ENTROPY_GRAD(uqnm1[q],guqnm1[q][0])+vyqnm1[q]*ENTROPY_GRAD(uqnm1[q],guqnm1[q][1]))/2.;</div><div class="line">    <span class="keywordflow">if</span> (dim==3) </div><div class="line">      Rk += 0.5*(vzqn[q]*ENTROPY_GRAD(uqn[q],guqn[q][2])+vzqnm1[q]*ENTROPY_GRAD(uqnm1[q],guqnm1[q][2]));</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = fe_values_LS.JxW(q);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell_LS; ++i)</div><div class="line">      {</div><div class="line">        shape_values_LS[i] = fe_values_LS.shape_value(i,q);</div><div class="line">        shape_grads_LS [i] = fe_values_LS.shape_grad (i,q);</div><div class="line">      }</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell_LS; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; dofs_per_cell_LS; j++)</div><div class="line">        {</div><div class="line">          cell_EntRes (i,j) += Rk*shape_values_LS[i]*shape_values_LS[j]*JxW;</div><div class="line">          cell_volume (i,j) += JxW;</div><div class="line">        }</div><div class="line">    cell_entropy_mass += ENTROPY(uqn[q])*JxW;</div><div class="line">    cell_volume_double += JxW;</div><div class="line"></div><div class="line">    cell_min_entropy = std::min(cell_min_entropy,ENTROPY(uqn[q]));</div><div class="line">    cell_max_entropy = std::max(cell_max_entropy,ENTROPY(uqn[q]));</div><div class="line">  }</div><div class="line">entropy_mass += cell_entropy_mass;</div><div class="line">volume += cell_volume_double;</div><div class="line"></div><div class="line">min_entropy = std::min(min_entropy,cell_min_entropy);</div><div class="line">max_entropy = std::max(max_entropy,cell_max_entropy);</div></div><!-- fragment --><p>Distribute</p>
<div class="fragment"><div class="line">      constraints.distribute_local_to_global(cell_EntRes,local_dof_indices_LS,EntRes_matrix);</div><div class="line">      constraints.distribute_local_to_global(cell_volume,local_dof_indices_LS,SuppSize_matrix);</div><div class="line">    }</div><div class="line">EntRes_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">SuppSize_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div></div><!-- fragment --><p>ENTROPY NORM FACTOR</p>
<div class="fragment"><div class="line">  volume = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(volume,mpi_communicator);</div><div class="line">  entropy_mass = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(entropy_mass,mpi_communicator)/volume;</div><div class="line">  min_entropy = <a class="code" href="namespaceUtilities_1_1MPI.html#a9ac5275c3c74902f8a9d6e7bdb514179">Utilities::MPI::min</a>(min_entropy,mpi_communicator);</div><div class="line">  max_entropy = <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(max_entropy,mpi_communicator);</div><div class="line">  entropy_normalization_factor = std::max(std::abs(max_entropy-entropy_mass), std::abs(min_entropy-entropy_mass));</div><div class="line">}</div></div><!-- fragment --><p>---------------------------------------------------------------------------------&mdash; // ---------------------------&mdash; TO CHECK MAX PRINCIPLE ---------------------------&mdash; // ---------------------------------------------------------------------------------&mdash; //</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::compute_bounds(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un_solution)</div><div class="line">{</div><div class="line">  umin_vector = 0;</div><div class="line">  umax_vector = 0;</div></div><!-- fragment --><p>loop on locally owned i-DOFs (rows)</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet_1_1ElementIterator.html">IndexSet::ElementIterator</a> idofs_iter = locally_owned_dofs_LS.begin();</div><div class="line"><span class="keywordflow">for</span> (;idofs_iter!=locally_owned_dofs_LS.end(); idofs_iter++)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">int</span> gi = *idofs_iter;</div></div><!-- fragment --><p>get solution at DOFs on the sparsity pattern of i-th DOF</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; gj_indices = sparsity_pattern[gi];</div><div class="line">std::vector&lt;double&gt; soln(gj_indices.size());</div><div class="line">get_vector_values(un_solution,gj_indices,soln);</div></div><!-- fragment --><p>compute bounds, ith row of flux matrix, P vectors</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mini=1E10, maxi=-1E10;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j =0; j &lt; gj_indices.size(); j++)</div><div class="line">  {</div></div><!-- fragment --><p>bounds</p>
<div class="fragment"><div class="line">          mini = std::min(mini,soln[j]);</div><div class="line">          maxi = std::max(maxi,soln[j]);</div><div class="line">        }</div><div class="line">      umin_vector(gi) = mini;</div><div class="line">      umax_vector(gi) = maxi;</div><div class="line">    }</div><div class="line">  umin_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  umax_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);  </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::check_max_principle(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;unp1_solution) </div><div class="line">{</div></div><!-- fragment --><p>compute min and max vectors</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe_LS.dofs_per_cell;</div><div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices (dofs_per_cell);</div><div class="line">  </div><div class="line">  <span class="keywordtype">double</span> tol=1e-10;</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (; cell_LS!=endc_LS; ++cell_LS)</div><div class="line">    <span class="keywordflow">if</span> (cell_LS-&gt;is_locally_owned() &amp;&amp; !cell_LS-&gt;at_boundary())</div><div class="line">      {</div><div class="line">        cell_LS-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; i++)</div><div class="line">          <span class="keywordflow">if</span> (locally_owned_dofs_LS.is_element(local_dof_indices[i]))</div><div class="line">            {</div><div class="line">              <span class="keywordtype">double</span> solni = unp1_solution(local_dof_indices[i]);</div><div class="line">              <span class="keywordflow">if</span> (solni - umin_vector(local_dof_indices[i]) &lt; -tol || umax_vector(local_dof_indices[i]) - solni &lt; -tol)</div><div class="line">                {</div><div class="line">                  pcout &lt;&lt; <span class="stringliteral">&quot;MAX Principle violated&quot;</span> &lt;&lt; std::endl;</div><div class="line">                  <a class="code" href="namespacedeal__II__exceptions_1_1internals.html#a6f0d772e8c91609d7ea9e834bbb2eb7e">abort</a>();</div><div class="line">                }</div><div class="line">            }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p>----------------------------------------------------------------------------&mdash; // ---------------------------&mdash; COMPUTE SOLUTIONS ---------------------------&mdash; // ----------------------------------------------------------------------------&mdash; //</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::compute_MPP_uL_and_NMPP_uH</div><div class="line">(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uL_solution,</div><div class="line"> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;NMPP_uH_solution,</div><div class="line"> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un_solution)</div><div class="line">{</div></div><!-- fragment --><p>NON-GHOSTED VECTORS: MPP_uL_solution, NMPP_uH_solution GHOSTED VECTORS: un_solution</p>
<div class="fragment"><div class="line">MPP_uL_solution=un_solution;</div><div class="line">NMPP_uH_solution=un_solution; <span class="comment">// to start iterative solver at un_solution (instead of zero)</span></div></div><!-- fragment --><p>assemble RHS VECTORS</p>
<div class="fragment"><div class="line">assemble_K_times_vector(un_solution);</div><div class="line">assemble_K_DL_DH_times_vector(un_solution);  </div></div><!-- fragment --><p>/////////////////////////// COMPUTE MPP u1 solution // ///////////////////////////</p>
<div class="fragment"><div class="line">MPP_uL_solution.<a class="code" href="classPETScWrappers_1_1VectorBase.html#a57deb429a909bfa17e885ca20660f521">scale</a>(ML_vector);</div><div class="line">MPP_uL_solution.<a class="code" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a>(-time_step,K_times_solution);</div><div class="line">MPP_uL_solution.<a class="code" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a>(-time_step,DL_times_solution);</div><div class="line">MPP_uL_solution.<a class="code" href="classPETScWrappers_1_1VectorBase.html#a57deb429a909bfa17e885ca20660f521">scale</a>(inverse_ML_vector);</div></div><!-- fragment --><p>//////////////////////////////// COMPUTE GALERKIN u2 solution // ////////////////////////////////</p>
<div class="fragment"><div class="line">  MC_matrix.vmult(RHS,un_solution);</div><div class="line">  RHS.add(-time_step,K_times_solution,-time_step,DH_times_solution);</div><div class="line">  solve(constraints,MC_matrix,MC_preconditioner,NMPP_uH_solution,RHS);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::compute_MPP_uH</div><div class="line">(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uH_solution,</div><div class="line"> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uL_solution_ghosted,</div><div class="line"> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;NMPP_uH_solution_ghosted,</div><div class="line"> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;solution)</div><div class="line">{</div><div class="line">  MPP_uH_solution=0;</div></div><!-- fragment --><p>loop on locally owned i-DOFs (rows)</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet_1_1ElementIterator.html">IndexSet::ElementIterator</a> idofs_iter = locally_owned_dofs_LS.begin();</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> ncolumns;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> *gj; </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> *MCi, *dLi, *dCi;</div><div class="line"><span class="keywordtype">double</span> solni, mi, solLi, solHi;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (;idofs_iter!=locally_owned_dofs_LS.end(); idofs_iter++)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">int</span> gi = *idofs_iter;      </div></div><!-- fragment --><p>read vectors at i-th DOF</p>
<div class="fragment"><div class="line">solni=solution(gi);</div><div class="line">solHi=NMPP_uH_solution_ghosted(gi);</div><div class="line">solLi=MPP_uL_solution_ghosted(gi);</div><div class="line">mi=ML_vector(gi);</div></div><!-- fragment --><p>get i-th row of matrices</p>
<div class="fragment"><div class="line">MatGetRow(MC_matrix,gi,&amp;ncolumns,&amp;gj,&amp;MCi);</div><div class="line">MatGetRow(dLij_matrix,gi,&amp;ncolumns,&amp;gj,&amp;dLi);</div><div class="line">MatGetRow(dCij_matrix,gi,&amp;ncolumns,&amp;gj,&amp;dCi);</div></div><!-- fragment --><p>get vector values for support of i-th DOF</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; gj_indices (gj,gj+ncolumns);</div><div class="line">std::vector&lt;double&gt; soln(ncolumns);</div><div class="line">std::vector&lt;double&gt; solH(ncolumns);</div><div class="line">get_vector_values(solution,gj_indices,soln);</div><div class="line">get_vector_values(NMPP_uH_solution_ghosted,gj_indices,solH);</div></div><!-- fragment --><p>Array for i-th row of matrices</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; Ai(ncolumns);</div></div><!-- fragment --><p>compute bounds, ith row of flux matrix, P vectors</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mini=1E10, maxi=-1E10;</div><div class="line"><span class="keywordtype">double</span> Pposi=0 ,Pnegi=0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> j =0; j &lt; ncolumns; j++)</div><div class="line">  {</div></div><!-- fragment --><p>bounds</p>
<div class="fragment"><div class="line">mini = std::min(mini,soln[j]);</div><div class="line">maxi = std::max(maxi,soln[j]);</div></div><!-- fragment --><p>i-th row of flux matrix A</p>
<div class="fragment"><div class="line">Ai[j] = (((gi==gj[j]) ? 1 : 0)*mi - MCi[j])*(solH[j]-soln[j] - (solHi-solni))</div><div class="line">  +time_step*(dLi[j]-dCi[j])*(soln[j]-solni);</div></div><!-- fragment --><p>compute P vectors</p>
<div class="fragment"><div class="line">  Pposi += Ai[j]*((Ai[j] &gt; 0) ? 1. : 0.);</div><div class="line">  Pnegi += Ai[j]*((Ai[j] &lt; 0) ? 1. : 0.);</div><div class="line">}</div></div><!-- fragment --><p>save i-th row of flux matrix A</p>
<div class="fragment"><div class="line">MatSetValuesRow(A_matrix,gi,&amp;Ai[0]);</div></div><!-- fragment --><p>compute Q vectors</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> Qposi = mi*(maxi-solLi);</div><div class="line"><span class="keywordtype">double</span> Qnegi = mi*(mini-solLi);</div></div><!-- fragment --><p>compute R vectors</p>
<div class="fragment"><div class="line">R_pos_vector_nonGhosted(gi) = ((Pposi==0) ? 1. : std::min(1.0,Qposi/Pposi));</div><div class="line">R_neg_vector_nonGhosted(gi) = ((Pnegi==0) ? 1. : std::min(1.0,Qnegi/Pnegi));</div></div><!-- fragment --><p>Restore matrices after reading rows</p>
<div class="fragment"><div class="line">  MatRestoreRow(MC_matrix,gi,&amp;ncolumns,&amp;gj,&amp;MCi);</div><div class="line">  MatRestoreRow(dLij_matrix,gi,&amp;ncolumns,&amp;gj,&amp;dLi);</div><div class="line">  MatRestoreRow(dCij_matrix,gi,&amp;ncolumns,&amp;gj,&amp;dCi);</div><div class="line">}</div></div><!-- fragment --><p>compress A matrix</p>
<div class="fragment"><div class="line">A_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div></div><!-- fragment --><p>compress R vectors</p>
<div class="fragment"><div class="line">R_pos_vector_nonGhosted.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">R_neg_vector_nonGhosted.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div></div><!-- fragment --><p>update ghost values for R vectors</p>
<div class="fragment"><div class="line">R_pos_vector = R_pos_vector_nonGhosted;</div><div class="line">R_neg_vector = R_neg_vector_nonGhosted;</div></div><!-- fragment --><p>compute limiters. NOTE: this is a different loop due to need of i- and j-th entries of R vectors</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> *Ai;</div><div class="line"><span class="keywordtype">double</span> Rposi, Rnegi; </div><div class="line">idofs_iter=locally_owned_dofs_LS.begin();</div><div class="line"><span class="keywordflow">for</span> (;idofs_iter!=locally_owned_dofs_LS.end(); idofs_iter++)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">int</span> gi = *idofs_iter;</div><div class="line">    Rposi = R_pos_vector(gi);</div><div class="line">    Rnegi = R_neg_vector(gi);</div></div><!-- fragment --><p>get i-th row of A matrix</p>
<div class="fragment"><div class="line">MatGetRow(A_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Ai);</div></div><!-- fragment --><p>get vector values for column indices</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; gj_indices (gj,gj+ncolumns);</div><div class="line">std::vector&lt;double&gt; Rpos(ncolumns);</div><div class="line">std::vector&lt;double&gt; Rneg(ncolumns);</div><div class="line">get_vector_values(R_pos_vector,gj_indices,Rpos);</div><div class="line">get_vector_values(R_neg_vector,gj_indices,Rneg);</div></div><!-- fragment --><p>Array for i-th row of A_times_L matrix</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; LxAi(ncolumns);</div></div><!-- fragment --><p>loop in sparsity pattern of i-th DOF</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> j =0; j &lt; ncolumns; j++)</div><div class="line">  LxAi[j] = Ai[j] * ((Ai[j]&gt;0) ? std::min(Rposi,Rneg[j]) : std::min(Rnegi,Rpos[j]));</div></div><!-- fragment --><p>save i-th row of LxA</p>
<div class="fragment"><div class="line">MatSetValuesRow(LxA_matrix,gi,&amp;LxAi[0]); <span class="comment">// BTW: there is a dealii wrapper for this</span></div></div><!-- fragment --><p>restore A matrix after reading it</p>
<div class="fragment"><div class="line">      MatRestoreRow(A_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Ai);</div><div class="line">    }</div><div class="line">  LxA_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  LxA_matrix.vmult(MPP_uH_solution,ones_vector);</div><div class="line">  MPP_uH_solution.<a class="code" href="classPETScWrappers_1_1VectorBase.html#a57deb429a909bfa17e885ca20660f521">scale</a>(inverse_ML_vector);</div><div class="line">  MPP_uH_solution.<a class="code" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a>(1.0,MPP_uL_solution_ghosted);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::compute_MPP_uH_with_iterated_FCT</div><div class="line">(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uH_solution,</div><div class="line"> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;MPP_uL_solution_ghosted,</div><div class="line"> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;NMPP_uH_solution_ghosted,</div><div class="line"> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un_solution)</div><div class="line">{</div><div class="line">  MPP_uH_solution=0;</div><div class="line">  compute_MPP_uH(MPP_uH_solution,MPP_uL_solution_ghosted,NMPP_uH_solution_ghosted,un_solution);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (NUM_ITER&gt;0)</div><div class="line">    {</div><div class="line">      Akp1_matrix.copy_from(A_matrix);</div><div class="line">      LxAkp1_matrix.copy_from(LxA_matrix);</div></div><!-- fragment --><p>loop in num of FCT iterations</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ncolumns;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> *gj; </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> *Akp1i;</div><div class="line"><span class="keywordtype">double</span> mi;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> iter=0; iter&lt;NUM_ITER; iter++)</div><div class="line">  {</div><div class="line">    MPP_uLkp1_solution_ghosted = MPP_uH_solution;</div><div class="line">    Akp1_matrix.<a class="code" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a>(LxAkp1_matrix,-1.0); <span class="comment">//new matrix to limit: A-LxA</span></div></div><!-- fragment --><p>loop on locally owned i-DOFs (rows)</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet_1_1ElementIterator.html">IndexSet::ElementIterator</a> idofs_iter = locally_owned_dofs_LS.begin();</div><div class="line"><span class="keywordflow">for</span> (;idofs_iter!=locally_owned_dofs_LS.end(); idofs_iter++)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">int</span> gi = *idofs_iter;</div></div><!-- fragment --><p>read vectors at i-th DOF</p>
<div class="fragment"><div class="line">mi=ML_vector(gi);</div><div class="line"><span class="keywordtype">double</span> solLi = MPP_uLkp1_solution_ghosted(gi);</div></div><!-- fragment --><p>get i-th row of matrices</p>
<div class="fragment"><div class="line">MatGetRow(Akp1_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Akp1i);</div></div><!-- fragment --><p>get vector values for support of i-th DOF</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; gj_indices (gj,gj+ncolumns);</div><div class="line">std::vector&lt;double&gt; soln(ncolumns);</div><div class="line">get_vector_values(un_solution,gj_indices,soln);</div></div><!-- fragment --><p>compute bounds, ith row of flux matrix, P vectors</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mini=1E10, maxi=-1E10;</div><div class="line"><span class="keywordtype">double</span> Pposi=0 ,Pnegi=0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> j =0; j &lt; ncolumns; j++)</div><div class="line">  {</div></div><!-- fragment --><p>bounds</p>
<div class="fragment"><div class="line">mini = std::min(mini,soln[j]);</div><div class="line">maxi = std::max(maxi,soln[j]);</div></div><!-- fragment --><p>compute P vectors</p>
<div class="fragment"><div class="line">  Pposi += Akp1i[j]*((Akp1i[j] &gt; 0) ? 1. : 0.);</div><div class="line">  Pnegi += Akp1i[j]*((Akp1i[j] &lt; 0) ? 1. : 0.);</div><div class="line">}</div></div><!-- fragment --><p>compute Q vectors</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> Qposi = mi*(maxi-solLi);</div><div class="line"><span class="keywordtype">double</span> Qnegi = mi*(mini-solLi);</div></div><!-- fragment --><p>compute R vectors</p>
<div class="fragment"><div class="line">R_pos_vector_nonGhosted(gi) = ((Pposi==0) ? 1. : std::min(1.0,Qposi/Pposi));</div><div class="line">R_neg_vector_nonGhosted(gi) = ((Pnegi==0) ? 1. : std::min(1.0,Qnegi/Pnegi));</div></div><!-- fragment --><p>Restore matrices after reading rows</p>
<div class="fragment"><div class="line">  MatRestoreRow(Akp1_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Akp1i);</div><div class="line">}</div></div><!-- fragment --><p>compress R vectors</p>
<div class="fragment"><div class="line">R_pos_vector_nonGhosted.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">R_neg_vector_nonGhosted.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div></div><!-- fragment --><p>update ghost values for R vectors</p>
<div class="fragment"><div class="line">R_pos_vector = R_pos_vector_nonGhosted;</div><div class="line">R_neg_vector = R_neg_vector_nonGhosted;</div></div><!-- fragment --><p>compute limiters. NOTE: this is a different loop due to need of i- and j-th entries of R vectors</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> Rposi, Rnegi; </div><div class="line">idofs_iter=locally_owned_dofs_LS.begin();</div><div class="line"><span class="keywordflow">for</span> (;idofs_iter!=locally_owned_dofs_LS.end(); idofs_iter++)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">int</span> gi = *idofs_iter;</div><div class="line">    Rposi = R_pos_vector(gi);</div><div class="line">    Rnegi = R_neg_vector(gi);</div></div><!-- fragment --><p>get i-th row of Akp1 matrix</p>
<div class="fragment"><div class="line">MatGetRow(Akp1_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Akp1i);</div></div><!-- fragment --><p>get vector values for column indices</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; gj_indices(gj,gj+ncolumns);</div><div class="line">std::vector&lt;double&gt; Rpos(ncolumns);</div><div class="line">std::vector&lt;double&gt; Rneg(ncolumns);</div><div class="line">get_vector_values(R_pos_vector,gj_indices,Rpos);</div><div class="line">get_vector_values(R_neg_vector,gj_indices,Rneg);</div></div><!-- fragment --><p>Array for i-th row of LxAkp1 matrix</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; LxAkp1i(ncolumns);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> j =0; j &lt; ncolumns; j++)</div><div class="line">  LxAkp1i[j] = Akp1i[j] * ((Akp1i[j]&gt;0) ? std::min(Rposi,Rneg[j]) : std::min(Rnegi,Rpos[j]));</div></div><!-- fragment --><p>save i-th row of LxA</p>
<div class="fragment"><div class="line">MatSetValuesRow(LxAkp1_matrix,gi,&amp;LxAkp1i[0]); <span class="comment">// BTW: there is a dealii wrapper for this</span></div></div><!-- fragment --><p>restore A matrix after reading it</p>
<div class="fragment"><div class="line">              MatRestoreRow(Akp1_matrix,gi,&amp;ncolumns,&amp;gj,&amp;Akp1i);</div><div class="line">            }</div><div class="line">          LxAkp1_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">          LxAkp1_matrix.vmult(MPP_uH_solution,ones_vector);</div><div class="line">          MPP_uH_solution.<a class="code" href="classPETScWrappers_1_1VectorBase.html#a57deb429a909bfa17e885ca20660f521">scale</a>(inverse_ML_vector);</div><div class="line">          MPP_uH_solution.<a class="code" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a>(1.0,MPP_uLkp1_solution_ghosted);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::compute_solution(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;unp1,</div><div class="line">                                           <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un, </div><div class="line">                                           std::string algorithm)</div><div class="line">{</div><div class="line">  unp1=0;</div></div><!-- fragment --><p>COMPUTE MPP LOW-ORDER SOLN and NMPP HIGH-ORDER SOLN</p>
<div class="fragment"><div class="line">  compute_MPP_uL_and_NMPP_uH(MPP_uL_solution,NMPP_uH_solution,un);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (algorithm.compare(<span class="stringliteral">&quot;MPP_u1&quot;</span>)==0)</div><div class="line">    unp1=MPP_uL_solution;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (algorithm.compare(<span class="stringliteral">&quot;NMPP_uH&quot;</span>)==0)</div><div class="line">    unp1=NMPP_uH_solution;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (algorithm.compare(<span class="stringliteral">&quot;MPP_uH&quot;</span>)==0)</div><div class="line">    {</div><div class="line">      MPP_uL_solution_ghosted = MPP_uL_solution;</div><div class="line">      NMPP_uH_solution_ghosted=NMPP_uH_solution;</div><div class="line">      compute_MPP_uH_with_iterated_FCT(MPP_uH_solution,MPP_uL_solution_ghosted,NMPP_uH_solution_ghosted,un);</div><div class="line">      unp1=MPP_uH_solution;  </div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> </div><div class="line">    {</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Error in algorithm&quot;</span> &lt;&lt; std::endl;</div><div class="line">      <a class="code" href="namespacedeal__II__exceptions_1_1internals.html#a6f0d772e8c91609d7ea9e834bbb2eb7e">abort</a>();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::compute_solution_SSP33(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;unp1,</div><div class="line">                                                 <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;un, </div><div class="line">                                                 std::string algorithm)</div><div class="line">{</div></div><!-- fragment --><p>GHOSTED VECTORS: un NON-GHOSTED VECTORS: unp1</p>
<div class="fragment"><div class="line">unp1=0;</div><div class="line">uStage1=0., uStage2=0.;</div><div class="line">uStage1_nonGhosted=0., uStage2_nonGhosted=0.;</div></div><!-- fragment --><p>/////////////// FIRST STAGE // /////////////// u1=un-dt*RH*un</p>
<div class="fragment"><div class="line">compute_solution(uStage1_nonGhosted,un,algorithm);</div><div class="line">uStage1=uStage1_nonGhosted;</div></div><!-- fragment --><p>//////////////// SECOND STAGE // //////////////// u2=3/4*un+1/4*(u1-dt*RH*u1)</p>
<div class="fragment"><div class="line">compute_solution(uStage2_nonGhosted,uStage1,algorithm);</div><div class="line">uStage2_nonGhosted*=1./4; </div><div class="line">uStage2_nonGhosted.add(3./4,un);</div><div class="line">uStage2=uStage2_nonGhosted;</div></div><!-- fragment --><p>/////////////// THIRD STAGE // /////////////// unp1=1/3*un+2/3*(u2-dt*RH*u2)</p>
<div class="fragment"><div class="line">  compute_solution(unp1,uStage2,algorithm);</div><div class="line">  unp1*=2./3;</div><div class="line">  unp1.<a class="code" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a>(1./3,un);</div><div class="line">}</div></div><!-- fragment --><p>--------------------------------------------------------------------&mdash; // ---------------------------&mdash; UTILITIES ---------------------------&mdash; // --------------------------------------------------------------------&mdash; //</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::get_sparsity_pattern()</div><div class="line">{</div></div><!-- fragment --><p>loop on DOFs</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet_1_1ElementIterator.html">IndexSet::ElementIterator</a> idofs_iter = locally_owned_dofs_LS.begin();</div><div class="line"><span class="keywordtype">int</span> ncolumns;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> *gj; </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> *MCi;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (;idofs_iter!=locally_owned_dofs_LS.end(); idofs_iter++)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">int</span> gi = *idofs_iter;      </div></div><!-- fragment --><p>get i-th row of mass matrix (dummy, I just need the indices gj)</p>
<div class="fragment"><div class="line">      MatGetRow(MC_matrix,gi,&amp;ncolumns,&amp;gj,&amp;MCi);</div><div class="line">      sparsity_pattern[gi] = std::vector&lt;types::global_dof_index&gt;(gj,gj+ncolumns);</div><div class="line">      MatRestoreRow(MC_matrix,gi,&amp;ncolumns,&amp;gj,&amp;MCi);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::get_map_from_Q1_to_Q2()</div><div class="line">{</div><div class="line">  map_from_Q1_to_Q2.clear();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell_LS = fe_LS.dofs_per_cell;</div><div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices_LS (dofs_per_cell_LS);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell_U = fe_U.dofs_per_cell;</div><div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices_U (dofs_per_cell_U);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell_U = dof_handler_U.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell_LS!=endc_LS; ++cell_LS, ++cell_U)</div><div class="line">    <span class="keywordflow">if</span> (!cell_LS-&gt;is_artificial()) <span class="comment">// loop on ghost cells as well</span></div><div class="line">      {</div><div class="line">        cell_LS-&gt;get_dof_indices(local_dof_indices_LS);</div><div class="line">        cell_U-&gt;get_dof_indices(local_dof_indices_U);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell_LS; ++i)        </div><div class="line">          map_from_Q1_to_Q2[local_dof_indices_LS[i]] = local_dof_indices_U[i];</div><div class="line">      }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::solve(<span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, </div><div class="line">                                <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;Matrix,</div><div class="line">                                std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner,</div><div class="line">                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;completely_distributed_solution,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;rhs)</div><div class="line">{</div></div><!-- fragment --><p>all vectors are NON-GHOSTED</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (dof_handler_LS.n_dofs(), solver_tolerance);</div><div class="line">  <a class="code" href="classPETScWrappers_1_1SolverCG.html">PETScWrappers::SolverCG</a> solver(solver_control, mpi_communicator);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution);</div><div class="line">  solver.solve (Matrix, completely_distributed_solution, rhs, *preconditioner);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution);</div><div class="line">  <span class="keywordflow">if</span> (verbose==<span class="keyword">true</span>) pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::save_old_solution()</div><div class="line">{</div><div class="line">  unm1 = un; </div><div class="line">  un = unp1; </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::save_old_vel_solution()</div><div class="line">{</div><div class="line">  locally_relevant_solution_vx_old = locally_relevant_solution_vx;</div><div class="line">  locally_relevant_solution_vy_old = locally_relevant_solution_vy;</div><div class="line">  <span class="keywordflow">if</span>(dim==3)</div><div class="line">    locally_relevant_solution_vz_old = locally_relevant_solution_vz;</div><div class="line">}</div></div><!-- fragment --><p>----------------------------------------------------------------------------&mdash; // ---------------------------&mdash; MY PETSC WRAPPERS ---------------------------&mdash; // ----------------------------------------------------------------------------&mdash; //</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::get_vector_values (<a class="code" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;vector, </div><div class="line">                                             <span class="keyword">const</span> std::vector&lt;unsigned int&gt; &amp;indices,</div><div class="line">                                             std::vector&lt;PetscScalar&gt; &amp;values)</div><div class="line">{</div></div><!-- fragment --><p>PETSc wrapper to get sets of values from a petsc vector. we assume the vector is ghosted We need to figure out which elements we own locally. Then get a pointer to the elements that are stored here (both the ones we own as well as the ghost elements). In this array, the locally owned elements come first followed by the ghost elements whose position we can get from an index set</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> ghost_indices = locally_relevant_dofs_LS;</div><div class="line">  ghost_indices.<a class="code" href="classIndexSet.html#ac15601b7c5742d386127b3ecabf61cf8">subtract_set</a>(locally_owned_dofs_LS);</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> n_idx, begin, end, i;</div><div class="line">  n_idx = indices.size();</div><div class="line">    </div><div class="line">  VecGetOwnershipRange (vector, &amp;begin, &amp;end); </div><div class="line"> </div><div class="line">  Vec solution_in_local_form = PETSC_NULL;</div><div class="line">  VecGhostGetLocalForm(vector, &amp;solution_in_local_form);</div><div class="line">  </div><div class="line">  PetscScalar *soln;</div><div class="line">  VecGetArray(solution_in_local_form, &amp;soln);</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; n_idx; i++) </div><div class="line">    {</div><div class="line">      <span class="keywordtype">int</span> index = indices[i];</div><div class="line">      <span class="keywordflow">if</span> (index &gt;= begin &amp;&amp; index &lt; end)</div><div class="line">        values[i] = *(soln+index-begin);</div><div class="line">      <span class="keywordflow">else</span> <span class="comment">//ghost</span></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ghostidx = ghost_indices.<a class="code" href="classIndexSet.html#a4d924bea58d98feebf99fc714b14b7d0">index_within_set</a>(index);</div><div class="line">          values[i] = *(soln+ghostidx+end-begin);</div><div class="line">        }</div><div class="line">    }</div><div class="line">  VecRestoreArray(solution_in_local_form, &amp;soln);</div><div class="line">  VecGhostRestoreLocalForm(vector, &amp;solution_in_local_form);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LevelSetSolver&lt;dim&gt;::get_vector_values (<a class="code" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;vector, </div><div class="line">                                             <span class="keyword">const</span> std::vector&lt;unsigned int&gt; &amp;indices,</div><div class="line">                                             std::map&lt;types::global_dof_index, types::global_dof_index&gt; &amp;map_from_Q1_to_Q2,</div><div class="line">                                             std::vector&lt;PetscScalar&gt; &amp;values)</div><div class="line">{</div></div><!-- fragment --><p>THIS IS MEANT TO BE USED WITH VELOCITY VECTORS PETSc wrapper to get sets of values from a petsc vector. we assume the vector is ghosted We need to figure out which elements we own locally. Then get a pointer to the elements that are stored here (both the ones we own as well as the ghost elements). In this array, the locally owned elements come first followed by the ghost elements whose position we can get from an index set</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> ghost_indices = locally_relevant_dofs_U;</div><div class="line">  ghost_indices.<a class="code" href="classIndexSet.html#ac15601b7c5742d386127b3ecabf61cf8">subtract_set</a>(locally_owned_dofs_U);</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> n_idx, begin, end, i;</div><div class="line">  n_idx = indices.size();</div><div class="line">    </div><div class="line">  VecGetOwnershipRange (vector, &amp;begin, &amp;end); </div><div class="line"> </div><div class="line">  Vec solution_in_local_form = PETSC_NULL;</div><div class="line">  VecGhostGetLocalForm(vector, &amp;solution_in_local_form);</div><div class="line">  </div><div class="line">  PetscScalar *soln;</div><div class="line">  VecGetArray(solution_in_local_form, &amp;soln);</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; n_idx; i++) </div><div class="line">    {</div><div class="line">      <span class="keywordtype">int</span> index = map_from_Q1_to_Q2[indices[i]];</div><div class="line">      <span class="keywordflow">if</span> (index &gt;= begin &amp;&amp; index &lt; end)</div><div class="line">        values[i] = *(soln+index-begin);</div><div class="line">      <span class="keywordflow">else</span> <span class="comment">//ghost</span></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ghostidx = ghost_indices.<a class="code" href="classIndexSet.html#a4d924bea58d98feebf99fc714b14b7d0">index_within_set</a>(index);</div><div class="line">          values[i] = *(soln+ghostidx+end-begin);</div><div class="line">        }</div><div class="line">    }</div><div class="line">  VecRestoreArray(solution_in_local_form, &amp;soln);</div><div class="line">  VecGhostRestoreLocalForm(vector, &amp;solution_in_local_form);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-MultiPhase.cc"></a> </p><h1>Annotated version of MultiPhase.cc</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_simple_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_solver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>///////////////////////// FOR TRANSPORT PROBLEM // ///////////////////////// TIME_INTEGRATION</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FORWARD_EULER 0</span></div><div class="line"><span class="preprocessor">#define SSP33 1</span></div></div><!-- fragment --><p>PROBLEM</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FILLING_TANK 0</span></div><div class="line"><span class="preprocessor">#define BREAKING_DAM 1 </span></div><div class="line"><span class="preprocessor">#define FALLING_DROP 2</span></div><div class="line"><span class="preprocessor">#define SMALL_WAVE_PERTURBATION 3</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;NavierStokesSolver.cc&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;LevelSetSolver.cc&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;utilities.cc&quot;</span></div></div><!-- fragment --><p>///////////////////////////////////////////////////// /////////////////// MAIN CLASS ////////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MultiPhase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MultiPhase (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U);</div><div class="line">  ~MultiPhase ();</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> set_boundary_inlet();</div><div class="line">  <span class="keywordtype">void</span> get_boundary_values_U();</div><div class="line">  <span class="keywordtype">void</span> get_boundary_values_phi(std::vector&lt;unsigned int&gt; &amp;boundary_values_id_phi,</div><div class="line">                               std::vector&lt;double&gt; &amp;boundary_values_phi);</div><div class="line">  <span class="keywordtype">void</span> output_results();</div><div class="line">  <span class="keywordtype">void</span> output_vectors();</div><div class="line">  <span class="keywordtype">void</span> output_rho();</div><div class="line">  <span class="keywordtype">void</span> setup();</div><div class="line">  <span class="keywordtype">void</span> initial_condition();</div><div class="line">  <span class="keywordtype">void</span> init_constraints();</div><div class="line"></div><div class="line">  MPI_Comm mpi_communicator;</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  </div><div class="line">  <span class="keywordtype">int</span>                  degree_LS;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_LS;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_LS;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_LS;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_LS;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span>                  degree_U;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_U;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_U;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_U;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_U;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_P;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_P;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_P;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_P;</div><div class="line">  </div><div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a>                pcout;</div></div><!-- fragment --><p>SOLUTION VECTORS</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_phi;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_p;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_phi;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_u;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_v;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_p;</div></div><!-- fragment --><p>BOUNDARY VECTORS</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; boundary_values_id_u;</div><div class="line">std::vector&lt;unsigned int&gt; boundary_values_id_v;</div><div class="line">std::vector&lt;unsigned int&gt; boundary_values_id_phi;</div><div class="line">std::vector&lt;double&gt; boundary_values_u;</div><div class="line">std::vector&lt;double&gt; boundary_values_v;</div><div class="line">std::vector&lt;double&gt; boundary_values_phi;</div><div class="line"></div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> time;</div><div class="line"><span class="keywordtype">double</span> time_step;</div><div class="line"><span class="keywordtype">double</span> final_time;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"><span class="keywordtype">double</span> cfl;</div><div class="line"><span class="keywordtype">double</span> umax;</div><div class="line"><span class="keywordtype">double</span> min_h;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> sharpness; </div><div class="line"><span class="keywordtype">int</span> sharpness_integer;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_number;</div><div class="line"><span class="keywordtype">double</span> output_time;</div><div class="line"><span class="keywordtype">bool</span> get_output;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> verbose;</div></div><!-- fragment --><p>FOR NAVIER STOKES</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> rho_fluid;</div><div class="line"><span class="keywordtype">double</span> nu_fluid;</div><div class="line"><span class="keywordtype">double</span> rho_air;</div><div class="line"><span class="keywordtype">double</span> nu_air;</div><div class="line"><span class="keywordtype">double</span> nu;</div><div class="line"><span class="keywordtype">double</span> eps;</div></div><!-- fragment --><p>FOR TRANSPORT</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> cK; <span class="comment">//compression coeff</span></div><div class="line">  <span class="keywordtype">double</span> cE; <span class="comment">//entropy-visc coeff</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TRANSPORT_TIME_INTEGRATION;</div><div class="line">  std::string ALGORITHM;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MultiPhase&lt;dim&gt;::MultiPhase (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS, </div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U)</div><div class="line">  :</div><div class="line">  mpi_communicator (MPI_COMM_WORLD),</div><div class="line">  triangulation (mpi_communicator,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing</div><div class="line">                 (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening)),</div><div class="line">  degree_LS(degree_LS),</div><div class="line">  dof_handler_LS (triangulation),</div><div class="line">  fe_LS (degree_LS),</div><div class="line">  degree_U(degree_U),</div><div class="line">  dof_handler_U (triangulation),</div><div class="line">  fe_U (degree_U),</div><div class="line">  dof_handler_P (triangulation),</div><div class="line">  fe_P (degree_U-1), </div><div class="line">  pcout (<a class="code" href="namespacestd.html">std</a>::cout,(<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::this_mpi_process(mpi_communicator)== 0))</div><div class="line">{}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MultiPhase&lt;dim&gt;::~MultiPhase ()</div><div class="line">{</div><div class="line">  dof_handler_LS.clear ();</div><div class="line">  dof_handler_U.clear ();</div><div class="line">  dof_handler_P.clear ();</div><div class="line">}</div></div><!-- fragment --><p>/////////////////////////////////////// /////////////// SETUP ///////////////// ///////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::setup()</div><div class="line">{ </div></div><!-- fragment --><p>setup system LS</p>
<div class="fragment"><div class="line">dof_handler_LS.distribute_dofs (fe_LS);</div><div class="line">locally_owned_dofs_LS = dof_handler_LS.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_LS,</div><div class="line">                                         locally_relevant_dofs_LS);</div></div><!-- fragment --><p>setup system U</p>
<div class="fragment"><div class="line">dof_handler_U.distribute_dofs (fe_U);</div><div class="line">locally_owned_dofs_U = dof_handler_U.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_U,</div><div class="line">                                         locally_relevant_dofs_U);</div></div><!-- fragment --><p>setup system P //</p>
<div class="fragment"><div class="line">dof_handler_P.distribute_dofs (fe_P);</div><div class="line">locally_owned_dofs_P = dof_handler_P.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_P,</div><div class="line">                                         locally_relevant_dofs_P);</div></div><!-- fragment --><p>init vectors for phi</p>
<div class="fragment"><div class="line">locally_relevant_solution_phi.reinit(locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div><div class="line">locally_relevant_solution_phi = 0;</div><div class="line">completely_distributed_solution_phi.reinit (locally_owned_dofs_P,mpi_communicator);</div></div><!-- fragment --><p>init vectors for u</p>
<div class="fragment"><div class="line">locally_relevant_solution_u.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div><div class="line">locally_relevant_solution_u = 0;</div><div class="line">completely_distributed_solution_u.reinit (locally_owned_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for v</p>
<div class="fragment"><div class="line">locally_relevant_solution_v.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div><div class="line">locally_relevant_solution_v = 0;</div><div class="line">completely_distributed_solution_v.reinit (locally_owned_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for p</p>
<div class="fragment"><div class="line">locally_relevant_solution_p.reinit (locally_owned_dofs_P,locally_relevant_dofs_P,mpi_communicator);</div><div class="line">locally_relevant_solution_p = 0;</div><div class="line">completely_distributed_solution_p.reinit (locally_owned_dofs_P,mpi_communicator);</div></div><!-- fragment --><p>INIT CONSTRAINTS</p>
<div class="fragment"><div class="line">  init_constraints();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::initial_condition()</div><div class="line">{</div><div class="line">  time=0;</div></div><!-- fragment --><p>Initial conditions // init condition for phi</p>
<div class="fragment"><div class="line">completely_distributed_solution_phi = 0;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_LS,</div><div class="line">                   InitialPhi&lt;dim&gt;(PROBLEM, sharpness),</div><div class="line">                   completely_distributed_solution_phi);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_phi);</div><div class="line">locally_relevant_solution_phi = completely_distributed_solution_phi;</div></div><!-- fragment --><p>init condition for u=0</p>
<div class="fragment"><div class="line">completely_distributed_solution_u = 0;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                         <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                         completely_distributed_solution_u);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_u);</div><div class="line">locally_relevant_solution_u = completely_distributed_solution_u;</div></div><!-- fragment --><p>init condition for v</p>
<div class="fragment"><div class="line">completely_distributed_solution_v = 0;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                         <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                         completely_distributed_solution_v);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_v);</div><div class="line">locally_relevant_solution_v = completely_distributed_solution_v;</div></div><!-- fragment --><p>init condition for p</p>
<div class="fragment"><div class="line">  completely_distributed_solution_p = 0;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_P,</div><div class="line">                           <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                           completely_distributed_solution_p);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_p);</div><div class="line">  locally_relevant_solution_p = completely_distributed_solution_p;</div><div class="line">}</div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::init_constraints()</div><div class="line">{</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ();</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#ac2726821354883ac97fe7e6181de9792">reinit</a> (locally_relevant_dofs_LS);</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler_LS, constraints);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::get_boundary_values_U()</div><div class="line">{</div><div class="line">  std::map&lt;unsigned int, double&gt; map_boundary_values_u;</div><div class="line">  std::map&lt;unsigned int, double&gt; map_boundary_values_v;</div><div class="line">  std::map&lt;unsigned int, double&gt; map_boundary_values_w;</div></div><!-- fragment --><p>NO-SLIP CONDITION</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (PROBLEM==BREAKING_DAM || PROBLEM==FALLING_DROP)</div><div class="line">  {</div></div><!-- fragment --><p>LEFT</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,0,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u); </div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,0,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_v); </div></div><!-- fragment --><p>RIGHT</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,1,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u); </div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,1,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_v); </div></div><!-- fragment --><p>BOTTOM</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,2,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u); </div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,2,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_v); </div></div><!-- fragment --><p>TOP</p>
<div class="fragment"><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,3,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u); </div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,3,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_v); </div><div class="line">  } </div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (PROBLEM==SMALL_WAVE_PERTURBATION)</div><div class="line">  { <span class="comment">// no slip in bottom and top and slip in left and right</span></div></div><!-- fragment --><p>LEFT</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,0,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u); </div></div><!-- fragment --><p>RIGHT</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,1,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u); </div></div><!-- fragment --><p>BOTTOM</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,2,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u); </div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,2,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_v); </div></div><!-- fragment --><p>TOP</p>
<div class="fragment"><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,3,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u); </div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,3,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_v); </div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (PROBLEM==FILLING_TANK)           </div><div class="line">  {</div></div><!-- fragment --><p>LEFT: entry in x, zero in y</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,0,BoundaryU&lt;dim&gt;(PROBLEM),map_boundary_values_u);</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,0,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_v);</div></div><!-- fragment --><p>RIGHT: no-slip condition</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,1,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u);</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,1,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_v);</div></div><!-- fragment --><p>BOTTOM: non-slip</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,2,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u);</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,2,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_v);</div></div><!-- fragment --><p>TOP: exit in y, zero in x</p>
<div class="fragment"><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,3,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),map_boundary_values_u);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,3,BoundaryV&lt;dim&gt;(PROBLEM),map_boundary_values_v);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> </div><div class="line">    {</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Error in type of PROBLEM at Boundary Conditions&quot;</span> &lt;&lt; std::endl;</div><div class="line">      <a class="code" href="namespacedeal__II__exceptions_1_1internals.html#a6f0d772e8c91609d7ea9e834bbb2eb7e">abort</a>();</div><div class="line">    }</div><div class="line">  boundary_values_id_u.resize(map_boundary_values_u.size());</div><div class="line">  boundary_values_id_v.resize(map_boundary_values_v.size());</div><div class="line">  boundary_values_u.resize(map_boundary_values_u.size());</div><div class="line">  boundary_values_v.resize(map_boundary_values_v.size());</div><div class="line">  std::map&lt;unsigned int,double&gt;::const_iterator boundary_value_u =map_boundary_values_u.begin();</div><div class="line">  std::map&lt;unsigned int,double&gt;::const_iterator boundary_value_v =map_boundary_values_v.begin();</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; boundary_value_u !=map_boundary_values_u.end(); ++boundary_value_u, ++i)</div><div class="line">    {</div><div class="line">      boundary_values_id_u[i]=boundary_value_u-&gt;first;</div><div class="line">      boundary_values_u[i]=boundary_value_u-&gt;second;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; boundary_value_v !=map_boundary_values_v.end(); ++boundary_value_v, ++i)</div><div class="line">    {</div><div class="line">      boundary_values_id_v[i]=boundary_value_v-&gt;first;</div><div class="line">      boundary_values_v[i]=boundary_value_v-&gt;second;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::set_boundary_inlet()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt;  face_quadrature_formula(1); <span class="comment">// center of the face</span></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe_U,face_quadrature_formula,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  std::vector&lt;double&gt;  u_value (n_face_q_points);</div><div class="line">  std::vector&lt;double&gt;  v_value (n_face_q_points); </div><div class="line">  </div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell_U = dof_handler_U.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc_U = dof_handler_U.end();</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> u;</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (; cell_U!=endc_U; ++cell_U)</div><div class="line">    <span class="keywordflow">if</span> (cell_U-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        <span class="keywordflow">if</span> (cell_U-&gt;face(face)-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            fe_face_values.reinit(cell_U,face);</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(locally_relevant_solution_u,u_value);</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(locally_relevant_solution_v,v_value);</div><div class="line">            u[0]=u_value[0];</div><div class="line">            u[1]=v_value[0];</div><div class="line">            <span class="keywordflow">if</span> (fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(0)*u &lt; -1e-14)</div><div class="line">              cell_U-&gt;face(face)-&gt;set_boundary_id(10); <span class="comment">// SET ID 10 to inlet BOUNDARY (10 is an arbitrary number)</span></div><div class="line">          }    </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::get_boundary_values_phi(std::vector&lt;unsigned int&gt; &amp;boundary_values_id_phi,</div><div class="line">                                              std::vector&lt;double&gt; &amp;boundary_values_phi)</div><div class="line">{</div><div class="line">  std::map&lt;unsigned int, double&gt; map_boundary_values_phi;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> boundary_id=0;</div><div class="line">  </div><div class="line">  set_boundary_inlet();</div><div class="line">  boundary_id=10; <span class="comment">// inlet</span></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_LS,boundary_id,BoundaryPhi&lt;dim&gt;(1.0),map_boundary_values_phi);</div><div class="line">  boundary_values_id_phi.resize(map_boundary_values_phi.size());</div><div class="line">  boundary_values_phi.resize(map_boundary_values_phi.size());  </div><div class="line">  std::map&lt;unsigned int,double&gt;::const_iterator boundary_value_phi = map_boundary_values_phi.begin();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; boundary_value_phi !=map_boundary_values_phi.end(); ++boundary_value_phi, ++i)</div><div class="line">    {</div><div class="line">      boundary_values_id_phi[i]=boundary_value_phi-&gt;first;</div><div class="line">      boundary_values_phi[i]=boundary_value_phi-&gt;second;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::output_results()</div><div class="line">{</div></div><!-- fragment --><p>output_vectors();</p>
<div class="fragment"><div class="line">  output_rho();</div><div class="line">  output_number++;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::output_vectors()</div><div class="line">{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler_LS);  </div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (locally_relevant_solution_phi, <span class="stringliteral">&quot;phi&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> std::string filename = (<span class="stringliteral">&quot;sol_vectors-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_number, 3) +</div><div class="line">                                <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="line">                                (triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4));</div><div class="line">  std::ofstream output ((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line">  </div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;std::string&gt; filenames;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">           i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(mpi_communicator);</div><div class="line">           ++i)</div><div class="line">        filenames.push_back (<span class="stringliteral">&quot;sol_vectors-&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_number, 3) +</div><div class="line">                             <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (i, 4) +</div><div class="line">                             <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">      </div><div class="line">      std::ofstream master_output ((filename + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (master_output, filenames);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::output_rho()</div><div class="line">{</div><div class="line">  Postprocessor&lt;dim&gt; postprocessor(eps,rho_air,rho_fluid);  </div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler_LS);  </div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (locally_relevant_solution_phi, postprocessor);</div><div class="line">  </div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> std::string filename = (<span class="stringliteral">&quot;sol_rho-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_number, 3) +</div><div class="line">                                <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="line">                                (triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4));</div><div class="line">  std::ofstream output ((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line">  </div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;std::string&gt; filenames;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">           i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(mpi_communicator);</div><div class="line">           ++i)</div><div class="line">        filenames.push_back (<span class="stringliteral">&quot;sol_rho-&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_number, 3) +</div><div class="line">                             <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (i, 4) +</div><div class="line">                             <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">      </div><div class="line">      std::ofstream master_output ((filename + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (master_output, filenames);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MultiPhase&lt;dim&gt;::run()</div><div class="line">{</div></div><!-- fragment --><p>////////////////////// GENERAL PARAMETERS // //////////////////////</p>
<div class="fragment"><div class="line">umax=1;</div><div class="line">cfl=0.1;</div><div class="line">verbose = <span class="keyword">true</span>;</div><div class="line">get_output = <span class="keyword">true</span>;</div><div class="line">output_number = 0;</div><div class="line">n_refinement=8;</div><div class="line">output_time = 0.1;</div><div class="line">final_time = 10.0;</div></div><!-- fragment --><p>//////////////////////////////////////////// PARAMETERS FOR THE NAVIER STOKES PROBLEM // ////////////////////////////////////////////</p>
<div class="fragment"><div class="line">rho_fluid = 1000.;</div><div class="line">nu_fluid = 1.0;</div><div class="line">rho_air = 1.0;</div><div class="line">nu_air = 1.8e-2;</div><div class="line">PROBLEM=BREAKING_DAM;</div></div><!-- fragment --><p>PROBLEM=FILLING_TANK; PROBLEM=SMALL_WAVE_PERTURBATION; PROBLEM=FALLING_DROP;</p>
<div class="fragment"><div class="line">ForceTerms&lt;dim&gt; force_function(std::vector&lt;double&gt;{0.0,-1.0});</div></div><!-- fragment --><p>//////////////////////////////////// PARAMETERS FOR TRANSPORT PROBLEM // ////////////////////////////////////</p>
<div class="fragment"><div class="line">cK = 1.0;</div><div class="line">cE = 1.0;</div><div class="line">sharpness_integer=10; <span class="comment">//this will be multipled by min_h</span></div></div><!-- fragment --><p>TRANSPORT_TIME_INTEGRATION=FORWARD_EULER;</p>
<div class="fragment"><div class="line">TRANSPORT_TIME_INTEGRATION=SSP33;</div></div><!-- fragment --><p>ALGORITHM = "MPP_u1"; ALGORITHM = "NMPP_uH";</p>
<div class="fragment"><div class="line">ALGORITHM = <span class="stringliteral">&quot;MPP_uH&quot;</span>;</div></div><!-- fragment --><p>ADJUST PARAMETERS ACCORDING TO PROBLEM</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (PROBLEM==FALLING_DROP)</div><div class="line">  n_refinement=7;</div></div><!-- fragment --><p>//////////// GEOMETRY // ////////////</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (PROBLEM==FILLING_TANK)</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation,</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.0,0.0), <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.4,0.4), <span class="keyword">true</span>);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (PROBLEM==BREAKING_DAM || PROBLEM==SMALL_WAVE_PERTURBATION)</div><div class="line">  {</div><div class="line">    std::vector&lt; unsigned int &gt; repetitions;</div><div class="line">    repetitions.push_back(2);</div><div class="line">    repetitions.push_back(1);</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> </div><div class="line">      (triangulation, repetitions, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.0,0.0), <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(1.0,0.5), <span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (PROBLEM==FALLING_DROP)</div><div class="line">  {</div><div class="line">    std::vector&lt; unsigned int &gt; repetitions;</div><div class="line">    repetitions.push_back(1);</div><div class="line">    repetitions.push_back(4);</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> </div><div class="line">      (triangulation, repetitions, <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.0,0.0), <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.3,0.9), <span class="keyword">true</span>);</div><div class="line">  }</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (n_refinement);</div></div><!-- fragment --><p>SETUP</p>
<div class="fragment"><div class="line">setup();</div></div><!-- fragment --><p>PARAMETERS FOR TIME STEPPING</p>
<div class="fragment"><div class="line">min_h = <a class="code" href="namespaceGridTools.html#ac89deda30a32b232dbe9c95e14896df5">GridTools::minimal_cell_diameter</a>(triangulation)/std::sqrt(2);</div><div class="line">time_step = cfl*min_h/umax;</div><div class="line">eps=1.*min_h; <span class="comment">//For reconstruction of density in Navier Stokes</span></div><div class="line">sharpness=sharpness_integer*min_h; <span class="comment">//adjust value of sharpness (for init cond of phi)</span></div></div><!-- fragment --><p>INITIAL CONDITIONS</p>
<div class="fragment"><div class="line">initial_condition();</div><div class="line">output_results();</div></div><!-- fragment --><p>NAVIER STOKES SOLVER</p>
<div class="fragment"><div class="line">NavierStokesSolver&lt;dim&gt; navier_stokes (degree_LS,degree_U,</div><div class="line">                                       time_step,eps,</div><div class="line">                                       rho_air,nu_air,</div><div class="line">                                       rho_fluid,nu_fluid,</div><div class="line">                                       force_function,</div><div class="line">                                       verbose,</div><div class="line">                                       triangulation,mpi_communicator);</div></div><!-- fragment --><p>BOUNDARY CONDITIONS FOR NAVIER STOKES</p>
<div class="fragment"><div class="line">get_boundary_values_U();</div><div class="line">navier_stokes.set_boundary_conditions(boundary_values_id_u, boundary_values_id_v,</div><div class="line">                                      boundary_values_u, boundary_values_v);</div></div><!-- fragment --><p>set INITIAL CONDITION within NAVIER STOKES</p>
<div class="fragment"><div class="line">navier_stokes.initial_condition(locally_relevant_solution_phi,</div><div class="line">                                locally_relevant_solution_u,</div><div class="line">                                locally_relevant_solution_v,</div><div class="line">                                locally_relevant_solution_p);</div></div><!-- fragment --><p>TRANSPORT SOLVER</p>
<div class="fragment"><div class="line">LevelSetSolver&lt;dim&gt; transport_solver (degree_LS,degree_U,</div><div class="line">                                      time_step,cK,cE, </div><div class="line">                                      verbose, </div><div class="line">                                      ALGORITHM,</div><div class="line">                                      TRANSPORT_TIME_INTEGRATION,</div><div class="line">                                      triangulation, </div><div class="line">                                      mpi_communicator); </div></div><!-- fragment --><p>BOUNDARY CONDITIONS FOR PHI</p>
<div class="fragment"><div class="line">get_boundary_values_phi(boundary_values_id_phi,boundary_values_phi);</div><div class="line">transport_solver.set_boundary_conditions(boundary_values_id_phi,boundary_values_phi);</div></div><!-- fragment --><p>set INITIAL CONDITION within TRANSPORT PROBLEM</p>
<div class="fragment"><div class="line">transport_solver.initial_condition(locally_relevant_solution_phi,</div><div class="line">                                   locally_relevant_solution_u,</div><div class="line">                                   locally_relevant_solution_v);</div><div class="line"><span class="keywordtype">int</span> dofs_U = 2*dof_handler_U.n_dofs();</div><div class="line"><span class="keywordtype">int</span> dofs_P = 2*dof_handler_P.n_dofs();</div><div class="line"><span class="keywordtype">int</span> dofs_LS = dof_handler_LS.n_dofs();</div><div class="line"><span class="keywordtype">int</span> dofs_TOTAL = dofs_U+dofs_P+dofs_LS;</div></div><!-- fragment --><p>NO BOUNDARY CONDITIONS for LEVEL SET</p>
<div class="fragment"><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Cfl: &quot;</span> &lt;&lt; cfl &lt;&lt; <span class="stringliteral">&quot;; umax: &quot;</span> &lt;&lt; umax &lt;&lt; <span class="stringliteral">&quot;; min h: &quot;</span> &lt;&lt; min_h </div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;; time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span> </div><div class="line">      &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; std::endl</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;      U: &quot;</span> &lt;&lt; dofs_U &lt;&lt; std::endl</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;      P: &quot;</span> &lt;&lt; dofs_P &lt;&lt; std::endl</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;      LS: &quot;</span> &lt;&lt; dofs_LS &lt;&lt; std::endl</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;      TOTAL: &quot;</span> &lt;&lt; dofs_TOTAL</div><div class="line">      &lt;&lt; std::endl;</div></div><!-- fragment --><p>TIME STEPPING</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (timestep_number=1, time=time_step; time&lt;=final_time;</div><div class="line">     time+=time_step,++timestep_number)</div><div class="line">  {</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number </div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time </div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>GET NAVIER STOKES VELOCITY</p>
<div class="fragment"><div class="line">navier_stokes.set_phi(locally_relevant_solution_phi);</div><div class="line">navier_stokes.nth_time_step(); </div><div class="line">navier_stokes.get_velocity(locally_relevant_solution_u,locally_relevant_solution_v);</div><div class="line">transport_solver.set_velocity(locally_relevant_solution_u,locally_relevant_solution_v);</div></div><!-- fragment --><p>GET LEVEL SET SOLUTION</p>
<div class="fragment"><div class="line">      transport_solver.nth_time_step();</div><div class="line">      transport_solver.get_unp1(locally_relevant_solution_phi);      </div><div class="line">      <span class="keywordflow">if</span> (get_output &amp;&amp; time-(output_number)*output_time&gt;0)</div><div class="line">        output_results();</div><div class="line">    }</div><div class="line">  navier_stokes.get_velocity(locally_relevant_solution_u, locally_relevant_solution_v);</div><div class="line">  transport_solver.get_unp1(locally_relevant_solution_phi);      </div><div class="line">  <span class="keywordflow">if</span> (get_output)</div><div class="line">    output_results();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line">      PetscInitialize(&amp;argc, &amp;argv, PETSC_NULL, PETSC_NULL);</div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (0);</div><div class="line">      {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS = 1;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U = 2;</div><div class="line">        MultiPhase&lt;2&gt; multi_phase(degree_LS, degree_U);</div><div class="line">        multi_phase.run();</div><div class="line">      }</div><div class="line">      PetscFinalize();</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-NavierStokesSolver.cc"></a> </p><h1>Annotated version of NavierStokesSolver.cc</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_simple_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_solver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/std_cxx1x/shared_ptr.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#define MAX_NUM_ITER_TO_RECOMPUTE_PRECONDITIONER 10</span></div></div><!-- fragment --><p>/////////////////////////////////////////////////////////////// /////////////////// NAVIER STOKES SOLVER ////////////////////// ///////////////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>NavierStokesSolver {</div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --><p>constructor for using LEVEL SET</p>
<div class="fragment"><div class="line">NavierStokesSolver(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS, </div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> time_step, </div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> eps, </div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> rho_air, </div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> nu_air,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> rho_fluid, </div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> nu_fluid, </div><div class="line">                   <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;force_function,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose, </div><div class="line">                   <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation, </div><div class="line">                   MPI_Comm &amp;mpi_communicator);</div></div><!-- fragment --><p>constructor for NOT LEVEL SET</p>
<div class="fragment"><div class="line">NavierStokesSolver(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS, </div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> time_step, </div><div class="line">                   <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;force_function, </div><div class="line">                   <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rho_function,</div><div class="line">                   <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;nu_function, </div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose,</div><div class="line">                   <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation, </div><div class="line">                   MPI_Comm &amp;mpi_communicator);</div></div><!-- fragment --><p>rho and nu functions</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_rho_and_nu_functions(<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rho_function,</div><div class="line">                              <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;nu_function);</div></div><!-- fragment --><p>initial conditions</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initial_condition(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_rho,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_p);</div><div class="line"><span class="keywordtype">void</span> initial_condition(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_rho,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_w,</div><div class="line">                       <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_p);</div></div><!-- fragment --><p>boundary conditions</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_boundary_conditions(std::vector&lt;unsigned int&gt; boundary_values_id_u,</div><div class="line">                             std::vector&lt;unsigned int&gt; boundary_values_id_v, std::vector&lt;double&gt; boundary_values_u,</div><div class="line">                             std::vector&lt;double&gt; boundary_values_v);</div><div class="line"><span class="keywordtype">void</span> set_boundary_conditions(std::vector&lt;unsigned int&gt; boundary_values_id_u,</div><div class="line">                             std::vector&lt;unsigned int&gt; boundary_values_id_v,</div><div class="line">                             std::vector&lt;unsigned int&gt; boundary_values_id_w, std::vector&lt;double&gt; boundary_values_u,</div><div class="line">                             std::vector&lt;double&gt; boundary_values_v, std::vector&lt;double&gt; boundary_values_w);</div><div class="line"><span class="keywordtype">void</span> set_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v);</div><div class="line"><span class="keywordtype">void</span> set_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v,</div><div class="line">                  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_w);</div><div class="line"><span class="keywordtype">void</span> set_phi(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_phi);</div><div class="line"><span class="keywordtype">void</span> get_pressure(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_p);</div><div class="line"><span class="keywordtype">void</span> get_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_u,</div><div class="line">                  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_v);</div><div class="line"><span class="keywordtype">void</span> get_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_u,</div><div class="line">                  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_v,</div><div class="line">                  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_w);</div></div><!-- fragment --><p>DO STEPS //</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> nth_time_step();</div></div><!-- fragment --><p>SETUP //</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> setup();</div><div class="line"></div><div class="line">  ~NavierStokesSolver();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>SETUP AND INITIAL CONDITION //</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_DOF();</div><div class="line"><span class="keywordtype">void</span> setup_VECTORS();</div><div class="line"><span class="keywordtype">void</span> init_constraints();</div></div><!-- fragment --><p>ASSEMBLE SYSTEMS //</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_system_U();</div><div class="line"><span class="keywordtype">void</span> assemble_system_dpsi_q();</div></div><!-- fragment --><p>SOLVERS //</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> solve_U(<span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;Matrix,</div><div class="line">             std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner,</div><div class="line">             <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;completely_distributed_solution,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;rhs);</div><div class="line"><span class="keywordtype">void</span> solve_P(<span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;Matrix,</div><div class="line">             std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner,</div><div class="line">             <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;completely_distributed_solution,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;rhs);</div></div><!-- fragment --><p>GET DIFFERENT FIELDS //</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> get_rho_and_nu(<span class="keywordtype">double</span> phi);</div><div class="line"><span class="keywordtype">void</span> get_velocity();</div><div class="line"><span class="keywordtype">void</span> get_pressure();</div></div><!-- fragment --><p>OTHERS //</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> save_old_solution();</div><div class="line"></div><div class="line">  MPI_Comm &amp;mpi_communicator;</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation;</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> degree_LS;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_LS;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe_LS;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs_LS;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs_LS;</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> degree_U;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_U;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe_U;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs_U;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs_U;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler_P;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe_P;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs_P;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs_P;</div><div class="line"></div><div class="line">  <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;force_function;</div><div class="line">  <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rho_function;</div><div class="line">  <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;nu_function;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> rho_air;</div><div class="line">  <span class="keywordtype">double</span> nu_air;</div><div class="line">  <span class="keywordtype">double</span> rho_fluid;</div><div class="line">  <span class="keywordtype">double</span> nu_fluid;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> time_step;</div><div class="line">  <span class="keywordtype">double</span> eps;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> verbose;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> LEVEL_SET;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> RHO_TIMES_RHS;</div><div class="line"></div><div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> rho_min;</div><div class="line">  <span class="keywordtype">double</span> rho_value;</div><div class="line">  <span class="keywordtype">double</span> nu_value;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> h;</div><div class="line">  <span class="keywordtype">double</span> umax;</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> degree_MAX;</div><div class="line"></div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints_psi;</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; boundary_values_id_u;</div><div class="line">  std::vector&lt;unsigned int&gt; boundary_values_id_v;</div><div class="line">  std::vector&lt;unsigned int&gt; boundary_values_id_w;</div><div class="line">  std::vector&lt;double&gt; boundary_values_u;</div><div class="line">  std::vector&lt;double&gt; boundary_values_v;</div><div class="line">  std::vector&lt;double&gt; boundary_values_w;</div><div class="line"></div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> system_Matrix_u;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> system_Matrix_v;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> system_Matrix_w;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_Matrix_U;</div><div class="line">  std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner_Matrix_u;</div><div class="line">  std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner_Matrix_v;</div><div class="line">  std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner_Matrix_w;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> system_S;</div><div class="line">  std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner_S;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> system_M;</div><div class="line">  std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner_M;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_S_M;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_Matrix_U_preconditioners;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_S_M_preconditioners;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> system_rhs_u;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> system_rhs_v;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> system_rhs_w;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> system_rhs_psi;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> system_rhs_q;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_phi;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_w;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u_old;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v_old;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_w_old;</div><div class="line"></div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_psi;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_psi_old;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_p;</div><div class="line"></div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_u;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_v;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_w;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_psi;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_q;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_p;</div><div class="line">};</div></div><!-- fragment --><p>CONSTRUCTOR FOR LEVEL SET</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">NavierStokesSolver&lt;dim&gt;::NavierStokesSolver(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U, </div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> time_step, </div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> eps, </div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> rho_air,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> nu_air, </div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> rho_fluid, </div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> nu_fluid,</div><div class="line">                                            <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;force_function, </div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose, </div><div class="line">                                            <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation, </div><div class="line">                                            MPI_Comm &amp;mpi_communicator) </div><div class="line">  :</div><div class="line">  mpi_communicator(mpi_communicator), </div><div class="line">  triangulation(triangulation), </div><div class="line">  degree_LS(degree_LS), </div><div class="line">  dof_handler_LS(triangulation), </div><div class="line">  fe_LS(degree_LS), </div><div class="line">  degree_U(degree_U), </div><div class="line">  dof_handler_U(triangulation), </div><div class="line">  fe_U(degree_U), </div><div class="line">  dof_handler_P(triangulation), </div><div class="line">  fe_P(degree_U-1), </div><div class="line">  force_function(force_function),</div></div><!-- fragment --><p>This is dummy since rho and nu functions won't be used</p>
<div class="fragment"><div class="line">  rho_function(force_function), </div><div class="line">  nu_function(force_function), </div><div class="line">  rho_air(rho_air), </div><div class="line">  nu_air(nu_air), </div><div class="line">  rho_fluid(rho_fluid), </div><div class="line">  nu_fluid(nu_fluid), </div><div class="line">  time_step(time_step), </div><div class="line">  eps(eps), </div><div class="line">  verbose(verbose), </div><div class="line">  LEVEL_SET(1), </div><div class="line">  RHO_TIMES_RHS(1),</div><div class="line">  pcout(std::cout,(<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator)==0)), </div><div class="line">  rebuild_Matrix_U(<span class="keyword">true</span>), </div><div class="line">  rebuild_S_M(<span class="keyword">true</span>),</div><div class="line">  rebuild_Matrix_U_preconditioners(<span class="keyword">true</span>),</div><div class="line">  rebuild_S_M_preconditioners(<span class="keyword">true</span>)</div><div class="line">{setup();}</div></div><!-- fragment --><p>CONSTRUCTOR NOT FOR LEVEL SET</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">NavierStokesSolver&lt;dim&gt;::NavierStokesSolver(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U, </div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">double</span> time_step, </div><div class="line">                                            <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;force_function,</div><div class="line">                                            <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rho_function, </div><div class="line">                                            <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;nu_function, </div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">bool</span> verbose,</div><div class="line">                                            <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation, </div><div class="line">                                            MPI_Comm &amp;mpi_communicator) :</div><div class="line">  mpi_communicator(mpi_communicator), </div><div class="line">  triangulation(triangulation), </div><div class="line">  degree_LS(degree_LS), </div><div class="line">  dof_handler_LS(triangulation), </div><div class="line">  fe_LS(degree_LS), </div><div class="line">  degree_U(degree_U), </div><div class="line">  dof_handler_U(triangulation), </div><div class="line">  fe_U(degree_U), </div><div class="line">  dof_handler_P(triangulation), </div><div class="line">  fe_P(degree_U-1), </div><div class="line">  force_function(force_function), </div><div class="line">  rho_function(rho_function), </div><div class="line">  nu_function(nu_function), </div><div class="line">  time_step(time_step), </div><div class="line">  verbose(verbose), </div><div class="line">  LEVEL_SET(0), </div><div class="line">  RHO_TIMES_RHS(0), </div><div class="line">  pcout(<a class="code" href="namespacestd.html">std</a>::cout,(<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::this_mpi_process(mpi_communicator)==0)), </div><div class="line">  rebuild_Matrix_U(true), </div><div class="line">  rebuild_S_M(true),</div><div class="line">  rebuild_Matrix_U_preconditioners(true),</div><div class="line">  rebuild_S_M_preconditioners(true)</div><div class="line">{setup();}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">NavierStokesSolver&lt;dim&gt;::~NavierStokesSolver() {</div><div class="line">  dof_handler_LS.clear();</div><div class="line">  dof_handler_U.clear();</div><div class="line">  dof_handler_P.clear();</div><div class="line">}</div></div><!-- fragment --><p>/////////////////////////////////////////////////////////// ////////////////// SETTERS AND GETTERS //////////////////// ///////////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::set_rho_and_nu_functions(<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rho_function,</div><div class="line">                                                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;nu_function) {</div><div class="line">  this-&gt;rho_function=rho_function;</div><div class="line">  this-&gt;nu_function=nu_function;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::initial_condition(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_phi,</div><div class="line">                                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v,</div><div class="line">                                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_p) {</div><div class="line">  this-&gt;locally_relevant_solution_phi=locally_relevant_solution_phi;</div><div class="line">  this-&gt;locally_relevant_solution_u=locally_relevant_solution_u;</div><div class="line">  this-&gt;locally_relevant_solution_v=locally_relevant_solution_v; </div><div class="line">  this-&gt;locally_relevant_solution_p=locally_relevant_solution_p;</div></div><!-- fragment --><p>set old vectors to the initial condition (just for first time step)</p>
<div class="fragment"><div class="line">  save_old_solution();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::initial_condition(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_phi,</div><div class="line">                                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v,</div><div class="line">                                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_w,</div><div class="line">                                                <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_p) </div><div class="line">{</div><div class="line">  this-&gt;locally_relevant_solution_phi=locally_relevant_solution_phi;</div><div class="line">  this-&gt;locally_relevant_solution_u=locally_relevant_solution_u;</div><div class="line">  this-&gt;locally_relevant_solution_v=locally_relevant_solution_v;</div><div class="line">  this-&gt;locally_relevant_solution_w=locally_relevant_solution_w;</div><div class="line">  this-&gt;locally_relevant_solution_p=locally_relevant_solution_p;</div></div><!-- fragment --><p>set old vectors to the initial condition (just for first time step)</p>
<div class="fragment"><div class="line">  save_old_solution();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::set_boundary_conditions(std::vector&lt;unsigned int&gt; boundary_values_id_u,</div><div class="line">                                                      std::vector&lt;unsigned int&gt; boundary_values_id_v, </div><div class="line">                                                      std::vector&lt;double&gt; boundary_values_u,</div><div class="line">                                                      std::vector&lt;double&gt; boundary_values_v) </div><div class="line">{</div><div class="line">  this-&gt;boundary_values_id_u=boundary_values_id_u;</div><div class="line">  this-&gt;boundary_values_id_v=boundary_values_id_v;</div><div class="line">  this-&gt;boundary_values_u=boundary_values_u;</div><div class="line">  this-&gt;boundary_values_v=boundary_values_v;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::set_boundary_conditions(std::vector&lt;unsigned int&gt; boundary_values_id_u,</div><div class="line">                                                      std::vector&lt;unsigned int&gt; boundary_values_id_v,</div><div class="line">                                                      std::vector&lt;unsigned int&gt; boundary_values_id_w, </div><div class="line">                                                      std::vector&lt;double&gt; boundary_values_u,</div><div class="line">                                                      std::vector&lt;double&gt; boundary_values_v, </div><div class="line">                                                      std::vector&lt;double&gt; boundary_values_w) </div><div class="line">{</div><div class="line">  this-&gt;boundary_values_id_u=boundary_values_id_u;</div><div class="line">  this-&gt;boundary_values_id_v=boundary_values_id_v;</div><div class="line">  this-&gt;boundary_values_id_w=boundary_values_id_w;</div><div class="line">  this-&gt;boundary_values_u=boundary_values_u;</div><div class="line">  this-&gt;boundary_values_v=boundary_values_v;</div><div class="line">  this-&gt;boundary_values_w=boundary_values_w;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::set_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                                           <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v) {</div><div class="line">  this-&gt;locally_relevant_solution_u=locally_relevant_solution_u;</div><div class="line">  this-&gt;locally_relevant_solution_v=locally_relevant_solution_v;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::set_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u,</div><div class="line">                                           <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v,</div><div class="line">                                           <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_w) {</div><div class="line">  this-&gt;locally_relevant_solution_u=locally_relevant_solution_u;</div><div class="line">  this-&gt;locally_relevant_solution_v=locally_relevant_solution_v;</div><div class="line">  this-&gt;locally_relevant_solution_w=locally_relevant_solution_w;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::set_phi(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_phi) {</div><div class="line">  this-&gt;locally_relevant_solution_phi=locally_relevant_solution_phi;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::get_rho_and_nu(<span class="keywordtype">double</span> phi) {</div><div class="line">  <span class="keywordtype">double</span> H=0;</div></div><!-- fragment --><p>get rho, nu</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (phi&gt;eps)</div><div class="line">  H=1;</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (phi&lt;-eps)</div><div class="line">  H=-1;</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  H=phi/eps;</div><div class="line">rho_value=rho_fluid*(1+H)/2.+rho_air*(1-H)/2.;</div><div class="line">nu_value=nu_fluid*(1+H)/2.+nu_air*(1-H)/2.;</div></div><!-- fragment --><p>rho_value=rho_fluid*(1+phi)/2.+rho_air*(1-phi)/2.; nu_value=nu_fluid*(1+phi)/2.+nu_air*(1-phi)/2.;</p>
<div class="fragment"><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::get_pressure(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_p) </div><div class="line">{</div><div class="line">  locally_relevant_solution_p=this-&gt;locally_relevant_solution_p;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::get_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_u,</div><div class="line">                                           <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_v) {</div><div class="line">  locally_relevant_solution_u=this-&gt;locally_relevant_solution_u;</div><div class="line">  locally_relevant_solution_v=this-&gt;locally_relevant_solution_v;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::get_velocity(<a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_u,</div><div class="line">                                           <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_v,</div><div class="line">                                           <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;locally_relevant_solution_w) {</div><div class="line">  locally_relevant_solution_u=this-&gt;locally_relevant_solution_u;</div><div class="line">  locally_relevant_solution_v=this-&gt;locally_relevant_solution_v;</div><div class="line">  locally_relevant_solution_w=this-&gt;locally_relevant_solution_w;</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// /////////// SETUP AND INITIAL CONDITION ///////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::setup() {</div><div class="line">  pcout&lt;&lt;<span class="stringliteral">&quot;***** SETUP IN NAVIER STOKES SOLVER *****&quot;</span>&lt;&lt;std::endl;</div><div class="line">  setup_DOF();</div><div class="line">  init_constraints();</div><div class="line">  setup_VECTORS();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::setup_DOF() {</div><div class="line">  rho_min = 1.;</div><div class="line">  degree_MAX=std::max(degree_LS,degree_U);</div></div><!-- fragment --><p>setup system LS</p>
<div class="fragment"><div class="line">dof_handler_LS.distribute_dofs(fe_LS);</div><div class="line">locally_owned_dofs_LS=dof_handler_LS.locally_owned_dofs();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler_LS,locally_relevant_dofs_LS);</div></div><!-- fragment --><p>setup system U</p>
<div class="fragment"><div class="line">dof_handler_U.distribute_dofs(fe_U);</div><div class="line">locally_owned_dofs_U=dof_handler_U.locally_owned_dofs();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler_U,locally_relevant_dofs_U);</div></div><!-- fragment --><p>setup system P //</p>
<div class="fragment"><div class="line">  dof_handler_P.distribute_dofs(fe_P);</div><div class="line">  locally_owned_dofs_P=dof_handler_P.locally_owned_dofs();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler_P,locally_relevant_dofs_P);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::setup_VECTORS() {</div></div><!-- fragment --><p>init vectors for phi</p>
<div class="fragment"><div class="line">locally_relevant_solution_phi.reinit(locally_owned_dofs_LS,locally_relevant_dofs_LS,</div><div class="line">                                     mpi_communicator);</div><div class="line">locally_relevant_solution_phi=0;</div></div><!-- fragment --><p>init vectors for u</p>
<div class="fragment"><div class="line">locally_relevant_solution_u.reinit(locally_owned_dofs_U,locally_relevant_dofs_U,</div><div class="line">                                   mpi_communicator);</div><div class="line">locally_relevant_solution_u=0;</div><div class="line">completely_distributed_solution_u.reinit(locally_owned_dofs_U,mpi_communicator);</div><div class="line">system_rhs_u.reinit(locally_owned_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for u_old</p>
<div class="fragment"><div class="line">locally_relevant_solution_u_old.reinit(locally_owned_dofs_U,locally_relevant_dofs_U,</div><div class="line">                                       mpi_communicator);</div><div class="line">locally_relevant_solution_u_old=0;</div></div><!-- fragment --><p>init vectors for v</p>
<div class="fragment"><div class="line">locally_relevant_solution_v.reinit(locally_owned_dofs_U,locally_relevant_dofs_U,</div><div class="line">                                   mpi_communicator);</div><div class="line">locally_relevant_solution_v=0;</div><div class="line">completely_distributed_solution_v.reinit(locally_owned_dofs_U,mpi_communicator);</div><div class="line">system_rhs_v.reinit(locally_owned_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for v_old</p>
<div class="fragment"><div class="line">locally_relevant_solution_v_old.reinit(locally_owned_dofs_U,locally_relevant_dofs_U,</div><div class="line">                                       mpi_communicator);</div><div class="line">locally_relevant_solution_v_old=0;</div></div><!-- fragment --><p>init vectors for w</p>
<div class="fragment"><div class="line">locally_relevant_solution_w.reinit(locally_owned_dofs_U,locally_relevant_dofs_U,</div><div class="line">                                   mpi_communicator);</div><div class="line">locally_relevant_solution_w=0;</div><div class="line">completely_distributed_solution_w.reinit(locally_owned_dofs_U,mpi_communicator);</div><div class="line">system_rhs_w.reinit(locally_owned_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for w_old</p>
<div class="fragment"><div class="line">locally_relevant_solution_w_old.reinit(locally_owned_dofs_U,locally_relevant_dofs_U,</div><div class="line">                                       mpi_communicator);</div><div class="line">locally_relevant_solution_w_old=0;</div></div><!-- fragment --><p>init vectors for dpsi</p>
<div class="fragment"><div class="line">locally_relevant_solution_psi.reinit(locally_owned_dofs_P,locally_relevant_dofs_P,</div><div class="line">                                     mpi_communicator);</div><div class="line">locally_relevant_solution_psi=0;</div><div class="line">system_rhs_psi.reinit(locally_owned_dofs_P,mpi_communicator);</div></div><!-- fragment --><p>init vectors for dpsi old</p>
<div class="fragment"><div class="line">locally_relevant_solution_psi_old.reinit(locally_owned_dofs_P,locally_relevant_dofs_P,</div><div class="line">                                         mpi_communicator);</div><div class="line">locally_relevant_solution_psi_old=0;</div></div><!-- fragment --><p>init vectors for q</p>
<div class="fragment"><div class="line">completely_distributed_solution_q.reinit(locally_owned_dofs_P,mpi_communicator);</div><div class="line">system_rhs_q.reinit(locally_owned_dofs_P,mpi_communicator);</div></div><!-- fragment --><p>init vectors for psi</p>
<div class="fragment"><div class="line">completely_distributed_solution_psi.reinit(locally_owned_dofs_P,mpi_communicator);</div></div><!-- fragment --><p>init vectors for p</p>
<div class="fragment"><div class="line">locally_relevant_solution_p.reinit(locally_owned_dofs_P,locally_relevant_dofs_P,</div><div class="line">                                   mpi_communicator);</div><div class="line">locally_relevant_solution_p=0;</div><div class="line">completely_distributed_solution_p.reinit(locally_owned_dofs_P,mpi_communicator);</div></div><!-- fragment --><p>////////////////////////// Initialize constraints // //////////////////////////</p>
<div class="fragment"><div class="line">init_constraints();</div></div><!-- fragment --><p>//////////////////// Sparsity pattern // //////////////////// sparsity pattern for A</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp_Matrix(locally_relevant_dofs_U);</div><div class="line"><a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler_U,dsp_Matrix,constraints,<span class="keyword">false</span>);</div><div class="line"><a class="code" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">SparsityTools::distribute_sparsity_pattern</a>(dsp_Matrix,</div><div class="line">                                           dof_handler_U.n_locally_owned_dofs_per_processor(),mpi_communicator,</div><div class="line">                                           locally_relevant_dofs_U);</div><div class="line">system_Matrix_u.reinit(mpi_communicator,dsp_Matrix,</div><div class="line">                       dof_handler_U.n_locally_owned_dofs_per_processor(),</div><div class="line">                       dof_handler_U.n_locally_owned_dofs_per_processor(),</div><div class="line">                       <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">system_Matrix_v.reinit(mpi_communicator,dsp_Matrix,</div><div class="line">                       dof_handler_U.n_locally_owned_dofs_per_processor(),</div><div class="line">                       dof_handler_U.n_locally_owned_dofs_per_processor(),</div><div class="line">                       <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">system_Matrix_w.reinit(mpi_communicator,dsp_Matrix,</div><div class="line">                       dof_handler_U.n_locally_owned_dofs_per_processor(),</div><div class="line">                       dof_handler_U.n_locally_owned_dofs_per_processor(),</div><div class="line">                       <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">rebuild_Matrix_U=<span class="keyword">true</span>;</div></div><!-- fragment --><p>sparsity pattern for S</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp_S(locally_relevant_dofs_P);</div><div class="line"><a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler_P,dsp_S,constraints_psi,<span class="keyword">false</span>);</div><div class="line"><a class="code" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">SparsityTools::distribute_sparsity_pattern</a>(dsp_S,</div><div class="line">                                           dof_handler_P.n_locally_owned_dofs_per_processor(),mpi_communicator,</div><div class="line">                                           locally_relevant_dofs_P);</div><div class="line">system_S.reinit(mpi_communicator,dsp_S,dof_handler_P.n_locally_owned_dofs_per_processor(),</div><div class="line">                dof_handler_P.n_locally_owned_dofs_per_processor(),</div><div class="line">                <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div></div><!-- fragment --><p>sparsity pattern for M</p>
<div class="fragment"><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp_M(locally_relevant_dofs_P);</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler_P,dsp_M,constraints_psi,<span class="keyword">false</span>);</div><div class="line">  <a class="code" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">SparsityTools::distribute_sparsity_pattern</a>(dsp_M,</div><div class="line">                                             dof_handler_P.n_locally_owned_dofs_per_processor(),mpi_communicator,</div><div class="line">                                             locally_relevant_dofs_P);</div><div class="line">  system_M.reinit(mpi_communicator,dsp_M,dof_handler_P.n_locally_owned_dofs_per_processor(),</div><div class="line">                  dof_handler_P.n_locally_owned_dofs_per_processor(),</div><div class="line">                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">  rebuild_S_M=<span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::init_constraints() {</div></div><!-- fragment --><p>grl constraints</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a>();</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#ac2726821354883ac97fe7e6181de9792">reinit</a>(locally_relevant_dofs_U);</div><div class="line"><a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a>(dof_handler_U,constraints);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div></div><!-- fragment --><p>constraints for dpsi</p>
<div class="fragment"><div class="line">constraints_psi.clear();</div><div class="line">constraints_psi.reinit(locally_relevant_dofs_P);</div><div class="line"><a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a>(dof_handler_P,constraints_psi);</div></div><!-- fragment --><p>if (constraints_psi.can_store_line(0)) constraints_psi.add_line(0); //constraint u0 = 0</p>
<div class="fragment"><div class="line">  constraints_psi.close();</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// //////////////// ASSEMBLE SYSTEMS /////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::assemble_system_U() </div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_Matrix_U==<span class="keyword">true</span>) </div><div class="line">    {</div><div class="line">      system_Matrix_u=0;</div><div class="line">      system_Matrix_v=0;</div><div class="line">      system_Matrix_w=0;</div><div class="line">    }</div><div class="line">  system_rhs_u=0;</div><div class="line">  system_rhs_v=0;</div><div class="line">  system_rhs_w=0;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree_MAX+1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_LS(fe_LS,quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_U(fe_U,quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_P(fe_P,quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell=fe_U.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points=quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_A_u(dofs_per_cell,dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs_u(dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs_v(dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs_w(dofs_per_cell);</div><div class="line">  </div><div class="line">  std::vector&lt;double&gt; phiqnp1(n_q_points);</div><div class="line">  </div><div class="line">  std::vector&lt;double&gt; uqn(n_q_points);</div><div class="line">  std::vector&lt;double&gt; uqnm1(n_q_points);</div><div class="line">  std::vector&lt;double&gt; vqn(n_q_points);</div><div class="line">  std::vector&lt;double&gt; vqnm1(n_q_points);</div><div class="line">  std::vector&lt;double&gt; wqn(n_q_points);</div><div class="line">  std::vector&lt;double&gt; wqnm1(n_q_points);</div></div><!-- fragment --><p>FOR Explicit nonlinearity std::vector&lt;<a class="el" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &gt; grad_un(n_q_points); std::vector&lt;<a class="el" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &gt; grad_vn(n_q_points); std::vector&lt;<a class="el" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &gt; grad_wn(n_q_points); <a class="el" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Un;</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim&gt; &gt; grad_pqn(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt; &gt; grad_psiqn(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt; &gt; grad_psiqnm1(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;unsigned int&gt; local_dof_indices(dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt; &gt; shape_grad(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt; shape_value(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> force_u;</div><div class="line"><span class="keywordtype">double</span> force_v;</div><div class="line"><span class="keywordtype">double</span> force_w;</div><div class="line"><span class="keywordtype">double</span> pressure_grad_u;</div><div class="line"><span class="keywordtype">double</span> pressure_grad_v;</div><div class="line"><span class="keywordtype">double</span> pressure_grad_w;</div><div class="line"><span class="keywordtype">double</span> u_star=0;</div><div class="line"><span class="keywordtype">double</span> v_star=0;</div><div class="line"><span class="keywordtype">double</span> w_star=0;</div><div class="line"><span class="keywordtype">double</span> rho_star;</div><div class="line"><span class="keywordtype">double</span> rho;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> force_terms(dim);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> </div><div class="line">  cell_U=dof_handler_U.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), endc_U=dof_handler_U.end();</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell_P=dof_handler_P.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell_LS=dof_handler_LS.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell_U!=endc_U; ++cell_U,++cell_P,++cell_LS)</div><div class="line">  <span class="keywordflow">if</span> (cell_U-&gt;is_locally_owned()) {</div><div class="line">    cell_A_u=0;</div><div class="line">    cell_rhs_u=0;</div><div class="line">    cell_rhs_v=0;</div><div class="line">    cell_rhs_w=0;</div><div class="line">    </div><div class="line">    fe_values_LS.reinit(cell_LS);</div><div class="line">    fe_values_U.reinit(cell_U);</div><div class="line">    fe_values_P.reinit(cell_P);</div></div><!-- fragment --><p>get function values for LS</p>
<div class="fragment"><div class="line">fe_values_LS.get_function_values(locally_relevant_solution_phi,phiqnp1);</div></div><!-- fragment --><p>get function values for U</p>
<div class="fragment"><div class="line">fe_values_U.get_function_values(locally_relevant_solution_u,uqn);</div><div class="line">fe_values_U.get_function_values(locally_relevant_solution_u_old,uqnm1);</div><div class="line">fe_values_U.get_function_values(locally_relevant_solution_v,vqn);</div><div class="line">fe_values_U.get_function_values(locally_relevant_solution_v_old,vqnm1);</div><div class="line"><span class="keywordflow">if</span> (dim==3) </div><div class="line">  {</div><div class="line">    fe_values_U.get_function_values(locally_relevant_solution_w,wqn);</div><div class="line">    fe_values_U.get_function_values(locally_relevant_solution_w_old,wqnm1);</div><div class="line">  }</div></div><!-- fragment --><p>For explicit nonlinearity get gradient values for U fe_values_U.get_function_gradients(locally_relevant_solution_u,grad_un); fe_values_U.get_function_gradients(locally_relevant_solution_v,grad_vn); if (dim==3) fe_values_U.get_function_gradients(locally_relevant_solution_w,grad_wn);</p>
<p>get values and gradients for p and dpsi</p>
<div class="fragment"><div class="line">fe_values_P.get_function_gradients(locally_relevant_solution_p,grad_pqn);</div><div class="line">fe_values_P.get_function_gradients(locally_relevant_solution_psi,grad_psiqn);</div><div class="line">fe_values_P.get_function_gradients(locally_relevant_solution_psi_old,grad_psiqnm1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> JxW=fe_values_U.JxW(q_point);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i) {</div><div class="line">    shape_grad[i]=fe_values_U.shape_grad(i,q_point);</div><div class="line">    shape_value[i]=fe_values_U.shape_value(i,q_point);</div><div class="line">  }</div><div class="line">  </div><div class="line">  pressure_grad_u=(grad_pqn[q_point][0]+4./3*grad_psiqn[q_point][0]-1./3*grad_psiqnm1[q_point][0]);</div><div class="line">  pressure_grad_v=(grad_pqn[q_point][1]+4./3*grad_psiqn[q_point][1]-1./3*grad_psiqnm1[q_point][1]);</div><div class="line">  <span class="keywordflow">if</span> (dim==3)</div><div class="line">    pressure_grad_w=(grad_pqn[q_point][2]+4./3*grad_psiqn[q_point][2]-1./3*grad_psiqnm1[q_point][2]);</div><div class="line">  </div><div class="line">  <span class="keywordflow">if</span> (LEVEL_SET==1) <span class="comment">// use level set to define rho and nu</span></div><div class="line">    get_rho_and_nu(phiqnp1[q_point]);</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// rho and nu are defined through functions</span></div><div class="line">    {</div><div class="line">      rho_value=rho_function.value(fe_values_U.quadrature_point(q_point));</div><div class="line">      nu_value=nu_function.value(fe_values_U.quadrature_point(q_point));</div><div class="line">    }</div></div><!-- fragment --><p>Non-linearity: for semi-implicit</p>
<div class="fragment"><div class="line">u_star=2*uqn[q_point]-uqnm1[q_point];</div><div class="line">v_star=2*vqn[q_point]-vqnm1[q_point];</div><div class="line"><span class="keywordflow">if</span> (dim==3)</div><div class="line">  w_star=2*wqn[q_point]-wqnm1[q_point];</div></div><!-- fragment --><p>for explicit nonlinearity Un[0] = uqn[q_point]; Un[1] = vqn[q_point]; if (dim==3) Un[2] = wqn[q_point];</p>
<p>double nonlinearity_u = Un*grad_un[q_point]; double nonlinearity_v = Un*grad_vn[q_point]; double nonlinearity_w = 0; if (dim==3) nonlinearity_w = Un*grad_wn[q_point];</p>
<div class="fragment"><div class="line">rho_star=rho_value; <span class="comment">// This is because we consider rho*u_t instead of (rho*u)_t</span></div><div class="line">rho=rho_value;</div></div><!-- fragment --><p>FORCE TERMS</p>
<div class="fragment"><div class="line">force_function.<a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a>(fe_values_U.quadrature_point(q_point),force_terms);</div><div class="line">force_u=force_terms[0];</div><div class="line">force_v=force_terms[1]; </div><div class="line"><span class="keywordflow">if</span> (dim==3)</div><div class="line">  force_w=force_terms[2];</div><div class="line"><span class="keywordflow">if</span> (RHO_TIMES_RHS==1) </div><div class="line">  {</div><div class="line">    force_u*=rho;</div><div class="line">    force_v*=rho;</div><div class="line">    <span class="keywordflow">if</span> (dim==3)</div><div class="line">      force_w*=rho;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i) </div><div class="line">  {</div><div class="line">    cell_rhs_u(i)+=((4./3*rho*uqn[q_point]-1./3*rho*uqnm1[q_point]</div><div class="line">                     +2./3*time_step*(force_u-pressure_grad_u)</div></div><!-- fragment --><p>-2./3*time_step*rho*nonlinearity_u</p>
<div class="fragment"><div class="line">                 )*shape_value[i])*JxW;</div><div class="line">cell_rhs_v(i)+=((4./3*rho*vqn[q_point]-1./3*rho*vqnm1[q_point]</div><div class="line">                 +2./3*time_step*(force_v-pressure_grad_v)</div></div><!-- fragment --><p>-2./3*time_step*rho*nonlinearity_v</p>
<div class="fragment"><div class="line">                 )*shape_value[i])*JxW;</div><div class="line"><span class="keywordflow">if</span> (dim==3)</div><div class="line">  cell_rhs_w(i)+=((4./3*rho*wqn[q_point]-1./3*rho*wqnm1[q_point]</div><div class="line">                   +2./3*time_step*(force_w-pressure_grad_w)</div></div><!-- fragment --><p>-2./3*time_step*rho*nonlinearity_w</p>
<div class="fragment"><div class="line">                         )*shape_value[i])*JxW;</div><div class="line">      <span class="keywordflow">if</span> (rebuild_Matrix_U==<span class="keyword">true</span>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j) </div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (dim==2) </div><div class="line">              cell_A_u(i,j)+=(rho_star*shape_value[i]*shape_value[j]</div><div class="line">                              +2./3*time_step*nu_value*(shape_grad[i]*shape_grad[j])</div><div class="line">                              +2./3*time_step*rho*shape_value[i]</div><div class="line">                              *(u_star*shape_grad[j][0]+v_star*shape_grad[j][1]) <span class="comment">// semi-implicit NL</span></div><div class="line">                              )*JxW;</div><div class="line">            <span class="keywordflow">else</span> <span class="comment">//dim==3</span></div><div class="line">              cell_A_u(i,j)+=(rho_star*shape_value[i]*shape_value[j]</div><div class="line">                              +2./3*time_step*nu_value*(shape_grad[i]*shape_grad[j])</div><div class="line">                              +2./3*time_step*rho*shape_value[i]</div><div class="line">                              *(u_star*shape_grad[j][0]+v_star*shape_grad[j][1]+w_star*shape_grad[j][2]) <span class="comment">// semi-implicit NL</span></div><div class="line">                              )*JxW;</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div><div class="line">cell_U-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>distribute</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (rebuild_Matrix_U==<span class="keyword">true</span>) </div><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a>(cell_A_u,local_dof_indices,system_Matrix_u);</div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a>(cell_rhs_u,local_dof_indices,system_rhs_u);</div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a>(cell_rhs_v,local_dof_indices,system_rhs_v);</div><div class="line">    <span class="keywordflow">if</span> (dim==3)</div><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a>(cell_rhs_w,local_dof_indices,system_rhs_w);</div><div class="line">  }</div><div class="line">system_rhs_u.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">system_rhs_v.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"><span class="keywordflow">if</span> (dim==3) system_rhs_w.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"><span class="keywordflow">if</span> (rebuild_Matrix_U==<span class="keyword">true</span>) </div><div class="line">  {</div><div class="line">    system_Matrix_u.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_Matrix_v.copy_from(system_Matrix_u);</div><div class="line">    <span class="keywordflow">if</span> (dim==3) </div><div class="line">      system_Matrix_w.copy_from(system_Matrix_u);</div><div class="line">  }</div></div><!-- fragment --><p>BOUNDARY CONDITIONS</p>
<div class="fragment"><div class="line">system_rhs_u.set(boundary_values_id_u,boundary_values_u);</div><div class="line">system_rhs_u.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">system_rhs_v.set(boundary_values_id_v,boundary_values_v);</div><div class="line">system_rhs_v.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"><span class="keywordflow">if</span> (dim==3) </div><div class="line">  {</div><div class="line">    system_rhs_w.set(boundary_values_id_w,boundary_values_w);</div><div class="line">    system_rhs_w.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  }</div><div class="line"><span class="keywordflow">if</span> (rebuild_Matrix_U)</div><div class="line">  {</div><div class="line">    system_Matrix_u.clear_rows(boundary_values_id_u,1);</div><div class="line">    system_Matrix_v.clear_rows(boundary_values_id_v,1);</div><div class="line">    <span class="keywordflow">if</span> (dim==3)</div><div class="line">      system_Matrix_w.clear_rows(boundary_values_id_w,1);</div><div class="line">    <span class="keywordflow">if</span> (rebuild_Matrix_U_preconditioners)</div><div class="line">      {</div></div><!-- fragment --><p>PRECONDITIONERS</p>
<div class="fragment"><div class="line">          rebuild_Matrix_U_preconditioners=<span class="keyword">false</span>;</div><div class="line">          preconditioner_Matrix_u.reset(<span class="keyword">new</span> <a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html">PETScWrappers::PreconditionBoomerAMG</a></div><div class="line">                                        (system_Matrix_u,<a class="code" href="structPETScWrappers_1_1PreconditionBoomerAMG_1_1AdditionalData.html">PETScWrappers::PreconditionBoomerAMG::AdditionalData</a>(<span class="keyword">false</span>)));</div><div class="line">          preconditioner_Matrix_v.reset( <span class="keyword">new</span> <a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html">PETScWrappers::PreconditionBoomerAMG</a></div><div class="line">                                         (system_Matrix_v,<a class="code" href="structPETScWrappers_1_1PreconditionBoomerAMG_1_1AdditionalData.html">PETScWrappers::PreconditionBoomerAMG::AdditionalData</a>(<span class="keyword">false</span>)));</div><div class="line">          <span class="keywordflow">if</span> (dim==3)</div><div class="line">            preconditioner_Matrix_w.reset(<span class="keyword">new</span> <a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html">PETScWrappers::PreconditionBoomerAMG</a></div><div class="line">                                          (system_Matrix_w,<a class="code" href="structPETScWrappers_1_1PreconditionBoomerAMG_1_1AdditionalData.html">PETScWrappers::PreconditionBoomerAMG::AdditionalData</a>(<span class="keyword">false</span>)));</div><div class="line">        }</div><div class="line">    }</div><div class="line">  rebuild_Matrix_U=<span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::assemble_system_dpsi_q() {</div><div class="line">  <span class="keywordflow">if</span> (rebuild_S_M==<span class="keyword">true</span>) {</div><div class="line">    system_S=0;</div><div class="line">    system_M=0;</div><div class="line">  }</div><div class="line">  system_rhs_psi=0;</div><div class="line">  system_rhs_q=0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(degree_MAX+1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_U(fe_U,quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_P(fe_P,quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_LS(fe_LS,quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>|<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell=fe_P.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points=quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_S(dofs_per_cell,dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_M(dofs_per_cell,dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs_psi(dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs_q(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; phiqnp1(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt; &gt; gunp1(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt; &gt; gvnp1(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt; &gt; gwnp1(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt; shape_value(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt; &gt; shape_grad(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> </div><div class="line">    cell_P=dof_handler_P.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), endc_P=dof_handler_P.end();</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell_U=dof_handler_U.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell_LS=dof_handler_LS.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell_P!=endc_P; ++cell_P,++cell_U,++cell_LS)</div><div class="line">    <span class="keywordflow">if</span> (cell_P-&gt;is_locally_owned()) {</div><div class="line">      cell_S=0;</div><div class="line">      cell_M=0;</div><div class="line">      cell_rhs_psi=0;</div><div class="line">      cell_rhs_q=0;</div><div class="line"></div><div class="line">      fe_values_P.reinit(cell_P);</div><div class="line">      fe_values_U.reinit(cell_U);</div><div class="line">      fe_values_LS.reinit(cell_LS);</div></div><!-- fragment --><p>get function values for LS</p>
<div class="fragment"><div class="line">fe_values_LS.get_function_values(locally_relevant_solution_phi,phiqnp1);</div></div><!-- fragment --><p>get function grads for u and v</p>
<div class="fragment"><div class="line">fe_values_U.get_function_gradients(locally_relevant_solution_u,gunp1);</div><div class="line">fe_values_U.get_function_gradients(locally_relevant_solution_v,gvnp1);</div><div class="line"><span class="keywordflow">if</span> (dim==3)</div><div class="line">  fe_values_U.get_function_gradients(locally_relevant_solution_w,gwnp1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> JxW=fe_values_P.JxW(q_point);</div><div class="line">  <span class="keywordtype">double</span> divU = gunp1[q_point][0]+gvnp1[q_point][1];</div><div class="line">  <span class="keywordflow">if</span> (dim==3) divU += gwnp1[q_point][2]; </div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i) {</div><div class="line">    shape_value[i]=fe_values_P.shape_value(i,q_point);</div><div class="line">    shape_grad[i]=fe_values_P.shape_grad(i,q_point);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (LEVEL_SET==1) <span class="comment">// use level set to define rho and nu</span></div><div class="line">    get_rho_and_nu (phiqnp1[q_point]);</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// rho and nu are defined through functions</span></div><div class="line">    nu_value=nu_function.value(fe_values_U.quadrature_point(q_point));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i) {</div><div class="line">    cell_rhs_psi(i)+=-3./2./time_step*rho_min*divU*shape_value[i]*JxW;</div><div class="line">    cell_rhs_q(i)-=nu_value*divU*shape_value[i]*JxW;</div><div class="line">    <span class="keywordflow">if</span> (rebuild_S_M==<span class="keyword">true</span>)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j) </div><div class="line">        <span class="keywordflow">if</span> (i==j)</div><div class="line">          {</div><div class="line">            cell_S(i,j)+=shape_grad[i]*shape_grad[j]*JxW+1E-10;</div><div class="line">            cell_M(i,j)+=shape_value[i]*shape_value[j]*JxW;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            cell_S(i,j)+=shape_grad[i]*shape_grad[j]*JxW;</div><div class="line">            cell_M(i,j)+=shape_value[i]*shape_value[j]*JxW;</div><div class="line">          }</div><div class="line">  }</div><div class="line">}</div><div class="line">cell_P-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>Distribute</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (rebuild_S_M==<span class="keyword">true</span>) {</div><div class="line">        constraints_psi.distribute_local_to_global(cell_S,local_dof_indices,system_S);</div><div class="line">        constraints_psi.distribute_local_to_global(cell_M,local_dof_indices,system_M);</div><div class="line">      }</div><div class="line">      constraints_psi.distribute_local_to_global(cell_rhs_q,local_dof_indices,system_rhs_q);</div><div class="line">      constraints_psi.distribute_local_to_global(cell_rhs_psi,local_dof_indices,system_rhs_psi);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">if</span> (rebuild_S_M==<span class="keyword">true</span>) </div><div class="line">    {</div><div class="line">      system_M.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">      system_S.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">      <span class="keywordflow">if</span> (rebuild_S_M_preconditioners)</div><div class="line">        {</div><div class="line">          rebuild_S_M_preconditioners=<span class="keyword">false</span>;</div><div class="line">          preconditioner_S.reset(<span class="keyword">new</span> <a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html">PETScWrappers::PreconditionBoomerAMG</a></div><div class="line">                                 (system_S,<a class="code" href="structPETScWrappers_1_1PreconditionBoomerAMG_1_1AdditionalData.html">PETScWrappers::PreconditionBoomerAMG::AdditionalData</a>(<span class="keyword">true</span>)));</div><div class="line">          preconditioner_M.reset(<span class="keyword">new</span> <a class="code" href="classPETScWrappers_1_1PreconditionBoomerAMG.html">PETScWrappers::PreconditionBoomerAMG</a></div><div class="line">                                 (system_M,<a class="code" href="structPETScWrappers_1_1PreconditionBoomerAMG_1_1AdditionalData.html">PETScWrappers::PreconditionBoomerAMG::AdditionalData</a>(<span class="keyword">true</span>)));</div><div class="line">        }</div><div class="line">    }</div><div class="line">  system_rhs_psi.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  system_rhs_q.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  rebuild_S_M=<span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// ///////////////////// SOLVERS /////////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::solve_U(<span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints,</div><div class="line">                                      <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;Matrix,</div><div class="line">                                      std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner,</div><div class="line">                                      <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;completely_distributed_solution,</div><div class="line">                                      <span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;rhs) </div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(dof_handler_U.n_dofs(),1e-6);</div></div><!-- fragment --><p><a class="el" href="classPETScWrappers_1_1SolverCG.html">PETScWrappers::SolverCG</a> solver(solver_control, mpi_communicator); <a class="el" href="classPETScWrappers_1_1SolverGMRES.html">PETScWrappers::SolverGMRES</a> solver(solver_control, mpi_communicator); <a class="el" href="classPETScWrappers_1_1SolverChebychev.html">PETScWrappers::SolverChebychev</a> solver(solver_control, mpi_communicator);</p>
<div class="fragment"><div class="line">  <a class="code" href="classPETScWrappers_1_1SolverBicgstab.html">PETScWrappers::SolverBicgstab</a> solver(solver_control,mpi_communicator);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(completely_distributed_solution);</div><div class="line">  solver.solve(Matrix,completely_distributed_solution,rhs,*preconditioner);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(completely_distributed_solution);</div><div class="line">  <span class="keywordflow">if</span> (solver_control.last_step() &gt; MAX_NUM_ITER_TO_RECOMPUTE_PRECONDITIONER)</div><div class="line">    rebuild_Matrix_U_preconditioners=<span class="keyword">true</span>;</div><div class="line">  <span class="keywordflow">if</span> (verbose==<span class="keyword">true</span>)</div><div class="line">    pcout&lt;&lt;<span class="stringliteral">&quot;   Solved U in &quot;</span>&lt;&lt;solver_control.last_step()&lt;&lt;<span class="stringliteral">&quot; iterations.&quot;</span>&lt;&lt;std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::solve_P(<span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints,</div><div class="line">                                      <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> &amp;Matrix,</div><div class="line">                                      std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner,</div><div class="line">                                      <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;completely_distributed_solution,</div><div class="line">                                      <span class="keyword">const</span> <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;rhs) {</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(dof_handler_P.n_dofs(),1e-6);</div><div class="line">  <a class="code" href="classPETScWrappers_1_1SolverCG.html">PETScWrappers::SolverCG</a> solver(solver_control,mpi_communicator);</div></div><!-- fragment --><p><a class="el" href="classPETScWrappers_1_1SolverGMRES.html">PETScWrappers::SolverGMRES</a> solver(solver_control, mpi_communicator);</p>
<div class="fragment"><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(completely_distributed_solution);</div><div class="line">  solver.solve(Matrix,completely_distributed_solution,rhs,*preconditioner);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(completely_distributed_solution);</div><div class="line">  <span class="keywordflow">if</span> (solver_control.last_step() &gt; MAX_NUM_ITER_TO_RECOMPUTE_PRECONDITIONER)</div><div class="line">    rebuild_S_M_preconditioners=<span class="keyword">true</span>;</div><div class="line">  <span class="keywordflow">if</span> (verbose==<span class="keyword">true</span>)</div><div class="line">    pcout&lt;&lt;<span class="stringliteral">&quot;   Solved P in &quot;</span>&lt;&lt;solver_control.last_step()&lt;&lt;<span class="stringliteral">&quot; iterations.&quot;</span>&lt;&lt;std::endl;</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// ////////////// get different fields ///////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::get_velocity() {</div><div class="line">  assemble_system_U(); </div><div class="line">  save_old_solution();</div><div class="line">  solve_U(constraints,system_Matrix_u,preconditioner_Matrix_u,completely_distributed_solution_u,system_rhs_u);</div><div class="line">  locally_relevant_solution_u=completely_distributed_solution_u;</div><div class="line">  solve_U(constraints,system_Matrix_v,preconditioner_Matrix_v,completely_distributed_solution_v,system_rhs_v);</div><div class="line">  locally_relevant_solution_v=completely_distributed_solution_v; </div><div class="line">  <span class="keywordflow">if</span> (dim==3) </div><div class="line">    {</div><div class="line">      solve_U(constraints,system_Matrix_w,preconditioner_Matrix_w,completely_distributed_solution_w,system_rhs_w);</div><div class="line">      locally_relevant_solution_w=completely_distributed_solution_w;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::get_pressure() </div><div class="line">{</div></div><!-- fragment --><p>GET DPSI</p>
<div class="fragment"><div class="line">assemble_system_dpsi_q();</div><div class="line">solve_P(constraints_psi,system_S,preconditioner_S,completely_distributed_solution_psi,system_rhs_psi);</div><div class="line">locally_relevant_solution_psi=completely_distributed_solution_psi;</div></div><!-- fragment --><p>SOLVE Q</p>
<div class="fragment"><div class="line">solve_P(constraints,system_M,preconditioner_M,completely_distributed_solution_q,system_rhs_q);</div></div><!-- fragment --><p>UPDATE THE PRESSURE</p>
<div class="fragment"><div class="line">  completely_distributed_solution_p.add(1,completely_distributed_solution_psi);</div><div class="line">  completely_distributed_solution_p.add(1,completely_distributed_solution_q);</div><div class="line">  locally_relevant_solution_p = completely_distributed_solution_p;</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// ///////////////////// DO STEPS ////////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::nth_time_step() {</div><div class="line">  get_velocity();</div><div class="line">  get_pressure();</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// ////////////////////// OTHERS /////////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NavierStokesSolver&lt;dim&gt;::save_old_solution() {</div><div class="line">  locally_relevant_solution_u_old=locally_relevant_solution_u;</div><div class="line">  locally_relevant_solution_v_old=locally_relevant_solution_v;</div><div class="line">  locally_relevant_solution_w_old=locally_relevant_solution_w;</div><div class="line">  locally_relevant_solution_psi_old=locally_relevant_solution_psi;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-TestLevelSet.cc"></a> </p><h1>Annotated version of TestLevelSet.cc</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_simple_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_solver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>///////////////////////// FOR TRANSPORT PROBLEM // ///////////////////////// TIME_INTEGRATION</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FORWARD_EULER 0</span></div><div class="line"><span class="preprocessor">#define SSP33 1</span></div></div><!-- fragment --><p>PROBLEM</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CIRCULAR_ROTATION 0</span></div><div class="line"><span class="preprocessor">#define DIAGONAL_ADVECTION 1</span></div></div><!-- fragment --><p>OTHER FLAGS</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define VARIABLE_VELOCITY 0</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;utilities_test_LS.cc&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;LevelSetSolver.cc&quot;</span></div></div><!-- fragment --><p>///////////////////////////////////////////////////// /////////////////// MAIN CLASS ////////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TestLevelSet</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TestLevelSet (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS,</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U);</div><div class="line">  ~TestLevelSet ();</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>BOUNDARY //</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_boundary_inlet();</div><div class="line"><span class="keywordtype">void</span> get_boundary_values_phi(std::vector&lt;unsigned int&gt; &amp;boundary_values_id_phi,</div><div class="line">                             std::vector&lt;double&gt; &amp;boundary_values_phi);</div></div><!-- fragment --><p>VELOCITY //</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> get_interpolated_velocity();</div></div><!-- fragment --><p>SETUP AND INIT CONDITIONS //</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup();</div><div class="line"><span class="keywordtype">void</span> initial_condition();</div><div class="line"><span class="keywordtype">void</span> init_constraints();</div></div><!-- fragment --><p>POST PROCESSING //</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> process_solution(<a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation,</div><div class="line">                      <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler_LS, </div><div class="line">                      <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;solution);</div><div class="line"><span class="keywordtype">void</span> output_results();</div><div class="line"><span class="keywordtype">void</span> output_solution();</div></div><!-- fragment --><p>SOLUTION VECTORS</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_phi;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_w;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_phi;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_u;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_v;</div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_w;</div></div><!-- fragment --><p>BOUNDARY VECTORS</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; boundary_values_id_phi;</div><div class="line">std::vector&lt;double&gt; boundary_values_phi;</div></div><!-- fragment --><p>GENERAL</p>
<div class="fragment"><div class="line">MPI_Comm mpi_communicator;</div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span>                  degree;</div><div class="line"><span class="keywordtype">int</span>                  degree_LS;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_LS;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_LS;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_LS;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_LS;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span>                  degree_U;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_U;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_U;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_U;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_U;</div><div class="line"></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_U_disp_field;</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe_U_disp_field;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_U_disp_field;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_U_disp_field;</div><div class="line"></div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints_disp_field;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> time;</div><div class="line"><span class="keywordtype">double</span> time_step;</div><div class="line"><span class="keywordtype">double</span> final_time;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"><span class="keywordtype">double</span> cfl;</div><div class="line"><span class="keywordtype">double</span> min_h;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> sharpness; </div><div class="line"><span class="keywordtype">int</span> sharpness_integer;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_number;</div><div class="line"><span class="keywordtype">double</span> output_time;</div><div class="line"><span class="keywordtype">bool</span> get_output;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> verbose;</div><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div></div><!-- fragment --><p>FOR TRANSPORT</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> cK; <span class="comment">//compression coeff</span></div><div class="line"><span class="keywordtype">double</span> cE; <span class="comment">//entropy-visc coeff</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TRANSPORT_TIME_INTEGRATION;</div><div class="line">std::string ALGORITHM;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM;</div></div><!-- fragment --><p>FOR RECONSTRUCTION OF MATERIAL FIELDS</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> eps, rho_air, rho_fluid;</div></div><!-- fragment --><p>MASS MATRIX</p>
<div class="fragment"><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> matrix_MC, matrix_MC_tnm1;</div><div class="line">  std_cxx1x::shared_ptr&lt;PETScWrappers::PreconditionBoomerAMG&gt; preconditioner_MC;</div><div class="line">  </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TestLevelSet&lt;dim&gt;::TestLevelSet (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS, </div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U)</div><div class="line">  :</div><div class="line">  mpi_communicator (MPI_COMM_WORLD),</div><div class="line">  triangulation (mpi_communicator,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing</div><div class="line">                 (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening)),</div><div class="line">  degree_LS(degree_LS),</div><div class="line">  dof_handler_LS (triangulation),</div><div class="line">  fe_LS (degree_LS),</div><div class="line">  degree_U(degree_U),</div><div class="line">  dof_handler_U (triangulation),</div><div class="line">  fe_U (degree_U),</div><div class="line">  dof_handler_U_disp_field(triangulation),</div><div class="line">  fe_U_disp_field(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree_U),dim),</div><div class="line">  pcout (<a class="code" href="namespacestd.html">std</a>::cout,(<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::this_mpi_process(mpi_communicator)== 0))</div><div class="line">{}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TestLevelSet&lt;dim&gt;::~TestLevelSet ()</div><div class="line">{</div><div class="line">  dof_handler_U_disp_field.clear();</div><div class="line">  dof_handler_LS.clear ();</div><div class="line">  dof_handler_U.clear ();</div><div class="line">}</div></div><!-- fragment --><p>VELOCITY // ////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::get_interpolated_velocity()</div><div class="line">{</div></div><!-- fragment --><p>velocity in x</p>
<div class="fragment"><div class="line">completely_distributed_solution_u = 0;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                         ExactU&lt;dim&gt;(PROBLEM,time),</div><div class="line">                         completely_distributed_solution_u);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_u);</div><div class="line">locally_relevant_solution_u = completely_distributed_solution_u;</div></div><!-- fragment --><p>velocity in y</p>
<div class="fragment"><div class="line">  completely_distributed_solution_v = 0;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                           ExactV&lt;dim&gt;(PROBLEM,time),</div><div class="line">                           completely_distributed_solution_v);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_v);</div><div class="line">  locally_relevant_solution_v = completely_distributed_solution_v;</div><div class="line">  <span class="keywordflow">if</span> (dim==3)</div><div class="line">    {</div><div class="line">      completely_distributed_solution_w = 0;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                               ExactW&lt;dim&gt;(PROBLEM,time),</div><div class="line">                               completely_distributed_solution_w);</div><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_w);</div><div class="line">      locally_relevant_solution_w = completely_distributed_solution_w;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>//////////// BOUNDARY // ////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::set_boundary_inlet()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt;  face_quadrature_formula(1); <span class="comment">// center of the face</span></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe_U,face_quadrature_formula,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  std::vector&lt;double&gt;  u_value (n_face_q_points);</div><div class="line">  std::vector&lt;double&gt;  v_value (n_face_q_points); </div><div class="line">  std::vector&lt;double&gt;  w_value (n_face_q_points); </div><div class="line">  </div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell_U = dof_handler_U.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc_U = dof_handler_U.end();</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> u;</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (; cell_U!=endc_U; ++cell_U)</div><div class="line">    <span class="keywordflow">if</span> (cell_U-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        <span class="keywordflow">if</span> (cell_U-&gt;face(face)-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            fe_face_values.reinit(cell_U,face);</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(locally_relevant_solution_u,u_value);</div><div class="line">            fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(locally_relevant_solution_v,v_value);</div><div class="line">            <span class="keywordflow">if</span> (dim==3)</div><div class="line">              fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(locally_relevant_solution_w,w_value);</div><div class="line">            u[0]=u_value[0];</div><div class="line">            u[1]=v_value[0];</div><div class="line">            <span class="keywordflow">if</span> (dim==3) </div><div class="line">              u[2]=w_value[0];</div><div class="line">            <span class="keywordflow">if</span> (fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(0)*u &lt; -1e-14)</div><div class="line">              cell_U-&gt;face(face)-&gt;set_boundary_id(10);</div><div class="line">          }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::get_boundary_values_phi(std::vector&lt;unsigned int&gt; &amp;boundary_values_id_phi,</div><div class="line">                                            std::vector&lt;double&gt; &amp;boundary_values_phi)</div><div class="line">{</div><div class="line">  std::map&lt;unsigned int, double&gt; map_boundary_values_phi;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> boundary_id=0;</div><div class="line">  </div><div class="line">  set_boundary_inlet();</div><div class="line">  boundary_id=10; <span class="comment">// inlet</span></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_LS,</div><div class="line">                                            boundary_id,BoundaryPhi&lt;dim&gt;(),</div><div class="line">                                            map_boundary_values_phi);</div><div class="line"></div><div class="line">  boundary_values_id_phi.resize(map_boundary_values_phi.size());</div><div class="line">  boundary_values_phi.resize(map_boundary_values_phi.size());  </div><div class="line">  std::map&lt;unsigned int,double&gt;::const_iterator boundary_value_phi = map_boundary_values_phi.begin();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; boundary_value_phi !=map_boundary_values_phi.end(); ++boundary_value_phi, ++i)</div><div class="line">    {</div><div class="line">      boundary_values_id_phi[i]=boundary_value_phi-&gt;first;</div><div class="line">      boundary_values_phi[i]=boundary_value_phi-&gt;second;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////// SETUP AND INITIAL CONDITIONS // ////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::setup()</div><div class="line">{ </div><div class="line">  degree = std::max(degree_LS,degree_U);</div></div><!-- fragment --><p>setup system LS</p>
<div class="fragment"><div class="line">dof_handler_LS.distribute_dofs (fe_LS);</div><div class="line">locally_owned_dofs_LS = dof_handler_LS.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_LS,</div><div class="line">                                         locally_relevant_dofs_LS);</div></div><!-- fragment --><p>setup system U</p>
<div class="fragment"><div class="line">dof_handler_U.distribute_dofs (fe_U);</div><div class="line">locally_owned_dofs_U = dof_handler_U.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_U,</div><div class="line">                                         locally_relevant_dofs_U);</div></div><!-- fragment --><p>setup system U for disp field</p>
<div class="fragment"><div class="line">dof_handler_U_disp_field.distribute_dofs (fe_U_disp_field);</div><div class="line">locally_owned_dofs_U_disp_field = dof_handler_U_disp_field.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_U_disp_field,</div><div class="line">                                         locally_relevant_dofs_U_disp_field);</div></div><!-- fragment --><p>init vectors for phi</p>
<div class="fragment"><div class="line">locally_relevant_solution_phi.reinit(locally_owned_dofs_LS,</div><div class="line">                                     locally_relevant_dofs_LS,</div><div class="line">                                     mpi_communicator);</div><div class="line">locally_relevant_solution_phi = 0;</div><div class="line">completely_distributed_solution_phi.reinit(mpi_communicator, </div><div class="line">                                           dof_handler_LS.n_dofs(),</div><div class="line">                                           dof_handler_LS.n_locally_owned_dofs());</div></div><!-- fragment --><p>init vectors for u</p>
<div class="fragment"><div class="line">locally_relevant_solution_u.reinit(locally_owned_dofs_U,</div><div class="line">                                   locally_relevant_dofs_U,</div><div class="line">                                   mpi_communicator);</div><div class="line">locally_relevant_solution_u = 0;</div><div class="line">completely_distributed_solution_u.reinit(mpi_communicator, </div><div class="line">                                         dof_handler_U.n_dofs(),</div><div class="line">                                         dof_handler_U.n_locally_owned_dofs());</div></div><!-- fragment --><p>init vectors for v</p>
<div class="fragment"><div class="line">locally_relevant_solution_v.reinit(locally_owned_dofs_U,</div><div class="line">                                   locally_relevant_dofs_U,</div><div class="line">                                   mpi_communicator);</div><div class="line">locally_relevant_solution_v = 0;</div><div class="line">completely_distributed_solution_v.reinit(mpi_communicator, </div><div class="line">                                         dof_handler_U.n_dofs(),</div><div class="line">                                         dof_handler_U.n_locally_owned_dofs());</div></div><!-- fragment --><p>init vectors for w</p>
<div class="fragment"><div class="line">locally_relevant_solution_w.reinit(locally_owned_dofs_U,</div><div class="line">                                   locally_relevant_dofs_U,</div><div class="line">                                   mpi_communicator);</div><div class="line">locally_relevant_solution_w = 0;</div><div class="line">completely_distributed_solution_w.reinit(mpi_communicator, </div><div class="line">                                         dof_handler_U.n_dofs(),</div><div class="line">                                         dof_handler_U.n_locally_owned_dofs());</div><div class="line">init_constraints();</div></div><!-- fragment --><p>MASS MATRIX</p>
<div class="fragment"><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (locally_relevant_dofs_LS);</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler_LS,dsp,constraints,<span class="keyword">false</span>);</div><div class="line">  <a class="code" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">SparsityTools::distribute_sparsity_pattern</a> (dsp,</div><div class="line">                                              dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                                              mpi_communicator,</div><div class="line">                                              locally_relevant_dofs_LS);</div><div class="line">  matrix_MC.reinit (mpi_communicator,</div><div class="line">                    dsp,</div><div class="line">                    dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                    dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">  matrix_MC_tnm1.reinit (mpi_communicator,</div><div class="line">                         dsp,</div><div class="line">                         dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                         dof_handler_LS.n_locally_owned_dofs_per_processor(),</div><div class="line">                         <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::initial_condition()</div><div class="line">{</div><div class="line">  time=0;</div></div><!-- fragment --><p>Initial conditions // init condition for phi</p>
<div class="fragment"><div class="line">completely_distributed_solution_phi = 0;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_LS,</div><div class="line">                         InitialPhi&lt;dim&gt;(PROBLEM, sharpness),</div></div><!-- fragment --><p>ZeroFunction&lt;dim&gt;(),</p>
<div class="fragment"><div class="line">                         completely_distributed_solution_phi);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_phi);</div><div class="line">locally_relevant_solution_phi = completely_distributed_solution_phi;</div></div><!-- fragment --><p>init condition for u=0</p>
<div class="fragment"><div class="line">completely_distributed_solution_u = 0;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                         ExactU&lt;dim&gt;(PROBLEM,time),</div><div class="line">                         completely_distributed_solution_u);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_u);</div><div class="line">locally_relevant_solution_u = completely_distributed_solution_u;</div></div><!-- fragment --><p>init condition for v</p>
<div class="fragment"><div class="line">  completely_distributed_solution_v = 0;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                           ExactV&lt;dim&gt;(PROBLEM,time),</div><div class="line">                           completely_distributed_solution_v);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_v);</div><div class="line">  locally_relevant_solution_v = completely_distributed_solution_v;</div><div class="line">}</div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::init_constraints()</div><div class="line">{</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ();</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#ac2726821354883ac97fe7e6181de9792">reinit</a> (locally_relevant_dofs_LS);</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler_LS, constraints);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line">  constraints_disp_field.clear ();</div><div class="line">  constraints_disp_field.reinit (locally_relevant_dofs_LS);</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler_LS, constraints_disp_field);</div><div class="line">  constraints_disp_field.close ();</div><div class="line">}</div></div><!-- fragment --><p>/////////////////// POST PROCESSING // ///////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::process_solution(<a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation, </div><div class="line">                                         <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler_LS, </div><div class="line">                                         <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> difference_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>error for phi</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_LS,</div><div class="line">                                     solution,</div><div class="line">                                     InitialPhi&lt;dim&gt;(PROBLEM,sharpness),</div><div class="line">                                     difference_per_cell,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_LS+3),</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a8a97c0127bcfceec1fefbd0ad5839357">VectorTools::L1_norm</a>);</div><div class="line">  </div><div class="line">  <span class="keywordtype">double</span> u_L1_error = difference_per_cell.l1_norm();</div><div class="line">  u_L1_error = std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(u_L1_error * u_L1_error, mpi_communicator));</div><div class="line">  </div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_LS,</div><div class="line">                                     solution,</div><div class="line">                                     InitialPhi&lt;dim&gt;(PROBLEM,sharpness),</div><div class="line">                                     difference_per_cell,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_LS+3),</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keywordtype">double</span> u_L2_error = difference_per_cell.l2_norm();</div><div class="line">  u_L2_error = std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(u_L2_error * u_L2_error, mpi_communicator));</div><div class="line">  </div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;L1 error: &quot;</span> &lt;&lt; u_L1_error &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;L2 error: &quot;</span> &lt;&lt; u_L2_error &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::output_results()</div><div class="line">{</div><div class="line">  output_solution();</div><div class="line">  output_number++;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::output_solution()</div><div class="line">{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler_LS);  </div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (locally_relevant_solution_phi, <span class="stringliteral">&quot;phi&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_number, 3) +</div><div class="line">                                <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="line">                                (triangulation.<a class="code" href="classparallel_1_1Triangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4));</div><div class="line">  std::ofstream output ((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line">  </div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;std::string&gt; filenames;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">           i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(mpi_communicator);</div><div class="line">           ++i)</div><div class="line">        filenames.push_back (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_number, 3) +</div><div class="line">                             <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (i, 4) +</div><div class="line">                             <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">      </div><div class="line">      std::ofstream master_output ((filename + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (master_output, filenames);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestLevelSet&lt;dim&gt;::run()</div><div class="line">{</div></div><!-- fragment --><p>////////////////////// GENERAL PARAMETERS // //////////////////////</p>
<div class="fragment"><div class="line">cfl=0.1;</div><div class="line">verbose = <span class="keyword">false</span>;</div><div class="line">get_output = <span class="keyword">true</span>;</div><div class="line">output_number = 0;</div><div class="line"><a class="code" href="classTimer.html">Timer</a> t;</div><div class="line">n_refinement=6;</div><div class="line">output_time = 0.1;</div><div class="line">final_time = 1.0;</div><div class="line">PROBLEM=CIRCULAR_ROTATION;</div></div><!-- fragment --><p>PROBLEM=DIAGONAL_ADVECTION;</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> umax = 0;</div><div class="line"><span class="keywordflow">if</span> (PROBLEM==CIRCULAR_ROTATION)</div><div class="line">  umax = std::sqrt(2)*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>;</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  umax = std::sqrt(2);</div></div><!-- fragment --><p>//////////////////////////////////// PARAMETERS FOR TRANSPORT PROBLEM // ////////////////////////////////////</p>
<div class="fragment"><div class="line">cK = 1.0; <span class="comment">// compression constant</span></div><div class="line">cE = 1.0; <span class="comment">// entropy viscosity constant</span></div><div class="line">sharpness_integer=1; <span class="comment">//this will be multipled by min_h</span></div></div><!-- fragment --><p>TRANSPORT_TIME_INTEGRATION=FORWARD_EULER;</p>
<div class="fragment"><div class="line">TRANSPORT_TIME_INTEGRATION=SSP33;</div></div><!-- fragment --><p>ALGORITHM = "MPP_u1";</p>
<div class="fragment"><div class="line">ALGORITHM = <span class="stringliteral">&quot;NMPP_uH&quot;</span>;</div></div><!-- fragment --><p>ALGORITHM = "MPP_uH";</p>
<p>//////////// GEOMETRY // ////////////</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (PROBLEM==CIRCULAR_ROTATION || PROBLEM==DIAGONAL_ADVECTION) </div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div></div><!-- fragment --><p><a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation, <a class="el" href="classPoint.html">Point&lt;dim&gt;</a>(0.0,0.0), <a class="el" href="classPoint.html">Point&lt;dim&gt;</a>(1.0,1.0), true);</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (n_refinement);</div></div><!-- fragment --><p>///////// SETUP // /////////</p>
<div class="fragment"><div class="line">setup();</div></div><!-- fragment --><p>for Reconstruction of MATERIAL FIELDS</p>
<div class="fragment"><div class="line">min_h = <a class="code" href="namespaceGridTools.html#ac89deda30a32b232dbe9c95e14896df5">GridTools::minimal_cell_diameter</a>(triangulation)/std::sqrt(dim)/degree;</div><div class="line">eps=1*min_h; <span class="comment">//For reconstruction of density in Navier Stokes</span></div><div class="line">sharpness=sharpness_integer*min_h; <span class="comment">//adjust value of sharpness (for init cond of phi)</span></div><div class="line">rho_fluid = 1000;</div><div class="line">rho_air = 1;</div></div><!-- fragment --><p>GET TIME STEP //</p>
<div class="fragment"><div class="line">time_step = cfl*min_h/umax;</div></div><!-- fragment --><p>//////////////////// TRANSPORT SOLVER // ////////////////////</p>
<div class="fragment"><div class="line">LevelSetSolver&lt;dim&gt; level_set (degree_LS,degree_U,</div><div class="line">                               time_step,cK,cE, </div><div class="line">                               verbose, </div><div class="line">                               ALGORITHM,</div><div class="line">                               TRANSPORT_TIME_INTEGRATION,</div><div class="line">                               triangulation,</div><div class="line">                               mpi_communicator); </div></div><!-- fragment --><p>///////////////////// INITIAL CONDITION // /////////////////////</p>
<div class="fragment"><div class="line">initial_condition();</div><div class="line">output_results();</div><div class="line"><span class="keywordflow">if</span> (dim==2)</div><div class="line">  level_set.initial_condition(locally_relevant_solution_phi,</div><div class="line">                              locally_relevant_solution_u,locally_relevant_solution_v);</div><div class="line"><span class="keywordflow">else</span> <span class="comment">//dim=3</span></div><div class="line">  level_set.initial_condition(locally_relevant_solution_phi,</div><div class="line">                              locally_relevant_solution_u,locally_relevant_solution_v,locally_relevant_solution_w);</div></div><!-- fragment --><p>/////////////////////////////// BOUNDARY CONDITIONS FOR PHI // ///////////////////////////////</p>
<div class="fragment"><div class="line">get_boundary_values_phi(boundary_values_id_phi,boundary_values_phi);</div><div class="line">level_set.set_boundary_conditions(boundary_values_id_phi,boundary_values_phi);</div></div><!-- fragment --><p>OUTPUT DATA REGARDING TIME STEPPING AND MESH //</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> dofs_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Cfl: &quot;</span> &lt;&lt; cfl &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span> </div><div class="line">        &lt;&lt; triangulation.<a class="code" href="classparallel_1_1Triangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; std::endl</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;      LS: &quot;</span> &lt;&lt; dofs_LS &lt;&lt; std::endl;</div></div><!-- fragment --><p>TIME STEPPING</p>
<div class="fragment"><div class="line">timestep_number=0;</div><div class="line">time=0;</div><div class="line"><span class="keywordflow">while</span>(time&lt;final_time)</div><div class="line">  { </div><div class="line">    timestep_number++;</div><div class="line">    <span class="keywordflow">if</span> (time+time_step &gt; final_time)</div><div class="line">      { </div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;FINAL TIME STEP... &quot;</span> &lt;&lt; std::endl; </div><div class="line">        time_step = final_time-time;</div><div class="line">      }</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number </div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;\twith dt=&quot;</span> &lt;&lt; time_step </div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;\tat tn=&quot;</span> &lt;&lt; time &lt;&lt; std::endl;</div></div><!-- fragment --><p>//////////////// GET VELOCITY // (NS or interpolate from a function) at current time tn ////////////////</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (VARIABLE_VELOCITY)</div><div class="line">  {</div><div class="line">    get_interpolated_velocity();</div></div><!-- fragment --><p>SET VELOCITY TO LEVEL SET SOLVER</p>
<div class="fragment"><div class="line">  level_set.set_velocity(locally_relevant_solution_u,locally_relevant_solution_v);</div><div class="line">}</div></div><!-- fragment --><p>////////////////////////// GET LEVEL SET SOLUTION // (at tnp1) //////////////////////////</p>
<div class="fragment"><div class="line">level_set.nth_time_step();</div></div><!-- fragment --><p>/////////////// UPDATE TIME // ///////////////</p>
<div class="fragment"><div class="line">time+=time_step; <span class="comment">// time tnp1</span></div></div><!-- fragment --><p>////////// OUTPUT // //////////</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (get_output &amp;&amp; time-(output_number)*output_time&gt;=0)</div><div class="line">        {</div><div class="line">          level_set.get_unp1(locally_relevant_solution_phi); </div><div class="line">          output_results();</div><div class="line">        }</div><div class="line">    }</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;FINAL TIME T=&quot;</span> &lt;&lt; time &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line">      PetscInitialize(&amp;argc, &amp;argv, PETSC_NULL, PETSC_NULL);</div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (0);</div><div class="line">      {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree = 1;</div><div class="line">        TestLevelSet&lt;2&gt; multiphase(degree, degree);</div><div class="line">        multiphase.run();</div><div class="line">      }</div><div class="line">      PetscFinalize();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-TestNavierStokes.cc"></a> </p><h1>Annotated version of TestNavierStokes.cc</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_simple_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_solver.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/petsc_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;utilities_test_NS.cc&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;NavierStokesSolver.cc&quot;</span></div></div><!-- fragment --><p>///////////////////////////////////////////////////// /////////////////// MAIN CLASS ////////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TestNavierStokes</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TestNavierStokes (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U);</div><div class="line">  ~TestNavierStokes ();</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> get_boundary_values_U(<span class="keywordtype">double</span> t);</div><div class="line">  <span class="keywordtype">void</span> fix_pressure();</div><div class="line">  <span class="keywordtype">void</span> output_results();</div><div class="line">  <span class="keywordtype">void</span> process_solution(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line">  <span class="keywordtype">void</span> setup();</div><div class="line">  <span class="keywordtype">void</span> initial_condition();</div><div class="line">  <span class="keywordtype">void</span> init_constraints();</div><div class="line">  </div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_rho;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_u;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_v;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_w;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> locally_relevant_solution_p;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_rho;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_u;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_v;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_w;</div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> completely_distributed_solution_p;</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; boundary_values_id_u;</div><div class="line">  std::vector&lt;unsigned int&gt; boundary_values_id_v;</div><div class="line">  std::vector&lt;unsigned int&gt; boundary_values_id_w;</div><div class="line">  std::vector&lt;double&gt; boundary_values_u;</div><div class="line">  std::vector&lt;double&gt; boundary_values_v;</div><div class="line">  std::vector&lt;double&gt; boundary_values_w;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> rho_fluid;</div><div class="line">  <span class="keywordtype">double</span> nu_fluid;</div><div class="line">  <span class="keywordtype">double</span> rho_air;</div><div class="line">  <span class="keywordtype">double</span> nu_air;</div><div class="line"></div><div class="line">  MPI_Comm mpi_communicator;</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span>                  degree_LS;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_LS;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_LS;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_LS;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_LS;</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span>                  degree_U;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_U;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_U;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_U;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_U;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_P;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe_P;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_owned_dofs_P;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs_P;</div><div class="line"></div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div></div><!-- fragment --><p><a class="el" href="classTimerOutput.html">TimerOutput</a> timer;</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> time;</div><div class="line">  <span class="keywordtype">double</span> time_step;</div><div class="line">  <span class="keywordtype">double</span> final_time;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">  <span class="keywordtype">double</span> cfl;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> min_h;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_number;</div><div class="line">  <span class="keywordtype">double</span> output_time;</div><div class="line">  <span class="keywordtype">bool</span> get_output;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> h;</div><div class="line">  <span class="keywordtype">double</span> umax;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> verbose;</div><div class="line"></div><div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a>                pcout;</div><div class="line">  <a class="code" href="classConvergenceTable.html">ConvergenceTable</a> convergence_table;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> nu;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TestNavierStokes&lt;dim&gt;::TestNavierStokes (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS, </div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U)</div><div class="line">  :</div><div class="line">  mpi_communicator (MPI_COMM_WORLD),</div><div class="line">  triangulation (mpi_communicator,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing</div><div class="line">                 (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening)),</div><div class="line">  degree_LS(degree_LS),</div><div class="line">  dof_handler_LS (triangulation),</div><div class="line">  fe_LS (degree_LS),</div><div class="line">  degree_U(degree_U),</div><div class="line">  dof_handler_U (triangulation),</div><div class="line">  fe_U (degree_U),</div><div class="line">  dof_handler_P (triangulation),</div><div class="line">  fe_P (degree_U-1), <span class="comment">//TODO: change this to be degree_Q-1</span></div></div><!-- fragment --><p>timer(std::cout, TimerOutput::summary, TimerOutput::wall_times),</p>
<div class="fragment"><div class="line">  pcout (std::cout,(<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator)== 0))</div><div class="line">{}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TestNavierStokes&lt;dim&gt;::~TestNavierStokes ()</div><div class="line">{</div><div class="line">  dof_handler_LS.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">  dof_handler_U.clear ();</div><div class="line">  dof_handler_P.clear ();</div><div class="line">}</div></div><!-- fragment --><p>/////////////////////////////////////// /////////////// SETUP ///////////////// ///////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestNavierStokes&lt;dim&gt;::setup()</div><div class="line">{ </div></div><!-- fragment --><p>setup system LS</p>
<div class="fragment"><div class="line">dof_handler_LS.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe_LS);</div><div class="line">locally_owned_dofs_LS = dof_handler_LS.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a> ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_LS,</div><div class="line">                                         locally_relevant_dofs_LS);</div></div><!-- fragment --><p>setup system U</p>
<div class="fragment"><div class="line">dof_handler_U.distribute_dofs (fe_U);</div><div class="line">locally_owned_dofs_U = dof_handler_U.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_U,</div><div class="line">                                         locally_relevant_dofs_U);</div></div><!-- fragment --><p>setup system P //</p>
<div class="fragment"><div class="line">dof_handler_P.distribute_dofs (fe_P);</div><div class="line">locally_owned_dofs_P = dof_handler_P.locally_owned_dofs ();</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler_P,</div><div class="line">                                         locally_relevant_dofs_P);  </div><div class="line">init_constraints();</div></div><!-- fragment --><p>init vectors for rho</p>
<div class="fragment"><div class="line">locally_relevant_solution_rho.reinit (locally_owned_dofs_LS,locally_relevant_dofs_LS,mpi_communicator);</div><div class="line">locally_relevant_solution_rho = 0;</div><div class="line">completely_distributed_solution_rho.reinit(locally_owned_dofs_LS,mpi_communicator);</div></div><!-- fragment --><p>init vectors for u</p>
<div class="fragment"><div class="line">locally_relevant_solution_u.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div><div class="line">locally_relevant_solution_u = 0;</div><div class="line">completely_distributed_solution_u.reinit(locally_owned_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for v</p>
<div class="fragment"><div class="line">locally_relevant_solution_v.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div><div class="line">locally_relevant_solution_v = 0;</div><div class="line">completely_distributed_solution_v.reinit(locally_owned_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for w</p>
<div class="fragment"><div class="line">locally_relevant_solution_w.reinit (locally_owned_dofs_U,locally_relevant_dofs_U,mpi_communicator);</div><div class="line">locally_relevant_solution_w = 0;</div><div class="line">completely_distributed_solution_w.reinit(locally_owned_dofs_U,mpi_communicator);</div></div><!-- fragment --><p>init vectors for p</p>
<div class="fragment"><div class="line">  locally_relevant_solution_p.reinit(locally_owned_dofs_P,locally_relevant_dofs_P,mpi_communicator);</div><div class="line">  locally_relevant_solution_p = 0;</div><div class="line">  completely_distributed_solution_p.reinit(locally_owned_dofs_P,mpi_communicator); </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestNavierStokes&lt;dim&gt;::initial_condition()</div><div class="line">{</div><div class="line">  time=0;</div></div><!-- fragment --><p>Initial conditions // init condition for rho</p>
<div class="fragment"><div class="line">completely_distributed_solution_rho = 0;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_LS,</div><div class="line">                         RhoFunction&lt;dim&gt;(0),</div><div class="line">                         completely_distributed_solution_rho);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_rho);</div><div class="line">locally_relevant_solution_rho = completely_distributed_solution_rho;</div></div><!-- fragment --><p>init condition for u</p>
<div class="fragment"><div class="line">completely_distributed_solution_u = 0;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                         ExactSolution_and_BC_U&lt;dim&gt;(0,0),</div><div class="line">                         completely_distributed_solution_u);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_u);</div><div class="line">locally_relevant_solution_u = completely_distributed_solution_u;</div></div><!-- fragment --><p>init condition for v</p>
<div class="fragment"><div class="line">completely_distributed_solution_v = 0;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                         ExactSolution_and_BC_U&lt;dim&gt;(0,1),</div><div class="line">                         completely_distributed_solution_v);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_v);</div><div class="line">locally_relevant_solution_v = completely_distributed_solution_v;</div></div><!-- fragment --><p>init condition for w</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (dim == 3)</div><div class="line">  {</div><div class="line">    completely_distributed_solution_w = 0;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_U,</div><div class="line">                             ExactSolution_and_BC_U&lt;dim&gt;(0,2),</div><div class="line">                             completely_distributed_solution_w);</div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_w);</div><div class="line">    locally_relevant_solution_w = completely_distributed_solution_w;</div><div class="line">  }</div></div><!-- fragment --><p>init condition for p</p>
<div class="fragment"><div class="line">  completely_distributed_solution_p = 0;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a>(dof_handler_P,</div><div class="line">                           ExactSolution_p&lt;dim&gt;(0),</div><div class="line">                           completely_distributed_solution_p);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (completely_distributed_solution_p);</div><div class="line">  locally_relevant_solution_p = completely_distributed_solution_p;</div><div class="line">}</div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestNavierStokes&lt;dim&gt;::init_constraints()</div><div class="line">{</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ();</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#ac2726821354883ac97fe7e6181de9792">reinit</a> (locally_relevant_dofs_LS);</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler_LS, constraints);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestNavierStokes&lt;dim&gt;::fix_pressure()</div><div class="line">{</div></div><!-- fragment --><p>fix the constant in the pressure</p>
<div class="fragment"><div class="line">  completely_distributed_solution_p = locally_relevant_solution_p;</div><div class="line">  <span class="keywordtype">double</span> mean_value = <a class="code" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">VectorTools::compute_mean_value</a>(dof_handler_P,</div><div class="line">                                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                                                      locally_relevant_solution_p,</div><div class="line">                                                      0);</div><div class="line">  <span class="keywordflow">if</span> (dim==2)</div><div class="line">    completely_distributed_solution_p.add(-mean_value+std::sin(1)*(std::cos(time)-<a class="code" href="classVectorizedArray.html#afbe6a626041041e9d34cbf408a796db6">cos</a>(1+time)));</div><div class="line">  <span class="keywordflow">else</span> </div><div class="line">    completely_distributed_solution_p.add(-mean_value+8*std::pow(std::sin(0.5),3)*std::sin(1.5+time));</div><div class="line">  locally_relevant_solution_p = completely_distributed_solution_p;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestNavierStokes&lt;dim&gt;::output_results ()</div><div class="line">{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler_U);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (locally_relevant_solution_u, <span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (locally_relevant_solution_v, <span class="stringliteral">&quot;v&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (dim==3) data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (locally_relevant_solution_w, <span class="stringliteral">&quot;w&quot;</span>);</div><div class="line">    </div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;subdomain.size(); ++i)</div><div class="line">    subdomain(i) = triangulation.<a class="code" href="classparallel_1_1Triangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_number, 3) +</div><div class="line">                                <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="line">                                (triangulation.<a class="code" href="classparallel_1_1Triangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4));</div><div class="line">  std::ofstream output ((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;std::string&gt; filenames;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">           i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(mpi_communicator);</div><div class="line">           ++i)</div><div class="line">        filenames.push_back (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_number, 3) +</div><div class="line">                             <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (i, 4) +</div><div class="line">                             <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"></div><div class="line">      std::ofstream master_output ((filename + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (master_output, filenames);</div><div class="line">    }</div><div class="line">  output_number++;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestNavierStokes&lt;dim&gt;::process_solution(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> difference_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>error for u</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_U,</div><div class="line">                                   locally_relevant_solution_u,</div><div class="line">                                   ExactSolution_and_BC_U&lt;dim&gt;(time,0),</div><div class="line">                                   difference_per_cell,</div><div class="line">                                   <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_U+1),</div><div class="line">                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);        </div><div class="line"><span class="keywordtype">double</span> u_L2_error = difference_per_cell.l2_norm();</div><div class="line">u_L2_error = </div><div class="line">  std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(u_L2_error * u_L2_error, mpi_communicator));</div><div class="line"><a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_U,</div><div class="line">                                   locally_relevant_solution_u,</div><div class="line">                                   ExactSolution_and_BC_U&lt;dim&gt;(time,0),</div><div class="line">                                   difference_per_cell,</div><div class="line">                                   <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_U+1),</div><div class="line">                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line"><span class="keywordtype">double</span> u_H1_error = difference_per_cell.l2_norm();</div><div class="line">u_H1_error = </div><div class="line">  std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(u_H1_error * u_H1_error, mpi_communicator));</div></div><!-- fragment --><p>error for v</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_U,</div><div class="line">                                   locally_relevant_solution_v,</div><div class="line">                                   ExactSolution_and_BC_U&lt;dim&gt;(time,1),</div><div class="line">                                   difference_per_cell,</div><div class="line">                                   <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_U+1),</div><div class="line">                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"><span class="keywordtype">double</span> v_L2_error = difference_per_cell.l2_norm();</div><div class="line">v_L2_error = </div><div class="line">  std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(v_L2_error * v_L2_error, </div><div class="line">                                mpi_communicator));</div><div class="line"><a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_U,</div><div class="line">                                   locally_relevant_solution_v,</div><div class="line">                                   ExactSolution_and_BC_U&lt;dim&gt;(time,1),</div><div class="line">                                   difference_per_cell,</div><div class="line">                                   <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_U+1),</div><div class="line">                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line"><span class="keywordtype">double</span> v_H1_error = difference_per_cell.l2_norm();</div><div class="line">v_H1_error = </div><div class="line">  std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(v_H1_error * </div><div class="line">                                v_H1_error, mpi_communicator));</div></div><!-- fragment --><p>error for w</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> w_L2_error = 0;</div><div class="line"><span class="keywordtype">double</span> w_H1_error = 0;</div><div class="line"><span class="keywordflow">if</span> (dim == 3)</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_U,</div><div class="line">                                       locally_relevant_solution_w,</div><div class="line">                                       ExactSolution_and_BC_U&lt;dim&gt;(time,2),</div><div class="line">                                       difference_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_U+1),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">    w_L2_error = difference_per_cell.l2_norm();</div><div class="line">    w_L2_error = </div><div class="line">      std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(w_L2_error * w_L2_error, </div><div class="line">                                    mpi_communicator));</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_U,</div><div class="line">                                       locally_relevant_solution_w,</div><div class="line">                                       ExactSolution_and_BC_U&lt;dim&gt;(time,2),</div><div class="line">                                       difference_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_U+1),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">    w_H1_error = difference_per_cell.l2_norm();</div><div class="line">    w_H1_error = </div><div class="line">      std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(w_H1_error * </div><div class="line">                                    w_H1_error, mpi_communicator));</div><div class="line">  }</div></div><!-- fragment --><p>error for p</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_P,</div><div class="line">                                     locally_relevant_solution_p,</div><div class="line">                                     ExactSolution_p&lt;dim&gt;(time),</div><div class="line">                                     difference_per_cell,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_U+1),</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keywordtype">double</span> p_L2_error = difference_per_cell.l2_norm();</div><div class="line">  p_L2_error = </div><div class="line">    std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(p_L2_error * p_L2_error, </div><div class="line">                                  mpi_communicator));</div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_P,</div><div class="line">                                     locally_relevant_solution_p,</div><div class="line">                                     ExactSolution_p&lt;dim&gt;(time),</div><div class="line">                                     difference_per_cell,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree_U+1),</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">VectorTools::H1_norm</a>);</div><div class="line">  <span class="keywordtype">double</span> p_H1_error = difference_per_cell.l2_norm();</div><div class="line">  p_H1_error = </div><div class="line">    std::sqrt(<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(p_H1_error * p_H1_error, </div><div class="line">                                  mpi_communicator));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells=triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>();    </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_U=dof_handler_U.n_dofs();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_P=dof_handler_P.n_dofs();</div><div class="line">        </div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cycle&quot;</span>, cycle);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, n_active_cells);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;dofs_U&quot;</span>, n_dofs_U);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;dofs_P&quot;</span>, n_dofs_P);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;dt&quot;</span>, time_step);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;u L2&quot;</span>, u_L2_error);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;u H1&quot;</span>, u_H1_error);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;v L2&quot;</span>, v_L2_error);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;v H1&quot;</span>, v_H1_error);</div><div class="line">  <span class="keywordflow">if</span> (dim==3)</div><div class="line">    {</div><div class="line">      convergence_table.add_value(<span class="stringliteral">&quot;w L2&quot;</span>, w_L2_error);</div><div class="line">      convergence_table.add_value(<span class="stringliteral">&quot;w H1&quot;</span>, w_H1_error);</div><div class="line">    }</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;p L2&quot;</span>, p_L2_error);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;p H1&quot;</span>, p_H1_error);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestNavierStokes&lt;dim&gt;::get_boundary_values_U(<span class="keywordtype">double</span> t)</div><div class="line">{</div><div class="line">  std::map&lt;unsigned int, double&gt; map_boundary_values_u;</div><div class="line">  std::map&lt;unsigned int, double&gt; map_boundary_values_v;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,0,ExactSolution_and_BC_U&lt;dim&gt;(t,0),map_boundary_values_u);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,0,ExactSolution_and_BC_U&lt;dim&gt;(t,1),map_boundary_values_v);</div><div class="line"></div><div class="line">  boundary_values_id_u.resize(map_boundary_values_u.size());</div><div class="line">  boundary_values_id_v.resize(map_boundary_values_v.size());</div><div class="line">  boundary_values_u.resize(map_boundary_values_u.size());</div><div class="line">  boundary_values_v.resize(map_boundary_values_v.size());</div><div class="line">  std::map&lt;unsigned int,double&gt;::const_iterator boundary_value_u =map_boundary_values_u.begin();</div><div class="line">  std::map&lt;unsigned int,double&gt;::const_iterator boundary_value_v =map_boundary_values_v.begin();</div><div class="line">  <span class="keywordflow">if</span> (dim==3)</div><div class="line">    {</div><div class="line">      std::map&lt;unsigned int, double&gt; map_boundary_values_w;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler_U,0,ExactSolution_and_BC_U&lt;dim&gt;(t,2),map_boundary_values_w);</div><div class="line">      boundary_values_id_w.resize(map_boundary_values_w.size());</div><div class="line">      boundary_values_w.resize(map_boundary_values_w.size());</div><div class="line">      std::map&lt;unsigned int,double&gt;::const_iterator boundary_value_w =map_boundary_values_w.begin();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; boundary_value_w !=map_boundary_values_w.end(); ++boundary_value_w, ++i)</div><div class="line">        {</div><div class="line">          boundary_values_id_w[i]=boundary_value_w-&gt;first;</div><div class="line">          boundary_values_w[i]=boundary_value_w-&gt;second;</div><div class="line">        }</div><div class="line">    } </div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; boundary_value_u !=map_boundary_values_u.end(); ++boundary_value_u, ++i)</div><div class="line">    {</div><div class="line">      boundary_values_id_u[i]=boundary_value_u-&gt;first;</div><div class="line">      boundary_values_u[i]=boundary_value_u-&gt;second;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; boundary_value_v !=map_boundary_values_v.end(); ++boundary_value_v, ++i)</div><div class="line">    {</div><div class="line">      boundary_values_id_v[i]=boundary_value_v-&gt;first;</div><div class="line">      boundary_values_v[i]=boundary_value_v-&gt;second;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TestNavierStokes&lt;dim&gt;::run()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator)== 0)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;***** CONVERGENCE TEST FOR NS *****&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;DEGREE LS: &quot;</span> &lt;&lt; degree_LS &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;DEGREE U:  &quot;</span> &lt;&lt; degree_U &lt;&lt; std::endl;</div><div class="line">    }</div></div><!-- fragment --><p>PARAMETERS FOR THE NAVIER STOKES PROBLEM</p>
<div class="fragment"><div class="line">final_time = 1.0;</div><div class="line">time_step=0.1;</div><div class="line">n_cycles=6;</div><div class="line">n_refinement=6;</div><div class="line">ForceTerms&lt;dim&gt; force_function;</div><div class="line">RhoFunction&lt;dim&gt; rho_function;</div><div class="line">NuFunction&lt;dim&gt; nu_function;</div><div class="line"></div><div class="line">output_time=0.1;</div><div class="line">output_number=0;</div><div class="line"><span class="keywordtype">bool</span> get_output = <span class="keyword">false</span>;</div><div class="line"><span class="keywordtype">bool</span> get_error = <span class="keyword">true</span>;</div><div class="line">verbose = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;n_cycles; ++cycle)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (n_refinement);</div><div class="line">        setup();</div><div class="line">        initial_condition();</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1); </div><div class="line">        setup();</div><div class="line">        initial_condition();</div><div class="line">        time_step*=0.5;</div><div class="line">      }</div><div class="line"></div><div class="line">    output_results();</div></div><!-- fragment --><p>if (cycle==0)</p>
<div class="fragment"><div class="line">NavierStokesSolver&lt;dim&gt; navier_stokes (degree_LS,</div><div class="line">                                       degree_U,</div><div class="line">                                       time_step,</div><div class="line">                                       force_function,</div><div class="line">                                       rho_function,</div><div class="line">                                       nu_function,</div><div class="line">                                       verbose,</div><div class="line">                                       triangulation,</div><div class="line">                                       mpi_communicator);</div></div><!-- fragment --><p>set INITIAL CONDITION within TRANSPORT PROBLEM</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (dim==2)</div><div class="line">  navier_stokes.initial_condition(locally_relevant_solution_rho,</div><div class="line">                                  locally_relevant_solution_u,</div><div class="line">                                  locally_relevant_solution_v,</div><div class="line">                                  locally_relevant_solution_p);</div><div class="line"><span class="keywordflow">else</span> <span class="comment">//dim=3</span></div><div class="line">  navier_stokes.initial_condition(locally_relevant_solution_rho,</div><div class="line">                                  locally_relevant_solution_u,</div><div class="line">                                  locally_relevant_solution_v,</div><div class="line">                                  locally_relevant_solution_w,</div><div class="line">                                  locally_relevant_solution_p);</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   Cycle   &quot;</span> &lt;&lt; cycle</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span> </div><div class="line">      &lt;&lt; triangulation.<a class="code" href="classparallel_1_1Triangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom (velocity): &quot;</span></div><div class="line">      &lt;&lt; dof_handler_U.n_dofs() &lt;&lt; std::endl</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;   min h=&quot;</span> &lt;&lt; <a class="code" href="namespaceGridTools.html#ac89deda30a32b232dbe9c95e14896df5">GridTools::minimal_cell_diameter</a>(triangulation)/std::sqrt(2)/degree_U</div><div class="line">      &lt;&lt; std::endl;</div></div><!-- fragment --><p>TIME STEPPING</p>
<div class="fragment"><div class="line">timestep_number=0;</div><div class="line">time=0;</div><div class="line"><span class="keywordtype">double</span> time_step_backup=time_step;</div><div class="line"><span class="keywordflow">while</span>(time&lt;final_time)</div><div class="line">  {</div><div class="line">    timestep_number++;</div></div><!-- fragment --><p>///////////////// GET TIME_STEP // /////////////////</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (time+time_step &gt; final_time-1E-10)</div><div class="line">  {</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;FINAL TIME STEP...&quot;</span> &lt;&lt; std::endl;</div><div class="line">    time_step_backup=time_step;</div><div class="line">    time_step=final_time-time;</div><div class="line">  }</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;\twith dt=&quot;</span> &lt;&lt; time_step </div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;\tat tn=&quot;</span> &lt;&lt; time</div><div class="line">      &lt;&lt; std::endl;</div></div><!-- fragment --><p>/////////////// FORCE TERMS // ///////////////</p>
<div class="fragment"><div class="line">force_function.set_time(time+time_step);</div></div><!-- fragment --><p>/////////////////////////////// DENSITY AND VISCOSITY FIELD // ///////////////////////////////</p>
<div class="fragment"><div class="line">rho_function.set_time(time+time_step);</div><div class="line">nu_function.set_time(time+time_step);</div></div><!-- fragment --><p>/////////////////////// BOUNDARY CONDITIONS // ///////////////////////</p>
<div class="fragment"><div class="line">get_boundary_values_U(time+time_step);</div><div class="line"><span class="keywordflow">if</span> (dim==2) navier_stokes.set_boundary_conditions(boundary_values_id_u, boundary_values_id_v,</div><div class="line">                                                  boundary_values_u, boundary_values_v);</div><div class="line"><span class="keywordflow">else</span> navier_stokes.set_boundary_conditions(boundary_values_id_u, </div><div class="line">                                           boundary_values_id_v, </div><div class="line">                                           boundary_values_id_w,</div><div class="line">                                           boundary_values_u, boundary_values_v, boundary_values_w);</div></div><!-- fragment --><p>//////////////// GET SOLUTION // ////////////////</p>
<div class="fragment"><div class="line">navier_stokes.nth_time_step();</div><div class="line"><span class="keywordflow">if</span> (dim==2) </div><div class="line">  navier_stokes.get_velocity(locally_relevant_solution_u,locally_relevant_solution_v);</div><div class="line"><span class="keywordflow">else</span> </div><div class="line">  navier_stokes.get_velocity(locally_relevant_solution_u,</div><div class="line">                             locally_relevant_solution_v,</div><div class="line">                             locally_relevant_solution_w);</div><div class="line">navier_stokes.get_pressure(locally_relevant_solution_p);</div></div><!-- fragment --><p>//////////////// FIX PRESSURE // ////////////////</p>
<div class="fragment"><div class="line">fix_pressure();</div></div><!-- fragment --><p>/////////////// UPDATE TIME // ///////////////</p>
<div class="fragment"><div class="line">time+=time_step;</div></div><!-- fragment --><p>////////// OUTPUT // //////////</p>
<div class="fragment"><div class="line">          <span class="keywordflow">if</span> (get_output &amp;&amp; time-(output_number)*output_time&gt;=1E-10)</div><div class="line">            output_results();</div><div class="line">        }</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;FINAL TIME: &quot;</span> &lt;&lt; time &lt;&lt; std::endl;</div><div class="line">      time_step=time_step_backup;</div><div class="line">      <span class="keywordflow">if</span> (get_error)</div><div class="line">        process_solution(cycle);</div><div class="line">    </div><div class="line">      <span class="keywordflow">if</span> (get_error)</div><div class="line">        {</div><div class="line">          convergence_table.set_precision(<span class="stringliteral">&quot;u L2&quot;</span>, 2);</div><div class="line">          convergence_table.set_precision(<span class="stringliteral">&quot;u H1&quot;</span>, 2);</div><div class="line">          convergence_table.set_scientific(<span class="stringliteral">&quot;u L2&quot;</span>,<span class="keyword">true</span>);</div><div class="line">          convergence_table.set_scientific(<span class="stringliteral">&quot;u H1&quot;</span>,<span class="keyword">true</span>);</div><div class="line">          </div><div class="line">          convergence_table.set_precision(<span class="stringliteral">&quot;v L2&quot;</span>, 2);</div><div class="line">          convergence_table.set_precision(<span class="stringliteral">&quot;v H1&quot;</span>, 2);</div><div class="line">          convergence_table.set_scientific(<span class="stringliteral">&quot;v L2&quot;</span>,<span class="keyword">true</span>);</div><div class="line">          convergence_table.set_scientific(<span class="stringliteral">&quot;v H1&quot;</span>,<span class="keyword">true</span>);</div><div class="line">          </div><div class="line">          <span class="keywordflow">if</span> (dim==3)</div><div class="line">            {</div><div class="line">              convergence_table.set_precision(<span class="stringliteral">&quot;w L2&quot;</span>, 2);</div><div class="line">              convergence_table.set_precision(<span class="stringliteral">&quot;w H1&quot;</span>, 2);</div><div class="line">              convergence_table.set_scientific(<span class="stringliteral">&quot;w L2&quot;</span>,<span class="keyword">true</span>);</div><div class="line">              convergence_table.set_scientific(<span class="stringliteral">&quot;w H1&quot;</span>,<span class="keyword">true</span>);</div><div class="line">            }</div><div class="line">          </div><div class="line">          convergence_table.set_precision(<span class="stringliteral">&quot;p L2&quot;</span>, 2);</div><div class="line">          convergence_table.set_precision(<span class="stringliteral">&quot;p H1&quot;</span>, 2);</div><div class="line">          convergence_table.set_scientific(<span class="stringliteral">&quot;p L2&quot;</span>,<span class="keyword">true</span>);</div><div class="line">          convergence_table.set_scientific(<span class="stringliteral">&quot;p H1&quot;</span>,<span class="keyword">true</span>);</div><div class="line"></div><div class="line">          convergence_table.set_tex_format(<span class="stringliteral">&quot;cells&quot;</span>,<span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">          convergence_table.set_tex_format(<span class="stringliteral">&quot;dofs_U&quot;</span>,<span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">          convergence_table.set_tex_format(<span class="stringliteral">&quot;dofs_P&quot;</span>,<span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">          convergence_table.set_tex_format(<span class="stringliteral">&quot;dt&quot;</span>,<span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">            {</div><div class="line">              std::cout &lt;&lt; std::endl;</div><div class="line">              convergence_table.write_text(std::cout);</div><div class="line">            }        </div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line">      PetscInitialize(&amp;argc, &amp;argv, PETSC_NULL, PETSC_NULL);</div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (0);</div><div class="line"></div><div class="line">      {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_LS = 1;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_U = 2;</div><div class="line">        TestNavierStokes&lt;2&gt; test_navier_stokes(degree_LS, degree_U);</div><div class="line">        test_navier_stokes.run();</div><div class="line">      }</div><div class="line"></div><div class="line">      PetscFinalize();</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-utilities.cc"></a> </p><h1>Annotated version of utilities.cc</h1>
<p>/////////////////////////////////////////////////// ////////////////// INITIAL PHI //////////////////// ///////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialPhi : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialPhi (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM, <span class="keywordtype">double</span> sharpness=0.005) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(),</div><div class="line">                                                              sharpness(sharpness),</div><div class="line">                                                              PROBLEM(PROBLEM) {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> sharpness;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> InitialPhi&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> x = p[0]; <span class="keywordtype">double</span> y = p[1];</div><div class="line">  <span class="keywordtype">double</span> pi=<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (PROBLEM==FILLING_TANK)</div><div class="line">    <span class="keywordflow">return</span> 0.5*(-std::tanh((y-0.3)/sharpness)*std::tanh((y-0.35)/sharpness)+1)</div><div class="line">      *(-std::tanh((x-0.02)/sharpness)+1)-1;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PROBLEM==BREAKING_DAM)</div><div class="line">    <span class="keywordflow">return</span> 0.5*(-std::tanh((x-0.35)/sharpness)*std::tanh((x-0.65)/sharpness)+1)</div><div class="line">      *(1-std::tanh((y-0.35)/sharpness))-1;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PROBLEM==FALLING_DROP)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> x0=0.15; <span class="keywordtype">double</span> y0=0.75;</div><div class="line">      <span class="keywordtype">double</span> r0=0.1;</div><div class="line">      <span class="keywordtype">double</span> r = std::sqrt(std::pow(x-x0,2)+std::pow(y-y0,2));</div><div class="line">      <span class="keywordflow">return</span> 1-(std::tanh((r-r0)/sharpness)+std::tanh((y-0.3)/sharpness));</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PROBLEM==SMALL_WAVE_PERTURBATION)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> wave = 0.1*std::sin(pi*x)+0.25;</div><div class="line">      <span class="keywordflow">return</span> -std::tanh((y-wave)/sharpness);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> </div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Error in type of PROBLEM&quot;</span> &lt;&lt; std::endl;</div><div class="line">      <a class="code" href="namespacedeal__II__exceptions_1_1internals.html#a6f0d772e8c91609d7ea9e834bbb2eb7e">abort</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// ////////////////// FORCE TERMS ///// //////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ForceTerms : <span class="keyword">public</span> <a class="code" href="classConstantFunction.html">ConstantFunction</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ForceTerms (<span class="keyword">const</span> std::vector&lt;double&gt; values) : <a class="code" href="classConstantFunction.html">ConstantFunction</a>&lt;dim&gt;(values) {}</div><div class="line">};</div></div><!-- fragment --><p>/////////////////////////////////////////////////// ////////////////// BOUNDARY PHI /////////////////// ///////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryPhi : <span class="keyword">public</span> <a class="code" href="classConstantFunction.html">ConstantFunction</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryPhi (<span class="keyword">const</span> <span class="keywordtype">double</span> value, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_components=1) : <a class="code" href="classConstantFunction.html">ConstantFunction</a>&lt;dim&gt;(value,n_components) {}</div><div class="line">};</div></div><!-- fragment --><p>//////////////////////////////////////////////////////// ////////////////// BOUNDARY VELOCITY /////////////////// ////////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryU (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM, <span class="keywordtype">double</span> t=0) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(), PROBLEM(PROBLEM) {this-&gt;<a class="code" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a>(t);}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">unsigned</span> PROBLEM;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryU&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>//////////////////// FILLING THE TANK // //////////////////// boundary for filling the tank (inlet)</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> x = p[0]; <span class="keywordtype">double</span> y = p[1];</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (PROBLEM==FILLING_TANK)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (x==0 &amp;&amp; y&gt;=0.3 &amp;&amp; y&lt;=0.35)</div><div class="line">        <span class="keywordflow">return</span> 0.25;</div><div class="line">      <span class="keywordflow">else</span> </div><div class="line">        <span class="keywordflow">return</span> 0.0;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> </div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Error in PROBLEM definition&quot;</span> &lt;&lt; std::endl;</div><div class="line">      <a class="code" href="namespacedeal__II__exceptions_1_1internals.html#a6f0d772e8c91609d7ea9e834bbb2eb7e">abort</a>();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryV (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM, <span class="keywordtype">double</span> t=0) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(), PROBLEM(PROBLEM) {this-&gt;<a class="code" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a>(t);}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryV&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>boundary for filling the tank (outlet)</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> x = p[0]; <span class="keywordtype">double</span> y = p[1];</div><div class="line">  <span class="keywordtype">double</span> return_value = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (PROBLEM==FILLING_TANK)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (y==0.4 &amp;&amp; x&gt;=0.3 &amp;&amp; x&lt;=0.35)</div><div class="line">        return_value = 0.25;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// ///////////////// POST-PROCESSING /////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Postprocessor : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Postprocessor(<span class="keywordtype">double</span> eps, <span class="keywordtype">double</span> rho_air, <span class="keywordtype">double</span> rho_fluid)</div><div class="line">    :</div><div class="line">    <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Density&quot;</span>,<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {</div><div class="line">    this-&gt;eps=eps;</div><div class="line">    this-&gt;rho_air=rho_air;</div><div class="line">    this-&gt;rho_fluid=rho_fluid;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#ae6d9f42d2d8acaeab94da23442632796">compute_derived_quantities_scalar</a> (<span class="keyword">const</span> std::vector&lt; double &gt; &amp;uh,</div><div class="line">                                                  <span class="keyword">const</span> std::vector&lt; <a class="code" href="classTensor.html">Tensor&lt; 1, dim &gt;</a> &gt; &amp;duh,</div><div class="line">                                                  <span class="keyword">const</span> std::vector&lt; <a class="code" href="classTensor.html">Tensor&lt; 2, dim &gt;</a> &gt; &amp;dduh,</div><div class="line">                                                  <span class="keyword">const</span> std::vector&lt; <a class="code" href="classPoint.html">Point&lt; dim &gt;</a> &gt; &amp;normals,</div><div class="line">                                                  <span class="keyword">const</span> std::vector&lt; <a class="code" href="classPoint.html">Point&lt; dim &gt;</a> &gt; &amp;evaluation_points,</div><div class="line">                                                  std::vector&lt; <a class="code" href="classVector.html">Vector&lt; double &gt;</a> &gt; &amp;computed_quantities </div><div class="line">                                                  ) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> eps;</div><div class="line">  <span class="keywordtype">double</span> rho_air;</div><div class="line">  <span class="keywordtype">double</span> rho_fluid;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Postprocessor&lt;dim&gt;::compute_derived_quantities_scalar(<span class="keyword">const</span> std::vector&lt; double &gt; &amp;uh,</div><div class="line">                                                           <span class="keyword">const</span> std::vector&lt; <a class="code" href="classTensor.html">Tensor&lt; 1, dim &gt;</a> &gt; &amp; / *duh* /,</div><div class="line">                                                           <span class="keyword">const</span> std::vector&lt; <a class="code" href="classTensor.html">Tensor&lt; 2, dim &gt;</a> &gt; &amp; / *dduh* /,</div><div class="line">                                                           <span class="keyword">const</span> std::vector&lt; <a class="code" href="classPoint.html">Point&lt; dim &gt;</a> &gt; &amp; / *normals* /,</div><div class="line">                                                           <span class="keyword">const</span> std::vector&lt; <a class="code" href="classPoint.html">Point&lt; dim &gt;</a> &gt; &amp; / *evaluation_points* /,</div><div class="line">                                                           std::vector&lt; <a class="code" href="classVector.html">Vector&lt; double &gt;</a> &gt; &amp;computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_quadrature_points = uh.size();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_quadrature_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> H;</div><div class="line">      <span class="keywordtype">double</span> rho_value;</div><div class="line">      <span class="keywordtype">double</span> phi_value=uh[q];</div><div class="line">      <span class="keywordflow">if</span>(phi_value &gt; eps) </div><div class="line">        H=1;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phi_value &lt; -eps) </div><div class="line">        H=-1;</div><div class="line">      <span class="keywordflow">else</span> </div><div class="line">        H=phi_value/eps;</div><div class="line">      rho_value = rho_fluid*(1+H)/2. + rho_air*(1-H)/2.;</div><div class="line">      computed_quantities[q] = rho_value;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-utilities_test_LS.cc"></a> </p><h1>Annotated version of utilities_test_LS.cc</h1>
<p>///////////////////////////////////////////////////// ////////////////// INITIAL PHI //////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialPhi : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialPhi (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM, <span class="keywordtype">double</span> sharpness=0.005) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(),</div><div class="line">                                                                sharpness(sharpness),</div><div class="line">                                                                PROBLEM(PROBLEM) {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> sharpness;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> InitialPhi&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> x = p[0]; <span class="keywordtype">double</span> y = p[1];</div><div class="line">  <span class="keywordtype">double</span> return_value = -1.;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (PROBLEM==CIRCULAR_ROTATION)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> x0=0.5; <span class="keywordtype">double</span> y0=0.75;</div><div class="line">      <span class="keywordtype">double</span> r0=0.15;</div><div class="line">      <span class="keywordtype">double</span> r = std::sqrt(std::pow(x-x0,2)+std::pow(y-y0,2));</div><div class="line">      return_value = -std::tanh((r-r0)/sharpness);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// (PROBLEM==DIAGONAL_ADVECTION)</span></div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> x0=0.25; <span class="keywordtype">double</span> y0=0.25;</div><div class="line">      <span class="keywordtype">double</span> r0=0.15;</div><div class="line">      <span class="keywordtype">double</span> r=0;</div><div class="line">      <span class="keywordflow">if</span> (dim==2)</div><div class="line">        r = std::sqrt(std::pow(x-x0,2)+std::pow(y-y0,2));        </div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="keywordtype">double</span> z0=0.25;</div><div class="line">          <span class="keywordtype">double</span> z=p[2];</div><div class="line">          r = std::sqrt(std::pow(x-x0,2)+std::pow(y-y0,2)+std::pow(z-z0,2));</div><div class="line">        }</div><div class="line">      return_value = -std::tanh((r-r0)/sharpness);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>/////////////////////////////////////////////////// ////////////////// BOUNDARY PHI /////////////////// ///////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryPhi : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryPhi (<span class="keywordtype">double</span> t=0) </div><div class="line">    : </div><div class="line">    <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() </div><div class="line">  {this-&gt;<a class="code" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a>(t);}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryPhi&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> -1.0;</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// ////////////////// EXACT VELOCITY /////////////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactU (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM, <span class="keywordtype">double</span> time=0) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(), PROBLEM(PROBLEM), time(time) {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a>(<span class="keywordtype">double</span> time){this-&gt;time=<a class="code" href="classFunctionTime.html#a8932e3ec9ed7b6f6d6a91c23f82e36d8">time</a>;};</div><div class="line">  <span class="keywordtype">unsigned</span> PROBLEM;</div><div class="line">  <span class="keywordtype">double</span> <a class="code" href="classFunctionTime.html#a8932e3ec9ed7b6f6d6a91c23f82e36d8">time</a>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ExactU&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (PROBLEM==CIRCULAR_ROTATION)</div><div class="line">    <span class="keywordflow">return</span> -2*numbers::PI*(p[1]-0.5);</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// (PROBLEM==DIAGONAL_ADVECTION)</span></div><div class="line">    <span class="keywordflow">return</span> 1.0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactV (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM, <span class="keywordtype">double</span> time=0) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(), PROBLEM(PROBLEM), time(time) {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> set_time(<span class="keywordtype">double</span> time){this-&gt;time=time;};</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM;</div><div class="line">  <span class="keywordtype">double</span> time;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ExactV&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (PROBLEM==CIRCULAR_ROTATION)</div><div class="line">    <span class="keywordflow">return</span> 2*numbers::PI*(p[0]-0.5);</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// (PROBLEM==DIAGONAL_ADVECTION)</span></div><div class="line">    <span class="keywordflow">return</span> 1.0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactW : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactW (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM, <span class="keywordtype">double</span> time=0) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(), PROBLEM(PROBLEM), time(time) {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> set_time(<span class="keywordtype">double</span> time){this-&gt;time=time;};</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PROBLEM;</div><div class="line">  <span class="keywordtype">double</span> time;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ExactW&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>PROBLEM = 3D_DIAGONAL_ADVECTION</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> 1.0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-utilities_test_NS.cc"></a> </p><h1>Annotated version of utilities_test_NS.cc</h1>
<p>///////////////////////////////////////////////////// ////////// EXACT SOLUTION RHO TO TEST NS //////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RhoFunction : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RhoFunction (<span class="keywordtype">double</span> t=0) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(){this-&gt;<a class="code" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a>(t);}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RhoFunction&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> t = this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>();</div><div class="line">  <span class="keywordtype">double</span> return_value = 0;</div><div class="line">  <span class="keywordflow">if</span> (dim==2)</div><div class="line">    return_value = std::pow(std::sin(p[0]+p[1]+t),2)+1;</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">//dim=3</span></div><div class="line">    return_value = std::pow(std::sin(p[0]+p[1]+p[2]+t),2)+1;</div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>NuFunction : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  NuFunction (<span class="keywordtype">double</span> t=0) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(){this-&gt;set_time(t);}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> NuFunction&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 1.;</div><div class="line">}</div></div><!-- fragment --><p>//////////////////////////////////////////////////////////////// ///////////////// EXACT SOLUTION U to TEST NS ////////////////// ////////////////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactSolution_and_BC_U : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactSolution_and_BC_U (<span class="keywordtype">double</span> t=0, <span class="keywordtype">int</span> field=0) </div><div class="line">    : </div><div class="line">    <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(), </div><div class="line">    field(field)</div><div class="line">  {</div><div class="line">    this-&gt;<a class="code" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a>(t);</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component=1) <span class="keyword">const</span>;</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> <a class="code" href="classFunction.html#ae0a836ba78787fed039c5a097bdda854">gradient</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=1) <span class="keyword">const</span>;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_field(<span class="keywordtype">int</span> field) {this-&gt;field=field;}</div><div class="line">  <span class="keywordtype">int</span> field;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> type_simulation;</div><div class="line">};</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ExactSolution_and_BC_U&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> t = this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>();</div><div class="line">  <span class="keywordtype">double</span> return_value = 0;</div><div class="line">  <span class="keywordtype">double</span> Pi = <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>;</div><div class="line">  <span class="keywordtype">double</span> x = p[0]; <span class="keywordtype">double</span> y = p[1]; <span class="keywordtype">double</span> z = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (dim == 2)</div><div class="line">    <span class="keywordflow">if</span> (field == 0)</div><div class="line">      return_value = std::sin(x)*std::sin(y+t);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      return_value = std::cos(x)*std::cos(y+t); </div><div class="line">  <span class="keywordflow">else</span> <span class="comment">//dim=3</span></div><div class="line">    {</div><div class="line">      z = p[2];</div><div class="line">      <span class="keywordflow">if</span> (field == 0)</div><div class="line">        return_value = std::cos(t)*std::cos(Pi*y)*std::cos(Pi*z)*std::sin(Pi*x);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (field == 1)</div><div class="line">        return_value = std::cos(t)*std::cos(Pi*x)*std::cos(Pi*z)*std::sin(Pi*y);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        return_value = -2*std::cos(t)*std::cos(Pi*x)*std::cos(Pi*y)*std::sin(Pi*z);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> return_value;  </div><div class="line">}</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> ExactSolution_and_BC_U&lt;dim&gt;::gradient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{ <span class="comment">// THIS IS USED JUST FOR TESTING NS</span></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> return_value;</div><div class="line">  <span class="keywordtype">double</span> t = this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>();</div><div class="line">  <span class="keywordtype">double</span> Pi = <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>;</div><div class="line">  <span class="keywordtype">double</span> x = p[0]; <span class="keywordtype">double</span> y = p[1]; <span class="keywordtype">double</span> z = 0;</div><div class="line">  <span class="keywordflow">if</span> (dim == 2)</div><div class="line">    <span class="keywordflow">if</span> (field == 0)</div><div class="line">      {</div><div class="line">        return_value[0] = std::cos(x)*std::sin(y+t);</div><div class="line">        return_value[1] = std::sin(x)*std::cos(y+t);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> </div><div class="line">      {</div><div class="line">        return_value[0] = -std::sin(x)*std::cos(y+t);</div><div class="line">        return_value[1] = -std::cos(x)*std::sin(y+t);</div><div class="line">      }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">//dim=3</span></div><div class="line">    {</div><div class="line">      z=p[2];</div><div class="line">      <span class="keywordflow">if</span> (field == 0)</div><div class="line">        {</div><div class="line">          return_value[0] = Pi*std::cos(t)*std::cos(Pi*x)*std::cos(Pi*y)*std::cos(Pi*z);</div><div class="line">          return_value[1] = -(Pi*std::cos(t)*std::cos(Pi*z)*std::sin(Pi*x)*std::sin(Pi*y));</div><div class="line">          return_value[2] = -(Pi*std::cos(t)*std::cos(Pi*y)*std::sin(Pi*x)*std::sin(Pi*z));</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (field == 1)</div><div class="line">        {</div><div class="line">          return_value[0] = -(Pi*std::cos(t)*std::cos(Pi*z)*std::sin(Pi*x)*std::sin(Pi*y));</div><div class="line">          return_value[1] = Pi*std::cos(t)*std::cos(Pi*x)*std::cos(Pi*y)*std::cos(Pi*z);</div><div class="line">          return_value[2] = -(Pi*std::cos(t)*std::cos(Pi*x)*std::sin(Pi*y)*std::sin(Pi*z));</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          return_value[0] = 2*Pi*std::cos(t)*std::cos(Pi*y)*std::sin(Pi*x)*std::sin(Pi*z);</div><div class="line">          return_value[1] = 2*Pi*std::cos(t)*std::cos(Pi*x)*std::sin(Pi*y)*std::sin(Pi*z);</div><div class="line">          return_value[2] = -2*Pi*std::cos(t)*std::cos(Pi*x)*std::cos(Pi*y)*std::cos(Pi*z);</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>///////////////////////////////////////////////////// ///////// EXACT SOLUTION FOR p TO TEST NS /////////// /////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactSolution_p : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactSolution_p (<span class="keywordtype">double</span> t=0) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(){this-&gt;<a class="code" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a>(t);}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component=0) <span class="keyword">const</span>;</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> <a class="code" href="classFunction.html#ae0a836ba78787fed039c5a097bdda854">gradient</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ExactSolution_p&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> t = this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>();</div><div class="line">  <span class="keywordtype">double</span> return_value = 0;</div><div class="line">  <span class="keywordflow">if</span> (dim == 2)</div><div class="line">    return_value = std::cos(p[0])*std::sin(p[1]+t);</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">//dim=3</span></div><div class="line">    return_value = std::sin(p[0]+p[1]+p[2]+t);</div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> ExactSolution_p&lt;dim&gt;::gradient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> return_value;</div><div class="line">  <span class="keywordtype">double</span> t = this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>();</div><div class="line">  <span class="keywordflow">if</span> (dim == 2)</div><div class="line">    {</div><div class="line">      return_value[0] = -std::sin(p[0])*std::sin(p[1]+t);</div><div class="line">      return_value[1] = std::cos(p[0])*std::cos(p[1]+t);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">//dim=3</span></div><div class="line">    {</div><div class="line">      return_value[0] = std::cos(t+p[0]+p[1]+p[2]);</div><div class="line">      return_value[1] = std::cos(t+p[0]+p[1]+p[2]);</div><div class="line">      return_value[2] = std::cos(t+p[0]+p[1]+p[2]);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>//////////////////////////////////////////////////////////////// ////////////////// FORCE TERMS to TEST NS ////////////////////// ////////////////////////////////////////////////////////////////</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ForceTerms : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a> &lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ForceTerms (<span class="keywordtype">double</span> t=0) </div><div class="line">    : </div><div class="line">    <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() </div><div class="line">  {</div><div class="line">    this-&gt;<a class="code" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a>(t);</div><div class="line">    nu = 1.;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> nu;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ForceTerms&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  <span class="keywordtype">double</span> x = p[0]; <span class="keywordtype">double</span> y = p[1]; <span class="keywordtype">double</span> z = 0;</div><div class="line">  <span class="keywordtype">double</span> t = this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>();</div><div class="line">  <span class="keywordtype">double</span> Pi = <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>;</div><div class="line">  </div><div class="line">  <span class="keywordflow">if</span> (dim == 2)</div><div class="line">    {</div></div><!-- fragment --><p>force in x</p>
<div class="fragment"><div class="line">values[0] = std::cos(t+y)*std::sin(x)*(1+std::pow(std::sin(t+x+y),2)) <span class="comment">// time derivative</span></div><div class="line">  +2*nu*std::sin(x)*std::sin(t+y) <span class="comment">// viscosity</span></div><div class="line">  +std::cos(x)*std::sin(x)*(1+std::pow(std::sin(t+x+y),2)) <span class="comment">// non-linearity</span></div><div class="line">  -std::sin(x)*std::sin(y+t); <span class="comment">// pressure</span></div></div><!-- fragment --><p>force in y</p>
<div class="fragment"><div class="line">    values[1] = -(std::cos(x)*std::sin(t+y)*(1+std::pow(std::sin(t+x+y),2))) <span class="comment">// time derivative</span></div><div class="line">      +2*nu*std::cos(x)*std::cos(t+y) <span class="comment">// viscosity</span></div><div class="line">      -(std::sin(2*(t+y))*(1+std::pow(std::sin(t+x+y),2)))/2. <span class="comment">// non-linearity</span></div><div class="line">      +std::cos(x)*std::cos(y+t); <span class="comment">// pressure</span></div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="comment">//3D</span></div><div class="line">  {</div><div class="line">    z = p[2];</div></div><!-- fragment --><p>force in x</p>
<div class="fragment"><div class="line">      values[0]=</div><div class="line">        -(std::cos(Pi*y)*std::cos(Pi*z)*std::sin(t)*std::sin(Pi*x)*(1+std::pow(std::sin(t+x+y+z),2))) <span class="comment">//time der.</span></div><div class="line">        +3*std::pow(Pi,2)*std::cos(t)*std::cos(Pi*y)*std::cos(Pi*z)*std::sin(Pi*x) <span class="comment">//viscosity</span></div><div class="line">        -(Pi*std::pow(std::cos(t),2)*(-3+std::cos(2*(t+x+y+z)))*std::sin(2*Pi*x)*(std::cos(2*Pi*y)+std::pow(std::sin(Pi*z),2)))/4. <span class="comment">//NL</span></div><div class="line">        +std::cos(t+x+y+z); <span class="comment">// pressure</span></div><div class="line">      values[1]=</div><div class="line">        -(std::cos(Pi*x)*std::cos(Pi*z)*std::sin(t)*std::sin(Pi*y)*(1+std::pow(std::sin(t+x+y+z),2))) <span class="comment">//time der</span></div><div class="line">        +3*std::pow(Pi,2)*std::cos(t)*std::cos(Pi*x)*std::cos(Pi*z)*std::sin(Pi*y) <span class="comment">//viscosity</span></div><div class="line">        -(Pi*std::pow(std::cos(t),2)*(-3+std::cos(2*(t+x+y+z)))*std::sin(2*Pi*y)*(std::cos(2*Pi*x)+std::pow(std::sin(Pi*z),2)))/4. <span class="comment">//NL</span></div><div class="line">        +std::cos(t+x+y+z); <span class="comment">// pressure</span></div><div class="line">      values[2]=</div><div class="line">        2*std::cos(Pi*x)*std::cos(Pi*y)*std::sin(t)*std::sin(Pi*z)*(1+std::pow(std::sin(t+x+y+z),2)) <span class="comment">//time der</span></div><div class="line">        -6*std::pow(Pi,2)*std::cos(t)*std::cos(Pi*x)*std::cos(Pi*y)*std::sin(Pi*z) <span class="comment">//viscosity</span></div><div class="line">        -(Pi*std::pow(std::cos(t),2)*(2+std::cos(2*Pi*x)+std::cos(2*Pi*y))*(-3+std::cos(2*(t+x+y+z)))*std::sin(2*Pi*z))/4. <span class="comment">//NL</span></div><div class="line">        +std::cos(t+x+y+z); <span class="comment">// pressure</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
