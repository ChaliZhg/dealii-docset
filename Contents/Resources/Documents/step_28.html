<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-28 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-28 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Theeigenvalueproblem">The eigenvalue problem</a>
        <li><a href="#Meshesandmeshrefinement">Meshes and mesh refinement</a>
      <ul>
        <li><a href="#Meshrefinement">Mesh refinement</a>
        <li><a href="#Assemblingtermsondifferentmeshes">Assembling terms on different meshes</a>
      </ul>
        <li><a href="#Descriptionofthetestcase">Description of the test case</a>
        <li><a href="#Whattheprogramdoesandhowitdoesthat">What the program does (and how it does that)</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Materialdata">Material data</a>
        <li><a href="#ThecodeEnergyGroupcodeclass">The <code>EnergyGroup</code> class</a>
      <ul>
      <ul>
        <li><a href="#Publicmemberfunctions">Public member functions</a>
        <li><a href="#Publicdatamembers">Public data members</a>
        <li><a href="#Privatedatamembers">Private data members</a>
        <li><a href="#Privatememberfunctions">Private member functions</a>
      </ul>
        <li><a href="#ImplementationofthecodeEnergyGroupcodeclass">Implementation of the <code>EnergyGroup</code> class</a>
      <ul>
        <li><a href="#codeEnergyGroupsetup_linear_systemcode"><code>EnergyGroup::setup_linear_system</code></a>
        <li><a href="#codeEnergyGroupassemble_system_matrixcode"><code>EnergyGroup::assemble_system_matrix</code></a>
        <li><a href="#codeEnergyGroupassemble_ingroup_rhscode"><code>EnergyGroup::assemble_ingroup_rhs</code></a>
        <li><a href="#codeEnergyGroupassemble_cross_group_rhscode"><code>EnergyGroup::assemble_cross_group_rhs</code></a>
        <li><a href="#codeEnergyGroupassemble_cross_group_rhs_recursivecode"><code>EnergyGroup::assemble_cross_group_rhs_recursive</code></a>
        <li><a href="#codeEnergyGroupget_fission_sourcecode"><code>EnergyGroup::get_fission_source</code></a>
        <li><a href="#codeEnergyGroupsolvecode"><code>EnergyGroup::solve</code></a>
        <li><a href="#codeEnergyGroupestimate_errorscode"><code>EnergyGroup::estimate_errors</code></a>
        <li><a href="#codeEnergyGrouprefine_gridcode"><code>EnergyGroup::refine_grid</code></a>
        <li><a href="#codeEnergyGroupoutput_resultscode"><code>EnergyGroup::output_results</code></a>
      </ul>
      </ul>
        <li><a href="#ThecodeNeutronDiffusionProblemcodeclasstemplate">The <code>NeutronDiffusionProblem</code> class template</a>
      <ul>
      <ul>
        <li><a href="#Privatememberfunctions">Private member functions</a>
        <li><a href="#Privatemembervariables">Private member variables</a>
      </ul>
        <li><a href="#ImplementationofthecodeNeutronDiffusionProblemParameterscodeclass">Implementation of the <code>NeutronDiffusionProblem::Parameters</code> class</a>
        <li><a href="#ImplementationofthecodeNeutronDiffusionProblemcodeclass">Implementation of the <code>NeutronDiffusionProblem</code> class</a>
      <ul>
        <li><a href="#codeNeutronDiffusionProbleminitialize_problemcode"><code>NeutronDiffusionProblem::initialize_problem</code></a>
        <li><a href="#codeNeutronDiffusionProblemget_total_fission_sourcecode"><code>NeutronDiffusionProblem::get_total_fission_source</code></a>
        <li><a href="#codeNeutronDiffusionProblemrefine_gridcode"><code>NeutronDiffusionProblem::refine_grid</code></a>
        <li><a href="#codeNeutronDiffusionProblemruncode"><code>NeutronDiffusionProblem::run</code></a>
      </ul>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Yaqi Wang and Wolfgang Bangerth. Results from this program are used and discussed in the publication "Three-dimensional \form#720-adaptivity for the multigroup neutron diffusion
equations" by Yaqi Wang, Wolfgang Bangerth and Jean Ragusa. The paper's full bibliographic details are as follows: </p><div class="fragment"><div class="line">@Article{WBR09,</div><div class="line">  author =       {Yaqi Wang and Wolfgang Bangerth and Jean Ragusa},</div><div class="line">  title =        {Three-dimensional @f$h@f$-adaptivity <span class="keywordflow">for</span> the multigroup</div><div class="line">                  neutron diffusion equations},</div><div class="line">  journal =      {Progr. Nucl. Energy},</div><div class="line">  year =         2009,</div><div class="line">  <a class="code" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">volume</a> =       51,</div><div class="line">  pages =        {543--555}</div><div class="line">}</div></div><!-- fragment --><p> A preprint that mostly matches the final version of the paper is available <a href="http://iamcs.tamu.edu/file_dl.php?type=preprint&amp;preprint_id=19" target="_top">here</a>. </em></p>
<p><br />
</p>
<p><a class="anchor" id="Introduction"></a><a class="anchor" id="Intro"></a> </p><h1>Introduction</h1>
<p>In this example, we intend to solve the multigroup diffusion approximation of the neutron transport equation. Essentially, the way to view this is as follows: In a nuclear reactor, neutrons are speeding around at different energies, get absorbed or scattered, or start a new fission event. If viewed at long enough length scales, the movement of neutrons can be considered a diffusion process.</p>
<p>A mathematical description of this would group neutrons into energy bins, and consider the balance equations for the neutron fluxes in each of these bins, or energy groups. The scattering, absorption, and fission events would then be operators within the diffusion equation describing the neutron fluxes. Assume we have energy groups <img class="formulaInl" alt="$g=1,\ldots,G$" src="form_2299.png"/>, where by convention we assume that the neutrons with the highest energy are in group 1 and those with the lowest energy in group <img class="formulaInl" alt="$G$" src="form_2300.png"/>. Then the neutron flux of each group satisfies the following equations: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac 1{v_g}\frac{\partial \phi_g(x,t)}{\partial t} &amp;=&amp; \nabla \cdot(D_g(x) \nabla \phi_g(x,t)) - \Sigma_{r,g}(x)\phi_g(x,t) \\ &amp;&amp; \qquad + \chi_g\sum_{g'=1}^G\nu\Sigma_{f,g'}(x)\phi_{g'}(x,t) + \sum_{g'\ne g}\Sigma_{s,g'\to g}(x)\phi_{g'}(x,t) + s_{\mathrm{ext},g}(x,t) \end{eqnarray*}" src="form_2301.png"/>
</p>
<p> augmented by appropriate boundary conditions. Here, <img class="formulaInl" alt="$v_g$" src="form_2302.png"/> is the velocity of neutrons within group <img class="formulaInl" alt="$g$" src="form_36.png"/>. In other words, the change in time in flux of neutrons in group <img class="formulaInl" alt="$g$" src="form_36.png"/> is governed by the following processes: </p><ul>
<li>
Diffusion <img class="formulaInl" alt="$\nabla \cdot(D_g(x) \nabla \phi_g(x,t))$" src="form_2303.png"/>. Here, <img class="formulaInl" alt="$D_g$" src="form_2304.png"/> is the (spatially variable) diffusion coefficient. </li>
<li>
Absorption <img class="formulaInl" alt="$\Sigma_{r,g}(x)\phi_g(x,t)$" src="form_2305.png"/> (note the negative sign). The coefficient <img class="formulaInl" alt="$\Sigma_{r,g}$" src="form_2306.png"/> is called the <em>removal cross section</em>. </li>
<li>
Nuclear fission <img class="formulaInl" alt="$\chi_g\sum_{g'=1}^G\nu\Sigma_{f,g'}(x)\phi_{g'}(x,t)$" src="form_2307.png"/>. The production of neutrons of energy <img class="formulaInl" alt="$g$" src="form_36.png"/> is proportional to the flux of neutrons of energy <img class="formulaInl" alt="$g'$" src="form_2308.png"/> times the probability <img class="formulaInl" alt="$\Sigma_{f,g'}$" src="form_2309.png"/> that neutrons of energy <img class="formulaInl" alt="$g'$" src="form_2308.png"/> cause a fission event times the number <img class="formulaInl" alt="$\nu$" src="form_1655.png"/> of neutrons produced in each fission event times the probability that a neutron produced in this event has energy <img class="formulaInl" alt="$g$" src="form_36.png"/>. <img class="formulaInl" alt="$\nu\Sigma_{f,g'}$" src="form_2310.png"/> is called the <em>fission cross section</em> and <img class="formulaInl" alt="$\chi_g$" src="form_2311.png"/> the <em>fission spectrum</em>. We will denote the term <img class="formulaInl" alt="$\chi_g\nu\Sigma_{f,g'}$" src="form_2312.png"/> as the <em>fission distribution cross section</em> in the program. </li>
<li>
Scattering <img class="formulaInl" alt="$\sum_{g'\ne g}\Sigma_{s,g'\to g}(x)\phi_{g'}(x,t)$" src="form_2313.png"/> of neutrons of energy <img class="formulaInl" alt="$g'$" src="form_2308.png"/> producing neutrons of energy <img class="formulaInl" alt="$g$" src="form_36.png"/>. <img class="formulaInl" alt="$\Sigma_{s,g'\to g}$" src="form_2314.png"/> is called the <em>scattering cross section</em>. The case of elastic, in-group scattering <img class="formulaInl" alt="$g'=g$" src="form_2315.png"/> exists, too, but we subsume this into the removal cross section. The case <img class="formulaInl" alt="$g'&lt;g$" src="form_2316.png"/> is called down-scattering, since a neutron loses energy in such an event. On the other hand, <img class="formulaInl" alt="$g'&gt;g$" src="form_2317.png"/> corresponds to up-scattering: a neutron gains energy in a scattering event from the thermal motion of the atoms surrounding it; up-scattering is therefore only an important process for neutrons with kinetic energies that are already on the same order as the thermal kinetic energy (i.e. in the sub <img class="formulaInl" alt="$eV$" src="form_2318.png"/> range). </li>
<li>
An extraneous source <img class="formulaInl" alt="$s_{\mathrm{ext},g}$" src="form_2319.png"/>. </li>
</ul>
<p>For realistic simulations in reactor analysis, one may want to split the continuous spectrum of neutron energies into many energy groups, often up to</p><ol type="1">
<li>However, if neutron energy spectra are known well enough for some type of reactor (for example Pressurized Water Reactors, PWR), it is possible to obtain satisfactory results with only 2 energy groups.</li>
</ol>
<p>In the program shown in this tutorial program, we provide the structure to compute with as many energy groups as desired. However, to keep computing times moderate and in order to avoid tabulating hundreds of coefficients, we only provide the coefficients for above equations for a two-group simulation, i.e. <img class="formulaInl" alt="$g=1,2$" src="form_2320.png"/>. We do, however, consider a realistic situation by assuming that the coefficients are not constant, but rather depend on the materials that are assembled into reactor fuel assemblies in rather complicated ways (see below).</p>
<p><a class="anchor" id="Theeigenvalueproblem"></a></p><h3>The eigenvalue problem</h3>
<p>If we consider all energy groups at once, we may write above equations in the following operator form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac 1v \frac{\partial \phi}{\partial t} = -L\phi + F\phi + X\phi + s_{\mathrm{ext}}, \end{eqnarray*}" src="form_2321.png"/>
</p>
<p> where <img class="formulaInl" alt="$L,F,X$" src="form_2322.png"/> are sinking, fission, and scattering operators, respectively. <img class="formulaInl" alt="$L$" src="form_2323.png"/> here includes both the diffusion and removal terms. Note that <img class="formulaInl" alt="$L$" src="form_2323.png"/> is symmetric, whereas <img class="formulaInl" alt="$F$" src="form_249.png"/> and <img class="formulaInl" alt="$X$" src="form_711.png"/> are not.</p>
<p>It is well known that this equation admits a stable solution if all eigenvalues of the operator <img class="formulaInl" alt="$-L+F+X$" src="form_2324.png"/> are negative. This can be readily seen by multiplying the equation by <img class="formulaInl" alt="$\phi$" src="form_643.png"/> and integrating over the domain, leading to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac 1{2v} \frac{\partial}{\partial t} \|\phi\|^2 = ((-L+F+X)\phi,\phi). \end{eqnarray*}" src="form_2325.png"/>
</p>
<p> Stability means that the solution does not grow, i.e. we want the left hand side to be less than zero, which is the case if the eigenvalues of the operator on the right are all negative. For obvious reasons, it is not very desirable if a nuclear reactor produces neutron fluxes that grow exponentially, so eigenvalue analyses are the bread-and-butter of nuclear engineers. The main point of the program is therefore to consider the eigenvalue problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (L-F-X) \phi = \lambda \phi, \end{eqnarray*}" src="form_2326.png"/>
</p>
<p> where we want to make sure that all eigenvalues are positive. Note that <img class="formulaInl" alt="$L$" src="form_2323.png"/>, being the diffusion operator plus the absorption (removal), is positive definite; the condition that all eigenvalues are positive therefore means that we want to make sure that fission and inter-group scattering are weak enough to not shift the spectrum into the negative.</p>
<p>In nuclear engineering, one typically looks at a slightly different formulation of the eigenvalue problem. To this end, we do not just multiply with <img class="formulaInl" alt="$\phi$" src="form_643.png"/> and integrate, but rather multiply with <img class="formulaInl" alt="$\phi(L-X)^{-1}$" src="form_2327.png"/>. We then get the following evolution equation: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac 1{2v} \frac{\partial}{\partial t} \|\phi\|^2_{(L-X)^{-1}} = ((L-X)^{-1}(-L+F+X)\phi,\phi). \end{eqnarray*}" src="form_2328.png"/>
</p>
<p> Stability is then guaranteed if the eigenvalues of the following problem are all negative: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (L-X)^{-1}(-L+F+X)\phi = \lambda_F \phi, \end{eqnarray*}" src="form_2329.png"/>
</p>
<p> which is equivalent to the eigenvalue problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (L-X)\phi = \frac 1{\lambda_F+1} F \phi. \end{eqnarray*}" src="form_2330.png"/>
</p>
<p> The typical formulation in nuclear engineering is to write this as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (L-X) \phi = \frac 1{k_{\mathrm{eff}}} F \phi, \end{eqnarray*}" src="form_2331.png"/>
</p>
<p> where <img class="formulaInl" alt="$k_{\mathrm{eff}}=\frac 1{\lambda^F+1}$" src="form_2332.png"/>. Intuitively, <img class="formulaInl" alt="$k_{\mathrm{eff}}$" src="form_2333.png"/> is something like the multiplication factor for neutrons per typical time scale and should be less than or equal to one for stable operation of a reactor: if it is less than one, the chain reaction will die down, whereas nuclear bombs for example have a <img class="formulaInl" alt="$k$" src="form_44.png"/>-eigenvalue larger than one. A stable reactor should have <img class="formulaInl" alt="$k_{\mathrm{eff}}=1$" src="form_2334.png"/>.</p>
<p>[For those who wonder how this can be achieved in practice without inadvertently getting slightly larger than one and triggering a nuclear bomb: first, fission processes happen on different time scales. While most neutrons are released very quickly after a fission event, a small number of neutrons are only released by daughter nuclei after several further decays, up to 10-60 seconds after the fission was initiated. If one is therefore slightly beyond <img class="formulaInl" alt="$k_{\mathrm{eff}}=1$" src="form_2334.png"/>, one therefore has many seconds to react until all the neutrons created in fission re-enter the fission cycle. Nevertheless, control rods in nuclear reactors absorbing neutrons &ndash; and therefore reducing <img class="formulaInl" alt="$k_{\mathrm{eff}}$" src="form_2333.png"/> &ndash; are designed in such a way that they are all the way in the reactor in at most 2 seconds.</p>
<p>One therefore has on the order of 10-60 seconds to regulate the nuclear reaction if <img class="formulaInl" alt="$k_{\mathrm{eff}}$" src="form_2333.png"/> should be larger than one for some time, as indicated by a growing neutron flux. Regulation can be achieved by continuously monitoring the neutron flux, and if necessary increase or reduce neutron flux by moving neutron-absorbing control rods a few millimeters into or out of the reactor. On a longer scale, the water cooling the reactor contains boron, a good neutron absorber. Every few hours, boron concentrations are adjusted by adding boron or diluting the coolant.</p>
<p>Finally, some of the absorption and scattering reactions have some stability built in; for example, higher neutron fluxes result in locally higher temperatures, which lowers the density of water and therefore reduces the number of scatterers that are necessary to moderate neutrons from high to low energies before they can start fission events themselves.]</p>
<p>In this tutorial program, we solve above <img class="formulaInl" alt="$k$" src="form_44.png"/>-eigenvalue problem for two energy groups, and we are looking for the largest multiplication factor <img class="formulaInl" alt="$k_{\mathrm{eff}}$" src="form_2333.png"/>, which is proportional to the inverse of the minimum eigenvalue plus one. To solve the eigenvalue problem, we generally use a modified version of the <em>inverse power method</em>. The algorithm looks like this:</p>
<ol>
<li>
<p class="startli">Initialize <img class="formulaInl" alt="$\phi_g$" src="form_2335.png"/> and <img class="formulaInl" alt="$k_{\mathrm{eff}}$" src="form_2333.png"/> with <img class="formulaInl" alt="$\phi_g^{(0)}$" src="form_2336.png"/> and <img class="formulaInl" alt="$k_{\mathrm{eff}}^{(0)}$" src="form_2337.png"/> and let <img class="formulaInl" alt="$n=1$" src="form_2338.png"/>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Define the so-called <em>fission source</em> by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} s_f^{(n-1)}(x) = \frac{1}{k_{\mathrm{eff}}^{(n-1)}} \sum_{g'=1}^G\nu\Sigma_{f,g'}(x)\phi_{g'}^{(n-1)}(x). \end{eqnarray*}" src="form_2339.png"/>
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Solve for all group fluxes <img class="formulaInl" alt="$\phi_g,g=1,\ldots,G$" src="form_2340.png"/> using </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot D_g\nabla \phi_g^{(n)} + \Sigma_{r,g}\phi_g^{(n)} = \chi_g s_f^{(n-1)} + \sum_{g'&lt; g} \Sigma_{s,g'\to g} \phi_{g'}^{(n)} + \sum_{g'&gt; g}\Sigma_{s,g'\to g}\phi_{g'}^{(n-1)}. \end{eqnarray*}" src="form_2341.png"/>
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Update </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} k_{\mathrm{eff}}^{(n)} = \sum_{g'=1}^G \int_{\Omega}\nu\Sigma_{f,g'}(x) \phi_{g'}^{(n)}(x)dx. \end{eqnarray*}" src="form_2342.png"/>
</p>
<p class="endli"></p>
</li>
<li>
Compare <img class="formulaInl" alt="$k_{\mathrm{eff}}^{(n)}$" src="form_2343.png"/> with <img class="formulaInl" alt="$k_{\mathrm{eff}}^{(n-1)}$" src="form_2344.png"/>. If the change greater than a prescribed tolerance then set <img class="formulaInl" alt="$n=n+1$" src="form_2345.png"/> repeat the iteration starting at step 2, otherwise end the iteration. </li>
</ol>
<p>Note that in this scheme, we do not solve group fluxes exactly in each power iteration, but rather consider previously compute <img class="formulaInl" alt="$\phi_{g'}^{(n)}$" src="form_2346.png"/> only for down-scattering events <img class="formulaInl" alt="$g'&lt;g$" src="form_2316.png"/>. Up-scattering is only treated by using old iterators <img class="formulaInl" alt="$\phi_{g'}^{(n-1)}$" src="form_2347.png"/>, in essence assuming that the scattering operator is triangular. This is physically motivated since up-scattering does not play a too important role in neutron scattering. In addition, practices shows that the inverse power iteration is stable even using this simplification.</p>
<p>Note also that one can use lots of extrapolation techniques to accelerate the power iteration laid out above. However, none of these are implemented in this example.</p>
<p><a class="anchor" id="Meshesandmeshrefinement"></a></p><h3>Meshes and mesh refinement</h3>
<p>One may wonder whether it is appropriate to solve for the solutions of the individual energy group equations on the same meshes. The question boils down to this: will <img class="formulaInl" alt="$\phi_g$" src="form_2335.png"/> and <img class="formulaInl" alt="$\phi_{g'}$" src="form_2348.png"/> have similar smoothness properties? If this is the case, then it is appropriate to use the same mesh for the two; a typical application could be chemical combustion, where typically the concentrations of all or most chemical species change rapidly within the flame front. As it turns out, and as will be apparent by looking at the graphs shown in the results section of this tutorial program, this isn't the case here, however: since the diffusion coefficient is different for different energy groups, fast neutrons (in bins with a small group number <img class="formulaInl" alt="$g$" src="form_36.png"/>) have a very smooth flux function, whereas slow neutrons (in bins with a large group number) are much more affected by the local material properties and have a correspondingly rough solution if the coefficient are rough as in the case we compute here. Consequently, we will want to use different meshes to compute each energy group.</p>
<p>This has two implications that we will have to consider: First, we need to find a way to refine the meshes individually. Second, assembling the source terms for the inverse power iteration, where we have to integrate solution <img class="formulaInl" alt="$\phi_{g'}^{(n)}$" src="form_2346.png"/> defined on mesh <img class="formulaInl" alt="$g'$" src="form_2308.png"/> against the shape functions defined on mesh <img class="formulaInl" alt="$g$" src="form_36.png"/>, becomes a much more complicated task.</p>
<p><a class="anchor" id="Meshrefinement"></a></p><h4>Mesh refinement</h4>
<p>We use the usual paradigm: solve on a given mesh, then evaluate an error indicator for each cell of each mesh we have. Because it is so convenient, we again use the a posteriori error estimator by Kelly, Gago, Zienkiewicz and Babuska which approximates the error per cell by integrating the jump of the gradient of the solution along the faces of each cell. Using this, we obtain indicators </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \eta_{g,K}, \qquad g=1,2,\ldots,G,\qquad K\in{\cal T}_g, \end{eqnarray*}" src="form_2349.png"/>
</p>
<p> where <img class="formulaInl" alt="${\cal T}_g$" src="form_2350.png"/> is the triangulation used in the solution of <img class="formulaInl" alt="$\phi_g$" src="form_2335.png"/>. The question is what to do with this. For one, it is clear that refining only those cells with the highest error indicators might lead to bad results. To understand this, it is important to realize that <img class="formulaInl" alt="$\eta_{g,K}$" src="form_2351.png"/> scales with the second derivative of <img class="formulaInl" alt="$\phi_g$" src="form_2335.png"/>. In other words, if we have two energy groups <img class="formulaInl" alt="$g=1,2$" src="form_2320.png"/> whose solutions are equally smooth but where one is larger by a factor of 10,000, for example, then only the cells of that mesh will be refined, whereas the mesh for the solution of small magnitude will remain coarse. This is probably not what one wants, since we can consider both components of the solution equally important.</p>
<p>In essence, we would therefore have to scale <img class="formulaInl" alt="$\eta_{g,K}$" src="form_2351.png"/> by an importance factor <img class="formulaInl" alt="$z_g$" src="form_2352.png"/> that says how important it is to resolve <img class="formulaInl" alt="$\phi_g$" src="form_2335.png"/> to any given accuracy. Such important factors can be computed using duality techniques (see, for example, the <a class="el" href="step_14.html">step-14</a> tutorial program, and the reference to the book by Bangerth and Rannacher cited there). We won't go there, however, and simply assume that all energy groups are equally important, and will therefore normalize the error indicators <img class="formulaInl" alt="$\eta_{g,K}$" src="form_2351.png"/> for group <img class="formulaInl" alt="$g$" src="form_36.png"/> by the maximum of the solution <img class="formulaInl" alt="$\phi_g$" src="form_2335.png"/>. We then refine the cells whose errors satisfy </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{\eta_{g,K}}{\|\phi_g\|_\infty} &gt; \alpha_1 \displaystyle{\max_{\begin{matrix}1\le g\le G \\ K\in {\cal T}_g\end{matrix}} \frac{\eta_{g,K}}{\|\phi_g\|_\infty}} \end{eqnarray*}" src="form_2353.png"/>
</p>
<p> and coarsen the cells where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{\eta_{g,K}}{\|\phi_g\|_\infty} &lt; \alpha_2 \displaystyle{\max_{\begin{matrix}1\le g\le G \\ K\in {\cal T}_g\end{matrix}} \frac{\eta_{g,K}}{\|\phi_g\|_\infty}}. \end{eqnarray*}" src="form_2354.png"/>
</p>
<p> We chose <img class="formulaInl" alt="$\alpha_1=0.3$" src="form_2355.png"/> and <img class="formulaInl" alt="$\alpha_2=0.01$" src="form_2356.png"/> in the code. Note that this will, of course, lead to different meshes for the different energy groups.</p>
<p>The strategy above essentially means the following: If for energy group <img class="formulaInl" alt="$g$" src="form_36.png"/> there are many cells <img class="formulaInl" alt="$K\in {\cal T}_g$" src="form_2357.png"/> on which the error is large, for example because the solution is globally very rough, then many cells will be above the threshold. On the other hand, if there are a few cells with large and many with small errors, for example because the solution is overall rather smooth except at a few places, then only the few cells with large errors will be refined. Consequently, the strategy allows for meshes that track the global smoothness properties of the corresponding solutions rather well.</p>
<p><a class="anchor" id="Assemblingtermsondifferentmeshes"></a></p><h4>Assembling terms on different meshes</h4>
<p>As pointed out above, the multigroup refinement strategy results in different meshes for the different solutions <img class="formulaInl" alt="$\phi_g$" src="form_2335.png"/>. So what's the problem? In essence it goes like this: in step 3 of the eigenvalue iteration, we have form the weak form for the equation to compute <img class="formulaInl" alt="$\phi_g^{(n)}$" src="form_2358.png"/> as usual by multiplication with test functions <img class="formulaInl" alt="$\varphi_g^i$" src="form_2359.png"/> defined on the mesh for energy group <img class="formulaInl" alt="$g$" src="form_36.png"/>; in the process, we have to compute the right hand side vector that contains terms of the following form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i = \int_\Omega f(x) \varphi_g^i(x) \phi_{g'}(x) \ dx, \end{eqnarray*}" src="form_2360.png"/>
</p>
<p> where <img class="formulaInl" alt="$f(x)$" src="form_418.png"/> is one of the coefficient functions <img class="formulaInl" alt="$\Sigma_{s,g'\to g}$" src="form_2314.png"/> or <img class="formulaInl" alt="$\nu\chi_g\Sigma_{f,g'}$" src="form_2361.png"/> used in the right hand side of eigenvalue equation. The difficulty now is that <img class="formulaInl" alt="$\phi_{g'}$" src="form_2348.png"/> is defined on the mesh for energy group <img class="formulaInl" alt="$g'$" src="form_2308.png"/>, i.e. it can be expanded as <img class="formulaInl" alt="$\phi_{g'}(x)=\sum_j\phi_{g'}^j \varphi_{g'}^j(x)$" src="form_2362.png"/>, with basis functions <img class="formulaInl" alt="$\varphi_{g'}^j(x)$" src="form_2363.png"/> defined on mesh <img class="formulaInl" alt="$g'$" src="form_2308.png"/>. The contribution to the right hand side can therefore be written as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i = \sum_j \left\{\int_\Omega f(x) \varphi_g^i(x) \varphi_{g'}^j(x) \ dx \right\} \phi_{g'}^j , \end{eqnarray*}" src="form_2364.png"/>
</p>
<p> On the other hand, the test functions <img class="formulaInl" alt="$\varphi_g^i(x)$" src="form_2365.png"/> are defined on mesh <img class="formulaInl" alt="$g$" src="form_36.png"/>. This means that we can't just split the integral <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> into integrals over the cells of either mesh <img class="formulaInl" alt="$g$" src="form_36.png"/> or <img class="formulaInl" alt="$g'$" src="form_2308.png"/>, since the respectively other basis functions may not be defined on these cells.</p>
<p>The solution to this problem lies in the fact that both the meshes for <img class="formulaInl" alt="$g$" src="form_36.png"/> and <img class="formulaInl" alt="$g'$" src="form_2308.png"/> are derived by adaptive refinement from a common coarse mesh. We can therefore always find a set of cells, which we denote by <img class="formulaInl" alt="${\cal T}_g \cap {\cal T}_{g'}$" src="form_2366.png"/>, that satisfy the following conditions: </p><ul>
<li>
the union of the cells covers the entire domain, and </li>
<li>
a cell <img class="formulaInl" alt="$K \in {\cal T}_g \cap {\cal T}_{g'}$" src="form_2367.png"/> is active on at least one of the two meshes. </li>
</ul>
<p>A way to construct this set is to take each cell of coarse mesh and do the following steps: (i) if the cell is active on either <img class="formulaInl" alt="${\cal T}_g$" src="form_2350.png"/> or <img class="formulaInl" alt="${\cal T}_{g'}$" src="form_2368.png"/>, then add this cell to the set; (ii) otherwise, i.e. if this cell has children on both meshes, then do step (i) for each of the children of this cell. In fact, deal.II has a function <a class="el" href="namespaceGridTools.html#a32a5016c746ad756046ecff264dfa60d">GridTools::get_finest_common_cells</a> that computes exactly this set of cells that are active on at least one of two meshes.</p>
<p>With this, we can write above integral as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i = \sum_{K \in {\cal T}_g \cap {\cal T}_{g'}} \sum_j \left\{\int_K f(x) \varphi_g^i(x) \varphi_{g'}^j(x) \ dx \right\} \phi_{g'}^j. \end{eqnarray*}" src="form_2369.png"/>
</p>
<p> In the code, we compute the right hand side in the function <code>NeutronDiffusionProblem::assemble_rhs</code>, where (among other things) we loop over the set of common most refined cells, calling the function <code>NeutronDiffusionProblem::assemble_common_cell</code> on each pair of these cells.</p>
<p>By construction, there are now three cases to be considered: </p><ol>
<li>
The cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is active on both meshes, i.e. both the basis functions <img class="formulaInl" alt="$\varphi_g^i$" src="form_2359.png"/> as well as <img class="formulaInl" alt="$\varphi_{g'}^j$" src="form_2370.png"/> are defined on <img class="formulaInl" alt="$K$" src="form_57.png"/>. </li>
<li>
The cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is active on mesh <img class="formulaInl" alt="$g$" src="form_36.png"/>, but not <img class="formulaInl" alt="$g'$" src="form_2308.png"/>, i.e. the <img class="formulaInl" alt="$\varphi_g^i$" src="form_2359.png"/> are defined on <img class="formulaInl" alt="$K$" src="form_57.png"/>, whereas the <img class="formulaInl" alt="$\varphi_{g'}^j$" src="form_2370.png"/> are defined on children of <img class="formulaInl" alt="$K$" src="form_57.png"/>. </li>
<li>
The cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is active on mesh <img class="formulaInl" alt="$g'$" src="form_2308.png"/>, but not <img class="formulaInl" alt="$g$" src="form_36.png"/>, with opposite conclusions than in (ii). </li>
</ol>
<p>To compute the right hand side above, we then need to have different code for these three cases, as follows: </p><ol>
<li>
<p class="startli">If the cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is active on both meshes, then we can directly evaluate the integral. In fact, we don't even have to bother with the basis functions <img class="formulaInl" alt="$\varphi_{g'}$" src="form_2371.png"/>, since all we need is the values of <img class="formulaInl" alt="$\phi_{g'}$" src="form_2348.png"/> at the quadrature points. We can do this using the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> function. This is done directly in the <code>NeutronDiffusionProblem::assemble_common_cell</code> function.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is active on mesh <img class="formulaInl" alt="$g$" src="form_36.png"/>, but not <img class="formulaInl" alt="$g'$" src="form_2308.png"/>, then the basis functions <img class="formulaInl" alt="$\varphi_{g'}^j$" src="form_2370.png"/> are only defined either on the children <img class="formulaInl" alt="$K_c,0\le c&lt;2^{\texttt{dim}}$" src="form_2372.png"/>, or on children of these children if cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is refined more than once on mesh <img class="formulaInl" alt="$g'$" src="form_2308.png"/>.</p>
<p>Let us assume for a second that <img class="formulaInl" alt="$K$" src="form_57.png"/> is only once more refined on mesh <img class="formulaInl" alt="$g'$" src="form_2308.png"/> than on mesh <img class="formulaInl" alt="$g$" src="form_36.png"/>. Using the fact that we use embedded finite element spaces where each basis function on one mesh can be written as a linear combination of basis functions on the next refined mesh, we can expand the restriction of <img class="formulaInl" alt="$\phi_g^i$" src="form_2373.png"/> to child cell <img class="formulaInl" alt="$K_c$" src="form_2374.png"/> into the basis functions defined on that child cell (i.e. on cells on which the basis functions <img class="formulaInl" alt="$\varphi_{g'}^l$" src="form_2375.png"/> are defined): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \phi_g^i|_{K_c} = B_c^{il} \varphi_{g'}^l|_{K_c}. \end{eqnarray*}" src="form_2376.png"/>
</p>
<p> Here, and in the following, summation over indices appearing twice is implied. The matrix <img class="formulaInl" alt="$B_c$" src="form_2377.png"/> is the matrix that interpolated data from a cell to its <img class="formulaInl" alt="$c$" src="form_257.png"/>-th child.</p>
<p>Then we can write the contribution of cell <img class="formulaInl" alt="$K$" src="form_57.png"/> to the right hand side component <img class="formulaInl" alt="$F_i$" src="form_2378.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_K &amp;=&amp; \left\{ \int_K f(x) \varphi_g^i(x) \varphi_{g'}^j(x) \ dx \right\} \phi_{g'}^j \\ &amp;=&amp; \left\{ \sum_{0\le c&lt;2^{\texttt{dim}}} B_c^{il} \int_{K_c} f(x) \varphi_{g'}^l(x) \varphi_{g'}^j(x) \ dx \right\} \phi_{g'}^j. \end{eqnarray*}" src="form_2379.png"/>
</p>
<p> In matrix notation, this can be written as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_K = \sum_{0\le c&lt;2^{\texttt{dim}}} F_i|_{K_c}, \qquad \qquad F_i|_{K_c} = B_c^{il} M_{K_c}^{lj} \phi_{g'}^j = (B_c M_{K_c})^{ij} \phi_{g'}^j, \end{eqnarray*}" src="form_2380.png"/>
</p>
<p> where <img class="formulaInl" alt="$M_{K_c}^{lj}=\int_{K_c} f(x) \varphi_{g'}^l(x) \varphi_{g'}^j(x)$" src="form_2381.png"/> is the weighted mass matrix on child <img class="formulaInl" alt="$c$" src="form_257.png"/> of cell <img class="formulaInl" alt="$K$" src="form_57.png"/>.</p>
<p>The next question is what happens if a child <img class="formulaInl" alt="$K_c$" src="form_2374.png"/> of <img class="formulaInl" alt="$K$" src="form_57.png"/> is not active. Then, we have to apply the process recursively, i.e. we have to interpolate the basis functions <img class="formulaInl" alt="$\varphi_g^i$" src="form_2359.png"/> onto child <img class="formulaInl" alt="$K_c$" src="form_2374.png"/> of <img class="formulaInl" alt="$K$" src="form_57.png"/>, then onto child <img class="formulaInl" alt="$K_{cc'}$" src="form_2382.png"/> of that cell, onto child <img class="formulaInl" alt="$K_{cc'c''}$" src="form_2383.png"/> of that one, etc, until we find an active cell. We then have to sum up all the contributions from all the children, grandchildren, etc, of cell <img class="formulaInl" alt="$K$" src="form_57.png"/>, with contributions of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_{K_{cc'}} = (B_cB_{c'} M_{K_{cc'}})^{ij} \phi_{g'}^j, \end{eqnarray*}" src="form_2384.png"/>
</p>
<p> or </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_{K_{cc'c''}} = (B_c B_{c'} B_{c''}M_{K_{cc'c''}})^{ij} \phi_{g'}^j, \end{eqnarray*}" src="form_2385.png"/>
</p>
<p> etc. We do this process recursively, i.e. if we sit on cell <img class="formulaInl" alt="$K$" src="form_57.png"/> and see that it has children on grid <img class="formulaInl" alt="$g'$" src="form_2308.png"/>, then we call a function <code>assemble_case_2</code> with an identity matrix; the function will multiply it's argument from the left with the prolongation matrix; if the cell has further children, it will call itself with this new matrix, otherwise it will perform the integration.</p>
<p class="endli"></p>
</li>
<li>
The last case is where <img class="formulaInl" alt="$K$" src="form_57.png"/> is active on mesh <img class="formulaInl" alt="$g'$" src="form_2308.png"/> but not mesh <img class="formulaInl" alt="$g$" src="form_36.png"/>. In that case, we have to express basis function <img class="formulaInl" alt="$\varphi_{g'}^j$" src="form_2370.png"/> in terms of the basis functions defined on the children of cell <img class="formulaInl" alt="$K$" src="form_57.png"/>, rather than <img class="formulaInl" alt="$\varphi_g^i$" src="form_2359.png"/> as before. This of course works in exactly the same way. If the children of <img class="formulaInl" alt="$K$" src="form_57.png"/> are active on mesh <img class="formulaInl" alt="$g$" src="form_36.png"/>, then leading to the expression <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_K &amp;=&amp; \left\{ \int_K f(x) \varphi_g^i(x) \varphi_{g'}^j(x) \ dx \right\} \phi_{g'}^j \\ &amp;=&amp; \left\{ \sum_{0\le c&lt;2^{\texttt{dim}}} \int_{K_c} f(x) \varphi_g^i(x) B_c^{jl} \varphi_{g}^l(x) \ dx \right\} \phi_{g'}^j. \end{eqnarray*}" src="form_2386.png"/>
</p>
 In matrix notation, this expression now reads as <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_K = \sum_{0\le c&lt;2^{\texttt{dim}}} F_i|_{K_c}, \qquad \qquad F_i|_{K_c} = M_{K_c}^{il} B_c^{jl} \phi_{g'}^j = (M_{K_c} B_c^T)^{ij} \phi_{g'}^j, \end{eqnarray*}" src="form_2387.png"/>
</p>
 and correspondingly for cases where cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is refined more than once on mesh <img class="formulaInl" alt="$g$" src="form_36.png"/>: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_{K_{cc'}} = (M_{K_{cc'}} B_{c'}^T B_c^T)^{ij} \phi_{g'}^j, \end{eqnarray*}" src="form_2388.png"/>
</p>
 or <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_{K_{cc'c''}} = (M_{K_{cc'c''}} B_{c''}^T B_{c'}^T B_c^T)^{ij} \phi_{g'}^j, \end{eqnarray*}" src="form_2389.png"/>
</p>
 etc. In other words, the process works in exactly the same way as before, except that we have to take the transpose of the prolongation matrices and need to multiply it to the mass matrix from the other side. </li>
</ol>
<p>The expressions for cases (ii) and (iii) can be understood as repeatedly interpolating either the left or right basis functions in the scalar product <img class="formulaInl" alt="$(f \varphi_g^i, \varphi_{g'}^j)_K$" src="form_2390.png"/> onto child cells, and then finally forming the inner product (the mass matrix) on the final cell. To make the symmetry in these cases more obvious, we can write them like this: for case (ii), we have </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_{K_{cc'\cdots c^{(k)}}} = [B_c B_{c'} \cdots B_{c^{(k)}} M_{K_{cc'\cdots c^{(k)}}}]^{ij} \phi_{g'}^j, \end{eqnarray*}" src="form_2391.png"/>
</p>
<p> whereas for case (iii) we get </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F_i|_{K_{cc'\cdots c^{(k)}}} = [(B_c B_{c'} \cdots B_{c^{(k)}} M_{K_{cc'\cdots c^{(k)}}})^T]^{ij} \phi_{g'}^j, \end{eqnarray*}" src="form_2392.png"/>
</p>
<p><a class="anchor" id="Descriptionofthetestcase"></a></p><h3>Description of the test case</h3>
<p>A nuclear reactor core is composed of different types of assemblies. An assembly is essentially the smallest unit that can be moved in and out of a reactor, and is usually rectangular or square. However, assemblies are not fixed units, as they are assembled from a complex lattice of different fuel rods, control rods, and instrumentation elements that are held in place relative to each other by spacers that are permanently attached to the rods. To make things more complicated, there are different kinds of assemblies that are used at the same time in a reactor, where assemblies differ in the type and arrangement of rods they are made up of.</p>
<p>Obviously, the arrangement of assemblies as well as the arrangement of rods inside them affect the distribution of neutron fluxes in the reactor (a fact that will be obvious by looking at the solution shown below in the results sections of this program). Fuel rods, for example, differ from each other in the enrichment of U-235 or Pu-239. Control rods, on the other hand, have zero fission, but nonzero scattering and absorption cross sections.</p>
<p>This whole arrangement would make the description or spatially dependent material parameters very complicated. It will not become much simpler, but we will make one approximation: we merge the volume inhabited by each cylindrical rod and the surrounding water into volumes of quadratic cross section into so-called ``pin cells'' for which homogenized material data are obtained with nuclear database and knowledge of neutron spectrum. The homogenization makes all material data piecewise constant on the solution domain for a reactor with fresh fuel. Spatially dependent material parameters are then looked up for the quadratic assembly in which a point is located, and then for the quadratic pin cell within this assembly.</p>
<p>In this tutorial program, we simulate a quarter of a reactor consisting of <img class="formulaInl" alt="$4 \times 4$" src="form_1400.png"/> assemblies. We use symmetry (Neumann) boundary conditions to reduce the problem to one quarter of the domain, and consequently only simulate a <img class="formulaInl" alt="$2\times 2$" src="form_67.png"/> set of assemblies. Two of them will be UO <img class="formulaInl" alt="${}_2$" src="form_2393.png"/> fuel, the other two of them MOX fuel. Each of these assemblies consists of <img class="formulaInl" alt="$17\times 17$" src="form_2394.png"/> rods of different compositions. In total, we therefore create a <img class="formulaInl" alt="$34\times 34$" src="form_2395.png"/> lattice of rods. To make things simpler later on, we reflect this fact by creating a coarse mesh of <img class="formulaInl" alt="$34\times 34$" src="form_2395.png"/> cells (even though the domain is a square, for which we would usually use a single cell). In deal.II, each cell has a <code>material_id</code> which one may use to associated each cell with a particular number identifying the material from which this cell's volume is made of; we will use this material ID to identify which of the 8 different kinds of rods that are used in this testcase make up a particular cell. Note that upon mesh refinement, the children of a cell inherit the material ID, making it simple to track the material even after mesh refinement.</p>
<p>The arrangement of the rods will be clearly visible in the images shown in the results section. The cross sections for materials and for both energy groups are taken from a OECD/NEA benchmark problem. The detailed configuration and material data is given in the code.</p>
<p><a class="anchor" id="Whattheprogramdoesandhowitdoesthat"></a></p><h3>What the program does (and how it does that)</h3>
<p>As a coarse overview of what exactly the program does, here is the basic layout: starting on a coarse mesh that is the same for each energy group, we compute inverse eigenvalue iterations to compute the <img class="formulaInl" alt="$k$" src="form_44.png"/>-eigenvalue on a given set of meshes. We stop these iterations when the change in the eigenvalue drops below a certain tolerance, and then write out the meshes and solutions for each energy group for inspection by a graphics program. Because the meshes for the solutions are different, we have to generate a separate output file for each energy group, rather than being able to add all energy group solutions into the same file.</p>
<p>After this, we evaluate the error indicators as explained in one of the sections above for each of the meshes, and refine and coarsen the cells of each mesh independently. Since the eigenvalue iterations are fairly expensive, we don't want to start all over on the new mesh; rather, we use the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class to interpolate the solution on the previous mesh to the next one upon mesh refinement. A simple experiment will convince you that this is a lot cheaper than if we omitted this step. After doing so, we resume our eigenvalue iterations on the next set of meshes.</p>
<p>The program is controlled by a parameter file, using the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class already mentioned in the <a class="el" href="step_19.html">step-19</a> example program. We will show a parameter file in the results section of this tutorial. For the moment suffice it to say that it controls the polynomial degree of the finite elements used, the number of energy groups (even though all that is presently implemented are the coefficients for a 2-group problem), the tolerance where to stop the inverse eigenvalue iteration, and the number of refinement cycles we will do. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>We start with a bunch of include files that have already been explained in previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/thread_management.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div></div><!-- fragment --><p>We use the next include file to access block vectors which provide us a convenient way to manage solution and right hand side vectors of all energy groups:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div></div><!-- fragment --><p>This include file is for transferring solutions from one mesh to another different mesh. We use it when we are initializing solutions after each mesh iteration:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/solution_transfer.h&gt;</span></div></div><!-- fragment --><p>When integrating functions defined on one mesh against shape functions defined on a different mesh, we need a function <code>get_finest_common_cells</code> (as discussed in the introduction) which is defined in the following header file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div></div><!-- fragment --><p>We use a little utility class from boost to save the state of an output stream (see the <code>run</code> function below):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/io/ios_state.hpp&gt;</span></div></div><!-- fragment --><p>Here are two more C++ standard headers that we use to define list data types as well as to fine-tune the output we generate:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step28</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Materialdata"></a> </p><h3>Material data</h3>
<p>First up, we need to define a class that provides material data (including diffusion coefficients, removal cross sections, scattering cross sections, fission cross sections and fission spectra) to the main class.</p>
<p>The parameter to the constructor determines for how many energy groups we set up the relevant tables. At present, this program only includes data for 2 energy groups, but a more sophisticated program may be able to initialize the data structures for more groups as well, depending on how many energy groups are selected in the parameter file.</p>
<p>For each of the different coefficient types, there is one function that returns the value of this coefficient for a particular energy group (or combination of energy groups, as for the distribution cross section <img class="formulaInl" alt="$\chi_g\nu\Sigma_{f,g'}$" src="form_2312.png"/> or scattering cross section <img class="formulaInl" alt="$\Sigma_{s,g'\to g}$" src="form_2314.png"/>). In addition to the energy group or groups, these coefficients depend on the type of fuel or control rod, as explained in the introduction. The functions therefore take an additional parameter, <code>material_id</code>, that identifies the particular kind of rod. Within this program, we use <code>n_materials=8</code> different kinds of rods.</p>
<p>Except for the scattering cross section, each of the coefficients therefore can be represented as an entry in a two-dimensional array of floating point values indexed by the energy group number as well as the material ID. The <a class="el" href="classTable.html">Table</a> class template is the ideal way to store such data. Finally, the scattering coefficient depends on both two energy group indices and therefore needs to be stored in a three-dimensional array, for which we again use the <a class="el" href="classTable.html">Table</a> class, where this time the first template argument (denoting the dimensionality of the array) of course needs to be three:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MaterialData</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MaterialData (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_groups);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_diffusion_coefficient (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_removal_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_fission_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_fission_dist_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_scattering_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_fission_spectrum (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_groups;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_materials;</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> diffusion;</div><div class="line">  <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> sigma_r;</div><div class="line">  <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> nu_sigma_f;</div><div class="line">  <a class="code" href="classTable.html">Table&lt;3,double&gt;</a> sigma_s;</div><div class="line">  <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> chi;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the class is used to initialize all the material data arrays. It takes the number of energy groups as an argument (an throws an error if that value is not equal to two, since at presently only data for two energy groups is implemented; however, using this, the function remains flexible and extendable into the future). In the member initialization part at the beginning, it also resizes the arrays to their correct sizes.</p>
<p>At present, material data is stored for 8 different types of material. This, as well, may easily be extended in the future.</p>
<div class="fragment"><div class="line">MaterialData::MaterialData (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_groups)</div><div class="line">  :</div><div class="line">  n_groups (n_groups),</div><div class="line">  n_materials (8),</div><div class="line">  diffusion (n_materials, n_groups),</div><div class="line">  sigma_r (n_materials, n_groups),</div><div class="line">  nu_sigma_f (n_materials, n_groups),</div><div class="line">  sigma_s (n_materials, n_groups, n_groups),</div><div class="line">  chi (n_materials, n_groups)</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (this-&gt;n_groups)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> 2:</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m=0; m&lt;n_materials; ++m)</div><div class="line">        {</div><div class="line">          diffusion[m][0] = 1.2;</div><div class="line">          diffusion[m][1] = 0.4;</div><div class="line">          chi[m][0]       = 1.0;</div><div class="line">          chi[m][1]       = 0.0;</div><div class="line">          sigma_r[m][0]   = 0.03;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1=0; group_1&lt;n_groups; ++group_1)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2=0; group_2&lt;n_groups; ++ group_2)</div><div class="line">              sigma_s[m][group_1][group_2]   = 0.0;</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      diffusion[5][1]  = 0.2;</div><div class="line"></div><div class="line">      sigma_r[4][0]    = 0.026;</div><div class="line">      sigma_r[5][0]    = 0.051;</div><div class="line">      sigma_r[6][0]    = 0.026;</div><div class="line">      sigma_r[7][0]    = 0.050;</div><div class="line"></div><div class="line">      sigma_r[0][1]    = 0.100;</div><div class="line">      sigma_r[1][1]    = 0.200;</div><div class="line">      sigma_r[2][1]    = 0.250;</div><div class="line">      sigma_r[3][1]    = 0.300;</div><div class="line">      sigma_r[4][1]    = 0.020;</div><div class="line">      sigma_r[5][1]    = 0.040;</div><div class="line">      sigma_r[6][1]    = 0.020;</div><div class="line">      sigma_r[7][1]    = 0.800;</div><div class="line"></div><div class="line">      nu_sigma_f[0][0] = 0.0050;</div><div class="line">      nu_sigma_f[1][0] = 0.0075;</div><div class="line">      nu_sigma_f[2][0] = 0.0075;</div><div class="line">      nu_sigma_f[3][0] = 0.0075;</div><div class="line">      nu_sigma_f[4][0] = 0.000;</div><div class="line">      nu_sigma_f[5][0] = 0.000;</div><div class="line">      nu_sigma_f[6][0] = 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-7;</div><div class="line">      nu_sigma_f[7][0] = 0.00;</div><div class="line"></div><div class="line">      nu_sigma_f[0][1] = 0.125;</div><div class="line">      nu_sigma_f[1][1] = 0.300;</div><div class="line">      nu_sigma_f[2][1] = 0.375;</div><div class="line">      nu_sigma_f[3][1] = 0.450;</div><div class="line">      nu_sigma_f[4][1] = 0.000;</div><div class="line">      nu_sigma_f[5][1] = 0.000;</div><div class="line">      nu_sigma_f[6][1] = 3<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6;</div><div class="line">      nu_sigma_f[7][1] = 0.00;</div><div class="line"></div><div class="line">      sigma_s[0][0][1] = 0.020;</div><div class="line">      sigma_s[1][0][1] = 0.015;</div><div class="line">      sigma_s[2][0][1] = 0.015;</div><div class="line">      sigma_s[3][0][1] = 0.015;</div><div class="line">      sigma_s[4][0][1] = 0.025;</div><div class="line">      sigma_s[5][0][1] = 0.050;</div><div class="line">      sigma_s[6][0][1] = 0.025;</div><div class="line">      sigma_s[7][0][1] = 0.010;</div><div class="line"></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a> (<span class="stringliteral">&quot;Presently, only data for 2 groups is implemented&quot;</span>));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next are the functions that return the coefficient values for given materials and energy groups. All they do is to make sure that the given arguments are within the allowed ranges, and then look the respective value up in the corresponding tables:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span></div><div class="line">MaterialData::get_diffusion_coefficient (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group &lt; n_groups,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group, 0, n_groups));</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> diffusion[material_id][group];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span></div><div class="line">MaterialData::get_removal_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group &lt; n_groups,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group, 0, n_groups));</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> sigma_r[material_id][group];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span></div><div class="line">MaterialData::get_fission_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group &lt; n_groups,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group, 0, n_groups));</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> nu_sigma_f[material_id][group];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span></div><div class="line">MaterialData::get_scattering_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group_1 &lt; n_groups,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group_1, 0, n_groups));</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group_2 &lt; n_groups,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group_2, 0, n_groups));</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> sigma_s[material_id][group_1][group_2];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span></div><div class="line">MaterialData::get_fission_spectrum (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group &lt; n_groups,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group, 0, n_groups));</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> chi[material_id][group];</div><div class="line">}</div></div><!-- fragment --><p>The function computing the fission distribution cross section is slightly different, since it computes its value as the product of two other coefficients. We don't need to check arguments here, since this already happens when we call the two other functions involved, even though it would probably not hurt either:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span></div><div class="line">MaterialData::get_fission_dist_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (get_fission_spectrum(group_1, material_id) *</div><div class="line">          get_fission_XS(group_2, material_id));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeEnergyGroupcodeclass"></a> </p><h3>The <code>EnergyGroup</code> class</h3>
<p>The first interesting class is the one that contains everything that is specific to a single energy group. To group things that belong together into individual objects, we declare a structure that holds the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> objects for the mesh used for a single energy group, and a number of other objects and member functions that we will discuss in the following sections.</p>
<p>The main reason for this class is as follows: for both the forward problem (with a specified right hand side) as well as for the eigenvalue problem, one typically solves a sequence of problems for a single energy group each, rather than the fully coupled problem. This becomes understandable once one realizes that the system matrix for a single energy group is symmetric and positive definite (it is simply a diffusion operator), whereas the matrix for the fully coupled problem is generally nonsymmetric and not definite. It is also very large and quite full if more than a few energy groups are involved.</p>
<p>Let us first look at the equation to solve in the case of an external right hand side (for the time independent case): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot(D_g(x) \nabla \phi_g(x)) + \Sigma_{r,g}(x)\phi_g(x) = \chi_g\sum_{g'=1}^G\nu\Sigma_{f,g'}(x)\phi_{g'}(x) + \sum_{g'\ne g}\Sigma_{s,g'\to g}(x)\phi_{g'}(x) + s_{\mathrm{ext},g}(x) \end{eqnarray*}" src="form_2396.png"/>
</p>
<p>We would typically solve this equation by moving all the terms on the right hand side with <img class="formulaInl" alt="$g'=g$" src="form_2315.png"/> to the left hand side, and solving for <img class="formulaInl" alt="$\phi_g$" src="form_2335.png"/>. Of course, we don't know <img class="formulaInl" alt="$\phi_{g'}$" src="form_2348.png"/> yet, since the equations for those variables include right hand side terms involving <img class="formulaInl" alt="$\phi_g$" src="form_2335.png"/>. What one typically does in such situations is to iterate: compute </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot(D_g(x) \nabla \phi^{(n)}_g(x)) &amp;+&amp; \Sigma_{r,g}(x)\phi^{(n)}_g(x) \\ &amp;=&amp; \chi_g\sum_{g'=1}^{g-1}\nu\Sigma_{f,g'}(x)\phi^{(n)}_{g'}(x) + \chi_g\sum_{g'=g}^G\nu\Sigma_{f,g'}(x)\phi^{(n-1)}_{g'}(x) + \sum_{g'\ne g, g'&lt;g}\Sigma_{s,g'\to g}(x)\phi^{(n)}_{g'}(x) + \sum_{g'\ne g, g'&gt;g}\Sigma_{s,g'\to g}(x)\phi^{(n-1)}_{g'}(x) + s_{\mathrm{ext},g}(x) \end{eqnarray*}" src="form_2397.png"/>
</p>
<p>In other words, we solve the equation one by one, using values for <img class="formulaInl" alt="$\phi_{g'}$" src="form_2348.png"/> from the previous iteration <img class="formulaInl" alt="$n-1$" src="form_1950.png"/> if <img class="formulaInl" alt="$g'\ge g$" src="form_2398.png"/> and already computed values for <img class="formulaInl" alt="$\phi_{g'}$" src="form_2348.png"/> from the present iteration if <img class="formulaInl" alt="$g'&lt;g$" src="form_2316.png"/>.</p>
<p>When computing the eigenvalue, we do a very similar iteration, except that we have no external right hand side and that the solution is scaled after each iteration as explained in the introduction.</p>
<p>In either case, these two cases can be treated jointly if all we do is to equip the following class with these abilities: (i) form the left hand side matrix, (ii) form the in-group right hand side contribution, i.e. involving the extraneous source, and (iii) form that contribution to the right hand side that stems from group <img class="formulaInl" alt="$g'$" src="form_2308.png"/>. This class does exactly these tasks (as well as some book-keeping, such as mesh refinement, setting up matrices and vectors, etc). On the other hand, the class itself has no idea how many energy groups there are, and in particular how they interact, i.e. the decision of how the outer iteration looks (and consequently whether we solve an eigenvalue or a direct problem) is left to the NeutronDiffusionProblem class further down below in this program.</p>
<p>So let us go through the class and its interface:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>EnergyGroup</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --><p><a class="anchor" id="Publicmemberfunctions"></a> </p><h5>Public member functions</h5>
<p>The class has a good number of public member functions, since its the way it operates is controlled from the outside, and therefore all functions that do something significant need to be called from another class. Let's start off with book-keeping: the class obviously needs to know which energy group it represents, which material data to use, and from what coarse grid to start. The constructor takes this information and initializes the relevant member variables with that (see below).</p>
<p>Then we also need functions that set up the linear system, i.e. correctly size the matrix and its sparsity pattern, etc, given a finite element object to use. The <code>setup_linear_system</code> function does that. Finally, for this initial block, there are two functions that return the number of active cells and degrees of freedom used in this object &ndash; using this, we can make the triangulation and DoF handler member variables private, and do not have to grant external use to it, enhancing encapsulation:</p>
<div class="fragment"><div class="line">EnergyGroup (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        group,</div><div class="line">             <span class="keyword">const</span> MaterialData       &amp;material_data,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup_linear_system ();</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells () <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs () <span class="keyword">const</span>;</div></div><!-- fragment --><p>Then there are functions that assemble the linear system for each iteration and the present energy group. Note that the matrix is independent of the iteration number, so only has to be computed once for each refinement cycle. The situation is a bit more involved for the right hand side that has to be updated in each inverse power iteration, and that is further complicated by the fact that computing it may involve several different meshes as explained in the introduction. To make things more flexible with regard to solving the forward or the eigenvalue problem, we split the computation of the right hand side into a function that assembles the extraneous source and in-group contributions (which we will call with a zero function as source terms for the eigenvalue problem) and one that computes contributions to the right hand side from another energy group:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_system_matrix ();</div><div class="line"><span class="keywordtype">void</span> assemble_ingroup_rhs (<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;extraneous_source);</div><div class="line"><span class="keywordtype">void</span> assemble_cross_group_rhs (<span class="keyword">const</span> EnergyGroup&lt;dim&gt; &amp;g_prime);</div></div><!-- fragment --><p>Next we need a set of functions that actually compute the solution of a linear system, and do something with it (such as computing the fission source contribution mentioned in the introduction, writing graphical information to an output file, computing error indicators, or actually refining the grid based on these criteria and thresholds for refinement and coarsening). All these functions will later be called from the driver class <code>NeutronDiffusionProblem</code>, or any other class you may want to implement to solve a problem involving the neutron flux equations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>   solve ();</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_fission_source () <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span>   output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span>   estimate_errors (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span>   refine_grid (<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span>         refine_threshold,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span>         coarsen_threshold);</div></div><!-- fragment --><p><a class="anchor" id="Publicdatamembers"></a> </p><h5>Public data members</h5>
<p>As is good practice in object oriented programming, we hide most data members by making them private. However, we have to grant the class that drives the process access to the solution vector as well as the solution of the previous iteration, since in the power iteration, the solution vector is scaled in every iteration by the present guess of the eigenvalue we are looking for:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_old;</div></div><!-- fragment --><p><a class="anchor" id="Privatedatamembers"></a> </p><h5>Private data members</h5>
<p>The rest of the data members are private. Compared to all the previous tutorial programs, the only new data members are an integer storing which energy group this object represents, and a reference to the material data object that this object's constructor gets passed from the driver class. Likewise, the constructor gets a reference to the finite element object we are to use.</p>
<p>Finally, we have to apply boundary values to the linear system in each iteration, i.e. quite frequently. Rather than interpolating them every time, we interpolate them once on each new mesh and then store them along with all the other data of this class:</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            group;</div><div class="line">  <span class="keyword">const</span> MaterialData           &amp;material_data;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>            triangulation;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a>     &amp;fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>               dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>               sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>          system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                system_rhs;</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>              hanging_node_constraints;</div></div><!-- fragment --><p><a class="anchor" id="Privatememberfunctions"></a> </p><h5>Private member functions</h5>
<p>There is one private member function in this class. It recursively walks over cells of two meshes to compute the cross-group right hand side terms. The algorithm for this is explained in the introduction to this program. The arguments to this function are a reference to an object representing the energy group against which we want to integrate a right hand side term, an iterator to a cell of the mesh used for the present energy group, an iterator to a corresponding cell on the other mesh, and the matrix that interpolates the degrees of freedom from the coarser of the two cells to the finer one:</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  assemble_cross_group_rhs_recursive (<span class="keyword">const</span> EnergyGroup&lt;dim&gt;                        &amp;g_prime,</div><div class="line">                                      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell_g,</div><div class="line">                                      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell_g_prime,</div><div class="line">                                      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                       prolongation_matrix);</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeEnergyGroupcodeclass"></a> </p><h4>Implementation of the <code>EnergyGroup</code> class</h4>
<p>The first few functions of this class are mostly self-explanatory. The constructor only sets a few data members and creates a copy of the given triangulation as the base for the triangulation used for this energy group. The next two functions simply return data from private data members, thereby enabling us to make these data members private.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">EnergyGroup&lt;dim&gt;::EnergyGroup (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        group,</div><div class="line">                               <span class="keyword">const</span> MaterialData       &amp;material_data,</div><div class="line">                               <span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid,</div><div class="line">                               <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe)</div><div class="line">  :</div><div class="line">  group (group),</div><div class="line">  material_data (material_data),</div><div class="line">  fe (fe),</div><div class="line">  dof_handler (triangulation)</div><div class="line">{</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a1f2bf1d34aacdba358add7fd59b32822">copy_triangulation</a> (coarse_grid);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">EnergyGroup&lt;dim&gt;::n_active_cells ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">EnergyGroup&lt;dim&gt;::n_dofs ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a> ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGroupsetup_linear_systemcode"></a> </p><h5><code>EnergyGroup::setup_linear_system</code></h5>
<p>The first "real" function is the one that sets up the mesh, matrices, etc, on the new mesh or after mesh refinement. We use this function to initialize sparse system matrices, and the right hand side vector. If the solution vector has never been set before (as indicated by a zero size), we also initialize it and set it to a default value. We don't do that if it already has a non-zero size (i.e. this function is called after mesh refinement) since in that case we want to preserve the solution across mesh refinement (something we do in the <code>EnergyGroup::refine_grid</code> function).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">EnergyGroup&lt;dim&gt;::setup_linear_system ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs = dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line"></div><div class="line">  hanging_node_constraints.clear ();</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                           hanging_node_constraints);</div><div class="line">  hanging_node_constraints.close ();</div><div class="line"></div><div class="line">  system_matrix.clear ();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_dofs, n_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">  hanging_node_constraints.condense (dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">  system_rhs.reinit (n_dofs);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (solution.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == 0)</div><div class="line">    {</div><div class="line">      solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_dofs);</div><div class="line">      solution_old.reinit(n_dofs);</div><div class="line">      solution_old = 1.0;</div><div class="line">      solution = solution_old;</div><div class="line">    }</div></div><!-- fragment --><p>At the end of this function, we update the list of boundary nodes and their values, by first clearing this list and the re-interpolating boundary values (remember that this function is called after first setting up the mesh, and each time after mesh refinement).</p>
<p>To understand the code, it is necessary to realize that we create the mesh using the <code><a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a></code> function (in <code>NeutronDiffusionProblem::initialize_problem</code>) where we set the last parameter to <code>true</code>. This means that boundaries of the domain are "colored", i.e. the four (or six, in 3d) sides of the domain are assigned different boundary indicators. As it turns out, the bottom boundary gets indicator zero, the top one boundary indicator one, and left and right boundaries get indicators two and three, respectively.</p>
<p>In this program, we simulate only one, namely the top right, quarter of a reactor. That is, we want to interpolate boundary conditions only on the top and right boundaries, while do nothing on the bottom and left boundaries (i.e. impose natural, no-flux Neumann boundary conditions). This is most easily generalized to arbitrary dimension by saying that we want to interpolate on those boundaries with indicators 1, 3, ..., which we do in the following loop (note that calls to <code><a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a></code> are additive, i.e. they do not first clear the boundary value map):</p>
<div class="fragment"><div class="line">  boundary_values.clear();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              2*i+1,</div><div class="line">                                              <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                              boundary_values);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGroupassemble_system_matrixcode"></a> </p><h5><code>EnergyGroup::assemble_system_matrix</code></h5>
<p>Next we need functions assembling the system matrix and right hand sides. Assembling the matrix is straightforward given the equations outlined in the introduction as well as what we've seen in previous example programs. Note the use of <code>cell-&gt;material_id()</code> to get at the kind of material from which a cell is made up of. Note also how we set the order of the quadrature formula so that it is always appropriate for the finite element in use.</p>
<p>Finally, note that since we only assemble the system matrix here, we can't yet eliminate boundary values (we need the right hand side vector for this). We defer this to the <code>EnergyGroup::solve</code> function, at which point all the information is available.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">EnergyGroup&lt;dim&gt;::assemble_system_matrix ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      cell_matrix = 0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient</div><div class="line">        = material_data.get_diffusion_coefficient (group, cell-&gt;material_id());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> removal_XS</div><div class="line">        = material_data.get_removal_XS (group,cell-&gt;material_id());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            cell_matrix(i,j) += ((diffusion_coefficient *</div><div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point)</div><div class="line">                                  +</div><div class="line">                                  removal_XS *</div><div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point))</div><div class="line">                                 *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">          system_matrix.add (local_dof_indices[i],</div><div class="line">                             local_dof_indices[j],</div><div class="line">                             cell_matrix(i,j));</div><div class="line">    }</div><div class="line"></div><div class="line">  hanging_node_constraints.condense (system_matrix);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGroupassemble_ingroup_rhscode"></a> </p><h5><code>EnergyGroup::assemble_ingroup_rhs</code></h5>
<p>As explained in the documentation of the <code>EnergyGroup</code> class, we split assembling the right hand side into two parts: the ingroup and the cross-group couplings. First, we need a function to assemble the right hand side of one specific group here, i.e. including an extraneous source (that we will set to zero for the eigenvalue problem) as well as the ingroup fission contributions. (In-group scattering has already been accounted for with the definition of removal cross section.) The function's workings are pretty standard as far as assembling right hand sides go, and therefore does not require more comments except that we mention that the right hand side vector is set to zero at the beginning of the function &ndash; something we are not going to do for the cross-group terms that simply add to the right hand side vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EnergyGroup&lt;dim&gt;::assemble_ingroup_rhs (<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;extraneous_source)</div><div class="line">{</div><div class="line">  system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            cell_rhs (dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;       extraneous_source_values (n_q_points);</div><div class="line">  std::vector&lt;double&gt;       solution_old_values (n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> fission_dist_XS</div><div class="line">        = material_data.get_fission_dist_XS (group, group, cell-&gt;material_id());</div><div class="line"></div><div class="line">      extraneous_source.<a class="code" href="classFunction.html#afc0acd3155a0c854dee816a096d88165">value_list</a> (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                    extraneous_source_values);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (solution_old, solution_old_values);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          cell_rhs(i) += ((extraneous_source_values[q_point]</div><div class="line">                           +</div><div class="line">                           fission_dist_XS *</div><div class="line">                           solution_old_values[q_point]) *</div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGroupassemble_cross_group_rhscode"></a> </p><h5><code>EnergyGroup::assemble_cross_group_rhs</code></h5>
<p>The more interesting function for assembling the right hand side vector for the equation of a single energy group is the one that couples energy group <img class="formulaInl" alt="$g$" src="form_36.png"/> and <img class="formulaInl" alt="$g'$" src="form_2308.png"/>. As explained in the introduction, we first have to find the set of cells common to the meshes of the two energy groups. First we call <code>get_finest_common_cells</code> to obtain this list of pairs of common cells from both meshes. Both cells in a pair may not be active but at least one of them is. We then hand each of these cell pairs off to a function that computes the right hand side terms recursively.</p>
<p>Note that ingroup coupling is handled already before, so we exit the function early if <img class="formulaInl" alt="$g=g'$" src="form_2399.png"/>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EnergyGroup&lt;dim&gt;::assemble_cross_group_rhs (<span class="keyword">const</span> EnergyGroup&lt;dim&gt; &amp;g_prime)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (group == g_prime.group)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::list&lt;std::pair&lt;typename DoFHandler&lt;dim&gt;::cell_iterator,</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a>&gt; &gt;</div><div class="line">        cell_list</div><div class="line">        = <a class="code" href="namespaceGridTools.html#a32a5016c746ad756046ecff264dfa60d">GridTools::get_finest_common_cells</a> (dof_handler,</div><div class="line">                                              g_prime.dof_handler);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> std::list&lt;std::pair&lt;typename DoFHandler&lt;dim&gt;::cell_iterator,</div><div class="line">           <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a>&gt; &gt;</div><div class="line">           ::const_iterator</div><div class="line">           cell_iter = cell_list.begin();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell_iter!=cell_list.end(); ++cell_iter)</div><div class="line">    {</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> unit_matrix (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;unit_matrix.m(); ++i)</div><div class="line">        unit_matrix(i,i) = 1;</div><div class="line">      assemble_cross_group_rhs_recursive (g_prime,</div><div class="line">                                          cell_iter-&gt;first,</div><div class="line">                                          cell_iter-&gt;second,</div><div class="line">                                          unit_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGroupassemble_cross_group_rhs_recursivecode"></a> </p><h5><code>EnergyGroup::assemble_cross_group_rhs_recursive</code></h5>
<p>This is finally the function that handles assembling right hand side terms on potentially different meshes recursively, using the algorithm described in the introduction. The function takes a reference to the object representing energy group <img class="formulaInl" alt="$g'$" src="form_2308.png"/>, as well as iterators to corresponding cells in the meshes for energy groups <img class="formulaInl" alt="$g$" src="form_36.png"/> and <img class="formulaInl" alt="$g'$" src="form_2308.png"/>. At first, i.e. when this function is called from the one above, these two cells will be matching cells on two meshes; however, one of the two may be further refined, and we will call the function recursively with one of the two iterators replaced by one of the children of the original cell.</p>
<p>The last argument is the matrix product matrix <img class="formulaInl" alt="$B_{c^{(k)}}^T \cdots B_{c'}^T B_c^T$" src="form_2400.png"/> from the introduction that interpolates from the coarser of the two cells to the finer one. If the two cells match, then this is the identity matrix &ndash; exactly what we pass to this function initially.</p>
<p>The function has to consider two cases: that both of the two cells are not further refined, i.e. have no children, in which case we can finally assemble the right hand side contributions of this pair of cells; and that one of the two cells is further refined, in which case we have to keep recursing by looping over the children of the one cell that is not active. These two cases will be discussed below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">EnergyGroup&lt;dim&gt;::</div><div class="line">assemble_cross_group_rhs_recursive (<span class="keyword">const</span> EnergyGroup&lt;dim&gt;                        &amp;g_prime,</div><div class="line">                                    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell_g,</div><div class="line">                                    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell_g_prime,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                       prolongation_matrix)</div><div class="line">{</div></div><!-- fragment --><p>The first case is that both cells are no further refined. In that case, we can assemble the relevant terms (see the introduction). This involves assembling the mass matrix on the finer of the two cells (in fact there are two mass matrices with different coefficients, one for the fission distribution cross section <img class="formulaInl" alt="$\chi_g\nu\Sigma_{f,g'}$" src="form_2312.png"/> and one for the scattering cross section <img class="formulaInl" alt="$\Sigma_{s,g'\to g}$" src="form_2314.png"/>). This is straight forward, but note how we determine which of the two cells is the finer one by looking at the refinement level of the two cells:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!cell_g-&gt;has_children() &amp;&amp; !cell_g_prime-&gt;has_children())</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cell_g-&gt;level() &gt; cell_g_prime-&gt;level())</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell_g);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell_g_prime);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> fission_dist_XS</div><div class="line">      = material_data.get_fission_dist_XS (group, g_prime.group,</div><div class="line">                                           cell_g_prime-&gt;material_id());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> scattering_XS</div><div class="line">      = material_data.get_scattering_XS (g_prime.group, group,</div><div class="line">                                         cell_g_prime-&gt;material_id());</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>    local_mass_matrix_f (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">                                               fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>    local_mass_matrix_g (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">                                               fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line">          {</div><div class="line">            local_mass_matrix_f(i,j) += (fission_dist_XS *</div><div class="line">                                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point) *</div><div class="line">                                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">            local_mass_matrix_g(i,j) += (scattering_XS *</div><div class="line">                                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point) *</div><div class="line">                                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">          }</div></div><!-- fragment --><p>Now we have all the interpolation (prolongation) matrices as well as local mass matrices, so we only have to form the product </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ F_i|_{K_{cc'\cdots c^{(k)}}} = [B_c B_{c'} \cdots B_{c^{(k)}} M_{K_{cc'\cdots c^{(k)}}}]^{ij} \phi_{g'}^j, \]" src="form_2401.png"/>
</p>
<p> or </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ F_i|_{K_{cc'\cdots c^{(k)}}} = [(B_c B_{c'} \cdots B_{c^{(k)}} M_{K_{cc'\cdots c^{(k)}}})^T]^{ij} \phi_{g'}^j, \]" src="form_2402.png"/>
</p>
<p> depending on which of the two cells is the finer. We do this using either the matrix-vector product provided by the <code>vmult</code> function, or the product with the transpose matrix using <code>Tvmult</code>. After doing so, we transfer the result into the global right hand side vector of energy group <img class="formulaInl" alt="$g$" src="form_36.png"/>.</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       g_prime_new_values (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       g_prime_old_values (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">  cell_g_prime-&gt;get_dof_values (g_prime.solution_old, g_prime_old_values);</div><div class="line">  cell_g_prime-&gt;get_dof_values (g_prime.solution,     g_prime_new_values);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       tmp (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (cell_g-&gt;level() &gt; cell_g_prime-&gt;level())</div><div class="line">    {</div><div class="line">      prolongation_matrix.<a class="code" href="classFullMatrix.html#a983d5ce20f0966866002dc762b964241">vmult</a> (tmp, g_prime_old_values);</div><div class="line">      local_mass_matrix_f.vmult (cell_rhs, tmp);</div><div class="line"></div><div class="line">      prolongation_matrix.<a class="code" href="classFullMatrix.html#a983d5ce20f0966866002dc762b964241">vmult</a> (tmp, g_prime_new_values);</div><div class="line">      local_mass_matrix_g.vmult_add (cell_rhs, tmp);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      local_mass_matrix_f.vmult (tmp, g_prime_old_values);</div><div class="line">      prolongation_matrix.<a class="code" href="classFullMatrix.html#a39d67895efe54f7810eec53925d72513">Tvmult</a> (cell_rhs, tmp);</div><div class="line"></div><div class="line">      local_mass_matrix_g.vmult (tmp, g_prime_new_values);</div><div class="line">      prolongation_matrix.<a class="code" href="classFullMatrix.html#abed6fffa5cb201496d751a4427cb59d6">Tvmult_add</a> (cell_rhs, tmp);</div><div class="line">    }</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">  cell_g-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">    system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">}</div></div><!-- fragment --><p>The alternative is that one of the two cells is further refined. In that case, we have to loop over all the children, multiply the existing interpolation (prolongation) product of matrices from the left with the interpolation from the present cell to its child (using the matrix-matrix multiplication function <code>mmult</code>), and then hand the result off to this very same function again, but with the cell that has children replaced by one of its children:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> child=0; child&lt;GeometryInfo&lt;dim&gt;::max_children_per_cell; ++child)</div><div class="line">      {</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   new_matrix (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix</a>(child).<a class="code" href="classFullMatrix.html#ac93d06d0f1305519dface996c8f93823">mmult</a> (new_matrix,</div><div class="line">                                                 prolongation_matrix);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_g-&gt;has_children())</div><div class="line">          assemble_cross_group_rhs_recursive (g_prime,</div><div class="line">                                              cell_g-&gt;child(child), cell_g_prime,</div><div class="line">                                              new_matrix);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          assemble_cross_group_rhs_recursive (g_prime,</div><div class="line">                                              cell_g, cell_g_prime-&gt;child(child),</div><div class="line">                                              new_matrix);</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGroupget_fission_sourcecode"></a> </p><h5><code>EnergyGroup::get_fission_source</code></h5>
<p>In the (inverse) power iteration, we use the integrated fission source to update the <img class="formulaInl" alt="$k$" src="form_44.png"/>-eigenvalue. Given its definition, the following function is essentially self-explanatory:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> EnergyGroup&lt;dim&gt;::get_fission_source ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;       solution_values (n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fission_source = 0;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> fission_XS</div><div class="line">        = material_data.get_fission_XS(group, cell-&gt;material_id());</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (solution, solution_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">        fission_source += (fission_XS *</div><div class="line">                           solution_values[q_point] *</div><div class="line">                           fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> fission_source;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGroupsolvecode"></a> </p><h5><code>EnergyGroup::solve</code></h5>
<p>Next a function that solves the linear system assembled before. Things are pretty much standard, except that we delayed applying boundary values until we get here, since in all the previous functions we were still adding up contributions the right hand side vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">EnergyGroup&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  hanging_node_constraints.condense (system_rhs);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      system_matrix,</div><div class="line">                                      solution,</div><div class="line">                                      system_rhs);</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (system_matrix.m(),</div><div class="line">                                          1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12*system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  cg.solve (system_matrix, solution, system_rhs, preconditioner);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute (solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGroupestimate_errorscode"></a> </p><h5><code>EnergyGroup::estimate_errors</code></h5>
<p>Mesh refinement is split into two functions. The first estimates the error for each cell, normalizes it by the magnitude of the solution, and returns it in the vector given as an argument. The calling function collects all error indicators from all energy groups, and computes thresholds for refining and coarsening cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EnergyGroup&lt;dim&gt;::estimate_errors (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a> (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                      <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                      solution,</div><div class="line">                                      error_indicators);</div><div class="line">  error_indicators /= solution.<a class="code" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">linfty_norm</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGrouprefine_gridcode"></a> </p><h5><code>EnergyGroup::refine_grid</code></h5>
<p>The second part is to refine the grid given the error indicators compute in the previous function and error thresholds above which cells shall be refined or below which cells shall be coarsened. Note that we do not use any of the functions in <code><a class="el" href="namespaceGridRefinement.html">GridRefinement</a></code> here, but rather set refinement flags ourselves.</p>
<p>After setting these flags, we use the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class to move the solution vector from the old to the new mesh. The procedure used here is described in detail in the documentation of that class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EnergyGroup&lt;dim&gt;::refine_grid (<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">double</span>         refine_threshold,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">double</span>         coarsen_threshold)</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">if</span> (error_indicators(cell-&gt;active_cell_index()) &gt; refine_threshold)</div><div class="line">      cell-&gt;set_refine_flag ();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error_indicators(cell-&gt;active_cell_index()) &lt; coarsen_threshold)</div><div class="line">      cell-&gt;set_coarsen_flag ();</div><div class="line"></div><div class="line">  <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> soltrans(dof_handler);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">  soltrans.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">  this-&gt;setup_linear_system ();</div><div class="line"></div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  soltrans.interpolate(solution_old, solution);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line"></div><div class="line">  solution_old.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_old = solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeEnergyGroupoutput_resultscode"></a> </p><h5><code>EnergyGroup::output_results</code></h5>
<p>The last function of this class outputs meshes and solutions after each mesh iteration. This has been shown many times before. The only thing worth pointing out is the use of the <code><a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></code> function to convert an integer into its string representation. The second argument of that function denotes how many digits we shall use &ndash; if this value was larger than one, then the number would be padded by leading zeros.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">EnergyGroup&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string filename = std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(group, 2) +</div><div class="line">                               <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  std::ofstream output (filename.c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeNeutronDiffusionProblemcodeclasstemplate"></a> </p><h3>The <code>NeutronDiffusionProblem</code> class template</h3>
<p>This is the main class of the program, not because it implements all the functionality (in fact, most of it is implemented in the <code>EnergyGroup</code> class) but because it contains the driving algorithm that determines what to compute and when. It is mostly as shown in many of the other tutorial programs in that it has a public <code>run</code> function and private functions doing all the rest. In several places, we have to do something for all energy groups, in which case we will start threads for each group to let these things run in parallel if deal.II was configured for multithreading. For strategies of parallelization, take a look at the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> module.</p>
<p>The biggest difference to previous example programs is that we also declare a nested class that has member variables for all the run-time parameters that can be passed to the program in an input file. Right now, these are the number of energy groups, the number of refinement cycles, the polynomial degree of the finite element to be used, and the tolerance used to determine when convergence of the inverse power iteration has occurred. In addition, we have a constructor of this class that sets all these values to their default values, a function <code>declare_parameters</code> that described to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class already used in <a class="el" href="step_19.html">step-19</a> what parameters are accepted in the input file, and a function <code>get_parameters</code> that can extract the values of these parameters from a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>NeutronDiffusionProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">class </span>Parameters</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Parameters ();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_groups;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_cycles;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> convergence_tolerance;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  NeutronDiffusionProblem (<span class="keyword">const</span> Parameters &amp;parameters);</div><div class="line">  ~NeutronDiffusionProblem ();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p><a class="anchor" id="Privatememberfunctions"></a> </p><h5>Private member functions</h5>
<p>There are not that many member functions in this class since most of the functionality has been moved into the <code>EnergyGroup</code> class and is simply called from the <code>run()</code> member function of this class. The ones that remain have self-explanatory names:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initialize_problem();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> refine_grid ();</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_total_fission_source () <span class="keyword">const</span>;</div></div><!-- fragment --><p><a class="anchor" id="Privatemembervariables"></a> </p><h5>Private member variables</h5>
<p>Next, we have a few member variables. In particular, these are (i) a reference to the parameter object (owned by the main function of this program, and passed to the constructor of this class), (ii) an object describing the material parameters for the number of energy groups requested in the input file, and (iii) the finite element to be used by all energy groups:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Parameters  &amp;parameters;</div><div class="line"><span class="keyword">const</span> MaterialData material_data;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div></div><!-- fragment --><p>Furthermore, we have (iv) the value of the computed eigenvalue at the present iteration. This is, in fact, the only part of the solution that is shared between all energy groups &ndash; all other parts of the solution, such as neutron fluxes are particular to one or the other energy group, and are therefore stored in objects that describe a single energy group:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> k_eff;</div></div><!-- fragment --><p>Finally, (v), we have an array of pointers to the energy group objects. The length of this array is, of course, equal to the number of energy groups specified in the parameter file.</p>
<div class="fragment"><div class="line">  std::vector&lt;EnergyGroup&lt;dim&gt;*&gt; energy_groups;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeNeutronDiffusionProblemParameterscodeclass"></a> </p><h4>Implementation of the <code>NeutronDiffusionProblem::Parameters</code> class</h4>
<p>Before going on to the implementation of the outer class, we have to implement the functions of the parameters structure. This is pretty straightforward and, in fact, looks pretty much the same for all such parameters classes using the <a class="el" href="classParameterHandler.html">ParameterHandler</a> capabilities. We will therefore not comment further on this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">NeutronDiffusionProblem&lt;dim&gt;::Parameters::Parameters ()</div><div class="line">  :</div><div class="line">  n_groups (2),</div><div class="line">  n_refinement_cycles (5),</div><div class="line">  fe_degree (2),</div><div class="line">  convergence_tolerance (1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">NeutronDiffusionProblem&lt;dim&gt;::Parameters::</div><div class="line">declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Number of energy groups&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (),</div><div class="line">                     <span class="stringliteral">&quot;The number of energy different groups considered&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Refinement cycles&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (),</div><div class="line">                     <span class="stringliteral">&quot;Number of refinement cycles to be performed&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Finite element degree&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (),</div><div class="line">                     <span class="stringliteral">&quot;Polynomial degree of the finite element to be used&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Power iteration tolerance&quot;</span>, <span class="stringliteral">&quot;1e-12&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (),</div><div class="line">                     <span class="stringliteral">&quot;Inner power iterations are stopped when the change in k_eff falls &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;below this tolerance&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">NeutronDiffusionProblem&lt;dim&gt;::Parameters::</div><div class="line">get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  n_groups              = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Number of energy groups&quot;</span>);</div><div class="line">  n_refinement_cycles   = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Refinement cycles&quot;</span>);</div><div class="line">  fe_degree             = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Finite element degree&quot;</span>);</div><div class="line">  convergence_tolerance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;Power iteration tolerance&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeNeutronDiffusionProblemcodeclass"></a> </p><h4>Implementation of the <code>NeutronDiffusionProblem</code> class</h4>
<p>Now for the <code>NeutronDiffusionProblem</code> class. The constructor and destructor have nothing of much interest:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">NeutronDiffusionProblem&lt;dim&gt;::</div><div class="line">NeutronDiffusionProblem (<span class="keyword">const</span> Parameters &amp;parameters)</div><div class="line">  :</div><div class="line">  parameters (parameters),</div><div class="line">  material_data (parameters.n_groups),</div><div class="line">  fe (parameters.fe_degree),</div><div class="line">  k_eff (<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;double&gt;::quiet_NaN())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">NeutronDiffusionProblem&lt;dim&gt;::~NeutronDiffusionProblem ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;energy_groups.size(); ++group)</div><div class="line">    <span class="keyword">delete</span> energy_groups[group];</div><div class="line"></div><div class="line">  energy_groups.resize (0);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeNeutronDiffusionProbleminitialize_problemcode"></a> </p><h5><code>NeutronDiffusionProblem::initialize_problem</code></h5>
<p>The first function of interest is the one that sets up the geometry of the reactor core. This is described in more detail in the introduction.</p>
<p>The first part of the function defines geometry data, and then creates a coarse mesh that has as many cells as there are fuel rods (or pin cells, for that matter) in that part of the reactor core that we simulate. As mentioned when interpolating boundary values above, the last parameter to the <code><a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a></code> function specifies that sides of the domain shall have unique boundary indicators that will later allow us to determine in a simple way which of the boundaries have Neumann and which have Dirichlet conditions attached to them.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NeutronDiffusionProblem&lt;dim&gt;::initialize_problem()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rods_per_assembly_x = 17,</div><div class="line">                     rods_per_assembly_y = 17;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pin_pitch_x = 1.26,</div><div class="line">               pin_pitch_y = 1.26;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> assembly_height = 200;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> assemblies_x = 2,</div><div class="line">                     assemblies_y = 2,</div><div class="line">                     assemblies_z = 1;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> upper_right = (dim == 2</div><div class="line">                                  ?</div><div class="line">                                  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (assemblies_x*rods_per_assembly_x*pin_pitch_x,</div><div class="line">                                              assemblies_y*rods_per_assembly_y*pin_pitch_y)</div><div class="line">                                  :</div><div class="line">                                  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (assemblies_x*rods_per_assembly_x*pin_pitch_x,</div><div class="line">                                              assemblies_y*rods_per_assembly_y*pin_pitch_y,</div><div class="line">                                              assemblies_z*assembly_height));</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; n_subdivisions;</div><div class="line">  n_subdivisions.push_back (assemblies_x*rods_per_assembly_x);</div><div class="line">  <span class="keywordflow">if</span> (dim &gt;= 2)</div><div class="line">    n_subdivisions.push_back (assemblies_y*rods_per_assembly_y);</div><div class="line">  <span class="keywordflow">if</span> (dim &gt;= 3)</div><div class="line">    n_subdivisions.push_back (assemblies_z);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> coarse_grid;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (coarse_grid,</div><div class="line">                                             n_subdivisions,</div><div class="line">                                             bottom_left,</div><div class="line">                                             upper_right,</div><div class="line">                                             <span class="keyword">true</span>);</div></div><!-- fragment --><p>The second part of the function deals with material numbers of pin cells of each type of assembly. Here, we define four different types of assembly, for which we describe the arrangement of fuel rods in the following tables.</p>
<p>The assemblies described here are taken from the benchmark mentioned in the introduction and are (in this order): </p><ol>
<li>
'UX' Assembly: UO2 fuel assembly with 24 guide tubes and a central Moveable Fission Chamber </li>
<li>
'UA' Assembly: UO2 fuel assembly with 24 AIC and a central Moveable Fission Chamber </li>
<li>
'PX' Assembly: MOX fuel assembly with 24 guide tubes and a central Moveable Fission Chamber </li>
<li>
'R' Assembly: a reflector. </li>
</ol>
<p>Note that the numbers listed here and taken from the benchmark description are, in good old Fortran fashion, one-based. We will later subtract one from each number when assigning materials to individual cells to convert things into the C-style zero-based indexing.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_assemblies=4;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">assembly_materials[n_assemblies][rods_per_assembly_x][rods_per_assembly_y]</div><div class="line">=</div><div class="line">{</div><div class="line">  {</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 5, 1, 1, 5, 1, 1, 7, 1, 1, 5, 1, 1, 5, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }</div><div class="line">  },</div><div class="line">  {</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 8, 1, 1, 8, 1, 1, 7, 1, 1, 8, 1, 1, 8, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }</div><div class="line">  },</div><div class="line">  {</div><div class="line">    { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 },</div><div class="line">    { 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2 },</div><div class="line">    { 2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2 },</div><div class="line">    { 2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2 },</div><div class="line">    { 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2 },</div><div class="line">    { 2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2 },</div><div class="line">    { 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2 },</div><div class="line">    { 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2 },</div><div class="line">    { 2, 3, 5, 4, 4, 5, 4, 4, 7, 4, 4, 5, 4, 4, 5, 3, 2 },</div><div class="line">    { 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2 },</div><div class="line">    { 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2 },</div><div class="line">    { 2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2 },</div><div class="line">    { 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2 },</div><div class="line">    { 2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2 },</div><div class="line">    { 2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2 },</div><div class="line">    { 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2 },</div><div class="line">    { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 }</div><div class="line">  },</div><div class="line">  {</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">    { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>After the description of the materials that make up an assembly, we have to specify the arrangement of assemblies within the core. We use a symmetric pattern that in fact only uses the 'UX' and 'PX' assemblies:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> core[assemblies_x][assemblies_y][assemblies_z]</div><div class="line">=  {{{0}, {2}}, {{2}, {0}}};</div></div><!-- fragment --><p>We are now in a position to actually set material IDs for each cell. To this end, we loop over all cells, look at the location of the cell's center, and determine which assembly and fuel rod this would be in. (We add a few checks to see that the locations we compute are within the bounds of the arrays in which we have to look up materials.) At the end of the loop, we set material identifiers accordingly:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">     cell = coarse_grid.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell!=coarse_grid.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">     ++cell)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = cell-&gt;center();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp_x = int(cell_center[0]/pin_pitch_x);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ax = tmp_x/rods_per_assembly_x;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cx = tmp_x - ax * rods_per_assembly_x;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> tmp_y = int(cell_center[1]/pin_pitch_y);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ay = tmp_y/rods_per_assembly_y;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cy = tmp_y - ay * rods_per_assembly_y;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> az = (dim == 2</div><div class="line">                             ?</div><div class="line">                             0</div><div class="line">                             :</div><div class="line">                             int (cell_center[dim-1]/assembly_height));</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (ax &lt; assemblies_x, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (ay &lt; assemblies_y, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (az &lt; assemblies_z, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (core[ax][ay][az] &lt; n_assemblies, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cx &lt; rods_per_assembly_x, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cy &lt; rods_per_assembly_y, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    cell-&gt;set_material_id(assembly_materials[core[ax][ay][az]][cx][cy] - 1);</div><div class="line">  }</div></div><!-- fragment --><p>With the coarse mesh so initialized, we create the appropriate number of energy group objects and let them initialize their individual meshes with the coarse mesh generated above:</p>
<div class="fragment"><div class="line">  energy_groups.resize (parameters.n_groups);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">    energy_groups[group] = <span class="keyword">new</span> EnergyGroup&lt;dim&gt; (group, material_data,</div><div class="line">                                                 coarse_grid, fe);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeNeutronDiffusionProblemget_total_fission_sourcecode"></a> </p><h5><code>NeutronDiffusionProblem::get_total_fission_source</code></h5>
<p>In the eigenvalue computation, we need to calculate total fission neutron source after each power iteration. The total power then is used to renew k-effective.</p>
<p>Since the total fission source is a sum over all the energy groups, and since each of these sums can be computed independently, we actually do this in parallel. One of the problems is that the function in the <code>EnergyGroup</code> class that computes the fission source returns a value. If we now simply spin off a new thread, we have to later capture the return value of the function run on that thread. The way this can be done is to use the return value of the <a class="el" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a> function, which returns an object of type <a class="el" href="classThreads_1_1Thread.html">Threads::Thread</a>&lt;double&gt; if the function spawned returns a double. We can then later ask this object for the returned value (when doing so, the <a class="el" href="classThreads_1_1Thread.html#a304085b2975789f821cd8c3417f3818d">Threads::Thread::return_value</a> function first waits for the thread to finish if it hasn't done so already).</p>
<p>The way this function then works is to first spawn one thread for each energy group we work with, then one-by-one collecting the returned values of each thread and return the sum.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> NeutronDiffusionProblem&lt;dim&gt;::get_total_fission_source ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;Threads::Thread&lt;double&gt; &gt; threads;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">    threads.push_back (<a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a> (&amp;EnergyGroup&lt;dim&gt;::get_fission_source,</div><div class="line">                                            *energy_groups[group]));</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fission_source = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">    fission_source += threads[group].return_value ();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> fission_source;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeNeutronDiffusionProblemrefine_gridcode"></a> </p><h5><code>NeutronDiffusionProblem::refine_grid</code></h5>
<p>The next function lets the individual energy group objects refine their meshes. Much of this, again, is a task that can be done independently in parallel: first, let all the energy group objects calculate their error indicators in parallel, then compute the maximum error indicator over all energy groups and determine thresholds for refinement and coarsening of cells, and then ask all the energy groups to refine their meshes accordingly, again in parallel.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NeutronDiffusionProblem&lt;dim&gt;::refine_grid ()</div><div class="line">{</div><div class="line">  std::vector&lt;types::global_dof_index&gt; n_cells (parameters.n_groups);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">    n_cells[group] = energy_groups[group]-&gt;n_active_cells();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;float&gt;</a>  group_error_indicators(n_cells);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classThreads_1_1ThreadGroup.html">Threads::ThreadGroup&lt;&gt;</a> threads;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">      threads += <a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a> (&amp;EnergyGroup&lt;dim&gt;::estimate_errors,</div><div class="line">                                      *energy_groups[group],</div><div class="line">                                      group_error_indicators.block(group));</div><div class="line">    threads.<a class="code" href="classThreads_1_1ThreadGroup.html#af715c77cbda5c5601f956896ca08cd37">join_all</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> max_error         = group_error_indicators.linfty_norm();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> refine_threshold  = 0.3*max_error;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> coarsen_threshold = 0.01*max_error;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classThreads_1_1ThreadGroup.html">Threads::ThreadGroup&lt;&gt;</a> threads;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">      threads += <a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a> (&amp;EnergyGroup&lt;dim&gt;::refine_grid,</div><div class="line">                                      *energy_groups[group],</div><div class="line">                                      group_error_indicators.block(group),</div><div class="line">                                      refine_threshold,</div><div class="line">                                      coarsen_threshold);</div><div class="line">    threads.<a class="code" href="classThreads_1_1ThreadGroup.html#af715c77cbda5c5601f956896ca08cd37">join_all</a> ();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeNeutronDiffusionProblemruncode"></a> </p><h5><code>NeutronDiffusionProblem::run</code></h5>
<p>Finally, this is the function where the meat is: iterate on a sequence of meshes, and on each of them do a power iteration to compute the eigenvalue.</p>
<p>Given the description of the algorithm in the introduction, there is actually not much to comment on:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NeutronDiffusionProblem&lt;dim&gt;::run ()</div><div class="line">{</div></div><!-- fragment --><p>We would like to change the output precision for just this function and restore the state of <code>std::cout</code> when this function returns. Hence, we need a way to undo the output format change. Boost provides a convenient way to save the state of an output stream and restore it at the end of the current block (when the destructor of <code>restore_flags</code> is called) with the <code>ios_flags_saver</code> class, which we use here.</p>
<div class="fragment"><div class="line">    boost::io::ios_flags_saver restore_flags(std::cout);</div><div class="line">    std::cout &lt;&lt; std::setprecision (12) &lt;&lt; std::fixed;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> k_eff_old = k_eff;</div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">    timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;parameters.n_refinement_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            initialize_problem();</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">              energy_groups[group]-&gt;setup_linear_system ();</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            refine_grid ();</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">              energy_groups[group]-&gt;solution *= k_eff;</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Numbers of active cells:       &quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">          std::cout &lt;&lt; energy_groups[group]-&gt;n_active_cells()</div><div class="line">                    &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Numbers of degrees of freedom: &quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">          std::cout &lt;&lt; energy_groups[group]-&gt;n_dofs()</div><div class="line">                    &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classThreads_1_1ThreadGroup.html">Threads::ThreadGroup&lt;&gt;</a> threads;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">          threads += <a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a></div><div class="line">                     (&amp;EnergyGroup&lt;dim&gt;::assemble_system_matrix,</div><div class="line">                      *energy_groups[group]);</div><div class="line">        threads.<a class="code" href="classThreads_1_1ThreadGroup.html#af715c77cbda5c5601f956896ca08cd37">join_all</a> ();</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> error;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration = 1;</div><div class="line">        <span class="keywordflow">do</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">              {</div><div class="line">                energy_groups[group]-&gt;assemble_ingroup_rhs (<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bgroup=0; bgroup&lt;parameters.n_groups; ++bgroup)</div><div class="line">                  energy_groups[group]-&gt;assemble_cross_group_rhs (*energy_groups[bgroup]);</div><div class="line"></div><div class="line">                energy_groups[group]-&gt;solve ();</div><div class="line">              }</div><div class="line"></div><div class="line">            k_eff = get_total_fission_source();</div><div class="line">            error = fabs(k_eff-k_eff_old)/fabs(k_eff);</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;   Iteration &quot;</span> &lt;&lt; iteration</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;: k_eff=&quot;</span> &lt;&lt; k_eff</div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">            k_eff_old=k_eff;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">              {</div><div class="line">                energy_groups[group]-&gt;solution_old = energy_groups[group]-&gt;solution;</div><div class="line">                energy_groups[group]-&gt;solution_old /= k_eff;</div><div class="line">              }</div><div class="line"></div><div class="line">            ++iteration;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">while</span> ((error &gt; parameters.convergence_tolerance)</div><div class="line">               &amp;&amp;</div><div class="line">               (iteration &lt; 500));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">          energy_groups[group]-&gt;output_results (cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Cycle=&quot;</span> &lt;&lt; cycle</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, n_dofs=&quot;</span> &lt;&lt; energy_groups[0]-&gt;n_dofs() + energy_groups[1]-&gt;n_dofs()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;,  k_eff=&quot;</span> &lt;&lt; k_eff</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, time=&quot;</span> &lt;&lt; timer()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>The last thing in the program in the <code>main()</code> function. The structure is as in most other tutorial programs, with the only exception that we here handle a parameter file. To this end, we first look at the command line arguments passed to this function: if no input file is specified on the command line, then use "project.prm", otherwise take the filename given as the first argument on the command line.</p>
<p>With this, we create a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object, let the <code>NeutronDiffusionProblem::Parameters</code> class declare all the parameters it wants to see in the input file (or, take the default values, if nothing is listed in the parameter file), then read the input file, ask the parameters object to extract the values, and finally hand everything off to an object of type <code>NeutronDiffusionProblem</code> for computation of the eigenvalue:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step28;</div><div class="line"></div><div class="line">      std::string filename;</div><div class="line">      <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">        filename = <span class="stringliteral">&quot;project.prm&quot;</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        filename = argv[1];</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> parameter_handler;</div><div class="line"></div><div class="line">      NeutronDiffusionProblem&lt;dim&gt;::Parameters parameters;</div><div class="line">      parameters.declare_parameters (parameter_handler);</div><div class="line"></div><div class="line">      parameter_handler.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (filename);</div><div class="line"></div><div class="line">      parameters.get_parameters (parameter_handler);</div><div class="line"></div><div class="line"></div><div class="line">      NeutronDiffusionProblem&lt;dim&gt; neutron_diffusion_problem (parameters);</div><div class="line">      neutron_diffusion_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>We can run the program with the following input file : </p><div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line"><span class="preprocessor"># Polynomial degree of the finite element to be used</span></div><div class="line"><span class="keyword">set</span> Finite element degree     = 2</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of energy different groups considered</span></div><div class="line"><span class="keyword">set</span> Number of energy groups   = 2</div><div class="line"></div><div class="line"><span class="preprocessor"># Inner power iterations are stopped when the change in k_eff falls below this</span></div><div class="line"><span class="preprocessor"># tolerance</span></div><div class="line"><span class="keyword">set</span> Power iteration tolerance = 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12</div><div class="line"></div><div class="line"><span class="preprocessor"># Number of refinement cycles to be performed</span></div><div class="line"><span class="preprocessor">set Refinement cycles         = 5</span></div></div><!-- fragment --><p> The output of this program then consists of the console output, a file named ``convergence_table'' to record main results of mesh iteration, and the graphical output in vtu format.</p>
<p>The console output looks like this: </p><div class="fragment"><div class="line">Cycle 0:</div><div class="line">   Numbers of active cells:       1156 1156 </div><div class="line">   Numbers of degrees of freedom: 4761 4761 </div><div class="line">Iter number:1 k_eff=319.375676634307 flux ratio=6.836246075631 max_thermal=1.433899030144</div><div class="line">Iter number:2 k_eff=0.834072546055 flux ratio=5.204601882141 max_thermal=0.004630925876</div><div class="line">Iter number:3 k_eff=0.862826188043 flux ratio=4.645051765984 max_thermal=0.005380396338</div><div class="line">Iter number:4 k_eff=0.877887920967 flux ratio=4.318030683875 max_thermal=0.006005512201</div><div class="line">Iter number:5 k_eff=0.887161559547 flux ratio=4.256596788174</div><div class="line">max_thermal=0.006639443035</div><div class="line">...</div><div class="line">Iter number:69 k_eff=0.906841960370 flux ratio=4.384056022578 max_thermal=0.008466414246</div><div class="line">Iter number:70 k_eff=0.906841960371 flux ratio=4.384056022582 max_thermal=0.008466414246</div><div class="line">Cycle 1:</div><div class="line">   Numbers of active cells:       1156 2380 </div><div class="line">   Numbers of degrees of freedom: 4761 10667 </div><div class="line">Iter number:1 k_eff=0.906838267472 flux ratio=4.385474405124 max_thermal=0.008463675976</div><div class="line">Iter number:2 k_eff=0.906837892433 flux ratio=4.385486158840 max_thermal=0.008463675386</div><div class="line">...</div><div class="line">Cycle 11:</div><div class="line">   Numbers of active cells:       11749 47074 </div><div class="line">   Numbers of degrees of freedom: 50261 204523 </div><div class="line">Iter number:1 k_eff=0.906805395149 flux ratio=4.384872231023 max_thermal=0.008464861813</div><div class="line">...Iter number:32 k_eff=0.906834736551 flux ratio=4.384846081796 max_thermal=0.008465019607</div><div class="line">Iter number:33 k_eff=0.906834736552 flux ratio=4.384846081800 max_thermal=0.008465019607</div></div><!-- fragment --><p>We see that power iteration does converge faster after cycle 0 due to the initialization with solution from last mesh iteration. The contents of ``convergence_table'' are, </p><div class="fragment"><div class="line">0 4761 4761 0.906841960371 4.384056022582</div><div class="line">1 4761 10667 0.906837901031 4.385489087760</div><div class="line">2 4761 18805 0.906836075928 4.385466647499</div><div class="line">3 6629 27301 0.906835500111 4.385404580865</div><div class="line">4 12263 48095 0.906835001796 4.385381798734</div><div class="line">5 17501 69297 0.906834858174 4.384853823414</div><div class="line">6 19933 78605 0.906834824060 4.384850658788</div><div class="line">7 23979 93275 0.906834787556 4.384848379257</div><div class="line">8 30285 117017 0.906834761604 4.384846544947</div><div class="line">9 40087 154355 0.906834746216 4.384846083191</div><div class="line">10 45467 179469 0.906834740155 4.384846005044</div><div class="line">11 50261 204523 0.906834736552 4.384846081800</div></div><!-- fragment --><p> The meanings of columns are: number of mesh iteration, numbers of degrees of freedom of fast energy group, numbers of DoFs of thermal group, converged k-effective and the ratio between maximum of fast flux and maximum of thermal one.</p>
<p>The grids of fast and thermal energy groups at mesh iteration #9 look as follows:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-28.grid-0.9.order2.png" width="400"/>
</div>
<p> &#160; </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-28.grid-1.9.order2.png" width="400"/>
</div>
<p>We see that the grid of thermal group is much finer than the one of fast group. The solutions on these grids are, (Note: flux are normalized with total fission source equal to 1)</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-28.solution-0.9.order2.png" width="400"/>
</div>
<p> &#160; </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-28.solution-1.9.order2.png" width="400"/>
</div>
<p>Then we plot the convergence data with polynomial order being equal to 1,2 and 3.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-28.convergence.png"/>
</div>
<p>The estimated ``exact'' k-effective = 0.906834721253 which is simply from last mesh iteration of polynomial order 3 minus 2e-10. We see that h-adaptive calculations deliver an algebraic convergence. And the higher polynomial order is, the faster mesh iteration converges. In our problem, we need smaller number of DoFs to achieve same accuracy with higher polynomial order. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Yaqi Wang, Texas A&amp;M University, 2009, 2010</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/thread_management.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/solution_transfer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/io/ios_state.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step28</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>MaterialData</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MaterialData (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_groups);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_diffusion_coefficient (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> get_removal_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> get_fission_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> get_fission_dist_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> get_scattering_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> get_fission_spectrum (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_groups;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_materials;</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> diffusion;</div><div class="line">    <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> sigma_r;</div><div class="line">    <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> nu_sigma_f;</div><div class="line">    <a class="code" href="classTable.html">Table&lt;3,double&gt;</a> sigma_s;</div><div class="line">    <a class="code" href="classTable.html">Table&lt;2,double&gt;</a> chi;</div><div class="line">  };</div><div class="line"></div><div class="line">  MaterialData::MaterialData (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_groups)</div><div class="line">    :</div><div class="line">    n_groups (n_groups),</div><div class="line">    n_materials (8),</div><div class="line">    diffusion (n_materials, n_groups),</div><div class="line">    sigma_r (n_materials, n_groups),</div><div class="line">    nu_sigma_f (n_materials, n_groups),</div><div class="line">    sigma_s (n_materials, n_groups, n_groups),</div><div class="line">    chi (n_materials, n_groups)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">switch</span> (this-&gt;n_groups)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m=0; m&lt;n_materials; ++m)</div><div class="line">          {</div><div class="line">            diffusion[m][0] = 1.2;</div><div class="line">            diffusion[m][1] = 0.4;</div><div class="line">            chi[m][0]       = 1.0;</div><div class="line">            chi[m][1]       = 0.0;</div><div class="line">            sigma_r[m][0]   = 0.03;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1=0; group_1&lt;n_groups; ++group_1)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2=0; group_2&lt;n_groups; ++ group_2)</div><div class="line">                sigma_s[m][group_1][group_2]   = 0.0;</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        diffusion[5][1]  = 0.2;</div><div class="line"></div><div class="line">        sigma_r[4][0]    = 0.026;</div><div class="line">        sigma_r[5][0]    = 0.051;</div><div class="line">        sigma_r[6][0]    = 0.026;</div><div class="line">        sigma_r[7][0]    = 0.050;</div><div class="line"></div><div class="line">        sigma_r[0][1]    = 0.100;</div><div class="line">        sigma_r[1][1]    = 0.200;</div><div class="line">        sigma_r[2][1]    = 0.250;</div><div class="line">        sigma_r[3][1]    = 0.300;</div><div class="line">        sigma_r[4][1]    = 0.020;</div><div class="line">        sigma_r[5][1]    = 0.040;</div><div class="line">        sigma_r[6][1]    = 0.020;</div><div class="line">        sigma_r[7][1]    = 0.800;</div><div class="line"></div><div class="line">        nu_sigma_f[0][0] = 0.0050;</div><div class="line">        nu_sigma_f[1][0] = 0.0075;</div><div class="line">        nu_sigma_f[2][0] = 0.0075;</div><div class="line">        nu_sigma_f[3][0] = 0.0075;</div><div class="line">        nu_sigma_f[4][0] = 0.000;</div><div class="line">        nu_sigma_f[5][0] = 0.000;</div><div class="line">        nu_sigma_f[6][0] = 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-7;</div><div class="line">        nu_sigma_f[7][0] = 0.00;</div><div class="line"></div><div class="line">        nu_sigma_f[0][1] = 0.125;</div><div class="line">        nu_sigma_f[1][1] = 0.300;</div><div class="line">        nu_sigma_f[2][1] = 0.375;</div><div class="line">        nu_sigma_f[3][1] = 0.450;</div><div class="line">        nu_sigma_f[4][1] = 0.000;</div><div class="line">        nu_sigma_f[5][1] = 0.000;</div><div class="line">        nu_sigma_f[6][1] = 3<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6;</div><div class="line">        nu_sigma_f[7][1] = 0.00;</div><div class="line"></div><div class="line">        sigma_s[0][0][1] = 0.020;</div><div class="line">        sigma_s[1][0][1] = 0.015;</div><div class="line">        sigma_s[2][0][1] = 0.015;</div><div class="line">        sigma_s[3][0][1] = 0.015;</div><div class="line">        sigma_s[4][0][1] = 0.025;</div><div class="line">        sigma_s[5][0][1] = 0.050;</div><div class="line">        sigma_s[6][0][1] = 0.025;</div><div class="line">        sigma_s[7][0][1] = 0.010;</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a> (<span class="stringliteral">&quot;Presently, only data for 2 groups is implemented&quot;</span>));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  MaterialData::get_diffusion_coefficient (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group &lt; n_groups,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group, 0, n_groups));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> diffusion[material_id][group];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  MaterialData::get_removal_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group &lt; n_groups,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group, 0, n_groups));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sigma_r[material_id][group];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  MaterialData::get_fission_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group &lt; n_groups,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group, 0, n_groups));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> nu_sigma_f[material_id][group];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  MaterialData::get_scattering_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group_1 &lt; n_groups,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group_1, 0, n_groups));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group_2 &lt; n_groups,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group_2, 0, n_groups));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sigma_s[material_id][group_1][group_2];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  MaterialData::get_fission_spectrum (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (group &lt; n_groups,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (group, 0, n_groups));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (material_id &lt; n_materials,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (material_id, 0, n_materials));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> chi[material_id][group];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  MaterialData::get_fission_dist_XS (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_1,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_2,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_id)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (get_fission_spectrum(group_1, material_id) *</div><div class="line">            get_fission_XS(group_2, material_id));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>EnergyGroup</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line"></div><div class="line">    EnergyGroup (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        group,</div><div class="line">                 <span class="keyword">const</span> MaterialData       &amp;material_data,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_linear_system ();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells () <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system_matrix ();</div><div class="line">    <span class="keywordtype">void</span> assemble_ingroup_rhs (<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;extraneous_source);</div><div class="line">    <span class="keywordtype">void</span> assemble_cross_group_rhs (<span class="keyword">const</span> EnergyGroup&lt;dim&gt; &amp;g_prime);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span>   solve ();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_fission_source () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span>   output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span>   estimate_errors (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span>   refine_grid (<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>         refine_threshold,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>         coarsen_threshold);</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_old;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            group;</div><div class="line">    <span class="keyword">const</span> MaterialData           &amp;material_data;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>            triangulation;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a>     &amp;fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>               dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>               sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>          system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                system_rhs;</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>              hanging_node_constraints;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_cross_group_rhs_recursive (<span class="keyword">const</span> EnergyGroup&lt;dim&gt;                        &amp;g_prime,</div><div class="line">                                        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell_g,</div><div class="line">                                        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell_g_prime,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                       prolongation_matrix);</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  EnergyGroup&lt;dim&gt;::EnergyGroup (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        group,</div><div class="line">                                 <span class="keyword">const</span> MaterialData       &amp;material_data,</div><div class="line">                                 <span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid,</div><div class="line">                                 <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe)</div><div class="line">    :</div><div class="line">    group (group),</div><div class="line">    material_data (material_data),</div><div class="line">    fe (fe),</div><div class="line">    dof_handler (triangulation)</div><div class="line">  {</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a1f2bf1d34aacdba358add7fd59b32822">copy_triangulation</a> (coarse_grid);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">  EnergyGroup&lt;dim&gt;::n_active_cells ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">  EnergyGroup&lt;dim&gt;::n_dofs ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  EnergyGroup&lt;dim&gt;::setup_linear_system ()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs = dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line"></div><div class="line">    hanging_node_constraints.clear ();</div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                             hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close ();</div><div class="line"></div><div class="line">    system_matrix.clear ();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_dofs, n_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">    hanging_node_constraints.condense (dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">    system_rhs.reinit (n_dofs);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (solution.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == 0)</div><div class="line">      {</div><div class="line">        solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_dofs);</div><div class="line">        solution_old.reinit(n_dofs);</div><div class="line">        solution_old = 1.0;</div><div class="line">        solution = solution_old;</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    boundary_values.clear();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                                2*i+1,</div><div class="line">                                                <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                                boundary_values);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  EnergyGroup&lt;dim&gt;::assemble_system_matrix ()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient</div><div class="line">          = material_data.get_diffusion_coefficient (group, cell-&gt;material_id());</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> removal_XS</div><div class="line">          = material_data.get_removal_XS (group,cell-&gt;material_id());</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              cell_matrix(i,j) += ((diffusion_coefficient *</div><div class="line">                                    fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                    fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point)</div><div class="line">                                    +</div><div class="line">                                    removal_XS *</div><div class="line">                                    fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                    fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point))</div><div class="line">                                   *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            system_matrix.add (local_dof_indices[i],</div><div class="line">                               local_dof_indices[j],</div><div class="line">                               cell_matrix(i,j));</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense (system_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EnergyGroup&lt;dim&gt;::assemble_ingroup_rhs (<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;extraneous_source)</div><div class="line">  {</div><div class="line">    system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            cell_rhs (dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;       extraneous_source_values (n_q_points);</div><div class="line">    std::vector&lt;double&gt;       solution_old_values (n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> fission_dist_XS</div><div class="line">          = material_data.get_fission_dist_XS (group, group, cell-&gt;material_id());</div><div class="line"></div><div class="line">        extraneous_source.<a class="code" href="classFunction.html#afc0acd3155a0c854dee816a096d88165">value_list</a> (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                      extraneous_source_values);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (solution_old, solution_old_values);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            cell_rhs(i) += ((extraneous_source_values[q_point]</div><div class="line">                             +</div><div class="line">                             fission_dist_XS *</div><div class="line">                             solution_old_values[q_point]) *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EnergyGroup&lt;dim&gt;::assemble_cross_group_rhs (<span class="keyword">const</span> EnergyGroup&lt;dim&gt; &amp;g_prime)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (group == g_prime.group)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::list&lt;std::pair&lt;typename DoFHandler&lt;dim&gt;::cell_iterator,</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a>&gt; &gt;</div><div class="line">          cell_list</div><div class="line">          = <a class="code" href="namespaceGridTools.html#a32a5016c746ad756046ecff264dfa60d">GridTools::get_finest_common_cells</a> (dof_handler,</div><div class="line">                                                g_prime.dof_handler);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> std::list&lt;std::pair&lt;typename DoFHandler&lt;dim&gt;::cell_iterator,</div><div class="line">             <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a>&gt; &gt;</div><div class="line">             ::const_iterator</div><div class="line">             cell_iter = cell_list.begin();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell_iter!=cell_list.end(); ++cell_iter)</div><div class="line">      {</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> unit_matrix (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;unit_matrix.m(); ++i)</div><div class="line">          unit_matrix(i,i) = 1;</div><div class="line">        assemble_cross_group_rhs_recursive (g_prime,</div><div class="line">                                            cell_iter-&gt;first,</div><div class="line">                                            cell_iter-&gt;second,</div><div class="line">                                            unit_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  EnergyGroup&lt;dim&gt;::</div><div class="line">  assemble_cross_group_rhs_recursive (<span class="keyword">const</span> EnergyGroup&lt;dim&gt;                        &amp;g_prime,</div><div class="line">                                      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell_g,</div><div class="line">                                      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell_g_prime,</div><div class="line">                                      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                       prolongation_matrix)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (!cell_g-&gt;has_children() &amp;&amp; !cell_g_prime-&gt;has_children())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_g-&gt;level() &gt; cell_g_prime-&gt;level())</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell_g);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell_g_prime);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> fission_dist_XS</div><div class="line">          = material_data.get_fission_dist_XS (group, g_prime.group,</div><div class="line">                                               cell_g_prime-&gt;material_id());</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> scattering_XS</div><div class="line">          = material_data.get_scattering_XS (g_prime.group, group,</div><div class="line">                                             cell_g_prime-&gt;material_id());</div><div class="line"></div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>    local_mass_matrix_f (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">                                                   fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>    local_mass_matrix_g (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">                                                   fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++j)</div><div class="line">              {</div><div class="line">                local_mass_matrix_f(i,j) += (fission_dist_XS *</div><div class="line">                                             fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                             fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point) *</div><div class="line">                                             fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                local_mass_matrix_g(i,j) += (scattering_XS *</div><div class="line">                                             fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                             fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point) *</div><div class="line">                                             fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              }</div><div class="line"></div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       g_prime_new_values (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       g_prime_old_values (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">        cell_g_prime-&gt;get_dof_values (g_prime.solution_old, g_prime_old_values);</div><div class="line">        cell_g_prime-&gt;get_dof_values (g_prime.solution,     g_prime_new_values);</div><div class="line"></div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       tmp (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_g-&gt;level() &gt; cell_g_prime-&gt;level())</div><div class="line">          {</div><div class="line">            prolongation_matrix.<a class="code" href="classFullMatrix.html#a983d5ce20f0966866002dc762b964241">vmult</a> (tmp, g_prime_old_values);</div><div class="line">            local_mass_matrix_f.vmult (cell_rhs, tmp);</div><div class="line"></div><div class="line">            prolongation_matrix.<a class="code" href="classFullMatrix.html#a983d5ce20f0966866002dc762b964241">vmult</a> (tmp, g_prime_new_values);</div><div class="line">            local_mass_matrix_g.vmult_add (cell_rhs, tmp);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            local_mass_matrix_f.vmult (tmp, g_prime_old_values);</div><div class="line">            prolongation_matrix.<a class="code" href="classFullMatrix.html#a39d67895efe54f7810eec53925d72513">Tvmult</a> (cell_rhs, tmp);</div><div class="line"></div><div class="line">            local_mass_matrix_g.vmult (tmp, g_prime_new_values);</div><div class="line">            prolongation_matrix.<a class="code" href="classFullMatrix.html#abed6fffa5cb201496d751a4427cb59d6">Tvmult_add</a> (cell_rhs, tmp);</div><div class="line">          }</div><div class="line"></div><div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">        cell_g-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> child=0; child&lt;GeometryInfo&lt;dim&gt;::max_children_per_cell; ++child)</div><div class="line">        {</div><div class="line">          <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   new_matrix (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">          fe.<a class="code" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix</a>(child).<a class="code" href="classFullMatrix.html#ac93d06d0f1305519dface996c8f93823">mmult</a> (new_matrix,</div><div class="line">                                                   prolongation_matrix);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (cell_g-&gt;has_children())</div><div class="line">            assemble_cross_group_rhs_recursive (g_prime,</div><div class="line">                                                cell_g-&gt;child(child), cell_g_prime,</div><div class="line">                                                new_matrix);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            assemble_cross_group_rhs_recursive (g_prime,</div><div class="line">                                                cell_g, cell_g_prime-&gt;child(child),</div><div class="line">                                                new_matrix);</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> EnergyGroup&lt;dim&gt;::get_fission_source ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;       solution_values (n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> fission_source = 0;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> fission_XS</div><div class="line">          = material_data.get_fission_XS(group, cell-&gt;material_id());</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (solution, solution_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          fission_source += (fission_XS *</div><div class="line">                             solution_values[q_point] *</div><div class="line">                             fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> fission_source;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  EnergyGroup&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    hanging_node_constraints.condense (system_rhs);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                        system_matrix,</div><div class="line">                                        solution,</div><div class="line">                                        system_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (system_matrix.m(),</div><div class="line">                                            1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12*system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    cg.solve (system_matrix, solution, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute (solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EnergyGroup&lt;dim&gt;::estimate_errors (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a> (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                        solution,</div><div class="line">                                        error_indicators);</div><div class="line">    error_indicators /= solution.<a class="code" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">linfty_norm</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EnergyGroup&lt;dim&gt;::refine_grid (<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;error_indicators,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">double</span>         refine_threshold,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">double</span>         coarsen_threshold)</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">    endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (error_indicators(cell-&gt;active_cell_index()) &gt; refine_threshold)</div><div class="line">        cell-&gt;set_refine_flag ();</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (error_indicators(cell-&gt;active_cell_index()) &lt; coarsen_threshold)</div><div class="line">        cell-&gt;set_coarsen_flag ();</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> soltrans(dof_handler);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">    soltrans.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">    this-&gt;setup_linear_system ();</div><div class="line"></div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    soltrans.interpolate(solution_old, solution);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(solution);</div><div class="line"></div><div class="line">    solution_old.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_old = solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  EnergyGroup&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string filename = std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(group, 2) +</div><div class="line">                                 <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2) +</div><div class="line">                                 <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">    std::ofstream output (filename.c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>NeutronDiffusionProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">class </span>Parameters</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Parameters ();</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">      <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_groups;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_cycles;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> convergence_tolerance;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    NeutronDiffusionProblem (<span class="keyword">const</span> Parameters &amp;parameters);</div><div class="line">    ~NeutronDiffusionProblem ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> initialize_problem();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_grid ();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_total_fission_source () <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> Parameters  &amp;parameters;</div><div class="line">    <span class="keyword">const</span> MaterialData material_data;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> k_eff;</div><div class="line"></div><div class="line">    std::vector&lt;EnergyGroup&lt;dim&gt;*&gt; energy_groups;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  NeutronDiffusionProblem&lt;dim&gt;::Parameters::Parameters ()</div><div class="line">    :</div><div class="line">    n_groups (2),</div><div class="line">    n_refinement_cycles (5),</div><div class="line">    fe_degree (2),</div><div class="line">    convergence_tolerance (1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  NeutronDiffusionProblem&lt;dim&gt;::Parameters::</div><div class="line">  declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Number of energy groups&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (),</div><div class="line">                       <span class="stringliteral">&quot;The number of energy different groups considered&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Refinement cycles&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (),</div><div class="line">                       <span class="stringliteral">&quot;Number of refinement cycles to be performed&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Finite element degree&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (),</div><div class="line">                       <span class="stringliteral">&quot;Polynomial degree of the finite element to be used&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Power iteration tolerance&quot;</span>, <span class="stringliteral">&quot;1e-12&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (),</div><div class="line">                       <span class="stringliteral">&quot;Inner power iterations are stopped when the change in k_eff falls &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;below this tolerance&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  NeutronDiffusionProblem&lt;dim&gt;::Parameters::</div><div class="line">  get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    n_groups              = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Number of energy groups&quot;</span>);</div><div class="line">    n_refinement_cycles   = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Refinement cycles&quot;</span>);</div><div class="line">    fe_degree             = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Finite element degree&quot;</span>);</div><div class="line">    convergence_tolerance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;Power iteration tolerance&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  NeutronDiffusionProblem&lt;dim&gt;::</div><div class="line">  NeutronDiffusionProblem (<span class="keyword">const</span> Parameters &amp;parameters)</div><div class="line">    :</div><div class="line">    parameters (parameters),</div><div class="line">    material_data (parameters.n_groups),</div><div class="line">    fe (parameters.fe_degree),</div><div class="line">    k_eff (<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;double&gt;::quiet_NaN())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  NeutronDiffusionProblem&lt;dim&gt;::~NeutronDiffusionProblem ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;energy_groups.size(); ++group)</div><div class="line">      <span class="keyword">delete</span> energy_groups[group];</div><div class="line"></div><div class="line">    energy_groups.resize (0);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NeutronDiffusionProblem&lt;dim&gt;::initialize_problem()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rods_per_assembly_x = 17,</div><div class="line">                       rods_per_assembly_y = 17;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> pin_pitch_x = 1.26,</div><div class="line">                 pin_pitch_y = 1.26;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> assembly_height = 200;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> assemblies_x = 2,</div><div class="line">                       assemblies_y = 2,</div><div class="line">                       assemblies_z = 1;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> upper_right = (dim == 2</div><div class="line">                                    ?</div><div class="line">                                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (assemblies_x*rods_per_assembly_x*pin_pitch_x,</div><div class="line">                                                assemblies_y*rods_per_assembly_y*pin_pitch_y)</div><div class="line">                                    :</div><div class="line">                                    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (assemblies_x*rods_per_assembly_x*pin_pitch_x,</div><div class="line">                                                assemblies_y*rods_per_assembly_y*pin_pitch_y,</div><div class="line">                                                assemblies_z*assembly_height));</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; n_subdivisions;</div><div class="line">    n_subdivisions.push_back (assemblies_x*rods_per_assembly_x);</div><div class="line">    <span class="keywordflow">if</span> (dim &gt;= 2)</div><div class="line">      n_subdivisions.push_back (assemblies_y*rods_per_assembly_y);</div><div class="line">    <span class="keywordflow">if</span> (dim &gt;= 3)</div><div class="line">      n_subdivisions.push_back (assemblies_z);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> coarse_grid;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (coarse_grid,</div><div class="line">                                               n_subdivisions,</div><div class="line">                                               bottom_left,</div><div class="line">                                               upper_right,</div><div class="line">                                               <span class="keyword">true</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_assemblies=4;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    assembly_materials[n_assemblies][rods_per_assembly_x][rods_per_assembly_y]</div><div class="line">    =</div><div class="line">    {</div><div class="line">      {</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 5, 1, 1, 5, 1, 1, 7, 1, 1, 5, 1, 1, 5, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }</div><div class="line">      },</div><div class="line">      {</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 8, 1, 1, 8, 1, 1, 7, 1, 1, 8, 1, 1, 8, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },</div><div class="line">        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }</div><div class="line">      },</div><div class="line">      {</div><div class="line">        { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 },</div><div class="line">        { 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2 },</div><div class="line">        { 2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2 },</div><div class="line">        { 2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2 },</div><div class="line">        { 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2 },</div><div class="line">        { 2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2 },</div><div class="line">        { 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2 },</div><div class="line">        { 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2 },</div><div class="line">        { 2, 3, 5, 4, 4, 5, 4, 4, 7, 4, 4, 5, 4, 4, 5, 3, 2 },</div><div class="line">        { 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2 },</div><div class="line">        { 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2 },</div><div class="line">        { 2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2 },</div><div class="line">        { 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2 },</div><div class="line">        { 2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2 },</div><div class="line">        { 2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2 },</div><div class="line">        { 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2 },</div><div class="line">        { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 }</div><div class="line">      },</div><div class="line">      {</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 },</div><div class="line">        { 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 }</div><div class="line">      }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> core[assemblies_x][assemblies_y][assemblies_z]</div><div class="line">    =  {{{0}, {2}}, {{2}, {0}}};</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = coarse_grid.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">         cell!=coarse_grid.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">         ++cell)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = cell-&gt;center();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp_x = int(cell_center[0]/pin_pitch_x);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ax = tmp_x/rods_per_assembly_x;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cx = tmp_x - ax * rods_per_assembly_x;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> tmp_y = int(cell_center[1]/pin_pitch_y);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ay = tmp_y/rods_per_assembly_y;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cy = tmp_y - ay * rods_per_assembly_y;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> az = (dim == 2</div><div class="line">                                 ?</div><div class="line">                                 0</div><div class="line">                                 :</div><div class="line">                                 int (cell_center[dim-1]/assembly_height));</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (ax &lt; assemblies_x, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (ay &lt; assemblies_y, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (az &lt; assemblies_z, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (core[ax][ay][az] &lt; n_assemblies, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cx &lt; rods_per_assembly_x, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cy &lt; rods_per_assembly_y, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        cell-&gt;set_material_id(assembly_materials[core[ax][ay][az]][cx][cy] - 1);</div><div class="line">      }</div><div class="line"></div><div class="line">    energy_groups.resize (parameters.n_groups);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">      energy_groups[group] = <span class="keyword">new</span> EnergyGroup&lt;dim&gt; (group, material_data,</div><div class="line">                                                   coarse_grid, fe);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> NeutronDiffusionProblem&lt;dim&gt;::get_total_fission_source ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;Threads::Thread&lt;double&gt; &gt; threads;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">      threads.push_back (<a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a> (&amp;EnergyGroup&lt;dim&gt;::get_fission_source,</div><div class="line">                                              *energy_groups[group]));</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> fission_source = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">      fission_source += threads[group].return_value ();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> fission_source;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NeutronDiffusionProblem&lt;dim&gt;::refine_grid ()</div><div class="line">  {</div><div class="line">    std::vector&lt;types::global_dof_index&gt; n_cells (parameters.n_groups);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">      n_cells[group] = energy_groups[group]-&gt;n_active_cells();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;float&gt;</a>  group_error_indicators(n_cells);</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classThreads_1_1ThreadGroup.html">Threads::ThreadGroup&lt;&gt;</a> threads;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">        threads += <a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a> (&amp;EnergyGroup&lt;dim&gt;::estimate_errors,</div><div class="line">                                        *energy_groups[group],</div><div class="line">                                        group_error_indicators.block(group));</div><div class="line">      threads.<a class="code" href="classThreads_1_1ThreadGroup.html#af715c77cbda5c5601f956896ca08cd37">join_all</a> ();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> max_error         = group_error_indicators.linfty_norm();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> refine_threshold  = 0.3*max_error;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coarsen_threshold = 0.01*max_error;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classThreads_1_1ThreadGroup.html">Threads::ThreadGroup&lt;&gt;</a> threads;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">        threads += <a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a> (&amp;EnergyGroup&lt;dim&gt;::refine_grid,</div><div class="line">                                        *energy_groups[group],</div><div class="line">                                        group_error_indicators.block(group),</div><div class="line">                                        refine_threshold,</div><div class="line">                                        coarsen_threshold);</div><div class="line">      threads.<a class="code" href="classThreads_1_1ThreadGroup.html#af715c77cbda5c5601f956896ca08cd37">join_all</a> ();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NeutronDiffusionProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    boost::io::ios_flags_saver restore_flags(std::cout);</div><div class="line">    std::cout &lt;&lt; std::setprecision (12) &lt;&lt; std::fixed;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> k_eff_old = k_eff;</div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">    timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;parameters.n_refinement_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            initialize_problem();</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">              energy_groups[group]-&gt;setup_linear_system ();</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            refine_grid ();</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">              energy_groups[group]-&gt;solution *= k_eff;</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Numbers of active cells:       &quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">          std::cout &lt;&lt; energy_groups[group]-&gt;n_active_cells()</div><div class="line">                    &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Numbers of degrees of freedom: &quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">          std::cout &lt;&lt; energy_groups[group]-&gt;n_dofs()</div><div class="line">                    &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classThreads_1_1ThreadGroup.html">Threads::ThreadGroup&lt;&gt;</a> threads;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">          threads += <a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a></div><div class="line">                     (&amp;EnergyGroup&lt;dim&gt;::assemble_system_matrix,</div><div class="line">                      *energy_groups[group]);</div><div class="line">        threads.<a class="code" href="classThreads_1_1ThreadGroup.html#af715c77cbda5c5601f956896ca08cd37">join_all</a> ();</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> error;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration = 1;</div><div class="line">        <span class="keywordflow">do</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">              {</div><div class="line">                energy_groups[group]-&gt;assemble_ingroup_rhs (<a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bgroup=0; bgroup&lt;parameters.n_groups; ++bgroup)</div><div class="line">                  energy_groups[group]-&gt;assemble_cross_group_rhs (*energy_groups[bgroup]);</div><div class="line"></div><div class="line">                energy_groups[group]-&gt;solve ();</div><div class="line">              }</div><div class="line"></div><div class="line">            k_eff = get_total_fission_source();</div><div class="line">            error = fabs(k_eff-k_eff_old)/fabs(k_eff);</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;   Iteration &quot;</span> &lt;&lt; iteration</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;: k_eff=&quot;</span> &lt;&lt; k_eff</div><div class="line">                      &lt;&lt; std::endl;</div><div class="line">            k_eff_old=k_eff;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">              {</div><div class="line">                energy_groups[group]-&gt;solution_old = energy_groups[group]-&gt;solution;</div><div class="line">                energy_groups[group]-&gt;solution_old /= k_eff;</div><div class="line">              }</div><div class="line"></div><div class="line">            ++iteration;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">while</span> ((error &gt; parameters.convergence_tolerance)</div><div class="line">               &amp;&amp;</div><div class="line">               (iteration &lt; 500));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group=0; group&lt;parameters.n_groups; ++group)</div><div class="line">          energy_groups[group]-&gt;output_results (cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Cycle=&quot;</span> &lt;&lt; cycle</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, n_dofs=&quot;</span> &lt;&lt; energy_groups[0]-&gt;n_dofs() + energy_groups[1]-&gt;n_dofs()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;,  k_eff=&quot;</span> &lt;&lt; k_eff</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, time=&quot;</span> &lt;&lt; timer()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step28;</div><div class="line"></div><div class="line">      std::string filename;</div><div class="line">      <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">        filename = <span class="stringliteral">&quot;project.prm&quot;</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        filename = argv[1];</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> parameter_handler;</div><div class="line"></div><div class="line">      NeutronDiffusionProblem&lt;dim&gt;::Parameters parameters;</div><div class="line">      parameters.declare_parameters (parameter_handler);</div><div class="line"></div><div class="line">      parameter_handler.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (filename);</div><div class="line"></div><div class="line">      parameters.get_parameters (parameter_handler);</div><div class="line"></div><div class="line"></div><div class="line">      NeutronDiffusionProblem&lt;dim&gt; neutron_diffusion_problem (parameters);</div><div class="line">      neutron_diffusion_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
