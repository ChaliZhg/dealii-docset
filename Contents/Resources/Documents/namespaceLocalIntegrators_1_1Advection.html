<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: LocalIntegrators::Advection Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLocalIntegrators.html">LocalIntegrators</a></li><li class="navelem"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html">Advection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LocalIntegrators::Advection Namespace Reference<div class="ingroups"><a class="el" href="group__Integrators.html">Integrators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Local integrators related to advection along a vector field and its DG formulations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa57fdeca62a0708d77768a3bb2aeb826"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aa57fdeca62a0708d77768a3bb2aeb826"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;M, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fetest, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, const double factor=1.)</td></tr>
<tr class="separator:aa57fdeca62a0708d77768a3bb2aeb826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21c42d71eba9418a5852d8b5b5a4e0e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ac21c42d71eba9418a5852d8b5b5a4e0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#ac21c42d71eba9418a5852d8b5b5a4e0e">cell_residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;input, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, double factor=1.)</td></tr>
<tr class="separator:ac21c42d71eba9418a5852d8b5b5a4e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260ddb49d8ff871db5cac34b27cdfbf5"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a260ddb49d8ff871db5cac34b27cdfbf5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#a260ddb49d8ff871db5cac34b27cdfbf5">cell_residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &gt; &amp;input, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, double factor=1.)</td></tr>
<tr class="separator:a260ddb49d8ff871db5cac34b27cdfbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6929bbe4173b3db1734146e8e8f084"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a4e6929bbe4173b3db1734146e8e8f084"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#a4e6929bbe4173b3db1734146e8e8f084">cell_residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe, const std::vector&lt; double &gt; &amp;input, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, double factor=1.)</td></tr>
<tr class="separator:a4e6929bbe4173b3db1734146e8e8f084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e2509d0af42385d38d1b32f2916371"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ae3e2509d0af42385d38d1b32f2916371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#ae3e2509d0af42385d38d1b32f2916371">cell_residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;input, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, double factor=1.)</td></tr>
<tr class="separator:ae3e2509d0af42385d38d1b32f2916371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36294df416ad121606f4a8b90b783713"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a36294df416ad121606f4a8b90b783713"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#a36294df416ad121606f4a8b90b783713">upwind_value_matrix</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;M, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fetest, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, double factor=1.)</td></tr>
<tr class="separator:a36294df416ad121606f4a8b90b783713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c1176070ebd513e84b628dd0e93d99"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aa9c1176070ebd513e84b628dd0e93d99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#aa9c1176070ebd513e84b628dd0e93d99">upwind_value_residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe, const std::vector&lt; double &gt; &amp;input, const std::vector&lt; double &gt; &amp;data, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, double factor=1.)</td></tr>
<tr class="separator:aa9c1176070ebd513e84b628dd0e93d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b78eeefa3218e84eb87986644a73f22"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a4b78eeefa3218e84eb87986644a73f22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#a4b78eeefa3218e84eb87986644a73f22">upwind_value_residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;input, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;data, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, double factor=1.)</td></tr>
<tr class="separator:a4b78eeefa3218e84eb87986644a73f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6540c8fd6b3d6c02909e5b665409c178"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6540c8fd6b3d6c02909e5b665409c178"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#a6540c8fd6b3d6c02909e5b665409c178">upwind_value_matrix</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;M11, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;M12, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;M21, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;M22, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe1, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe2, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fetest1, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fetest2, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, const double factor=1.)</td></tr>
<tr class="separator:a6540c8fd6b3d6c02909e5b665409c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b8ccdd254c0f98364431c393510536"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad2b8ccdd254c0f98364431c393510536"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#ad2b8ccdd254c0f98364431c393510536">upwind_face_residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result1, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result2, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe1, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe2, const std::vector&lt; double &gt; &amp;input1, const std::vector&lt; double &gt; &amp;input2, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, const double factor=1.)</td></tr>
<tr class="separator:ad2b8ccdd254c0f98364431c393510536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9000d9d268931603fc50de20562a1284"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a9000d9d268931603fc50de20562a1284"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLocalIntegrators_1_1Advection.html#a9000d9d268931603fc50de20562a1284">upwind_face_residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result1, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;result2, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe1, const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;fe2, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;input1, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;input2, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;velocity, const double factor=1.)</td></tr>
<tr class="separator:a9000d9d268931603fc50de20562a1284"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Local integrators related to advection along a vector field and its DG formulations. </p>
<p>All advection operators depend on an advection velocity denoted by <b>w</b> in the formulas below. It is denoted as <code>velocity</code> in the parameter lists.</p>
<p>The functions <a class="el" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix()</a> and both <a class="el" href="namespaceLocalIntegrators_1_1Advection.html#a36294df416ad121606f4a8b90b783713">upwind_value_matrix()</a> are taking the equation in weak form, that is, the directional derivative is on the test function.</p>
<dl class="section author"><dt>Author</dt><dd>Guido Kanschat </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2012 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa57fdeca62a0708d77768a3bb2aeb826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57fdeca62a0708d77768a3bb2aeb826">&#9670;&nbsp;</a></span>cell_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::cell_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fetest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceLocalIntegrators_1_1Advection.html" title="Local integrators related to advection along a vector field and its DG formulations. ">Advection</a> along the direction <b>w</b> in weak form with derivative on the test function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ m_{ij} = \int_Z u_j\,(\mathbf w \cdot \nabla) v_i \, dx. \]" src="form_909.png"/>
</p>
<p>The <a class="el" href="classFiniteElement.html">FiniteElement</a> in <code>fe</code> may be scalar or vector valued. In the latter case, the advection operator is applied to each component separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The advection matrix obtained as result </td></tr>
    <tr><td class="paramname">fe</td><td>The <a class="el" href="classFEValues.html">FEValues</a> object describing the local trial function space. <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea" title="Shape function values. ">update_values</a> and <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20" title="Shape function gradients. ">update_gradients</a>, and <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85" title="Transformed quadrature weights. ">update_JxW_values</a> must be set. </td></tr>
    <tr><td class="paramname">fetest</td><td>The <a class="el" href="classFEValues.html">FEValues</a> object describing the local test function space. <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea" title="Shape function values. ">update_values</a> and <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20" title="Shape function gradients. ">update_gradients</a> must be set. </td></tr>
    <tr><td class="paramname">velocity</td><td>The advection velocity, a vector of dimension <code>dim</code>. Each component may either contain a vector of length one, in which case a constant velocity is assumed, or a vector with as many entries as quadrature points if the velocity is not constant. </td></tr>
    <tr><td class="paramname">factor</td><td>is an optional multiplication factor for the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Guido Kanschat </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2012 </dd></dl>

<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00075">75</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="ac21c42d71eba9418a5852d8b5b5a4e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21c42d71eba9418a5852d8b5b5a4e0e">&#9670;&nbsp;</a></span>cell_residual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::cell_residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar advection residual operator in strong form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ r_i = \int_Z (\mathbf w \cdot \nabla)u\, v_i \, dx. \]" src="form_910.png"/>
</p>
<dl class="section warning"><dt>Warning</dt><dd>This is not the residual consistent with <a class="el" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix()</a>, but with its transpose. </dd></dl>

<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00132">132</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="a260ddb49d8ff871db5cac34b27cdfbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260ddb49d8ff871db5cac34b27cdfbf5">&#9670;&nbsp;</a></span>cell_residual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::cell_residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vector-valued advection residual operator in strong form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ r_i = \int_Z \bigl((\mathbf w \cdot \nabla) \mathbf u\bigr) \cdot\mathbf v_i \, dx. \]" src="form_911.png"/>
</p>
<dl class="section warning"><dt>Warning</dt><dd>This is not the residual consistent with <a class="el" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix()</a>, but with its transpose. </dd></dl>

<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00175">175</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="a4e6929bbe4173b3db1734146e8e8f084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6929bbe4173b3db1734146e8e8f084">&#9670;&nbsp;</a></span>cell_residual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::cell_residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar advection residual operator in weak form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ r_i = \int_Z (\mathbf w \cdot \nabla)v\, u_i \, dx. \]" src="form_912.png"/>
</p>
 
<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00216">216</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="ae3e2509d0af42385d38d1b32f2916371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e2509d0af42385d38d1b32f2916371">&#9670;&nbsp;</a></span>cell_residual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::cell_residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vector-valued advection residual operator in weak form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ r_i = \int_Z \bigl((\mathbf w \cdot \nabla) \mathbf v\bigr) \cdot\mathbf u_i \, dx. \]" src="form_913.png"/>
</p>
 
<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00256">256</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="a36294df416ad121606f4a8b90b783713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36294df416ad121606f4a8b90b783713">&#9670;&nbsp;</a></span>upwind_value_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::upwind_value_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fetest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Upwind flux at the boundary for weak advection operator. This is the value of the trial function at the outflow boundary and zero else: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_{ij} = \int_{\partial\Omega} [\mathbf w\cdot\mathbf n]_+ u_i v_j \, ds \]" src="form_914.png"/>
</p>
<p>The <code>velocity</code> is provided as a <a class="el" href="classVectorSlice.html">VectorSlice</a>, having <code>dim</code> vectors, one for each velocity component. Each of the vectors must either have only a single entry, if the advection velocity is constant, or have an entry for each quadrature point.</p>
<p>The finite element can have several components, in which case each component is advected by the same velocity. </p>

<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00308">308</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="aa9c1176070ebd513e84b628dd0e93d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c1176070ebd513e84b628dd0e93d99">&#9670;&nbsp;</a></span>upwind_value_residual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::upwind_value_residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar case: Residual for upwind flux at the boundary for weak advection operator. This is the value of the trial function at the outflow boundary and the value of the incoming boundary condition on the inflow boundary: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_{ij} = \int_{\partial\Omega} (\mathbf w\cdot\mathbf n) \widehat u v_j \, ds \]" src="form_915.png"/>
</p>
<p>Here, the numerical flux <img class="formulaInl" alt="$\widehat u$" src="form_916.png"/> is the upwind value at the face, namely the finite element function whose values are given in the argument <code>input</code> on the outflow boundary. On the inflow boundary, it is the inhomogenous boundary value in the argument <code>data</code>.</p>
<p>The <code>velocity</code> is provided as a <a class="el" href="classVectorSlice.html">VectorSlice</a>, having <code>dim</code> vectors, one for each velocity component. Each of the vectors must either have only a single entry, if the advection velocity is constant, or have an entry for each quadrature point.</p>
<p>The finite element can have several components, in which case each component is advected by the same velocity. </p>

<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00380">380</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="a4b78eeefa3218e84eb87986644a73f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b78eeefa3218e84eb87986644a73f22">&#9670;&nbsp;</a></span>upwind_value_residual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::upwind_value_residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vector-valued case: Residual for upwind flux at the boundary for weak advection operator. This is the value of the trial function at the outflow boundary and the value of the incoming boundary condition on the inflow boundary: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_{ij} = \int_{\partial\Omega} (\mathbf w\cdot\mathbf n) \widehat u v_j \, ds \]" src="form_915.png"/>
</p>
<p>Here, the numerical flux <img class="formulaInl" alt="$\widehat u$" src="form_916.png"/> is the upwind value at the face, namely the finite element function whose values are given in the argument <code>input</code> on the outflow boundary. On the inflow boundary, it is the inhomogenous boundary value in the argument <code>data</code>.</p>
<p>The <code>velocity</code> is provided as a <a class="el" href="classVectorSlice.html">VectorSlice</a>, having <code>dim</code> vectors, one for each velocity component. Each of the vectors must either have only a single entry, if the advection velocity is constant, or have an entry for each quadrature point.</p>
<p>The finite element can have several components, in which case each component is advected by the same velocity. </p>

<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00448">448</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="a6540c8fd6b3d6c02909e5b665409c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6540c8fd6b3d6c02909e5b665409c178">&#9670;&nbsp;</a></span>upwind_value_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::upwind_value_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fetest1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fetest2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Upwind flux in the interior for weak advection operator. Matrix entries correspond to the upwind value of the trial function, multiplied by the jump of the test functions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_{ij} = \int_F \left|\mathbf w \cdot \mathbf n\right| u^\uparrow (v^\uparrow-v^\downarrow) \,ds \]" src="form_917.png"/>
</p>
<p>The <code>velocity</code> is provided as a <a class="el" href="classVectorSlice.html">VectorSlice</a>, having <code>dim</code> vectors, one for each velocity component. Each of the vectors must either have only a single entry, if the advection velocity is constant, or have an entry for each quadrature point.</p>
<p>The finite element can have several components, in which case each component is advected the same way. </p>

<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00515">515</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="ad2b8ccdd254c0f98364431c393510536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b8ccdd254c0f98364431c393510536">&#9670;&nbsp;</a></span>upwind_face_residual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::upwind_face_residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar case: Upwind flux in the interior for weak advection operator. Matrix entries correspond to the upwind value of the trial function, multiplied by the jump of the test functions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_{ij} = \int_F \left|\mathbf w \cdot \mathbf n\right| u^\uparrow (v^\uparrow-v^\downarrow) \,ds \]" src="form_917.png"/>
</p>
<p>The <code>velocity</code> is provided as a <a class="el" href="classVectorSlice.html">VectorSlice</a>, having <code>dim</code> vectors, one for each velocity component. Each of the vectors must either have only a single entry, if the advection velocity is constant, or have an entry for each quadrature point.</p>
<p>The finite element can have several components, in which case each component is advected the same way. </p>

<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00593">593</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
<a id="a9000d9d268931603fc50de20562a1284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9000d9d268931603fc50de20562a1284">&#9670;&nbsp;</a></span>upwind_face_residual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LocalIntegrators::Advection::upwind_face_residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; std::vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Vector-valued case: Upwind flux in the interior for weak advection operator. Matrix entries correspond to the upwind value of the trial function, multiplied by the jump of the test functions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ a_{ij} = \int_F \left|\mathbf w \cdot \mathbf n\right| u^\uparrow (v^\uparrow-v^\downarrow) \,ds \]" src="form_917.png"/>
</p>
<p>The <code>velocity</code> is provided as a <a class="el" href="classVectorSlice.html">VectorSlice</a>, having <code>dim</code> vectors, one for each velocity component. Each of the vectors must either have only a single entry, if the advection velocity is constant, or have an entry for each quadrature point.</p>
<p>The finite element can have several components, in which case each component is advected the same way. </p>

<p class="definition">Definition at line <a class="el" href="advection_8h_source.html#l00671">671</a> of file <a class="el" href="advection_8h_source.html">advection.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
