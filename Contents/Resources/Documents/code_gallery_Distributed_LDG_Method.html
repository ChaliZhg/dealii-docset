<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The &#39;Distributed LDG Method&#39; code gallery program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The 'Distributed LDG Method' code gallery program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<p align="center"> 
  This program was contributed by Michael Harmon &lt;mdh266@gmail.com&gt;.
  <br>
  It comes without any warranty or support by its authors or the authors of deal.II.
</p>

</p>
<p>This program is part of the <a class="el" href="CodeGallery.html">deal.II code gallery</a> and consists of the following files (click to inspect):</p><ul>
<li><a href="../code-gallery/Distributed_LDG_Method/README.md">README.md</a> (<a href="#ann-README.md">annotated version</a>)</li>
<li><a href="../code-gallery/Distributed_LDG_Method/CMakeLists.txt">CMakeLists.txt</a></li>
<li><a href="../code-gallery/Distributed_LDG_Method/Functions.cc">Functions.cc</a> (<a href="#ann-Functions.cc">annotated version</a>)</li>
<li><a href="../code-gallery/Distributed_LDG_Method/LDGPoisson.cc">LDGPoisson.cc</a> (<a href="#ann-LDGPoisson.cc">annotated version</a>)</li>
<li><a href="../code-gallery/Distributed_LDG_Method/doc/entry-name">doc/entry-name</a></li>
<li><a href="../code-gallery/Distributed_LDG_Method/image/poisson.png">image/poisson.png</a></li>
</ul>
<h1>Pictures from this code gallery program</h1>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="../code-gallery/Distributed_LDG_Method/image/poisson.png" width="250"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="ann-README.md"></a> </p><h1>Annotated version of README.md</h1>
<h1>Distributed Local Discontinuous Galerkin Methods</h1>
<h2>Introduction</h2>
<p>This code is designed to numerically solve the <a href="https://en.wikipedia.org/wiki/Poisson&apos;s_equation">Poisson equation</a></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} - \nabla \cdot \left(\ \nabla u \ \right)&amp;= f(\textbf{x}) &amp;&amp; \mbox{in} \ \Omega,\nonumber \\ -\nabla u \cdot \textbf{n} &amp;= g_{N}(\textbf{x}) &amp;&amp; \mbox{on} \ \partial \Omega_{N} \nonumber\\ u &amp;= g_{D}(\textbf{x}) &amp;&amp; \mbox{on} \ \partial \Omega_{D}. \nonumber \end{align}" src="form_4266.png"/>
</p>
<p>in 2D and 3D using the local discontinuous Galerkin (LDG) method from scratch. The tutorial codes <a class="el" href="step_12.html">step-12</a> and <a class="el" href="step_39.html">step-39</a> use the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> interface to build <a href="https://en.wikipedia.org/wiki/Discontinuous_Galerkin_method">discontinuous Galerkin (DG) methods</a>. While this is very convenient, I could not use this framework for solving my research problem and I needed write the LDG method from scratch. I thought it would be helpful for others to have access to this example that goes through writing a discontinuous Galerkin method from scatch and also shows how to do it in a distributed setting using the <a href="https://www.trilinos.org">Trilinos</a> library. This example may also be of interest to users that wish to use the LDG method, as the method is distinctly different from the <a href="http://www3.nd.edu/~zxu2/acms60790S14/unified-analy-dg-elliptic-eq.pdf">Interior Penalty Discontinuous Galerkin (IPDG)</a> methods and was not covered in other tutorials on DG methods. The LDG method is very useful when one is working with a differential equation and desires both approximations to the scalar unknown function as well as its flux. The application of a mixed method offers a mechanism whereby one can obtain both the scalar unknown function as well as its flux, however, the LDG method has less degrees of freedom compared to the <a href="https://link.springer.com/chapter/10.1007/BFb0064470">mixed method with the Raviart-Thomas element</a>. It also approximates the scalar unknown function and its flux using discontinuous polynomial basis functions and are much more suitable when one wishes to use local refinement.</p>
<h2>Compiling and Running</h2>
<p>To generate a makefile for this code using CMake, type the following command into the terminal from the main directory: </p><pre class="fragment">    cmake . -DDEAL_II_DIR=/path/to/deal.II
</pre><p>To compile the code in debug mode use: </p><pre class="fragment">    make
</pre><p>To compile the code in release mode use: </p><pre class="fragment">    make release    
</pre><p>Either of these commands will create the executable, <code>main</code>, however the release mode will make a faster executable.</p>
<p>To run the code on <code>N</code> processors type the following command into the terminal from the main directory, </p><pre class="fragment">    mpirun -np N ./main
</pre><p>The output of the code will be in <code>.vtu</code> and <code>.pvtu</code> format and be written to disk in parallel. The results can be viewed using <a href="http://www.paraview.org/">ParaView</a>.</p>
<h2>Local Discontinuous Galerkin Method</h2>
<p>In this section we discuss the LDG method and first introduce some notation. Let <img class="formulaInl" alt="$\mathcal{T}_{h} = \mathcal{T}_{h}(\Omega) \, = \, \left\{ \, \Omega_{e} \, \right\}_{e=1}^{N}$" src="form_4267.png"/> be the general triangulation of a domain <img class="formulaInl" alt="$\Omega \; \subset \; \mathbb{R}^{d}, \; d \, = \, 1, 2, 3$" src="form_4268.png"/>, into <img class="formulaInl" alt="$N$" src="form_104.png"/> non-overlapping elements <img class="formulaInl" alt="$\Omega_{e}$" src="form_4269.png"/> of diameter <img class="formulaInl" alt="$h_{e}$" src="form_4270.png"/>. The maximum size of the diameters of all elements is <img class="formulaInl" alt="$h = \max( \, h_{e}\, )$" src="form_4271.png"/>. We define <img class="formulaInl" alt="$\mathcal{E}_{h}$" src="form_4272.png"/> to be the set of all element faces and <img class="formulaInl" alt="$\mathcal{E}_{h}^{i} $" src="form_4273.png"/> to be the set of all interior faces of elements which do not intersect the total boundary <img class="formulaInl" alt="$(\partial \Omega)$" src="form_4274.png"/>. We define <img class="formulaInl" alt="$\mathcal{E}_{D}$" src="form_4275.png"/> and <img class="formulaInl" alt="$\mathcal{E}_{N}$" src="form_4276.png"/> to be the sets of all element faces and on the Dirichlet and Neumann boundaries respectively. Let <img class="formulaInl" alt="$\partial \Omega_{e} \in \mathcal{E}_{h}^{i}$" src="form_4277.png"/> be a interior boundary face element, we define the unit normal vector to be, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \textbf{n} \; = \; \text{unit normal vector to } \partial \Omega_{e} \text{ pointing from } \Omega_{e}^{-} \, \rightarrow \, \Omega_{e}^{+}. \end{align}" src="form_4278.png"/>
</p>
<p>We take the following definition on limits of functions on element faces, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} w^{-} (\textbf{x} ) \, \vert_{\partial \Omega_{e} } \; = \; \lim_{s \rightarrow 0^{-}} \, w(\textbf{x} + s \textbf{n}), &amp;&amp; w^{+} (\textbf{x} ) \, \vert_{\partial \Omega_{e} } \; = \; \lim_{s \rightarrow 0^{+}} \, w(\textbf{x} + s \textbf{n}). \end{align}" src="form_4279.png"/>
</p>
<p>We define the average and jump of a function across an element face as, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \{f\} \; = \; \frac{1}{2}(f^-+f^+), \qquad \mbox{and} \qquad \left[ f \right] \; = \; f^+ \textbf{n}^+ + f^- \textbf{n}^-, \end{align}" src="form_4280.png"/>
</p>
<p>and, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \{\textbf{f} \} \; = \; \frac{1}{2}(\textbf{f}^- + \textbf{f}^+), \qquad \mbox{and}\qquad \left[ \textbf{f} \right] \; = \;\textbf{f}^+ \cdot \textbf{n}^+ + \textbf{f}^- \cdot \textbf{n}^- , \end{align}" src="form_4281.png"/>
</p>
<p>where <img class="formulaInl" alt="$f$" src="form_417.png"/> is a scalar function and <img class="formulaInl" alt="$\textbf{f}$" src="form_4085.png"/> is vector-valued function. We note that for faces that are on the boundary of the domain we have, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \left[ f \right] \; = \; f \, \textbf{n} \qquad \mbox{and}\qquad \left[ \textbf{f} \right] \; = \; \textbf{f} \cdot \textbf{n}. \end{align}" src="form_4282.png"/>
</p>
<p>We denote the volume integrals and surface integrals using the <img class="formulaInl" alt="$L^{2}(\Omega)$" src="form_4283.png"/> inner products by <img class="formulaInl" alt="$( \, \cdot \, , \, \cdot \, )_{\Omega}$" src="form_4284.png"/> and <img class="formulaInl" alt="$\langle \, \cdot \, , \, \cdot \, \rangle_{\partial \Omega}$" src="form_4285.png"/> respectively.</p>
<p>As with the mixed finite element method with the Raviart-Thomas element, the LDG discretization requires the Poisson equations be written as a first-order system. We do this by introducing an auxiliary variable which we call the current flux variable <img class="formulaInl" alt="$\textbf{q}$" src="form_4286.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \nabla \cdot \textbf{q} \; &amp;= \; f(\textbf{x}) &amp;&amp; \text{in} \ \Omega, \label{eq:Primary} \\ \textbf{q} \; &amp;= \; -\nabla u &amp;&amp; \text{in} \ \Omega, \label{eq:Auxillary} \\ \textbf{q} \cdot \textbf{n} \; &amp;= \; g_{N}(\textbf{x}) &amp;&amp; \text{on} \ \partial \Omega_{N},\\ u &amp;= g_{D}(\textbf{x}) &amp;&amp; \mbox{on}\ \partial \Omega_{D}. \end{align}" src="form_4287.png"/>
</p>
<p>In our numerical methods we will use approximations to scalar valued functions that reside in the finite-dimensional broken Sobolev spaces, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} W_{h,k} \, &amp;= \, \left\{ w \in L^{2}(\Omega) \, : \; w \vert_{\Omega_{e}} \in \mathcal{Q}_{k,k}(\Omega_{e}), \quad \forall \, \Omega_{e} \in \mathcal{T}_{h} \right\}, \end{align}" src="form_4288.png"/>
</p>
<p>where <img class="formulaInl" alt="$\mathcal{Q}_{k,k}(\Omega_{e})$" src="form_4289.png"/> denotes the tensor product of discontinuous polynomials of order <img class="formulaInl" alt="$k$" src="form_44.png"/> on the element <img class="formulaInl" alt="$\Omega_{e}$" src="form_4269.png"/>. We use approximations of vector valued functions that are in, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \textbf{W}_{h,k} \, &amp;= \, \left\{ \textbf{w} \in \left(L^{2}(\Omega)\right)^{d} \, : \; \textbf{w} \vert_{\Omega_{e}} \in \left( \mathcal{Q}_{k,k}(\Omega_{e}) \right)^{d}, \quad \forall \, \Omega_{e} \in \mathcal{T}_{h} \right\} \end{align}" src="form_4290.png"/>
</p>
<p>We seek approximations for densities <img class="formulaInl" alt="$u_{h} \in W_{h,k}$" src="form_4291.png"/> and gradients <img class="formulaInl" alt="$\textbf{q}_{h}\in \textbf{W}_{h,k}$" src="form_4292.png"/>. Multiplying (6) by <img class="formulaInl" alt="$w \in W_{h,k}$" src="form_4293.png"/> and (7) by <img class="formulaInl" alt="$\textbf{w} \in \textbf{W}_{h,k}$" src="form_4294.png"/> and integrating the divergence terms by parts over an element <img class="formulaInl" alt="$\Omega_{e} \in \mathcal{T}_{h}$" src="form_4295.png"/> we obtain, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} - \left( \nabla w \, , \, \textbf{q}_{h} \right)_{\Omega_{e}} + \langle w \, , \, \textbf{q}_{h} \rangle_{\partial \Omega_{e}} \ &amp;= \ \left( w , \, f \right)_{\Omega_{e}} , \\ \left( \textbf{w} \, , \, \textbf{q}_{h} \right)_{\Omega_{e}} - \left( \nabla \cdot \textbf{w} \, , \, u_{h} \right)_{\Omega_{e}} + \langle \textbf{w} \, , \, u_{h} \rangle_{\partial \Omega_{e}} \ &amp;= \ 0 \end{align}" src="form_4296.png"/>
</p>
<p>Summing over all the elements leads to the weak formulation:</p>
<p>Find <img class="formulaInl" alt="$u_{h} \in W_{h,k}$" src="form_4291.png"/> and <img class="formulaInl" alt="$\textbf{q}_{h} \in \textbf{W}_{h,k} $" src="form_4297.png"/> such that,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} - \sum_{e} \left( \nabla w, \, \textbf{q}_{h} \right)_{\Omega_{e}} + \langle \left[ \, w \, \right] \, , \, \widehat{\textbf{q}_{h} } \rangle_{\mathcal{E}_{h}^{i} } + \langle \left[ \, w \, \right] \, , \, \widehat{\textbf{q}_{h} } \rangle_{\mathcal{E}_{D} \cup \mathcal{E}_{N}} \ &amp;= \ \sum_{e} \left( w , \, f \right)_{\Omega_{e}} \\ \sum_{e} \left( \textbf{w} \, , \, \textbf{q}_{h} \right)_{\Omega_{e}} - \sum_{e} \left( \nabla \cdot \textbf{w} , \, u_{h} \right)_{\Omega_{e}} + \langle \, \left[ \, \textbf{w} \, \right] \, , \, \widehat{u_{h}} \rangle_{\mathcal{E}_{h}^{i}} + \langle \left[ \, \textbf{w} \, \right] \, , \, \widehat{u_{h}} \rangle_{\mathcal{E}_{D} \cup \mathcal{E}_{N}} \ &amp;= \ 0 \end{align}" src="form_4298.png"/>
</p>
<p>for all <img class="formulaInl" alt="$(w,\textbf{w}) \in W_{h,k} \times \textbf{W}_{h,k}$" src="form_4299.png"/>.</p>
<p>The terms <img class="formulaInl" alt="$\widehat{\textbf{q}_{h}}$" src="form_4300.png"/> and <img class="formulaInl" alt="$\widehat{u_{h}}$" src="form_4301.png"/> are the numerical fluxes. The numerical fluxes are introduced to ensure consistency, stability, and enforce the boundary conditions weakly, for more info see the book: <a href="http://www.springer.com/us/book/9780387720654">Nodal Discontinuous Galerkin Methods</a>. The flux <img class="formulaInl" alt="$\widehat{u_{h}}$" src="form_4301.png"/> is,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \widehat{u_{h}} \; = \; \left\{ \begin{array}{cl} \left\{ u_{h} \right\} \ + \ \boldsymbol \beta \cdot [ u_{h} ] \, &amp; \ \text{in} \ \mathcal{E}_{h}^{i} \\ u_{h} &amp; \ \text{in} \ \mathcal{E}_{N}\\ g_{D}(\textbf{x}) &amp; \ \text{in} \ \mathcal{E}_{D} \\ \end{array} \right. \end{align}" src="form_4302.png"/>
</p>
<p>The flux <img class="formulaInl" alt="$\widehat{\textbf{q}_{h}}$" src="form_4300.png"/> is, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \widehat{\textbf{q}_{h}} \; = \; \left\{ \begin{array}{cl} \left\{ \textbf{q}_{h} \right\} \ - \ \left[ \textbf{q}_{h} \right] \, \boldsymbol \beta \ + \ \sigma \, \left[ \, u_{h} \, \right] &amp; \ \text{in} \ \mathcal{E}_{h}^{i} \\ g_{N}(\textbf{x}) \, \textbf{n} \, &amp; \ \text{in} \ \mathcal{E}_{N}\\ \textbf{q}_{h} \ + \ \sigma \, \left(u_{h} - g_{D}(\textbf{x}) \right) \, \textbf{n} &amp; \ \text{in} \ \mathcal{E}_{D} \\ \end{array} \right. \end{align}" src="form_4303.png"/>
</p>
<p>The term <img class="formulaInl" alt="$\boldsymbol \beta$" src="form_4304.png"/> is a constant unit vector which does not lie parallel to any element face in <img class="formulaInl" alt="$ \mathcal{E}_{h}^{i}$" src="form_4305.png"/>. For <img class="formulaInl" alt="$\boldsymbol \beta = 0$" src="form_4306.png"/>, <img class="formulaInl" alt="$\widehat{\textbf{q}_{h}}$" src="form_4300.png"/> and <img class="formulaInl" alt="$\widehat{u_{h}}$" src="form_4301.png"/> are called the central or Brezzi et. al. fluxes. For <img class="formulaInl" alt="$\boldsymbol \beta \neq 0$" src="form_4307.png"/>, <img class="formulaInl" alt="$\widehat{\textbf{q}_{h}}$" src="form_4300.png"/> and <img class="formulaInl" alt="$\widehat{u_{h}}$" src="form_4301.png"/> are called the LDG/alternating fluxes, see <a href="http://www3.nd.edu/~zxu2/acms60790S14/unified-analy-dg-elliptic-eq.pdf">here</a> and <a href="http://www.springer.com/us/book/9780387720654">here</a>.</p>
<p>The term <img class="formulaInl" alt="$\sigma$" src="form_456.png"/> is the penalty parameter that is defined as, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \sigma \; = \; \left\{ \begin{array}{cc} \tilde{\sigma} \, \min \left( h^{-1}_{e_{1}}, h^{-1}_{e_{2}} \right) &amp; \textbf{x} \in \langle \Omega_{e_{1}}, \Omega_{e_{2}} \rangle \\ \tilde{\sigma} \, h^{-1}_{e} &amp; \textbf{x} \in \partial \Omega_{e} \cap \in \mathcal{E}_{D} \end{array} \right. \label{eq:Penalty} \end{align}" src="form_4308.png"/>
</p>
<p>with <img class="formulaInl" alt="$\tilde{\sigma}$" src="form_4309.png"/> being a positive constant. There are other choices of penalty values <img class="formulaInl" alt="$\sigma$" src="form_456.png"/>, but the one above produces in appoximations to solutions that are the most accurate, see this <a href="http://epubs.siam.org/doi/abs/10.1137/S0036142900371003">reference</a> for more info.</p>
<p>We can now substitute (16) and (17) into (14) and (15) to obtain the solution pair <img class="formulaInl" alt="$(u_{h}, \textbf{q}_{h})$" src="form_4310.png"/> to the LDG approximation to the Poisson equation given by:</p>
<p>Find <img class="formulaInl" alt="$u_{h} \in W_{h,k}$" src="form_4291.png"/> and <img class="formulaInl" alt="$\textbf{q}_{h} \in \textbf{W}_{h,k}$" src="form_4311.png"/> such that,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} a(\textbf{w}, \textbf{q}_{h}) \ + \ b^{T}(\textbf{w}, u_{h}) \ &amp;= \ G(\textbf{w}) \nonumber \\ b(w, \textbf{q}_{h}) \ + \ c(w, u_{h}) \ &amp;= \ F(w) \label{eq:LDG_bilinear} \end{align}" src="form_4312.png"/>
</p>
<p>for all <img class="formulaInl" alt="$(w, \textbf{w}) \in W_{h,k} \times \textbf{W}_{h,k}$" src="form_4313.png"/>. This leads to the linear system,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \left[ \begin{matrix} A &amp; -B^{T} \\ B &amp; C \end{matrix} \right] \left[ \begin{matrix} \textbf{Q}\\ \textbf{U} \end{matrix} \right] \ = \ \left[ \begin{matrix} \textbf{G}\\ \textbf{F} \end{matrix} \right] \end{align}" src="form_4314.png"/>
</p>
<p>Where <img class="formulaInl" alt="$\textbf{U}$" src="form_4315.png"/> and <img class="formulaInl" alt="$\textbf{Q}$" src="form_4316.png"/> are the degrees of freedom vectors for <img class="formulaInl" alt="$u_{h}$" src="form_4317.png"/> and <img class="formulaInl" alt="$\textbf{q}_{h}$" src="form_4318.png"/> respectively. The terms <img class="formulaInl" alt="$\textbf{G}$" src="form_4319.png"/> and <img class="formulaInl" alt="$\textbf{F}$" src="form_4320.png"/> are the corresponding vectors to <img class="formulaInl" alt="$G(\textbf{w})$" src="form_4321.png"/> and <img class="formulaInl" alt="$F(w)$" src="form_4322.png"/> respectively. The matrix in for the LDG system is non-singular for any <img class="formulaInl" alt="$\sigma &gt; 0$" src="form_4323.png"/>.</p>
<p>The bilinear forms in (19) and right hand functions are defined as,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} b(w, \textbf{q}_{h}) \, &amp;= \, - \sum_{e} \left(\nabla w, \textbf{q}_{h} \right)_{\Omega_{e}} + \langle \left[ w \right], \left\{\textbf{q}_{h} \right\} - \left[ \textbf{q}_{h} \right] \boldsymbol \beta \rangle_{\mathcal{E}_{h}^{i}} + \langle w, \textbf{n} \cdot \textbf{q}_{h} \rangle_{\mathcal{E}_{D}}\\ a(\textbf{w},\textbf{q}_{h}) \, &amp;= \, \sum_{e} \left(\textbf{w}, \textbf{q}_{h} \right)_{\Omega_{e}} \\ -b^{T}(w, \textbf{q}_{h}) \, &amp;= \, - \sum_{e} \left(\nabla \cdot \textbf{w}, u_{h} \right)_{\Omega_{e}} + \langle \left[ \textbf{w} \right], \left\{u_{h} \right\} + \boldsymbol \beta \cdot \left[ u_{h} \right] \rangle_{\mathcal{E}_h^{i} } + \langle w, u_{h} \rangle_{\mathcal{E}_{N} } \\ c(w,u_{h}) \, &amp;= \, \langle \left[ w \right], \sigma \left[ u_{h} \right] \rangle_{\mathcal{E}_{h}^{i}} + \langle w, \sigma u_{h} \rangle_{\mathcal{E}_{D}} \\ G(\textbf{w}) \ &amp; = \ - \langle \textbf{w}, g_{D} \rangle_{\mathcal{E}_{D}}\\ F(w) \ &amp; = \ \sum_{e} (w,f)_{\Omega_{e}} - \langle w, g_{N} \rangle_{\mathcal{E}_{N}} + \langle w, \sigma g_{D} \rangle_{\mathcal{E}_{D}} \end{align}" src="form_4324.png"/>
</p>
<p>As discussed in <a class="el" href="step_20.html">step-20</a>, we won't be assembling the bilinear terms explicitly, instead we will assemble all the solid integrals and fluxes at once. We note that in order to actually build the flux terms in our local flux matrices we will substitute in the definitions in the bilinear terms above.</p>
<h2>Useful References</h2>
<p>These are some useful references on the LDG and DG methods:</p>
<ul>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/s0036142997316712">The Local Discontinuous Galerkin Method for Time-Dependent Convection-Diffusion Systems</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.7688">Some Extensions Of The Local Discontinuous Galerkin Method For Convection-Diffusion Equations In Multidimensions</a></li>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/S1064827502410657">Preconditioning Methods for Local Discontinuous Galerkin Discretizations</a></li>
<li><a href="http://epubs.siam.org/doi/abs/10.1137/S0036142900371003">An A Priori Error Analysis of the Local Discontinuous Galerkin Method for Elliptic Problems</a></li>
<li><a href="http://www3.nd.edu/~zxu2/acms60790S14/unified-analy-dg-elliptic-eq.pdf">Unified Analysis Of Discontinuous Galerkin Methods For Elliptic Problems</a></li>
<li><a href="http://www.springer.com/us/book/9780387720654">Nodal Discontinuous Galerkin Methods</a></li>
<li><a href="http://epubs.siam.org/doi/book/10.1137/1.9780898717440">Discontinuous Galerkin Methods for Solving Elliptic and Parabolic Equations: Theory and Implementation</a></li>
</ul>
<h1>The Commented Code</h1>
<p><a class="anchor" id="ann-Functions.cc"></a> </p><h1>Annotated version of Functions.cc</h1>
<p><a class="anchor" id="Functionscc"></a> </p><h3>Functions.cc</h3>
<p>In this file we keep right hand side function, Dirichlet boundary conditions and solution to our Poisson equation problem. Since these classes and functions have been discussed extensively in the deal.ii tutorials we won't discuss them any further.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor_function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    RightHandSide() : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0 ) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DirichletBoundaryValues() : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0 ) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TrueSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    TrueSolution() : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;valuess) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">RightHandSide&lt;dim&gt;::</div><div class="line">value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = p[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = p[1];</div><div class="line">    <span class="keywordflow">return</span> 4*M_PI*M_PI*(cos(2*M_PI*y) - sin(2*M_PI*x));</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">DirichletBoundaryValues&lt;dim&gt;::</div><div class="line">value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = p[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = p[1];</div><div class="line">    <span class="keywordflow">return</span> cos(2*M_PI*y) -sin(2*M_PI*x) - x;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">TrueSolution&lt;dim&gt;::</div><div class="line">vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">             <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == dim+1,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim+1) );</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> x = p[0];</div><div class="line">    <span class="keywordtype">double</span> y = p[1];</div><div class="line"></div><div class="line">    values(0) = 1 + 2*M_PI*cos(2*M_PI*x);</div><div class="line">    values(1) = 2*M_PI*sin(2*M_PI*y);</div><div class="line"></div><div class="line">    values(2) = cos(2*M_PI*y) - sin(2*M_PI*x) - x;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-LDGPoisson.cc"></a> </p><h1>Annotated version of LDGPoisson.cc</h1>
<p><a class="anchor" id="LDGPoissoncc"></a> </p><h3>LDGPoisson.cc</h3>
<p>The code begins as per usual with a long list of the the included files from the deal.ii library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Here's where the classes for the DG methods begin. We can use either the Lagrange polynomials,</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span> </div></div><!-- fragment --><p>or the Legendre polynomials</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgp.h&gt;</span></div></div><!-- fragment --><p>as basis functions. I'll be using the Lagrange polynomials.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div></div><!-- fragment --><p>Now we have to load in the deal.ii files that will allow us to use a distributed computing framework.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparsity_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div></div><!-- fragment --><p>Additionally we load the files that will allow us to interact with the Trilinos library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_solver.h&gt;</span></div></div><!-- fragment --><p>The functions class contains all the defintions of the functions we will use, i.e. the right hand side function, the boundary conditions and the test functions.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Functions.cc&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>Here is the main class for the Local Discontinuous Galerkin method applied to Poisson's equation, we won't explain much of the the class and method declarations, but dive deeper into describing the functions when they are defined. The only thing I will menion about the class declaration is that this is where I labeled the different types of boundaries using enums.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LDGPoissonProblem</div><div class="line">{</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    LDGPoissonProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refine);</div><div class="line"></div><div class="line">    ~LDGPoissonProblem();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_cell_terms(<span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>    &amp;cell_fe,</div><div class="line">                             <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     &amp;cell_matrix,</div><div class="line">                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>         &amp;cell_vector);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_Neumann_boundary_terms(<span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    &amp;face_fe,</div><div class="line">                                    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>         &amp;local_matrix,</div><div class="line">                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>             &amp;local_vector);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_Dirichlet_boundary_terms(<span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>  &amp;face_fe,</div><div class="line">                                      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>       &amp;local_matrix,</div><div class="line">                                      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>           &amp;local_vector,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">double</span>             &amp; h);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_flux_terms(<span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>  &amp;fe_face_values,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>  &amp;fe_neighbor_face_values,</div><div class="line">                        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>           &amp;vi_ui_matrix,</div><div class="line">                        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>           &amp;vi_ue_matrix,</div><div class="line">                        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>           &amp;ve_ui_matrix,</div><div class="line">                        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>           &amp;ve_ue_matrix,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>                 &amp; h);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> distribute_local_flux_to_global(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp; vi_ui_matrix,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp; vi_ue_matrix,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp; ve_ui_matrix,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp; ve_ue_matrix,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp; local_dof_indices,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp; local_neighbor_dof_indices);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refine;</div><div class="line">    <span class="keywordtype">double</span> penalty;</div><div class="line">    <span class="keywordtype">double</span> h_max;</div><div class="line">    <span class="keywordtype">double</span> h_min;</div><div class="line"></div><div class="line">    <span class="keyword">enum</span></div><div class="line">    {</div><div class="line">        Dirichlet,</div><div class="line">        Neumann</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a>       triangulation;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>                                   fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                                 dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                                constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                                 sparsity_pattern;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix                  system_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>                   locally_relevant_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>                   system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a>                              pcout;</div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a>                                     computing_timer;</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                                   solver_control;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1SolverDirect.html">TrilinosWrappers::SolverDirect</a>                  solver;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt;              rhs_function;</div><div class="line">    <span class="keyword">const</span> DirichletBoundaryValues&lt;dim&gt;    Dirichlet_bc_function;</div><div class="line">    <span class="keyword">const</span> TrueSolution&lt;dim&gt;               true_solution;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Classconstructoranddestructor"></a> </p><h4>Class constructor and destructor</h4>
<p>The constructor and destructor for this class is very much like the like those for <a class="el" href="step_40.html">step-40</a>. The difference being that we'll be passing in an integer, <code>degree</code>, which tells us the maxiumum order of the polynomial to use as well as <code>n_refine</code> which is the global number of times we refine our mesh. The other main differences are that we use a <a class="el" href="classFESystem.html">FESystem</a> object for our choice of basis functions. This is reminiscent of the mixed finite element method in <a class="el" href="step_20.html">step-20</a>, however, in our case we use a <a class="el" href="classFESystem.html">FESystem</a> of the form,</p>
<p><code> fe( FESystem&lt;dim&gt;(FE_DGQ&lt;dim&gt;(degree), dim), 1, FE_DGQ&lt;dim&gt;(degree), 1) </code></p>
<p>which tells us that the basis functions contain discontinous polynomials of order <code>degree</code> in each of the <code>dim</code> dimensions for the vector field. For the scalar unknown we use a discontinuous polynomial of the order <code>degree</code>. The LDG method for Poisson equations solves for both the primary variable as well as its gradient, just like the mixed finite element method. However, unlike the mixed method, the LDG method uses discontinuous polynomials to approximate both variables. The other difference bewteen our constructor and that of <a class="el" href="step_40.html">step-40</a> is that we all instantiate our linear solver in the constructor definition.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">LDGPoissonProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refine)</div><div class="line">    :</div><div class="line">    degree(degree),</div><div class="line">    n_refine(n_refine),</div><div class="line">    triangulation(MPI_COMM_WORLD,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing</div><div class="line">                 (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening)),</div><div class="line">    fe( <a class="code" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), dim),        1,</div><div class="line">       <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree),                             1),</div><div class="line">    dof_handler(triangulation),</div><div class="line">    pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">         <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0),</div><div class="line">    computing_timer(MPI_COMM_WORLD,</div><div class="line">                   pcout,</div><div class="line">                   <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                   <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times),</div><div class="line">    solver_control(1),</div><div class="line">    solver(solver_control),</div><div class="line">    rhs_function(),</div><div class="line">    Dirichlet_bc_function()</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">~LDGPoissonProblem()</div><div class="line">{</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Make_grid"></a> </p><h4>Make_grid</h4>
<p>This function shows how to make a grid using local refinement and also shows how to label the boundaries using the defined enum.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_refine);</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> local_refine = 2;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =0; i &lt;local_refine; i++)</div><div class="line">  {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">        cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">        endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div></div><!-- fragment --><p>We loop over all the cells in the mesh and mark the appropriate cells for refinement. In this example we only choose cells which are near <img class="formulaInl" alt="$x=0$" src="form_810.png"/> and <img class="formulaInl" alt="$x=1$" src="form_2498.png"/> in the the domain. This was just to show that the LDG method is working with local refinement and discussions on building more realistic refinement stategies are discussed elsewhere in the deal.ii documentation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(; cell != endc; cell++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>((cell-&gt;center()[1]) &gt; 0.9 )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>((cell-&gt;center()[0] &gt; 0.9)  || (cell-&gt;center()[0] &lt; 0.1))</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now that we have marked all the cells that we want to refine locally we can go ahead and refine them.</p>
<div class="fragment"><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p>To label the boundary faces of the mesh with their type, i.e. Dirichlet or Neumann, we loop over all the cells in the mesh and then over all the faces of each cell. We then have to figure out which faces are on the bounadry and set all faces on the boundary to have <code>boundary_id</code> to be <code>Dirichlet</code>. We remark that one could easily set more complicated conditions where there are both Dirichlet or Neumann boundaries.</p>
<div class="fragment"><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">  <span class="keywordflow">for</span>(; cell != endc; cell++)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0;</div><div class="line">        face_no &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">        face_no++)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span>(cell-&gt;face(face_no)-&gt;at_boundary() )</div><div class="line">          cell-&gt;face(face_no)-&gt;set_boundary_id(Dirichlet);</div><div class="line">    } </div><div class="line">  } </div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="make_dofs"></a> </p><h3>make_dofs</h3>
<p>This function is responsible for distributing the degrees of freedom (dofs) to the processors and allocating memory for the global system matrix, <code>system_matrix</code>, and global right hand side vector, <code>system_rhs</code> . The dofs are the unknown coefficients for the polynomial approximation of our solution to Poisson's equation in the scalar variable and its gradient.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">make_dofs()</div><div class="line">{</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;setup&quot;</span>);</div></div><!-- fragment --><p>The first step to setting up our linear system is to distribute the degrees of freedom (dofs) across the processors, this is done with the <code>distribute_dofs()</code> method of the <a class="el" href="classDoFHandler.html">DoFHandler</a>. We remark the same exact function call that occurs when using deal.ii on a single machine, the <a class="el" href="classDoFHandler.html">DoFHandler</a> automatically knows that we are distributed setting because it was instantiated with a distributed triangulation!</p>
<div class="fragment"><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div></div><!-- fragment --><p>We now renumber the dofs so that the vector of unkonwn dofs that we are solving for, <code>locally_relevant_solution</code>, corresponds to a vector of the form,</p>
<p><img class="formulaInl" alt="$ \left[\begin{matrix} \textbf{Q} \\ \textbf{U} \end{matrix}\right] $" src="form_4325.png"/></p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler);</div></div><!-- fragment --><p>Now we get the locally owned dofs, that is the dofs that our local to this processor. These dofs corresponding entries in the matrix and vectors that we will write to.</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div></div><!-- fragment --><p>In additon to the locally owned dofs, we also need the the locally relevant dofs. These are the dofs that have read access to and we need in order to do computations on our processor, but, that we do not have the ability to write to.</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"><a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler,</div><div class="line">                                        locally_relevant_dofs);</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; dofs_per_component(dim+1);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a1a86f6b2291b6bc814a982b85fa64a09">DoFTools::count_dofs_per_component</a>(dof_handler, dofs_per_component);</div></div><!-- fragment --><p>Discontinuous Galerkin methods are fantanistic methods in part because many of the limitations of traditional finite element methods no longer exist. Specifically, the need to use constraint matrices in order handle hanging nodes is no longer necessary. However, we will continue to use the constraint matrices inorder to efficiently distribute local computations to the global system, i.e. to the <code>system_matrix</code> and <code>system_rhs</code>. Therefore, we just instantiate the constraints matrix object, clear and close it.</p>
<div class="fragment"><div class="line">constraints.clear();</div><div class="line">constraints.close();</div></div><!-- fragment --><p>Just like <a class="el" href="step_40.html">step-40</a> we create a dynamic sparsity pattern and distribute it to the processors. Notice how we do not have to explictly mention that we are using a <a class="el" href="classFESystem.html">FESystem</a> for system of variables instead of a <a class="el" href="classFE__DGQ.html">FE_DGQ</a> for a scalar variable or that we are using a discributed <a class="el" href="classDoFHandler.html">DoFHandler</a>. All these specifics are taken care of under the hood by the deal.ii library. In order to build the sparsity pattern we use the <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> function since we using a DG method and need to take into account the DG fluxes in the sparsity pattern.</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a>(dof_handler,</div><div class="line">                                     dsp);</div><div class="line"></div><div class="line"><a class="code" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">SparsityTools::distribute_sparsity_pattern</a>(dsp,</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#aff791a67d5a9383fb2ef05ea540b71e8">n_locally_owned_dofs_per_processor</a>(),</div><div class="line">        MPI_COMM_WORLD,</div><div class="line">        locally_relevant_dofs);</div></div><!-- fragment --><p>Here is one area that I had to learn the hard way. The local discontinuous Galerkin method like the mixed method with the Raviart-Thomas element is written in mixed form and will lead to a block-structured matrix. In <a class="el" href="step_20.html">step-20</a> we see that we that we initialize the <code>system_martrix</code> such that we explicitly declare it to be block-structured. It turns out there are reasons to do this when you are going to be using a Schur complement method to solve the system of equations. While the LDG method will lead to a block-structured matrix, we do not have to explicitly declare our matrix to be one. I found that most of the distributed linear solvers did not accept block structured matrices and since I was using a distributed direct solver it was unnecessary to explicitly use a block structured matrix.</p>
<div class="fragment"><div class="line">system_matrix.reinit(locally_owned_dofs,</div><div class="line">                     locally_owned_dofs,</div><div class="line">                     dsp,</div><div class="line">                     MPI_COMM_WORLD);</div></div><!-- fragment --><p>The final note that I will make in that this subroutine is that we initialize this processors solution and the right hand side vector the exact same was as we did in <a class="el" href="step_40.html">step-40</a>. We should note that the <code>locally_relevant_solution</code> solution vector includes dofs that are locally relevant to our computations while the <code>system_rhs</code> right hand side vector will only include dofs that are locally owned by this processor.</p>
<div class="fragment"><div class="line">    locally_relevant_solution.reinit(locally_relevant_dofs,</div><div class="line">                                     MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(locally_owned_dofs,</div><div class="line">                      locally_relevant_dofs,</div><div class="line">                      MPI_COMM_WORLD,</div><div class="line">                      <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vector_field = dim * dofs_per_component[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_potential = dofs_per_component[dim];</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Number of active cells : &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">          &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_vector_field &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; n_potential &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="assemble_system"></a> </p><h4>assemble_system</h4>
<p>This is the function that will assemble the global system matrix and global right hand side vector for the LDG method. It starts out like many of the deal.ii tutorial codes: declaring quadrature formulas and UpdateFlags objects, as well as vectors that will hold the dof indices for the cells we are working on in the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">assemble_system()</div><div class="line">{</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembly&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>         quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt;       face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags  = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="line">                                      | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="line">                                      | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="line">                                      | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_update_flags =   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="line">                                            | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a></div><div class="line">                                            | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="line">                                            | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line">                                            </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; </div><div class="line">                                local_neighbor_dof_indices(dofs_per_cell);                                      </div></div><!-- fragment --><p>We first remark that we have the <a class="el" href="classFEValues.html">FEValues</a> objects for the values of our cell basis functions as was done in most other examples. Now because we are using discontinuous Galerkin methods we also introduce a <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object, <code>fe_face_values</code>, for evaluating the basis functions on one side of an element face as well as another <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object, <code>fe_neighbor_face_values</code>, for evaluating the basis functions on the opposite side of the face, i.e. on the neighoring element's face. In addition, we also introduce a <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object, <code>fe_subface_values</code>, that will be used for dealing with faces that have multiple refinement levels, i.e. hanging nodes. When we have to evaluate the fluxes across a face that multiple refinement levels, we need to evaluate the fluxes across all its childrens' faces; we'll explain this more when the time comes.</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>           fe_values(fe, quadrature_formula, update_flags);</div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>       fe_face_values(fe,face_quadrature_formula, </div><div class="line">                                      face_update_flags);</div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>       fe_neighbor_face_values(fe, </div><div class="line">                                            face_quadrature_formula,</div><div class="line">                                            face_update_flags);</div><div class="line"></div><div class="line"><a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a>    fe_subface_values(fe, face_quadrature_formula,</div><div class="line">                                          face_update_flags);</div></div><!-- fragment --><p>Here are the local (dense) matrix and right hand side vector for the solid integrals as well as the integrals on the boundaries in the local discontinuous Galerkin method. These terms will be built for each local element in the mesh and then distributed to the global system matrix and right hand side vector.</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>      local_matrix(dofs_per_cell,dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>          local_vector(dofs_per_cell);</div></div><!-- fragment --><p>The next four matrices are used to incorporate the flux integrals across interior faces of the mesh:</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>      vi_ui_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>      vi_ue_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>      ve_ui_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>      ve_ue_matrix(dofs_per_cell, dofs_per_cell);</div></div><!-- fragment --><p>As explained in the section on the LDG method we take our test function to be v and multiply it on the left side of our differential equation that is on u and peform integration by parts as explained in the introduction. Using this notation for test and solution function, the matrices below will then stand for:</p>
<p><code>vi_ui</code> - Taking the value of the test function from interior of this cell's face and the solution function from the interior of this cell.</p>
<p><code>vi_ue</code> - Taking the value of the test function from interior of this cell's face and the solution function from the exterior of this cell.</p>
<p><code>ve_ui</code> - Taking the value of the test function from exterior of this cell's face and the solution function from the interior of this cell.</p>
<p><code>ve_ue</code> - Taking the value of the test function from exterior of this cell's face and the solution function from the exterior of this cell.</p>
<p>Now that we have gotten preliminary orders out of the way, we loop over all the cells and assemble the local system matrix and local right hand side vector using the <a class="el" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler::active_cell_iterator</a>,</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(; cell!=endc; cell++)</div><div class="line">{</div></div><!-- fragment --><p>Now, since we are working in a distributed setting, we can only work on cells and write to dofs in the <code>system_matrix</code> and <code>rhs_vector</code> that corresponds to cells that are locally owned by this processor. We note that while we can only write to locally owned dofs, we will still use information from cells that are locally relevant. This is very much the same as in <a class="el" href="step_40.html">step-40</a>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(cell-&gt;is_locally_owned())</div><div class="line">{</div></div><!-- fragment --><p>We now assemble the local contributions to the system matrix that includes the solid integrals in the LDG method as well as the right hand side vector. This involves resetting the local matrix and vector to contain all zeros, reinitializing the <a class="el" href="classFEValues.html">FEValues</a> object for this cell and then building the <code>local_matrix</code> and <code>local_rhs</code> vector.</p>
<div class="fragment"><div class="line">local_matrix = 0;</div><div class="line">local_vector = 0;</div><div class="line"></div><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line">assemble_cell_terms(fe_values,</div><div class="line">                    local_matrix,</div><div class="line">                    local_vector);</div></div><!-- fragment --><p>We remark that we need to get the local indices for the dofs to to this cell before we begin to compute the contributions from the numerical fluxes, i.e. the boundary conditions and interior fluxes.</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div></div><!-- fragment --><p>Now is where we start to loop over all the faces of the cell and construct the local contribtuions from the numerical fluxes. The numerical fluxes will be due to 3 contributions: the interior faces, the faces on the Neumann boundary and the faces on the Dirichlet boundary. We instantiate a <code>face_iterator</code> to loop over all the faces of this cell and first see if the face is on the boundary. Notice how we do not reinitiaize the <code>fe_face_values</code> object for the face until we know that we are actually on face that lies on the boundary of the domain. The reason for doing this is for computational efficiency; reinitializing the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> for each face is expensive and we do not want to do it unless we are actually going use it to do computations. After this, we test if the face is on the a Dirichlet or a Neumann segment of the boundary and call the appropriate subroutine to assemble the contributions for that boundary. Note that this assembles the flux contribution in the <code>local_matrix</code> as well as the boundary condition that ends up in the <code>local_vector</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0;</div><div class="line">        face_no&lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">        face_no++)</div><div class="line">{</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a>  face = </div><div class="line">                                          cell-&gt;face(face_no);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(face-&gt;at_boundary() )</div><div class="line">    {</div><div class="line">        fe_face_values.<a class="code" href="classFEFaceValues.html#af6e079ca7429d54433343d50bd334c3c">reinit</a>(cell, face_no);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(face-&gt;boundary_id() == Dirichlet)</div><div class="line">        {</div></div><!-- fragment --><p>Here notice that in order to assemble the flux due to the penalty term for the the Dirichlet boundary condition we need the local cell diameter size and we can get that value for this specific cell with the following,</p>
<div class="fragment"><div class="line">        <span class="keywordtype">double</span> h = cell-&gt;diameter();</div><div class="line">        assemble_Dirichlet_boundary_terms(fe_face_values,</div><div class="line">                                          local_matrix,</div><div class="line">                                          local_vector,</div><div class="line">                                          h);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(face-&gt;boundary_id() == Neumann)</div><div class="line">    {</div><div class="line">        assemble_Neumann_boundary_terms(fe_face_values,</div><div class="line">                                        local_matrix,</div><div class="line">                                        local_vector);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>() );</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div></div><!-- fragment --><p>At this point we know that the face we are on is an interior face. We can begin to assemble the interior flux matrices, but first we want to make sure that the neighbor cell to this face is a valid cell. Once we know that the neighbor is a valid cell then we also want to get the meighbor cell that shares this cell's face.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cell-&gt;neighbor(face_no).state() == </div><div class="line">                                      <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>,</div><div class="line">                                      <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor =</div><div class="line">    cell-&gt;neighbor(face_no);</div></div><!-- fragment --><p>Now that we have the two cells whose face we want to compute the numerical flux across, we need to know if the face has been refined, i.e. if it has children faces. This occurs when one of the cells has a different level of refinement than the other cell. If this is the case, then this face has a different level of refinement than the other faces of the cell, i.e. on this face there is a hanging node. Hanging nodes are not a problem in DG methods, the only time we have to watch out for them is at this step and as you will see the changes we have to our make are minor.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(face-&gt;has_children())</div><div class="line">{</div></div><!-- fragment --><p>We now need to find the face of our neighbor cell such that neighbor(neigh_face_no) = cell(face_no).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_face_no =</div><div class="line">    cell-&gt;neighbor_of_neighbor(face_no);</div></div><!-- fragment --><p>Once we do this we then have to loop over all the subfaces (children faces) of our cell's face and compute the interior fluxes across the children faces and the neighbor's face.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no=0;</div><div class="line">        subface_no &lt; face-&gt;number_of_children();</div><div class="line">        ++subface_no)</div><div class="line">{</div></div><!-- fragment --><p>We then get the neighbor cell's subface that matches our cell face's subface and the specific subface number. We assert that the parent face cannot be more than one level of refinement above the child's face. This is because the deal.ii library does not allow neighboring cells to have refinement levels that are more than one level in difference.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor_child =</div><div class="line">         cell-&gt;neighbor_child_on_subface(face_no, </div><div class="line">                                         subface_no);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!neighbor_child-&gt;has_children(), </div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Now that we are ready to build the local flux matrices for this face we reset them e zero and reinitialize this <code>fe_values</code> to this cell's subface and <code>neighbor_child</code>'s <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and the <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects on the appropriate faces.</p>
<div class="fragment"><div class="line">vi_ui_matrix = 0;</div><div class="line">vi_ue_matrix = 0;</div><div class="line">ve_ui_matrix = 0;</div><div class="line">ve_ue_matrix = 0;</div><div class="line"></div><div class="line">fe_subface_values.reinit(cell, face_no, subface_no);</div><div class="line">fe_neighbor_face_values.reinit(neighbor_child, </div><div class="line">                               neighbor_face_no);</div></div><!-- fragment --><p>In addition, we get the minimum of diameters of the two cells to include in the penalty term</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> h = std::min(cell-&gt;diameter(), </div><div class="line">                    neighbor_child-&gt;diameter());</div></div><!-- fragment --><p>We now finally assemble the interior fluxes for the case of a face which has been refined using exactly the same subroutine as we do when both cells have the same refinement level.</p>
<div class="fragment"><div class="line">assemble_flux_terms(fe_subface_values,</div><div class="line">                    fe_neighbor_face_values,</div><div class="line">                    vi_ui_matrix,</div><div class="line">                    vi_ue_matrix,</div><div class="line">                    ve_ui_matrix,</div><div class="line">                    ve_ue_matrix,</div><div class="line">                    h);</div></div><!-- fragment --><p>Now all that is left to be done before distribuing the local flux matrices to the global system is get the neighbor child faces dof indices.</p>
<div class="fragment"><div class="line">neighbor_child-&gt;get_dof_indices(local_neighbor_dof_indices);</div></div><!-- fragment --><p>Once we have this cells dof indices and the neighboring cell's dof indices we can use the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> to distribute the local flux matrices to the global system matrix. This is done through the class function <code>distribute_local_flux_to_global()</code>.</p>
<div class="fragment"><div class="line">        distribute_local_flux_to_global(</div><div class="line">                                  vi_ui_matrix,</div><div class="line">                                  vi_ue_matrix,</div><div class="line">                                  ve_ui_matrix,</div><div class="line">                                  ve_ue_matrix,</div><div class="line">                                  local_dof_indices,</div><div class="line">                                  local_neighbor_dof_indices);</div><div class="line">    } </div><div class="line">} </div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div></div><!-- fragment --><p>At this point we know that this cell and the neighbor of this cell are on the same refinement level and the work to assemble the interior flux matrices is very much the same as before. Infact it is much simpler since we do not have to loop through the subfaces. However, we have to check that we do not compute the same contribution twice. This would happen because we are looping over all the faces of all the cells in the mesh and assembling the interior flux matrices for each face. To avoid doing assembling the interior flux matrices twice we only compute the interior fluxes once for each face by restricting that the following computation only occur on the on the cell face with the lower <a class="el" href="classCellId.html">CellId</a>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(neighbor-&gt;level() == cell-&gt;level() &amp;&amp;</div><div class="line">    cell-&gt;id() &lt; neighbor-&gt;id())</div><div class="line">{</div></div><!-- fragment --><p>Here we find the neighbor face such that neighbor(neigh_face_no) = cell(face_no). In addition we, reinitialize the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and neighbor cell's <a class="el" href="classFEFaceValues.html">FEFaceValues</a> on their respective cells' faces, as well as get the minimum diameter of this cell and the neighbor cell and assign it to <code>h</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor_face_no =</div><div class="line">    cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">vi_ui_matrix = 0;</div><div class="line">vi_ue_matrix = 0;</div><div class="line">ve_ui_matrix = 0;</div><div class="line">ve_ue_matrix = 0;</div><div class="line"></div><div class="line">fe_face_values.<a class="code" href="classFEFaceValues.html#af6e079ca7429d54433343d50bd334c3c">reinit</a>(cell, face_no);</div><div class="line">fe_neighbor_face_values.reinit(neighbor, </div><div class="line">                              neighbor_face_no);</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> h = std::min(cell-&gt;diameter(), </div><div class="line">                    neighbor-&gt;diameter());</div></div><!-- fragment --><p>Just as before we assemble the interior fluxes using the <code>assemble_flux_terms</code> subroutine, get the neighbor cell's face dof indices and use the constraint matrix to distribute the local flux matrices to the global <code>system_matrix</code> using the class function <code>distribute_local_flux_to_global()</code></p>
<div class="fragment"><div class="line">                assemble_flux_terms(fe_face_values,</div><div class="line">                                    fe_neighbor_face_values,</div><div class="line">                                    vi_ui_matrix,</div><div class="line">                                    vi_ue_matrix,</div><div class="line">                                    ve_ui_matrix,</div><div class="line">                                    ve_ue_matrix,</div><div class="line">                                    h);</div><div class="line"></div><div class="line">                neighbor-&gt;get_dof_indices(local_neighbor_dof_indices);</div><div class="line">                </div><div class="line">                distribute_local_flux_to_global(</div><div class="line">                                        vi_ui_matrix,</div><div class="line">                                        vi_ue_matrix,</div><div class="line">                                        ve_ui_matrix,</div><div class="line">                                        ve_ue_matrix,</div><div class="line">                                        local_dof_indices,</div><div class="line">                                        local_neighbor_dof_indices);</div><div class="line"></div><div class="line">              </div><div class="line">            } </div><div class="line">        } </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p>Now that have looped over all the faces for this cell and computed as well as disributed the local flux matrices to the <code>system_matrix</code>, we can finally distribute the cell's <code>local_matrix</code> and <code>local_vector</code> contribution to the global system matrix and global right hand side vector. We remark that we have to wait until this point to distribute the <code>local_matrix</code> and <code>system_rhs</code> to the global system. The reason being that in looping over the faces the faces on the boundary of the domain contribute to the <code>local_matrix</code> and <code>system_rhs</code>. We could distribute the local contributions for each component seperately, but writing to the distributed sparse matrix and vector is expensive and want to to minimize the number of times we do so.</p>
<div class="fragment"><div class="line">        constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(local_vector,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_rhs);</div><div class="line"></div><div class="line">    } </div><div class="line">}</div></div><!-- fragment --><p>We need to synchronize assembly of our global system matrix and global right hand side vector with all the other processors and use the compress() function to do this. This was discussed in detail in <a class="el" href="step_40.html">step-40</a>.</p>
<div class="fragment"><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#ad581edc4d3b86a88c4277117c4fae57a">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="assemble_cell_terms"></a> </p><h4>assemble_cell_terms</h4>
<p>This function deals with constructing the local matrix due to the solid integrals over each element and is very similar to the the other examples in the deal.ii tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">assemble_cell_terms(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     &amp;cell_fe,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>      &amp;cell_matrix,</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>          &amp;cell_vector)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell_fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = cell_fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> VectorField(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> Potential(dim);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;              rhs_values(n_q_points);</div></div><!-- fragment --><p>We first get the value of the right hand side function evaluated at the quadrature points in the cell.</p>
<div class="fragment"><div class="line">rhs_function.value_list(cell_fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                        rhs_values);</div></div><!-- fragment --><p>Now, we loop over the quadrature points in the cell and then loop over the degrees of freedom and perform quadrature to approximate the integrals.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; q++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> psi_i_field          = cell_fe[VectorField].value(i,q);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         div_psi_i_field      = cell_fe[VectorField].divergence(i,q);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         psi_i_potential      = cell_fe[Potential].value(i,q);</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_psi_i_potential = cell_fe[Potential].gradient(i,q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; j++)</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> psi_j_field        = cell_fe[VectorField].value(j,q);</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>         psi_j_potential    = cell_fe[Potential].value(j,q);</div></div><!-- fragment --><p>This computation corresponds to assembling the local system matrix for the integral over an element,</p>
<p><img class="formulaInl" alt="$\int_{\Omega_{e}} \left(\textbf{w} \cdot \textbf{q} - \nabla \cdot \textbf{w} u - \nabla w \cdot \textbf{q} \right) dx $" src="form_4326.png"/></p>
<div class="fragment"><div class="line">    cell_matrix(i,j)  += ( (psi_i_field * psi_j_field)</div><div class="line">                           -</div><div class="line">                           (div_psi_i_field * psi_j_potential)</div><div class="line">                           -</div><div class="line">                           (grad_psi_i_potential * psi_j_field)</div><div class="line">                         ) * cell_fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">} </div></div><!-- fragment --><p>And this local right hand vector corresponds to the integral over the element cell,</p>
<p><img class="formulaInl" alt="$ \int_{\Omega_{e}} w \, f(\textbf{x}) \, dx $" src="form_4327.png"/></p>
<div class="fragment"><div class="line">            cell_vector(i) += psi_i_potential *</div><div class="line">                              rhs_values[q] *</div><div class="line">                              cell_fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        } </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="assemble_Dirichlet_boundary_terms"></a> </p><h4>assemble_Dirichlet_boundary_terms</h4>
<p>Here we have the function that builds the <code>local_matrix</code> contribution and local right hand side vector, <code>local_vector</code> for the Dirichlet boundary condtions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">assemble_Dirichlet_boundary_terms(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     &amp;face_fe,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          &amp;local_matrix,</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>              &amp;local_vector,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                &amp; h)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell     = face_fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points        = face_fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> VectorField(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> Potential(dim);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;     Dirichlet_bc_values(n_q_points);</div></div><!-- fragment --><p>In order to evaluate the flux on the Dirichlet boundary face we first get the value of the Dirichlet boundary function on the quadrature points of the face. Then we loop over all the quadrature points and degrees of freedom and approximate the integrals on the Dirichlet boundary element faces.</p>
<div class="fragment"><div class="line">Dirichlet_bc_function.value_list(face_fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                 Dirichlet_bc_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; q++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> psi_i_field     = face_fe[VectorField].value(i,q);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         psi_i_potential = face_fe[Potential].value(i,q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; j++)</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> psi_j_field    = face_fe[VectorField].value(j,q);</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>         psi_j_potential = face_fe[Potential].value(j,q);</div></div><!-- fragment --><p>We compute contribution for the flux <img class="formulaInl" alt="$\widehat{q}$" src="form_4328.png"/> on the Dirichlet boundary which enters our system matrix as,</p>
<p><img class="formulaInl" alt="$ \int_{\text{face}} w \, ( \textbf{n} \cdot \textbf{q} + \sigma u) ds $" src="form_4329.png"/></p>
<div class="fragment"><div class="line">    local_matrix(i,j) += psi_i_potential * (</div><div class="line">                            face_fe.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                            psi_j_field</div><div class="line">                            +</div><div class="line">                            (penalty/h) *</div><div class="line">                            psi_j_potential) *</div><div class="line">                            face_fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">} </div></div><!-- fragment --><p>We also compute the contribution for the flux for <img class="formulaInl" alt="$\widehat{u}$" src="form_4330.png"/> on the Dirichlet boundary which is the Dirichlet boundary condition function and enters the right hand side vector as</p>
<p><img class="formulaInl" alt="$\int_{\text{face}} (-\textbf{w} \cdot \textbf{n} + \sigma w) \, u_{D} ds $" src="form_4331.png"/></p>
<div class="fragment"><div class="line">            local_vector(i) += (-1.0 * psi_i_field *</div><div class="line">                                face_fe.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q)</div><div class="line">                                +</div><div class="line">                                (penalty/h) *</div><div class="line">                                psi_i_potential) *</div><div class="line">                                Dirichlet_bc_values[q] *</div><div class="line">                                face_fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        } </div><div class="line">    }  </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="assemble_Neumann_boundary_terms"></a> </p><h4>assemble_Neumann_boundary_terms</h4>
<p>Here we have the function that builds the <code>local_matrix</code> and <code>local_vector</code> for the Neumann boundary condtions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">assemble_Neumann_boundary_terms(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>     &amp;face_fe,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          &amp;local_matrix,</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>              &amp;local_vector)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = face_fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = face_fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> VectorField(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> Potential(dim);</div></div><!-- fragment --><p>In order to get evaluate the flux on the Neumann boundary face we first get the value of the Neumann boundary function on the quadrature points of the face. Then we loop over all the quadrature points and degrees of freedom and approximate the integrals on the Neumann boundary element faces.</p>
<div class="fragment"><div class="line">std::vector&lt;double &gt;    Neumann_bc_values(n_q_points);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; q++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> psi_i_field     = face_fe[VectorField].value(i,q);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         psi_i_potential = face_fe[Potential].value(i,q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; j++)</div><div class="line">        {</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>    psi_j_potential = face_fe[Potential].value(j,q);</div></div><!-- fragment --><p>We compute contribution for the flux <img class="formulaInl" alt="$\widehat{u}$" src="form_4330.png"/> on the Neumann boundary which enters our system matrix as,</p>
<p><img class="formulaInl" alt="$\int_{\text{face}} \textbf{w} \cdot \textbf{n} \, u \, ds $" src="form_4332.png"/></p>
<div class="fragment"><div class="line">    local_matrix(i,j) += psi_i_field *</div><div class="line">                         face_fe.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                         psi_j_potential *</div><div class="line">                         face_fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">} </div></div><!-- fragment --><p>We also compute the contribution for the flux for <img class="formulaInl" alt="$\widehat{q}$" src="form_4328.png"/> on the Neumann bounary which is the Neumann boundary condition and enters the right hand side vector as</p>
<p><img class="formulaInl" alt="$\int_{\text{face}} -w \, g_{N} \, ds$" src="form_4333.png"/></p>
<div class="fragment"><div class="line">            local_vector(i) +=  -psi_i_potential *</div><div class="line">                                Neumann_bc_values[q] *</div><div class="line">                                face_fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        } </div><div class="line">    }  </div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="assemble_flux_terms"></a> </p><h4>assemble_flux_terms</h4>
<p>Now we finally get to the function which builds the interior fluxes. This is a rather long function and we will describe what is going on in detail.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">assemble_flux_terms(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>     &amp;fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>     &amp;fe_neighbor_face_values,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>              &amp;vi_ui_matrix,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>              &amp;vi_ue_matrix,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>              &amp;ve_ui_matrix,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>              &amp;ve_ue_matrix,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                    &amp; h)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_points      = fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_this_cell     = fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_neighbor_cell = fe_neighbor_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> VectorField(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> Potential(dim);</div></div><!-- fragment --><p>The first thing we do is after the boilerplate is define the unit vector <img class="formulaInl" alt="$\boldsymbol \beta$" src="form_4304.png"/> that is used in defining the LDG/ALternating fluxes.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> beta;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">    beta(i) = 1.0;</div><div class="line">beta /= <a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(beta.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>() );</div></div><!-- fragment --><p>Now we loop over all the quadrature points on the element face and loop over all the degrees of freedom and approximate the following flux integrals.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_points; q++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_this_cell; i++)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a>  psi_i_field_minus  =</div><div class="line">            fe_face_values[VectorField].value(i,q);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> psi_i_potential_minus  =</div><div class="line">            fe_face_values[Potential].value(i,q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_this_cell; j++)</div><div class="line">        {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> psi_j_field_minus   =</div><div class="line">                fe_face_values[VectorField].value(j,q);</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> psi_j_potential_minus  =</div><div class="line">                fe_face_values[Potential].value(j,q);</div></div><!-- fragment --><p>We compute the flux matrix where the test function's as well as the solution function's values are taken from the interior as,</p>
<p><img class="formulaInl" alt="$\int_{\text{face}} \left( \frac{1}{2} \, \textbf{n}^{-} \cdot ( \textbf{w}^{-} u^{-} + w^{-} \textbf{q}^{-}) + \boldsymbol \beta \cdot \textbf{w}^{-} u^{-} - w^{-} \boldsymbol \beta \cdot \textbf{q}^{-} + \sigma w^{-} \, u^{-} \right) ds$" src="form_4334.png"/></p>
<div class="fragment"><div class="line">    vi_ui_matrix(i,j)   += (0.5 * (</div><div class="line">                            psi_i_field_minus *</div><div class="line">                            fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                            psi_j_potential_minus</div><div class="line">                            +</div><div class="line">                            psi_i_potential_minus *</div><div class="line">                            fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                            psi_j_field_minus )</div><div class="line">                            +</div><div class="line">                            beta *</div><div class="line">                            psi_i_field_minus *</div><div class="line">                            psi_j_potential_minus</div><div class="line">                            -</div><div class="line">                            beta *</div><div class="line">                            psi_i_potential_minus *</div><div class="line">                            psi_j_field_minus</div><div class="line">                            +</div><div class="line">                            (penalty/h) *</div><div class="line">                            psi_i_potential_minus *</div><div class="line">                            psi_j_potential_minus</div><div class="line">                           ) *</div><div class="line">                           fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">} </div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_neighbor_cell; j++)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> psi_j_field_plus    =</div><div class="line">        fe_neighbor_face_values[VectorField].value(j,q);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>            psi_j_potential_plus        =</div><div class="line">        fe_neighbor_face_values[Potential].value(j,q);</div></div><!-- fragment --><p>We compute the flux matrix where the test function is from the interior of this elements face and solution function is taken from the exterior. This corresponds to the computation,</p>
<p><img class="formulaInl" alt="$\int_{\text{face}} \left( \frac{1}{2} \, \textbf{n}^{-} \cdot ( \textbf{w}^{-} u^{+} + w^{-} \textbf{q}^{+}) - \boldsymbol \beta \cdot \textbf{w}^{-} u^{+} + w^{-} \boldsymbol \beta \cdot \textbf{q}^{+} - \sigma w^{-} \, u^{+} \right) ds $" src="form_4335.png"/></p>
<div class="fragment"><div class="line">        vi_ue_matrix(i,j) += ( 0.5 * (</div><div class="line">                                psi_i_field_minus *</div><div class="line">                                fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                                psi_j_potential_plus</div><div class="line">                                +</div><div class="line">                                psi_i_potential_minus *</div><div class="line">                                fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                                psi_j_field_plus )</div><div class="line">                                -</div><div class="line">                                beta *</div><div class="line">                                psi_i_field_minus *</div><div class="line">                                psi_j_potential_plus</div><div class="line">                                +</div><div class="line">                                beta *</div><div class="line">                                psi_i_potential_minus *</div><div class="line">                                psi_j_field_plus</div><div class="line">                                -</div><div class="line">                                (penalty/h) *</div><div class="line">                                psi_i_potential_minus *</div><div class="line">                                psi_j_potential_plus</div><div class="line">                            ) *</div><div class="line">                             fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    } </div><div class="line">} </div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_neighbor_cell; i++)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a>  psi_i_field_plus =</div><div class="line">        fe_neighbor_face_values[VectorField].value(i,q);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>         psi_i_potential_plus =</div><div class="line">        fe_neighbor_face_values[Potential].value(i,q);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_this_cell; j++)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> psi_j_field_minus               =</div><div class="line">            fe_face_values[VectorField].value(j,q);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>        psi_j_potential_minus       =</div><div class="line">            fe_face_values[Potential].value(j,q);</div></div><!-- fragment --><p>We compute the flux matrix where the test function is from the exterior of this elements face and solution function is taken from the interior. This corresponds to the computation,</p>
<p><img class="formulaInl" alt="$ \int_{\text{face}} \left( -\frac{1}{2}\, \textbf{n}^{-} \cdot (\textbf{w}^{+} u^{-} + w^{+} \textbf{q}^{-} ) - \boldsymbol \beta \cdot \textbf{w}^{+} u^{-} + w^{+} \boldsymbol \beta \cdot \textbf{q}^{-} - \sigma w^{+} u^{-} \right) ds $" src="form_4336.png"/></p>
<div class="fragment"><div class="line">    ve_ui_matrix(i,j) +=  (-0.5 * (</div><div class="line">                            psi_i_field_plus *</div><div class="line">                            fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                            psi_j_potential_minus</div><div class="line">                            +</div><div class="line">                            psi_i_potential_plus *</div><div class="line">                            fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                            psi_j_field_minus)</div><div class="line">                            -</div><div class="line">                            beta *</div><div class="line">                            psi_i_field_plus *</div><div class="line">                            psi_j_potential_minus</div><div class="line">                            +</div><div class="line">                            beta *</div><div class="line">                            psi_i_potential_plus *</div><div class="line">                            psi_j_field_minus</div><div class="line">                            -</div><div class="line">                            (penalty/h) *</div><div class="line">                            psi_i_potential_plus *</div><div class="line">                            psi_j_potential_minus</div><div class="line">                            ) *</div><div class="line">                            fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">} </div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_neighbor_cell; j++)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> psi_j_field_plus =</div><div class="line">        fe_neighbor_face_values[VectorField].value(j,q);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>        psi_j_potential_plus =</div><div class="line">        fe_neighbor_face_values[Potential].value(j,q);</div></div><!-- fragment --><p>And lastly we compute the flux matrix where the test function and solution function are taken from the exterior cell to this face. This corresponds to the computation,</p>
<p><img class="formulaInl" alt="$\int_{\text{face}} \left( -\frac{1}{2}\, \textbf{n}^{-} \cdot ( \textbf{w}^{+} u^{+} + w^{+} \textbf{q}^{+} ) + \boldsymbol \beta \cdot \textbf{w}^{+} u^{+} - w^{+} \boldsymbol \beta \cdot \textbf{q}^{+} + \sigma w^{+} u^{+} \right) ds $" src="form_4337.png"/></p>
<div class="fragment"><div class="line">                ve_ue_matrix(i,j) +=    (-0.5 * (</div><div class="line">                                        psi_i_field_plus *</div><div class="line">                                        fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                                        psi_j_potential_plus</div><div class="line">                                        +</div><div class="line">                                        psi_i_potential_plus *</div><div class="line">                                        fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q) *</div><div class="line">                                        psi_j_field_plus )</div><div class="line">                                        +</div><div class="line">                                        beta *</div><div class="line">                                        psi_i_field_plus *</div><div class="line">                                        psi_j_potential_plus</div><div class="line">                                        -</div><div class="line">                                        beta *</div><div class="line">                                        psi_i_potential_plus *</div><div class="line">                                        psi_j_field_plus</div><div class="line">                                        +</div><div class="line">                                        (penalty/h) *</div><div class="line">                                        psi_i_potential_plus *</div><div class="line">                                        psi_j_potential_plus</div><div class="line">                                        ) *</div><div class="line">                                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            } </div><div class="line"></div><div class="line">        } </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="distribute_local_flux_to_global"></a> </p><h4>distribute_local_flux_to_global</h4>
<p>In this function we use the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> to distribute the local flux matrices to the global system matrix. Since I have to do this twice in assembling the system matrix, I made function to do it rather than have repeated code. We remark that the reader take special note of the which matrices we are distributing and the order in which we pass the dof indices vectors. In distributing the first matrix, i.e. <code>vi_ui_matrix</code>, we are taking the test function and solution function values from the interior of this cell and therefore only need the <code>local_dof_indices</code> since it contains the dof indices to this cell. When we distribute the second matrix, <code>vi_ue_matrix</code>, the test function is taken form the inteior of this cell while the solution function is taken from the exterior, i.e. the neighbor cell. Notice that the order degrees of freedom index vectors matrch this pattern: first the <code>local_dof_indices</code> which is local to this cell and then the <code>local_neighbor_dof_indices</code> which is local to the neighbor's cell. The order in which we pass the dof indices for the matrices is paramount to constructing our global system matrix properly. The ordering of the last two matrices follow the same logic as the first two we discussed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> </div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">distribute_local_flux_to_global(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp; vi_ui_matrix,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp; vi_ue_matrix,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp; ve_ui_matrix,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp; ve_ue_matrix,</div><div class="line">        <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp; local_dof_indices,</div><div class="line">        <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp; local_neighbor_dof_indices)</div><div class="line">{</div><div class="line">  constraints.distribute_local_to_global(vi_ui_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         system_matrix);</div><div class="line"></div><div class="line">  constraints.distribute_local_to_global(vi_ue_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         local_neighbor_dof_indices,</div><div class="line">                                         system_matrix);</div><div class="line"></div><div class="line">  constraints.distribute_local_to_global(ve_ui_matrix,</div><div class="line">                                        local_neighbor_dof_indices,</div><div class="line">                                        local_dof_indices,</div><div class="line">                                        system_matrix);</div><div class="line"></div><div class="line">  constraints.distribute_local_to_global(ve_ue_matrix,</div><div class="line">                                         local_neighbor_dof_indices,</div><div class="line">                                         system_matrix);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="solve"></a> </p><h4>solve</h4>
<p>As mentioned earlier I used a direct solver to solve the linear system of equations resulting from the LDG method applied to the Poisson equation. One could also use a iterative sovler, however, we then need to use a preconditoner and that was something I did not wanted to get into. For information on preconditioners for the LDG Method see this <a href="http://epubs.siam.org/doi/abs/10.1137/S1064827502410657">paper</a>. The uses of a direct sovler here is somewhat of a limitation. The built-in distributed direct solver in Trilinos reduces everything to one processor, solves the system and then distributes everything back out to the other processors. However, by linking to more advanced direct sovlers through Trilinos one can accomplish fully distributed computations and not much about the following function calls will change.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">solve()</div><div class="line">{</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;solve&quot;</span>);</div></div><!-- fragment --><p>As in <a class="el" href="step_40.html">step-40</a> in order to perform a linear solve we need solution vector where there is no overlap across the processors and we create this by instantiating <code>completely_distributed_solution</code> solution vector using the copy constructor on the global system right hand side vector which itself is completely distributed vector.</p>
<div class="fragment"><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="line">completely_distributed_solution(system_rhs);</div></div><!-- fragment --><p>Now we can preform the solve on the completeley distributed right hand side vector, system matrix and the completely distributed solution.</p>
<div class="fragment"><div class="line">solver.solve(system_matrix,</div><div class="line">             completely_distributed_solution,</div><div class="line">             system_rhs);</div></div><!-- fragment --><p>We now distribute the constraints of our system onto the completely solution vector, but in our case with the LDG method there are none.</p>
<div class="fragment"><div class="line">constraints.distribute(completely_distributed_solution);</div></div><!-- fragment --><p>Lastly we copy the completely distributed solution vector, <code>completely_distributed_solution</code>, to solution vector which has some overlap between processors, <code>locally_relevant_solution</code>. We need the overlapped portions of our solution in order to be able to do computations using the solution later in the code or in post processing.</p>
<div class="fragment"><div class="line">    locally_relevant_solution = completely_distributed_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="output_results"></a> </p><h4>output_results</h4>
<p>This function deals with the writing of the reuslts in parallel to disk. It is almost exactly the same as in <a class="el" href="step_40.html">step-40</a> and we wont go into it. It is noteworthy that in <a class="el" href="step_40.html">step-40</a> the output is only the scalar solution, while in our situation, we are outputing both the scalar solution as well as the vector field solution. The only difference between this function and the one in <a class="el" href="step_40.html">step-40</a> is in the <code>solution_names</code> vector where we have to add the gradient dimensions. Everything else is taken care of by the deal.ii library!</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">output_results()<span class="keyword">    const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    <span class="keywordflow">switch</span>(dim)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> 1:</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;du/dx&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">case</span> 2:</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;grad(u)_x&quot;</span>);</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;grad(u)_y&quot;</span>);</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">case</span> 3:</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;grad(u)_x&quot;</span>);</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;grad(u)_y&quot;</span>);</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;grad(u)_z&quot;</span>);</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>() );</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a>    data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(locally_relevant_solution,</div><div class="line">                             solution_names);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a>   subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;subdomain.size(); i++)</div><div class="line">        subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(subdomain,<span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = (<span class="stringliteral">&quot;solution.&quot;</span>   +</div><div class="line">                                  <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(</div><div class="line">                                  triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(),4));</div><div class="line"></div><div class="line">    std::ofstream output((filename + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0 )</div><div class="line">    {</div><div class="line">        std::vector&lt;std::string&gt;    filenames;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">                i &lt; <a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD);</div><div class="line">                i++)</div><div class="line">        {</div><div class="line">            filenames.push_back(<span class="stringliteral">&quot;solution.&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i,4) +</div><div class="line">                                <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">        }</div><div class="line">        std::ofstream master_output(<span class="stringliteral">&quot;solution.pvtu&quot;</span>);</div><div class="line">        data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a>(master_output, filenames);</div><div class="line">    } </div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="run"></a> </p><h4>run</h4>
<p>The only public function of this class is pretty much exactly the same as all the other deal.ii examples except I setting the constant in the DG penalty ( <img class="formulaInl" alt="$\tilde{\sigma}$" src="form_4309.png"/>) to be 1.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LDGPoissonProblem&lt;dim&gt;::</div><div class="line">run()</div><div class="line">{</div><div class="line">    penalty = 1.0;</div><div class="line">    make_grid();</div><div class="line">    make_dofs();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();  </div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="main"></a> </p><h3>main</h3>
<p>Here it the main class of our program, since it is nearly exactly the same as <a class="el" href="step_40.html">step-40</a> and many of the other examples I won't elaborate on it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">        deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(0);</div><div class="line"></div><div class="line">        <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv,</div><div class="line">                                            <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree = 1;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refine = 6;</div><div class="line">        LDGPoissonProblem&lt;2&gt;    Poisson(degree, n_refine);</div><div class="line">        Poisson.run();</div><div class="line">        </div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
