<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: deal.II and the C++11 standard</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">deal.II and the C++11 standard</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestd__cxx11"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestd__cxx11.html">std_cxx11</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIteratorRange.html">IteratorRange&lt; Iterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaec59eec63fe5999c595cd0980f998a5a"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObjectType &gt; </td></tr>
<tr class="memitem:gaec59eec63fe5999c595cd0980f998a5a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gaec59eec63fe5999c595cd0980f998a5a">Threads::new_thread</a> (FunctionObjectType function_object) -&gt; <a class="el" href="classThreads_1_1Thread.html">Thread</a>&lt; decltype(function_object())&gt;</td></tr>
<tr class="separator:gaec59eec63fe5999c595cd0980f998a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880e3efbb0a778f8c9d91c69c2967475"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObjectType &gt; </td></tr>
<tr class="memitem:ga880e3efbb0a778f8c9d91c69c2967475"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga880e3efbb0a778f8c9d91c69c2967475">Threads::new_task</a> (FunctionObjectType function_object) -&gt; <a class="el" href="classThreads_1_1Task.html">Task</a>&lt; decltype(function_object())&gt;</td></tr>
<tr class="separator:ga880e3efbb0a778f8c9d91c69c2967475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga3948dd66d9e66ac55d89dc8f75fa4855">filter_iterators</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; BaseIterator &gt; i, const Predicate &amp;p)</td></tr>
<tr class="separator:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0db06fce5af606f8fe78476ffd4587"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate , typename... Targs&gt; </td></tr>
<tr class="memitem:ga3c0db06fce5af606f8fe78476ffd4587"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename internal::FilteredIterator::NestFilteredIterators&lt; BaseIterator, std::tuple&lt; Predicate, Targs... &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga3c0db06fce5af606f8fe78476ffd4587">filter_iterators</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; BaseIterator &gt; i, const Predicate &amp;p, const Targs... args)</td></tr>
<tr class="separator:ga3c0db06fce5af606f8fe78476ffd4587"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cell iterator functions returning ranges of iterators</h2></td></tr>
<tr class="memitem:ga7295c669f32e78c45446ddc236f19136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga5cda850f6fb2dd1f2e473bac5cb1ed2a">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga7295c669f32e78c45446ddc236f19136">DoFHandler&lt; dim, spacedim &gt;::cell_iterators</a> () const</td></tr>
<tr class="separator:ga7295c669f32e78c45446ddc236f19136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdb6d3adec96a13a7079f6c893e1d3ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">DoFHandler&lt; dim, spacedim &gt;::active_cell_iterators</a> () const</td></tr>
<tr class="separator:gacdb6d3adec96a13a7079f6c893e1d3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63916e6c9bdd49cb161064204bde0c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; level_cell_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga63916e6c9bdd49cb161064204bde0c13">DoFHandler&lt; dim, spacedim &gt;::mg_cell_iterators</a> () const</td></tr>
<tr class="separator:ga63916e6c9bdd49cb161064204bde0c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb307c39a2891e324a723063c6994427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga5cda850f6fb2dd1f2e473bac5cb1ed2a">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">DoFHandler&lt; dim, spacedim &gt;::cell_iterators_on_level</a> (const unsigned int level) const</td></tr>
<tr class="separator:gacb307c39a2891e324a723063c6994427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b267dbf912ec4d8227070cf0ccac13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga47b267dbf912ec4d8227070cf0ccac13">DoFHandler&lt; dim, spacedim &gt;::active_cell_iterators_on_level</a> (const unsigned int level) const</td></tr>
<tr class="separator:ga47b267dbf912ec4d8227070cf0ccac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e87d46e8518de15c7e5d1cf0b407a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; level_cell_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga87e87d46e8518de15c7e5d1cf0b407a2">DoFHandler&lt; dim, spacedim &gt;::mg_cell_iterators_on_level</a> (const unsigned int level) const</td></tr>
<tr class="separator:ga87e87d46e8518de15c7e5d1cf0b407a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cell iterator functions returning ranges of iterators</h2></td></tr>
<tr class="memitem:gaef378969994082255fbc64366511a7d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga850b56c93cbebd27eb066edbd84aa711">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gaef378969994082255fbc64366511a7d1">Triangulation&lt; dim, spacedim &gt;::cell_iterators</a> () const</td></tr>
<tr class="separator:gaef378969994082255fbc64366511a7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4288670ae5bd80367e24918d542cb2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga7f54e1f60de3cc5adb6ad00d23ee150b">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation&lt; dim, spacedim &gt;::active_cell_iterators</a> () const</td></tr>
<tr class="separator:ga4288670ae5bd80367e24918d542cb2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27379d62cc1c17e52b4236601b943d0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga850b56c93cbebd27eb066edbd84aa711">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga27379d62cc1c17e52b4236601b943d0f">Triangulation&lt; dim, spacedim &gt;::cell_iterators_on_level</a> (const unsigned int level) const</td></tr>
<tr class="separator:ga27379d62cc1c17e52b4236601b943d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10cd3fe6ef8360e2599d3cff58e13e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga7f54e1f60de3cc5adb6ad00d23ee150b">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gac10cd3fe6ef8360e2599d3cff58e13e8">Triangulation&lt; dim, spacedim &gt;::active_cell_iterators_on_level</a> (const unsigned int level) const</td></tr>
<tr class="separator:gac10cd3fe6ef8360e2599d3cff58e13e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cell iterator functions returning ranges of iterators</h2></td></tr>
<tr class="memitem:ga7295c669f32e78c45446ddc236f19136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga7295c669f32e78c45446ddc236f19136">hp::DoFHandler&lt; dim, spacedim &gt;::cell_iterators</a> () const</td></tr>
<tr class="separator:ga7295c669f32e78c45446ddc236f19136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdb6d3adec96a13a7079f6c893e1d3ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">hp::DoFHandler&lt; dim, spacedim &gt;::active_cell_iterators</a> () const</td></tr>
<tr class="separator:gacdb6d3adec96a13a7079f6c893e1d3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb307c39a2891e324a723063c6994427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">hp::DoFHandler&lt; dim, spacedim &gt;::cell_iterators_on_level</a> (const unsigned int level) const</td></tr>
<tr class="separator:gacb307c39a2891e324a723063c6994427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b267dbf912ec4d8227070cf0ccac13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga47b267dbf912ec4d8227070cf0ccac13">hp::DoFHandler&lt; dim, spacedim &gt;::active_cell_iterators_on_level</a> (const unsigned int level) const</td></tr>
<tr class="separator:ga47b267dbf912ec4d8227070cf0ccac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>At present, deal.II only requires a compiler that conforms to the <a href="http://en.wikipedia.org/wiki/C%2B%2B#Standardization">C++98</a> standard and does not rely on compilers to either provide the features introduced in <a href="http://en.wikipedia.org/wiki/C%2B%2B03">C++03</a> or <a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11</a></p>
<p>That said, deal.II interfaces with C++11 in several ways as outlined below.</p>
<h3>Use of C++11 classes and substitution by BOOST</h3>
<p>deal.II makes use of many of the classes that were only added as part of C++11. This includes std::shared_ptr, std::function, std::bind, std::tuple and a number of others. Because we do not assume that the compiler actually supports C++11, there needs to be a way to ensure that these classes are available also for pre-C++11 compilers. This is done using the following approach:</p>
<ul>
<li>We create a namespace <a class="el" href="namespacestd__cxx11.html">std_cxx11</a>.</li>
<li>If the compiler supports C++11, we import the relevant classes and functions into this namespace using statements such as <div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacestd__cxx11.html">std_cxx11</a> {  <span class="keyword">using</span> std::shared_ptr;  }</div></div><!-- fragment --></li>
<li>If the compiler does not support C++11, if its support for C++11 is incomplete, or if it is buggy, then we use as a fallback the corresponding classes and functions provided by the <a href="http://www.boost.org">BOOST library</a> through statements such as <div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacestd__cxx11.html">std_cxx11</a> {  <span class="keyword">using</span> boost::shared_ptr;  }</div></div><!-- fragment --></li>
</ul>
<p>Consequently, namespace <a class="el" href="namespacestd__cxx11.html">std_cxx11</a> contains all of the symbols we require. The classes that can be used this way are obviously a subset of the intersection between C++11 and what BOOST provides.</p>
<h3>Support for C++11 range-based for loops</h3>
<p>C++11 provides many new core language features, such as rvalue references and move semantics, initialized lists, tuples, variadic templates and others. For a complete list, see <a href="http://en.wikipedia.org/wiki/C++11">http://en.wikipedia.org/wiki/C++11</a> . We can not use most of these in deal.II itself because we cannot rely on compilers supporting them.</p>
<p>However, this does not preclude users from using such features in their own applications if they can be reasonably sure that the compilers on all of the systems they will work on do support C++11. An example are <a href="http://en.wikipedia.org/wiki/C++11#Type_inference">automatically typed variables</a>.</p>
<p>deal.II does provide some features that make programming simpler when using C++11. This is true, in particular, for <a href="http://en.wikipedia.org/wiki/C++11#Range-based_for_loop">range-based for loops</a>. deal.II-based codes often have many loops of the kind </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> triangulation;</div><div class="line">...</div><div class="line">typename <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  cell-&gt;set_refine_flag();</div></div><!-- fragment --><p> Using C++11's range-based for loops, you can now write this as follows: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> triangulation;</div><div class="line">...</div><div class="line">for (<span class="keyword">auto</span> cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  cell-&gt;set_refine_flag();</div></div><!-- fragment --><p> This relies on functions such as <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators()</a>, and equivalents in the DoF handler classes, <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">DoFHandler::active_cell_iterators()</a>, <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">hp::DoFHandler::active_cell_iterators()</a>. There are variants of these functions that provide iterator ranges for all cells (not just the active ones) and for cells on individual levels.</p>
<h3>Things that are only enabled if your compiler supports C++11</h3>
<p>There is a small number of places inside deal.II where we allow ourselves the use of C++11 because it makes things so much simpler. These features are simply not available if your compiler does not support C++11, but this does not affect the usability of the remainder of deal.II.</p>
<p>Specifically, these places are:</p><ul>
<li>The <a class="el" href="classLinearOperator.html">LinearOperator</a> class and all associated functions such as <a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator()</a>, <a class="el" href="group__LAOperators.html#ga2043a16b6855670766f46780a39f03f3">null_operator()</a>, and everything else that is part of the LAOperators documentation module.</li>
<li>The <a class="el" href="classFE__Enriched.html">FE_Enriched</a> class. </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaec59eec63fe5999c595cd0980f998a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec59eec63fe5999c595cd0980f998a5a">&#9670;&nbsp;</a></span>new_thread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Threads::new_thread </td>
          <td>(</td>
          <td class="paramtype">FunctionObjectType&#160;</td>
          <td class="paramname"><em>function_object</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classThreads_1_1Thread.html">Thread</a>&lt;decltype(function_object())&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of the <a class="el" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">new_thread()</a> function for objects that can be called like a function object without arguments. In particular, this function allows calling <a class="el" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread()</a> with either objects that result from using std::bind, or using lambda functions. For example, this function is called when writing code such as </p><div class="fragment"><div class="line"><a class="code" href="classThreads_1_1Thread.html">Threads::Thread&lt;int&gt;</a></div><div class="line">  thread = <a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a> ( [] () {</div><div class="line">                                         do_this();</div><div class="line">                                         then_do_that();</div><div class="line">                                         <span class="keywordflow">return</span> 42;</div><div class="line">                                       });</div></div><!-- fragment --><p> Here, we run the sequence of functions <code>do_this()</code> and <code>then_do_that()</code> on a separate thread, by making the lambda function declared here the function to execute on the thread. The lambda function then returns 42 (which is a bit pointless here, but it could of course be some computed number), and this is going to be the returned value you can later retrieve via <code>thread.return_value()</code> once the thread (i.e., the body of the lambda function) has completed.</p>
<dl class="section note"><dt>Note</dt><dd>Every lambda function (or whatever else it is you pass to the <a class="el" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">new_thread()</a> function here, for example the result of a std::bind() expression) has a return type and consequently returns an object of this type. This type can be inferred using the C++11 <code>decltype</code> statement used in the declaration of this function, and it is then used as the template argument of the <a class="el" href="classThreads_1_1Thread.html">Threads::Thread</a> object returned by the current function. In the example above, because the lambda function returns 42 (which in C++ has data type <code>int</code>), the inferred type is <code>int</code> and the task object will have type <code><a class="el" href="classThreads_1_1Task.html">Task</a>&lt;int&gt;</code>. In other words, it is not <em>necessary</em> to explicitly specify in user code what that return type of the lambda or std::bind expression will be, though it is possible to explicitly do so by (entirely equivalently) writing <div class="fragment"><div class="line"><a class="code" href="classThreads_1_1Thread.html">Threads::Thread&lt;int&gt;</a></div><div class="line">  thread = <a class="code" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">Threads::new_thread</a> ( [] () -&gt; <span class="keywordtype">int</span> {</div><div class="line">                                                do_this();</div><div class="line">                                                then_do_that();</div><div class="line">                                                <span class="keywordflow">return</span> 42;</div><div class="line">                                              });</div></div><!-- fragment --></dd>
<dd>
In practice, the lambda functions you will pass to <a class="el" href="group__threads.html#ga2003df2a027b3e716c290108ddeb558a">new_thread()</a> will of course typically be more complicated. In particular, they will likely <em>capture</em> variables from the surrounding context and use them within the lambda. See <a href="https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29">https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29</a> for more on how lambda functions work.</dd>
<dd>
If you pass a lambda function as an argument to the current function that captures a variable <em>by reference</em>, or if you use a std::bind that binds a function argument to a reference variable using std::ref() or std::cref(), then obviously you can only do this if the variables you reference or capture have a lifetime that extends at least until the time where the thread finishes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread__management_8h_source.html#l01816">1816</a> of file <a class="el" href="thread__management_8h_source.html">thread_management.h</a>.</p>

</div>
</div>
<a id="ga880e3efbb0a778f8c9d91c69c2967475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga880e3efbb0a778f8c9d91c69c2967475">&#9670;&nbsp;</a></span>new_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Threads::new_task </td>
          <td>(</td>
          <td class="paramtype">FunctionObjectType&#160;</td>
          <td class="paramname"><em>function_object</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classThreads_1_1Task.html">Task</a>&lt;decltype(function_object())&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of the new_task function for objects that can be called like a function object without arguments. In particular, this function allows calling <a class="el" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task()</a> with either objects that result from using std::bind, or using lambda functions. For example, this function is called when writing code such as </p><div class="fragment"><div class="line"><a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;int&gt;</a></div><div class="line">  task = <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a> ( [] () {</div><div class="line">                                     do_this();</div><div class="line">                                     then_do_that();</div><div class="line">                                     <span class="keywordflow">return</span> 42;</div><div class="line">                                   });</div></div><!-- fragment --><p> Here, we schedule the call to the sequence of functions <code>do_this()</code> and <code>then_do_that()</code> on a separate task, by making the lambda function declared here the function to execute on the task. The lambda function then returns 42 (which is a bit pointless here, but it could of course be some computed number), and this is going to be the returned value you can later retrieve via <code>task.return_value()</code> once the task (i.e., the body of the lambda function) has completed.</p>
<dl class="section note"><dt>Note</dt><dd>Every lambda function (or whatever else it is you pass to the <a class="el" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">new_task()</a> function here, for example the result of a std::bind() expression) has a return type and consequently returns an object of this type. This type can be inferred using the C++11 <code>decltype</code> statement used in the declaration of this function, and it is then used as the template argument of the <a class="el" href="classThreads_1_1Task.html">Threads::Task</a> object returned by the current function. In the example above, because the lambda function returns 42 (which in C++ has data type <code>int</code>), the inferred type is <code>int</code> and the task object will have type <code><a class="el" href="classThreads_1_1Task.html">Task</a>&lt;int&gt;</code>. In other words, it is not <em>necessary</em> to explicitly specify in user code what that return type of the lambda or std::bind expression will be, though it is possible to explicitly do so by (entirely equivalently) writing <div class="fragment"><div class="line"><a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;int&gt;</a></div><div class="line">  task = <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a> ( [] () -&gt; <span class="keywordtype">int</span> {</div><div class="line">                                            do_this();</div><div class="line">                                            then_do_that();</div><div class="line">                                            <span class="keywordflow">return</span> 42;</div><div class="line">                                          });</div></div><!-- fragment --></dd>
<dd>
In practice, the lambda functions you will pass to <a class="el" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">new_task()</a> will of course typically be more complicated. In particular, they will likely <em>capture</em> variables from the surrounding context and use them within the lambda. See <a href="https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29">https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29</a> for more on how lambda functions work.</dd>
<dd>
If you pass a lambda function as an argument to the current function that captures a variable <em>by reference</em>, or if you use a std::bind that binds a function argument to a reference variable using std::ref() or std::cref(), then obviously you can only do this if the variables you reference or capture have a lifetime that extends at least until the time where the task finishes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread__management_8h_source.html#l03280">3280</a> of file <a class="el" href="thread__management_8h_source.html">thread_management.h</a>.</p>

</div>
</div>
<a id="ga7295c669f32e78c45446ddc236f19136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7295c669f32e78c45446ddc236f19136">&#9670;&nbsp;</a></span>cell_iterators() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga5cda850f6fb2dd1f2e473bac5cb1ed2a">cell_iterator</a> &gt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::cell_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up this <a class="el" href="classDoFHandler.html">DoFHandler</a>. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classDoFHandler.html#a6af050921f3f1c3f2e6e20679a07f49b">begin()</a>, this-&gt;<a class="el" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end()</a>)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dofs_2dof__handler_8cc_source.html#l00825">825</a> of file <a class="el" href="dofs_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="gacdb6d3adec96a13a7079f6c893e1d3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdb6d3adec96a13a7079f6c893e1d3ff">&#9670;&nbsp;</a></span>active_cell_iterators() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">active_cell_iterator</a> &gt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active cells that make up this <a class="el" href="classDoFHandler.html">DoFHandler</a>. Such a range is useful to initialize range-based for loops as supported by C++11, see also <a class="el" href="group__CPP11.html">C++11 standard</a>.</p>
<p>Range-based for loops are useful in that they require much less code than traditional loops (see <a href="http://en.wikipedia.org/wiki/C%2B%2B11
#Range-based_for_loop">here</a> for a discussion of how they work). An example is that without range-based for loops, one often writes code such as the following: </p><div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">...</div><div class="line">typename <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">    ...do the local integration on <span class="stringliteral">&#39;cell&#39;</span>...;</div><div class="line">  }</div></div><!-- fragment --><p> Using C++11's range-based for loops, this is now entirely equivalent to the following: </p><div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">...</div><div class="line">for (<span class="keyword">auto</span> cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">    ...do the local integration on <span class="stringliteral">&#39;cell&#39;</span>...;</div><div class="line">  }</div></div><!-- fragment --><p> To use this feature, you need a compiler that supports C++11.</p>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active()</a>, this-&gt;<a class="el" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end()</a>)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dofs_2dof__handler_8cc_source.html#l00835">835</a> of file <a class="el" href="dofs_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="ga63916e6c9bdd49cb161064204bde0c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63916e6c9bdd49cb161064204bde0c13">&#9670;&nbsp;</a></span>mg_cell_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::level_cell_iterator &gt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::mg_cell_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up this <a class="el" href="classDoFHandler.html">DoFHandler</a> in their level-cell form. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg()</a>, this-&gt;<a class="el" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg()</a>)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dofs_2dof__handler_8cc_source.html#l00846">846</a> of file <a class="el" href="dofs_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="gacb307c39a2891e324a723063c6994427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb307c39a2891e324a723063c6994427">&#9670;&nbsp;</a></span>cell_iterators_on_level() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga5cda850f6fb2dd1f2e473bac5cb1ed2a">cell_iterator</a> &gt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::cell_iterators_on_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up the given level of this <a class="el" href="classDoFHandler.html">DoFHandler</a>. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A given level in the refinement hierarchy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;begin(level), this-&gt;end(level))</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>level must be less than this-&gt;n_levels(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="dofs_2dof__handler_8cc_source.html#l00858">858</a> of file <a class="el" href="dofs_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="ga47b267dbf912ec4d8227070cf0ccac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47b267dbf912ec4d8227070cf0ccac13">&#9670;&nbsp;</a></span>active_cell_iterators_on_level() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">active_cell_iterator</a> &gt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterators_on_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active cells that make up the given level of this <a class="el" href="classDoFHandler.html">DoFHandler</a>. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A given level in the refinement hierarchy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;begin_active(level), this-&gt;end(level))</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>level must be less than this-&gt;n_levels(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="dofs_2dof__handler_8cc_source.html#l00869">869</a> of file <a class="el" href="dofs_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="ga87e87d46e8518de15c7e5d1cf0b407a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e87d46e8518de15c7e5d1cf0b407a2">&#9670;&nbsp;</a></span>mg_cell_iterators_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::level_cell_iterator &gt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::mg_cell_iterators_on_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up the given level of this <a class="el" href="classDoFHandler.html">DoFHandler</a> in their level-cell form. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A given level in the refinement hierarchy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;begin_mg(level), this-&gt;end_mg(level))</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>level must be less than this-&gt;n_levels(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="dofs_2dof__handler_8cc_source.html#l00880">880</a> of file <a class="el" href="dofs_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="gaef378969994082255fbc64366511a7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef378969994082255fbc64366511a7d1">&#9670;&nbsp;</a></span>cell_iterators() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga850b56c93cbebd27eb066edbd84aa711">cell_iterator</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up this triangulation. Such a range is useful to initialize range- based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin()</a>, this-&gt;<a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a>)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10777">10777</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga4288670ae5bd80367e24918d542cb2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4288670ae5bd80367e24918d542cb2d8">&#9670;&nbsp;</a></span>active_cell_iterators() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga7f54e1f60de3cc5adb6ad00d23ee150b">active_cell_iterator</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active cells that make up this triangulation. Such a range is useful to initialize range-based for loops as supported by C++11, see also <a class="el" href="group__CPP11.html">C++11 standard</a>.</p>
<p>Range-based for loops are useful in that they require much less code than traditional loops (see <a href="http://en.wikipedia.org/wiki/C%2B%2B11
#Range-based_for_loop">here</a> for a discussion of how they work). An example is that without range-based for loops, one often writes code such as the following (assuming for a moment that our goal is setting the user flag on every active cell): </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> triangulation;</div><div class="line">...</div><div class="line">typename <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  cell-&gt;set_user_flag();</div></div><!-- fragment --><p> Using C++11's range-based for loops, this is now entirely equivalent to the following: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> triangulation;</div><div class="line">...</div><div class="line">for (<span class="keyword">auto</span> cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  cell-&gt;set_user_flag();</div></div><!-- fragment --><p> To use this feature, you need a compiler that supports C++11.</p>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active()</a>, this-&gt;<a class="el" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end()</a>)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10787">10787</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga27379d62cc1c17e52b4236601b943d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27379d62cc1c17e52b4236601b943d0f">&#9670;&nbsp;</a></span>cell_iterators_on_level() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga850b56c93cbebd27eb066edbd84aa711">cell_iterator</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterators_on_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up the given level of this triangulation. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A given level in the refinement hierarchy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;begin(level), this-&gt;end(level))</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>level must be less than this-&gt;<a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10798">10798</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="gac10cd3fe6ef8360e2599d3cff58e13e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac10cd3fe6ef8360e2599d3cff58e13e8">&#9670;&nbsp;</a></span>active_cell_iterators_on_level() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga7f54e1f60de3cc5adb6ad00d23ee150b">active_cell_iterator</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterators_on_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active cells that make up the given level of this triangulation. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A given level in the refinement hierarchy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;begin_active(level), this-&gt;end(level))</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>level must be less than this-&gt;<a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l10809">10809</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga7295c669f32e78c45446ddc236f19136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7295c669f32e78c45446ddc236f19136">&#9670;&nbsp;</a></span>cell_iterators() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">cell_iterator</a> &gt; <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::cell_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up this <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>. Such a range is useful to initialize range- based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classhp_1_1DoFHandler.html#a6af050921f3f1c3f2e6e20679a07f49b">begin()</a>, this-&gt;<a class="el" href="classhp_1_1DoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end()</a>)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="hp_2dof__handler_8cc_source.html#l01767">1767</a> of file <a class="el" href="hp_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="gacdb6d3adec96a13a7079f6c893e1d3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdb6d3adec96a13a7079f6c893e1d3ff">&#9670;&nbsp;</a></span>active_cell_iterators() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">active_cell_iterator</a> &gt; <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active cells that make up this <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>. Such a range is useful to initialize range-based for loops as supported by C++11, see also <a class="el" href="group__CPP11.html">C++11 standard</a>.</p>
<p>Range-based for loops are useful in that they require much less code than traditional loops (see <a href="http://en.wikipedia.org/wiki/C%2B%2B11#Range-
based_for_loop">here</a> for a discussion of how they work). An example is that without range-based for loops, one often writes code such as the following: </p><div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">...</div><div class="line">typename <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">    ...do the local integration on <span class="stringliteral">&#39;cell&#39;</span>...;</div><div class="line">  }</div></div><!-- fragment --><p> Using C++11's range-based for loops, this is now entirely equivalent to the following: </p><div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">...</div><div class="line">for (<span class="keyword">auto</span> cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">    ...do the local integration on <span class="stringliteral">&#39;cell&#39;</span>...;</div><div class="line">  }</div></div><!-- fragment --><p> To use this feature, you need a compiler that supports C++11.</p>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;<a class="el" href="classhp_1_1DoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active()</a>, this-&gt;<a class="el" href="classhp_1_1DoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end()</a>)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="hp_2dof__handler_8cc_source.html#l01777">1777</a> of file <a class="el" href="hp_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="gacb307c39a2891e324a723063c6994427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb307c39a2891e324a723063c6994427">&#9670;&nbsp;</a></span>cell_iterators_on_level() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">cell_iterator</a> &gt; <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::cell_iterators_on_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all cells (active or not) that make up the given level of this <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A given level in the refinement hierarchy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;begin(level), this-&gt;end(level))</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>level must be less than this-&gt;n_levels(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="hp_2dof__handler_8cc_source.html#l01788">1788</a> of file <a class="el" href="hp_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="ga47b267dbf912ec4d8227070cf0ccac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47b267dbf912ec4d8227070cf0ccac13">&#9670;&nbsp;</a></span>active_cell_iterators_on_level() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">active_cell_iterator</a> &gt; <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterators_on_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator range that contains all active cells that make up the given level of this <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler</a>. Such a range is useful to initialize range-based for loops as supported by C++11. See the example in the documentation of <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>A given level in the refinement hierarchy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The half open range <code>[this-&gt;begin_active(level), this-&gt;end(level))</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>level must be less than this-&gt;n_levels(). </dd></dl>

<p class="definition">Definition at line <a class="el" href="hp_2dof__handler_8cc_source.html#l01799">1799</a> of file <a class="el" href="hp_2dof__handler_8cc_source.html">dof_handler.cc</a>.</p>

</div>
</div>
<a id="ga3948dd66d9e66ac55d89dc8f75fa4855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3948dd66d9e66ac55d89dc8f75fa4855">&#9670;&nbsp;</a></span>filter_iterators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &gt; filter_iterators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; BaseIterator &gt;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Filter the given range of iterators using a Predicate. This allows to replace: </p><div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">...</div><div class="line">for (<span class="keyword">auto</span> cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">        ...do the local integration on <span class="stringliteral">&#39;cell&#39;</span>...;</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p> by: </p><div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">...</div><div class="line">for (<span class="keyword">auto</span> cell : <a class="code" href="group__CPP11.html#ga3948dd66d9e66ac55d89dc8f75fa4855">filter_iterators</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                                 <a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">    ...do the local integration on <span class="stringliteral">&#39;cell&#39;</span>...;</div><div class="line">  }</div></div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>Bruno Turcksin, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00837">837</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="ga3c0db06fce5af606f8fe78476ffd4587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c0db06fce5af606f8fe78476ffd4587">&#9670;&nbsp;</a></span>filter_iterators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator , typename Predicate , typename... Targs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename internal::FilteredIterator::NestFilteredIterators&lt; BaseIterator, std::tuple&lt; Predicate, Targs... &gt; &gt;::type &gt; filter_iterators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; BaseIterator &gt;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Targs...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Filter the given range of iterators through an arbitrary number of Predicates. This allows to replace: </p><div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">...</div><div class="line">for (<span class="keyword">auto</span> cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">            ...do the local integration on <span class="stringliteral">&#39;cell&#39;</span>...;</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p> by: </p><div class="fragment"><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">...</div><div class="line">for (<span class="keyword">auto</span> cell : <a class="code" href="group__CPP11.html#ga3948dd66d9e66ac55d89dc8f75fa4855">filter_iterators</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(),</div><div class="line">                                 <a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                                 <a class="code" href="classIteratorFilters_1_1AtBoundary.html">IteratorFilters::AtBoundary</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">    ...do the local integration on <span class="stringliteral">&#39;cell&#39;</span>...;</div><div class="line">  }</div></div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>Bruno Turcksin, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00886">886</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
