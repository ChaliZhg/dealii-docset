<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-30 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-30 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Overview">Overview</a>
        <li><a href="#Anisotropicrefinement">Anisotropic refinement</a>
      <ul>
        <li><a href="#Motivation">Motivation</a>
      </ul>
        <li><a href="#Implementation">Implementation</a>
      <ul>
        <li><a href="#Meshsmoothing">Mesh smoothing</a>
      </ul>
        <li><a href="#Jumpindicator">Jump indicator</a>
        <li><a href="#Theproblem">The problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ClassDGTransportEquation">Class: DGTransportEquation</a>
        <li><a href="#ClassDGMethod">Class: DGMethod</a>
      <ul>
        <li><a href="#Functionassemble_system2">Function: assemble_system2</a>
      </ul>
        <li><a href="#Solver">Solver</a>
        <li><a href="#Refinement">Refinement</a>
        <li><a href="#TheRest">The Rest</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Overview"></a></p><h3>Overview</h3>
<p>This example is devoted to <em>anisotropic refinement</em>, which extends to possibilities of local refinement. In most parts, this is a modification of the <a class="el" href="step_12.html">step-12</a> tutorial program, we use the same DG method for a linear transport equation. This program will cover the following topics: </p><ol>
<li>
<em>Anisotropic refinement</em>: What is the meaning of anisotropic refinement? </li>
<li>
<em>Implementation</em>: Necessary modifications of code to work with anisotropically refined meshes. </li>
<li>
<em>Jump indicator</em>: A simple indicator for anisotropic refinement in the context of DG methods. </li>
</ol>
<p>The discretization itself will not be discussed, and neither will implementation techniques not specific to anisotropic refinement used here. Please refer to <a class="el" href="step_12.html">step-12</a> for this.</p>
<p>Please note, at the moment of writing this tutorial program, anisotropic refinement is only fully implemented for discontinuous Galerkin Finite Elements. This may later change (or may already have).</p>
<dl class="section note"><dt>Note</dt><dd>While this program is a modification of <a class="el" href="step_12.html">step-12</a>, it is an adaptation of a version of <a class="el" href="step_12.html">step-12</a> written early on in the history of deal.II when the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework wasn't available yet. Consequently, it bears little resemblance to the <a class="el" href="step_12.html">step-12</a> as it exists now, apart from the fact that it solves the same equation with the same discretization.</dd></dl>
<p><a class="anchor" id="Anisotropicrefinement"></a></p><h3>Anisotropic refinement</h3>
<p>All the adaptive processes in the preceding tutorial programs were based on <em>isotropic</em> refinement of cells, which cuts all edges in half and forms new cells of these split edges (plus some additional edges, faces and vertices, of course). In deal.II, <em>anisotropic refinement</em> refers to the process of splitting only part of the edges while leaving the others unchanged. Consider a simple square cell, for example: </p><div class="fragment"><div class="line"> -------*</div><div class="line">|       |</div><div class="line">|       |</div><div class="line">|       |</div><div class="line"> -------*</div></div><!-- fragment --><p> After the usual refinement it will consist of four children and look like this: </p><div class="fragment"><div class="line"> ---*---*</div><div class="line">|   |   |</div><div class="line"> ---*---*     <a class="code" href="classRefinementCase.html">RefinementCase&lt;2&gt;::cut_xy</a></div><div class="line">|   |   |</div><div class="line"> ---*---*</div></div><!-- fragment --><p> The new anisotropic refinement may take two forms: either we can split the edges which are parallel to the horizontal x-axis, resulting in these two child cells: </p><div class="fragment"><div class="line"> ---*---*</div><div class="line">|   |   |</div><div class="line">|   |   |     <a class="code" href="classRefinementCase.html">RefinementCase&lt;2&gt;::cut_x</a></div><div class="line">|   |   |</div><div class="line"> ---*---*</div></div><!-- fragment --><p> or we can split the two edges which run along the y-axis, resulting again in two children, which look that way, however: </p><div class="fragment"><div class="line"> -------*</div><div class="line">|       |</div><div class="line"> -------*     <a class="code" href="classRefinementCase.html">RefinementCase&lt;2&gt;::cut_y</a></div><div class="line">|       |</div><div class="line"> -------*</div></div><!-- fragment --><p> All refinement cases of cells are described by an enumeration <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8">RefinementPossibilities::Possibilities</a>, and the above anisotropic cases are called <code>cut_x</code> and <code>cut_y</code> for obvious reasons. The isotropic refinement case is called <code>cut_xy</code> in 2D and can be requested from the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class via GeometryInfo&lt;2&gt;::isotropic_refinement.</p>
<p>In 3D, there is a third axis which can be split, the z-axis, and thus we have an additional refinement case <code>cut_z</code> here. Isotropic refinement will now refine a cell along the x-, y- and z-axes and thus be referred to as <code>cut_xyz</code>. Additional cases <code>cut_xy</code>, <code>cut_xz</code> and <code>cut_yz</code> exist, which refine a cell along two of the axes, but not along the third one. Given a hex cell with x-axis running to the right, y-axis 'into the page' and z-axis to the top, </p><div class="fragment"><div class="line">     -----------*</div><div class="line">   /           /|</div><div class="line">  /           / |</div><div class="line"> /           /  |</div><div class="line"> -----------*   |</div><div class="line">|           |   |</div><div class="line">|           |   *</div><div class="line">|           |  /</div><div class="line">|           | /</div><div class="line">|           |/</div><div class="line"> -----------*</div></div><!-- fragment --><p> we have the isotropic refinement case, </p><div class="fragment"><div class="line">     -----*-----*</div><div class="line">   /     /     /|</div><div class="line">   -----*-----* |</div><div class="line"> /     /     /| *</div><div class="line"> -----*-----* |/|</div><div class="line">|     |     | * |</div><div class="line">|     |     |/| *</div><div class="line"> -----*-----* |/</div><div class="line">|     |     | *</div><div class="line">|     |     |/</div><div class="line"> -----*-----*</div><div class="line"></div><div class="line">   cut_xyz</div></div><!-- fragment --><p> three anisotropic cases which refine only one axis: </p><div class="fragment"><div class="line">     -----*-----*           *-----------*           *-----------*</div><div class="line">   /     /     /|          /           /|          /           /|</div><div class="line">  /     /     / |         *-----------* |         /           / |</div><div class="line"> /     /     /  |        /           /| |        /           /  *</div><div class="line"> -----*-----*   |       *-----------* | |       *-----------*  /|</div><div class="line">|     |     |   |       |           | | |       |           | / |</div><div class="line">|     |     |   *       |           | | *       |           |/  *</div><div class="line">|     |     |  /        |           | |/        *-----------*  /</div><div class="line">|     |     | /         |           | *         |           | /</div><div class="line">|     |     |/          |           |/          |           |/</div><div class="line"> -----*-----*           *-----------*           *-----------*</div><div class="line"></div><div class="line">   cut_x                   cut_y                   cut_z</div></div><!-- fragment --><p> and three cases which refine two of the three axes: </p><div class="fragment"><div class="line">     -----*-----*           *-----*-----*           *-----------*</div><div class="line">   /     /     /|          /     /     /|          /           /|</div><div class="line">   -----*-----* |         /     /     / |         *-----------* |</div><div class="line"> /     /     /| |        /     /     /  *        /           /| *</div><div class="line"> -----*-----* | |       *-----*-----*  /|       *-----------* |/|</div><div class="line">|     |     | | |       |     |     | / |       |           | * |</div><div class="line">|     |     | | *       |     |     |/  *       |           |/| *</div><div class="line">|     |     | |/        *-----*-----*  /        *-----------* |/</div><div class="line">|     |     | *         |     |     | /         |           | *</div><div class="line">|     |     |/          |     |     |/          |           |/</div><div class="line"> -----*-----*           *-----*-----*           *-----------*</div><div class="line"></div><div class="line">   cut_xy                  cut_xz                  cut_yz</div></div><!-- fragment --><p> For 1D problems, anisotropic refinement can make no difference, as there is only one coordinate direction for a cell, so it is not possible to split it in any other way than isotropically.</p>
<p><a class="anchor" id="Motivation"></a></p><h4>Motivation</h4>
<p>Adaptive local refinement is used to obtain fine meshes which are well adapted to solving the problem at hand efficiently. In short, the size of cells which produce a large error is reduced to obtain a better approximation of the solution to the problem at hand. However, a lot of problems contain anisotropic features. Prominent examples are shocks or boundary layers in compressible viscous flows. An efficient mesh approximates these features with cells of higher aspect ratio which are oriented according to the mentioned features. Using only isotropic refinement, the aspect ratios of the original mesh cells are preserved, as they are inherited by the children of a cell. Thus, starting from an isotropic mesh, a boundary layer will be refined in order to catch the rapid variation of the flow field in the wall normal direction, thus leading to cells with very small edge lengths both in normal and tangential direction. Usually, much higher edge lengths in tangential direction and thus significantly less cells could be used without a significant loss in approximation accuracy. An anisotropic refinement process can modify the aspect ratio from mother to child cells by a factor of two for each refinement step. In the course of several refinements, the aspect ratio of the fine cells can be optimized, saving a considerable number of cells and correspondingly degrees of freedom and thus computational resources, memory as well as CPU time.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>Most of the time, when we do finite element computations, we only consider one cell at a time, for example to calculate cell contributions to the global matrix, or to interpolate boundary values. However, sometimes we have to look at how cells are related in our algorithms. Relationships between cells come in two forms: neighborship and mother-child relationship. For the case of isotropic refinement, deal.II uses certain conventions (invariants) for cell relationships that are always maintained. For example, a refined cell always has exactly <img class="formulaInl" alt="$2^{dim}$" src="form_2486.png"/> children. And (except for the 1d case), two neighboring cells may differ by at most one refinement level: they are equally often refined or one of them is exactly once more refined, leaving exactly one hanging node on the common face. Almost all of the time these invariants are only of concern in the internal implementation of the library. However, there are cases where knowledge of them is also relevant to an application program.</p>
<p>In the current context, it is worth noting that the kind of mesh refinement affects some of the most fundamental assumptions. Consequently, some of the usual code found in application programs will need modifications to exploit the features of meshes which were created using anisotropic refinement. For those interested in how deal.II evolved, it may be of interest that the loosening of such invariants required some incompatible changes. For example, the library used to have a member GeometryInfo&lt;dim&gt;::children_per_cell that specified how many children a cell has once it is refined. For isotropic refinement, this number is equal to <img class="formulaInl" alt="$2^{dim}$" src="form_2486.png"/>, as mentioned above. However, for anisotropic refinement, this number does not exist, as is can be either two or four in 2D and two, four or eight in 3D, and the member GeometryInfo&lt;dim&gt;::children_per_cell has consequently been removed. It has now been replaced by <a class="el" href="structGeometryInfo.html#a1f80f436561bc1737e0298bec0d75062">GeometryInfo&lt;dim&gt;::max_children_per_cell</a> which specifies the <em>maximum</em> number of children a cell can have. How many children a refined cell has was previously available as static information, but now it depends on the actual refinement state of a cell and can be retrieved using the function call <code>cell-&gt;n_children()</code>, a call that works equally well for both isotropic and anisotropic refinement. A very similar situation can be found for faces and their subfaces: the previously available variable GeometryInfo&lt;dim&gt;::subfaces_per_face no longer exists; the pertinent information can now be queried using <a class="el" href="structGeometryInfo.html#a7694f4ca2ba56d23f8133d856d20bd45">GeometryInfo&lt;dim&gt;::max_children_per_face</a> or <code>face-&gt;n_children()</code>, depending on the context.</p>
<p>Another important aspect, and the most important one in this tutorial, is the treatment of neighbor-relations when assembling jump terms on the faces between cells. Looking at the documentation of the assemble_system functions in <a class="el" href="step_12.html">step-12</a> we notice, that we need to decide if a neighboring cell is coarser, finer or on the same (refinement) level as our current cell. These decisions do not work in the same way for anisotropic refinement as the information given by the <em>level</em> of a cell is not enough to completely characterize anisotropic cells; for example, are the terminal children of a two-dimensional cell that is first cut in <img class="formulaInl" alt="$x$" src="form_9.png"/>-direction and whose children are then cut in <img class="formulaInl" alt="$y$" src="form_10.png"/>-direction on level 2, or are they on level 1 as they would be if the cell would have been refined once isotropically, resulting in the same set of finest cells?</p>
<p>After anisotropic refinement, a coarser neighbor is not necessarily exactly one level below ours, but can pretty much have any level relative to the current one; in fact, it can even be on a higher level even though it is coarser. Thus the decisions have to be made on a different basis, whereas the intention of the decisions stays the same.</p>
<p>In the following, we will discuss the cases that can happen when we want to compute contributions to the matrix (or right hand side) of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\partial K} \varphi_i(x) \varphi_j(x) \; dx \]" src="form_2487.png"/>
</p>
<p> or similar; remember that we integrate terms like this using the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> classes. We will also show how to write code that works for both isotropic and anisotropic refinement:</p>
<ul>
<li>
<p class="startli"><em>Finer neighbor</em>: If we are on an active cell and want to integrate over a face <img class="formulaInl" alt="$f\subset \partial K$" src="form_2488.png"/>, the first possibility is that the neighbor behind this face is more refined, i.e. has children occupying only part of the common face. In this case, the face under consideration has to be a refined one, which can determine by asking <code>if(face-&gt;has_children())</code>. If this is true, we need to loop over all subfaces and get the neighbors' child behind this subface, so that we can reinit an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object with the neighbor and an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object with our cell and the respective subface.</p>
<p>For isotropic refinement, this kind is reasonably simple because we know that an invariant of the isotropically refined adaptive meshes in deal.II is that neighbors can only differ by exactly one refinement level. However, this isn't quite true any more for anisotropically refined meshes, in particular in 3d; there, the active cell we are interested on the other side of <img class="formulaInl" alt="$f$" src="form_417.png"/> might not actually be a child of our neighbor, but perhaps a grandchild or even a farther offspring. Fortunately, this complexity is hidden in the internals of the library. All we need to do is call the <code>cell-&gt;neighbor_child_on_subface(face_no, subface_no)</code> function. Still, in 3D there are two cases which need special consideration: </p><ul>
<li>
<p class="startli">If the neighbor is refined more than once anisotropically, it might be that here are not two or four but actually three subfaces to consider. Imagine the following refinement process of the (two-dimensional) face of the (three-dimensional) neighbor cell we are considering: first the face is refined along x, later on only the left subface is refined along y. </p><div class="fragment"><div class="line"> -------*        *---*---*        *---*---*</div><div class="line">|       |        |   |   |        |   |   |</div><div class="line">|       |  ---&gt;  |   |   |  ---&gt;  *---*   |</div><div class="line">|       |        |   |   |        |   |   |</div><div class="line"> -------*        *---*---*        *---*---*</div></div><!-- fragment --><p> Here the number of subfaces is three. It is important to note the subtle differences between <code>face-&gt;n_children()</code> and <code>face-&gt;number_of_children()</code>. The first function returns the number of immediate children, which would be two for the above example, whereas the second returns the number of active offsprings, which is the correct three in the example above. Using <code>face-&gt;number_of_children()</code> works for isotropic and anisotropic as well as 2D and 3D cases, so it should always be used. It should be noted that if any of the cells behind the two small subfaces on the left side of the rightmost image is further refined, then the current cell (i.e. the side from which we are viewing this common face) is going to be refined as well: this is so because otherwise the invariant of having only one hanging node per edge would be violated.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">It might be, that the neighbor is coarser, but still has children which are finer than our current cell. This situation can occur if two equally coarse cells are refined, where one of the cells has two children at the face under consideration and the other one four. The cells in the next graphic are only separated from each other to show the individual refinement cases. </p><div class="fragment"><div class="line">     -----------*     *-----------*</div><div class="line">   /           /|    /           /|</div><div class="line"><span class="preprocessor">  ############# |   +++++++++++++ |</span></div><div class="line"><span class="preprocessor"> #           ## |  +           ++ *</span></div><div class="line"><span class="preprocessor">############# # | +++++++++++++ +/|</span></div><div class="line"><span class="preprocessor">#           # # | +           + + |</span></div><div class="line"><span class="preprocessor">#           # # * +           +++ *</span></div><div class="line"><span class="preprocessor">#           # #/  +++++++++++++ +/</span></div><div class="line"><span class="preprocessor">#           # #   +           + +</span></div><div class="line"><span class="preprocessor">#           ##    +           ++</span></div><div class="line"><span class="preprocessor">#############     +++++++++++++</span></div></div><!-- fragment --><p class="endli">Here, the left two cells resulted from an anisotropic bisection of the mother cell in <img class="formulaInl" alt="$y$" src="form_10.png"/>-direction, whereas the right four cells resulted from a simultaneous anisotropic refinement in both the <img class="formulaInl" alt="$y$" src="form_10.png"/>- and <img class="formulaInl" alt="$z$" src="form_11.png"/>-directions. The left cell marked with # has two finer neighbors marked with +, but the actual neighbor of the left cell is the complete right mother cell, as the two cells marked with + are finer and their direct mother is the one large cell. </p>
</li>
</ul>
<p>However, it is comfortable to know, that <code>cell-&gt;neighbor_child_on_subface(face_no,subface_no)</code> takes care of these situations by itself, if you loop over the correct number of subfaces, in the above example this is two. The <a class="el" href="classFESubfaceValues.html#a31715f7c441dd083cc02ea72859fb9a3">FESubfaceValues&lt;dim&gt;::reinit</a> function takes care of this too, so that the resulting state is always correct. There is one little aspect, however: For reiniting the neighbors <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object you need to know the index of the face that points toward the current cell. Usually you assume that the neighbor you get directly is as coarse or as fine as you, if it has children, thus this information can be obtained by the <code>cell-&gt;neighbor_of_neighbor(face_no)</code> function. If the neighbor is coarser, however, you would have to use <code>cell-&gt;neighbor_of_coarser_neighbor(face_no).first</code> instead. In order to make this easy for you, there is the new <code>cell-&gt;neighbor_face_no(face_no)</code> function which does the correct thing for you and returns the desired result.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Neighbor is as fine as our cell</em>: After we ruled out all cases in which there are finer children, we only need to decide, whether the neighbor is coarser here. For this, there is the <code>cell-&gt;coarser_neighbor(face_no)</code> function returning a bool value. In order to get the relevant case of a neighbor of the same coarseness we would use <code>else if (!cell-&gt;coarser_neighbor(face_no))</code>. The code inside this block can be left untouched. However, there is one thing to mention here: If we want to use a rule, which cell should assemble certain terms on a given face we might think of the rule presented in <a class="el" href="step_12.html">step-12</a>. We know that we have to leave out the part about comparing our cell's level with that of the neighbor and replace it with the test for a coarser neighbor presented above. However, we also have to consider the possibility that neighboring cells of same coarseness have the same index (on different levels). Thus we have to include the case where the cells have the same index, and give an additional condition, which of the cells should assemble the terms, e.g. we can choose the cell with lower level. The details of this concept can be seen in the implementation below.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Coarser neighbor</em>: The remaining case is obvious: If there are no refined neighbors and the neighbor is not as fine as the current cell, then it needs to be coarser. Thus we can leave the old condition phrase, simply using <code>else</code>. The <code>cell-&gt;neighbor_of_coarser_neighbor(face_no)</code> function takes care of all the complexity of anisotropic refinement combined with possible non standard face orientation, flip and rotation on general 3D meshes.</p>
<p class="endli"></p>
</li>
</ul>
<p><a class="anchor" id="Meshsmoothing"></a></p><h4>Mesh smoothing</h4>
<p>When a triangulation is refined, cells which were not flagged for refinement may be refined nonetheless. This is due to additional smoothing algorithms which are either necessary or requested explicitly. In particular, the restriction that there be at most one hanging node on each edge frequently forces the refinement of additional cells neighboring ones that are already finer and are flagged for further refinement.</p>
<p>However, deal.II also implements a number of algorithms that make sure that resulting meshes are smoother than just the bare minimum, for example ensuring that there are no isolated refined cells surrounded by non-refined ones, since the additional degrees of freedom on these islands would almost all be constrained by hanging node constraints. (See the documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class and its <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a> member for more information on mesh smoothing.)</p>
<p>Most of the smoothing algorithms that were originally developed for the isotropic case have been adapted to work in a very similar way for both anisotropic and isotropic refinement. There are two algorithms worth mentioning, however: </p><ol>
<li>
<p class="startli"><code>MeshSmoothing::limit_level_difference_at_vertices</code>: In an isotropic environment, this algorithm tries to ensure a good approximation quality by reducing the difference in refinement level of cells meeting at a common vertex. However, there is no clear corresponding concept for anisotropic refinement, thus this algorithm may not be used in combination with anisotropic refinement. This restriction is enforced by an assertion which throws an error as soon as the algorithm is called on a triangulation which has been refined anisotropically.</p>
<p class="endli"></p>
</li>
<li>
<code>MeshSmoothing::allow_anisotropic_smoothing</code>: If refinement is introduced to limit the number of hanging nodes, the additional cells are often not needed to improve the approximation quality. This is especially true for DG methods. If you set the flag <code>allow_anisotropic_smoothing</code> the smoothing algorithm tries to minimize the number of probably unneeded additional cells by using anisotropic refinement for the smoothing. If you set this smoothing flag you might get anisotropically refined cells, even if you never set a single refinement flag to anisotropic refinement. Be aware that you should only use this flag, if your code respects the possibility of anisotropic meshes. Combined with a suitable anisotropic indicator this flag can help save additional cells and thus effort. </li>
</ol>
<p><a class="anchor" id="Jumpindicator"></a></p><h3>Jump indicator</h3>
<p>Using the benefits of anisotropic refinement requires an indicator to catch anisotropic features of the solution and exploit them for the refinement process. Generally the anisotropic refinement process will consist of several steps: </p><ol>
<li>
Calculate an error indicator. </li>
<li>
Use the error indicator to flag cells for refinement, e.g. using a fixed number or fraction of cells. Those cells will be flagged for isotropic refinement automatically. </li>
<li>
Evaluate a distinct anisotropic indicator only on the flagged cells. </li>
<li>
Use the anisotropic indicator to set a new, anisotropic refinement flag for cells where this is appropriate, leave the flags unchanged otherwise. </li>
<li>
Call <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation&lt;dim&gt;::execute_coarsening_and_refinement</a> to perform the requested refinement, using the requested isotropic and anisotropic flags. </li>
</ol>
<p>This approach is similar to the one we have used in <a class="el" href="step_27.html">step-27</a> for hp refinement and has the great advantage of flexibility: Any error indicator can be used in the anisotropic process, i.e. if you have quite involved a posteriori goal-oriented error indicators available you can use them as easily as a simple Kelly error estimator. The anisotropic part of the refinement process is not influenced by this choice. Furthermore, simply leaving out the third and forth steps leads to the same isotropic refinement you used to get before any anisotropic changes in deal.II or your application program. As a last advantage, working only on cells flagged for refinement results in a faster evaluation of the anisotropic indicator, which can become noticeable on finer meshes with a lot of cells if the indicator is quite involved.</p>
<p>Here, we use a very simple approach which is only applicable to DG methods. The general idea is quite simple: DG methods allow the discrete solution to jump over the faces of a cell, whereas it is smooth within each cell. Of course, in the limit we expect that the jumps tend to zero as we refine the mesh and approximate the true solution better and better. Thus, a large jump across a given face indicates that the cell should be refined (at least) orthogonal to that face, whereas a small jump does not lead to this conclusion. It is possible, of course, that the exact solution is not smooth and that it also features a jump. In that case, however, a large jump over one face indicates, that this face is more or less parallel to the jump and in the vicinity of it, thus again we would expect a refinement orthogonal to the face under consideration to be effective.</p>
<p>The proposed indicator calculates the average jump <img class="formulaInl" alt="$K_j$" src="form_2489.png"/>, i.e. the mean value of the absolute jump <img class="formulaInl" alt="$|[u]|$" src="form_2490.png"/> of the discrete solution <img class="formulaInl" alt="$u$" src="form_256.png"/> over the two faces <img class="formulaInl" alt="$f_i^j$" src="form_2491.png"/>, <img class="formulaInl" alt="$i=1,2$" src="form_2492.png"/>, <img class="formulaInl" alt="$j=1..d$" src="form_2493.png"/> orthogonal to coordinate direction <img class="formulaInl" alt="$j$" src="form_513.png"/> on the unit cell. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ K_j = \frac{\sum_{i=1}^2 \int_{f_i^j}|[u]| dx}{\sum_{i=1}^2 |f_i^j|} . \]" src="form_2494.png"/>
</p>
<p> If the average jump in one direction is larger than the average of the jumps in the other directions by a certain factor <img class="formulaInl" alt="$\kappa$" src="form_2495.png"/>, i.e. if <img class="formulaInl" alt="$K_i &gt; \kappa \frac 1{d-1} \sum_{j=1, j\neq i}^d K_j$" src="form_2496.png"/>, the cell is refined only along that particular direction <img class="formulaInl" alt="$i$" src="form_90.png"/>, otherwise the cell is refined isotropically.</p>
<p>Such a criterion is easily generalized to systems of equations: the absolute value of the jump would be replaced by an appropriate norm of the vector-valued jump.</p>
<p><a class="anchor" id="Theproblem"></a></p><h3>The problem</h3>
<p>We solve the linear transport equation presented in <a class="el" href="step_12.html">step-12</a>. The domain is extended to cover <img class="formulaInl" alt="$[-1,1]\times[0,1]$" src="form_2497.png"/> in 2D, where the flow field <img class="formulaInl" alt="$\beta$" src="form_414.png"/> describes a counterclockwise quarter circle around the origin in the right half of the domain and is parallel to the x-axis in the left part of the domain. The inflow boundary is again located at <img class="formulaInl" alt="$x=1$" src="form_2498.png"/> and along the positive part of the x-axis, and the boundary conditions are chosen as in <a class="el" href="step_12.html">step-12</a>. Compared to <a class="el" href="step_12.html">step-12</a> we only use the more effective second assembling technique. In order to make comparisons more effective, we decided to keep function names like <code>assemble_system2</code> even if there is only one of these routines in this tutorial program. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The deal.II include files have already been covered in previous examples and will thus not be further commented on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q1.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_richardson.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition_block.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/derivative_approximation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div></div><!-- fragment --><p>And this again is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step30</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>The classes describing equation data and the actual assembly of individual terms are almost entirely copied from <a class="el" href="step_12.html">step-12</a>. We will comment on differences.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RHS:  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#afc0acd3155a0c854dee816a096d88165">value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                           std::vector&lt;double&gt; &amp;values,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues:  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                           std::vector&lt;double&gt; &amp;values,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Beta</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Beta () {}</div><div class="line">  <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                   std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;values) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RHS&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void) points;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size()==points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(),points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;values.size(); ++i)</div><div class="line">    values[i]=0;</div><div class="line">}</div></div><!-- fragment --><p>The flow field is chosen to be a quarter circle with counterclockwise flow direction and with the origin as midpoint for the right half of the domain with positive <img class="formulaInl" alt="$x$" src="form_9.png"/> values, whereas the flow simply goes to the left in the left part of the domain at a velocity that matches the one coming in from the right. In the circular part the magnitude of the flow velocity is proportional to the distance from the origin. This is a difference to <a class="el" href="step_12.html">step-12</a>, where the magnitude was 1 everywhere. the new definition leads to a linear variation of <img class="formulaInl" alt="$\beta$" src="form_414.png"/> along each given face of a cell. On the other hand, the solution <img class="formulaInl" alt="$u(x,y)$" src="form_2499.png"/> is exactly the same as before.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Beta&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                           std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size()==points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(),points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;points.size(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (points[i](0) &gt; 0)</div><div class="line">        {</div><div class="line">          values[i](0) = -points[i](1);</div><div class="line">          values[i](1) = points[i](0);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          values[i] = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div><div class="line">          values[i](0) = -points[i](1);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size()==points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(),points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;values.size(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (points[i](0)&lt;0.5)</div><div class="line">        values[i]=1.;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        values[i]=0.;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClassDGTransportEquation"></a> </p><h3>Class: DGTransportEquation</h3>
<p>This declaration of this class is utterly unaffected by our current changes. The only substantial change is that we use only the second assembly scheme described in <a class="el" href="step_12.html">step-12</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>DGTransportEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  DGTransportEquation();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_cell_term(<span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">                          <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">                          <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;cell_vector) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_boundary_term(<span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">                              <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;cell_vector) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_face_term2(<span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_v_neighbor,</div><div class="line">                           <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">                           <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ue_vi_matrix,</div><div class="line">                           <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_ve_matrix,</div><div class="line">                           <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ue_ve_matrix) <span class="keyword">const</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> Beta&lt;dim&gt; beta_function;</div><div class="line">  <span class="keyword">const</span> RHS&lt;dim&gt; rhs_function;</div><div class="line">  <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function;</div><div class="line">};</div></div><!-- fragment --><p>Likewise, the constructor of the class as well as the functions assembling the terms corresponding to cell interiors and boundary faces are unchanged from before. The function that assembles face terms between cells also did not change because all it does is operate on two objects of type <a class="el" href="classFEFaceValuesBase.html">FEFaceValuesBase</a> (which is the base class of both <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a>). Where these objects come from, i.e. how they are initialized, is of no concern to this function: it simply assumes that the quadrature points on faces or subfaces represented by the two objects correspond to the same points in physical space.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">DGTransportEquation&lt;dim&gt;::DGTransportEquation ()</div><div class="line">  :</div><div class="line">  beta_function (),</div><div class="line">  rhs_function (),</div><div class="line">  boundary_function ()</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGTransportEquation&lt;dim&gt;::assemble_cell_term(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;cell_vector)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line"></div><div class="line">  std::vector&lt;Point&lt;dim&gt; &gt; beta (fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">  std::vector&lt;double&gt; rhs (fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">  beta_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), beta);</div><div class="line">  rhs_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">          ui_vi_matrix(i,j) -= beta[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>]*fe_v.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)*</div><div class="line">                               fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                               JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line"></div><div class="line">        cell_vector(i) += rhs[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] * fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) * JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">      }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGTransportEquation&lt;dim&gt;::assemble_boundary_term(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;cell_vector)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a> ();</div><div class="line"></div><div class="line">  std::vector&lt;Point&lt;dim&gt; &gt; beta (fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">  std::vector&lt;double&gt; g(fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">  beta_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), beta);</div><div class="line">  boundary_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), g);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_n=beta[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] * normals[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">      <span class="keywordflow">if</span> (beta_n&gt;0)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">            ui_vi_matrix(i,j) += beta_n *</div><div class="line">                                 fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                 fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                 JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">          cell_vector(i) -= beta_n *</div><div class="line">                            g[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] *</div><div class="line">                            fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                            JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGTransportEquation&lt;dim&gt;::assemble_face_term2(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_v_neighbor,</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ue_vi_matrix,</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_ve_matrix,</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ue_ve_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a> ();</div><div class="line"></div><div class="line">  std::vector&lt;Point&lt;dim&gt; &gt; beta (fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">  beta_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), beta);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_n=beta[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] * normals[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">      <span class="keywordflow">if</span> (beta_n&gt;0)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">              ui_vi_matrix(i,j) += beta_n *</div><div class="line">                                   fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">              ui_ve_matrix(k,j) -= beta_n *</div><div class="line">                                   fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">              ue_vi_matrix(i,l) += beta_n *</div><div class="line">                                   fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(l,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">              ue_ve_matrix(k,l) -= beta_n *</div><div class="line">                                   fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(l,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClassDGMethod"></a> </p><h3>Class: DGMethod</h3>
<p>Even the main class of this program stays more or less the same. We omit one of the assembly routines and use only the second, more effective one of the two presented in <a class="el" href="step_12.html">step-12</a>. However, we introduce a new routine (set_anisotropic_flags) and modify another one (refine_grid).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>DGMethod</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  DGMethod (<span class="keyword">const</span> <span class="keywordtype">bool</span> anisotropic);</div><div class="line">  ~DGMethod ();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system1 ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system2 ();</div><div class="line">  <span class="keywordtype">void</span> solve (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution);</div><div class="line">  <span class="keywordtype">void</span> refine_grid ();</div><div class="line">  <span class="keywordtype">void</span> set_anisotropic_flags ();</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div></div><!-- fragment --><p>Again we want to use DG elements of degree 1 (but this is only specified in the constructor). If you want to use a DG method of a different degree replace 1 in the constructor by the new degree.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   degree;</div><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>          fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div></div><!-- fragment --><p>This is new, the threshold value used in the evaluation of the anisotropic jump indicator explained in the introduction. Its value is set to 3.0 in the constructor, but it can easily be changed to a different value greater than 1.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> anisotropic_threshold_ratio;</div></div><!-- fragment --><p>This is a bool flag indicating whether anisotropic refinement shall be used or not. It is set by the constructor, which takes an argument of the same name.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> anisotropic;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution2;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       right_hand_side;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> DGTransportEquation&lt;dim&gt; dg;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">DGMethod&lt;dim&gt;::DGMethod (<span class="keyword">const</span> <span class="keywordtype">bool</span> anisotropic)</div><div class="line">  :</div><div class="line">  mapping (),</div></div><!-- fragment --><p>Change here for DG methods of different degrees.</p>
<div class="fragment"><div class="line">degree(1),</div><div class="line">fe (degree),</div><div class="line">dof_handler (triangulation),</div><div class="line">anisotropic_threshold_ratio(3.),</div><div class="line">anisotropic(anisotropic),</div></div><!-- fragment --><p>As beta is a linear function, we can choose the degree of the quadrature for which the resulting integration is correct. Thus, we choose to use <code>degree+1</code> Gauss points, which enables us to integrate exactly polynomials of degree <code>2*degree+1</code>, enough for all the integrals we will perform in this program.</p>
<div class="fragment"><div class="line">  quadrature (degree+1),</div><div class="line">  face_quadrature (degree+1),</div><div class="line">  dg ()</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">DGMethod&lt;dim&gt;::~DGMethod ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGMethod&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                           dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                           (<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::faces_per_cell</a></div><div class="line">                            *<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::max_children_per_face</a>+1)*fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> (dof_handler, sparsity_pattern);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">  solution2.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  right_hand_side.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Functionassemble_system2"></a> </p><h4><a class="el" href="classFunction.html">Function</a>: assemble_system2</h4>
<p>We proceed with the <code>assemble_system2</code> function that implements the DG discretization in its second version. This function is very similar to the <code>assemble_system2</code> function from <a class="el" href="step_12.html">step-12</a>, even the four cases considered for the neighbor-relations of a cell are the same, namely a) cell is at the boundary, b) there are finer neighboring cells, c) the neighbor is neither coarser nor finer and d) the neighbor is coarser. However, the way in which we decide upon which case we have are modified in the way described in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGMethod&lt;dim&gt;::assemble_system2 ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; dofs (dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; dofs_neighbor (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="line">                                   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="line">                                   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="line">                                   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="line">                                        | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="line">                                        | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="line">                                        | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> neighbor_face_update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_v (</div><div class="line">    mapping, fe, quadrature, update_flags);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_v_face (</div><div class="line">    mapping, fe, face_quadrature, face_update_flags);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> fe_v_subface (</div><div class="line">    mapping, fe, face_quadrature, face_update_flags);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_v_face_neighbor (</div><div class="line">    mapping, fe, face_quadrature, neighbor_face_update_flags);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ui_vi_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ue_vi_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ui_ve_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ue_ve_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>  cell_vector (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      ui_vi_matrix = 0;</div><div class="line">      cell_vector = 0;</div><div class="line"></div><div class="line">      fe_v.reinit (cell);</div><div class="line"></div><div class="line">      dg.assemble_cell_term(fe_v,</div><div class="line">                            ui_vi_matrix,</div><div class="line">                            cell_vector);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (dofs);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_no)</div><div class="line">        {</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face=</div><div class="line">            cell-&gt;face(face_no);</div></div><!-- fragment --><p>Case a)</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">  {</div><div class="line">    fe_v_face.reinit (cell, face_no);</div><div class="line"></div><div class="line">    dg.assemble_boundary_term(fe_v_face,</div><div class="line">                              ui_vi_matrix,</div><div class="line">                              cell_vector);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cell-&gt;neighbor(face_no).state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor=</div><div class="line">      cell-&gt;neighbor(face_no);</div></div><!-- fragment --><p>Case b), we decide that there are finer cells as neighbors by asking the face, whether it has children. if so, then there must also be finer cells which are children or farther offspring of our neighbor.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (face-&gt;has_children())</div><div class="line">  {</div></div><!-- fragment --><p>We need to know, which of the neighbors faces points in the direction of our cell. Using the <code>neighbor_face_no</code> function we get this information for both coarser and non-coarser neighbors.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor2=</div><div class="line">  cell-&gt;neighbor_face_no(face_no);</div></div><!-- fragment --><p>Now we loop over all subfaces, i.e. the children and possibly grandchildren of the current face.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no=0;</div><div class="line">     subface_no&lt;face-&gt;number_of_children(); ++subface_no)</div><div class="line">  {</div></div><!-- fragment --><p>To get the cell behind the current subface we can use the <code>neighbor_child_on_subface</code> function. it takes care of all the complicated situations of anisotropic refinement and non-standard faces.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor_child</div><div class="line">  = cell-&gt;neighbor_child_on_subface (face_no, subface_no);</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (!neighbor_child-&gt;has_children(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>The remaining part of this case is unchanged.</p>
<div class="fragment"><div class="line">        ue_vi_matrix = 0;</div><div class="line">        ui_ve_matrix = 0;</div><div class="line">        ue_ve_matrix = 0;</div><div class="line"></div><div class="line">        fe_v_subface.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (cell, face_no, subface_no);</div><div class="line">        fe_v_face_neighbor.reinit (neighbor_child, neighbor2);</div><div class="line"></div><div class="line">        dg.assemble_face_term2(fe_v_subface,</div><div class="line">                               fe_v_face_neighbor,</div><div class="line">                               ui_vi_matrix,</div><div class="line">                               ue_vi_matrix,</div><div class="line">                               ui_ve_matrix,</div><div class="line">                               ue_ve_matrix);</div><div class="line"></div><div class="line">        neighbor_child-&gt;get_dof_indices (dofs_neighbor);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              system_matrix.add(dofs[i], dofs_neighbor[j],</div><div class="line">                                ue_vi_matrix(i,j));</div><div class="line">              system_matrix.add(dofs_neighbor[i], dofs[j],</div><div class="line">                                ui_ve_matrix(i,j));</div><div class="line">              system_matrix.add(dofs_neighbor[i], dofs_neighbor[j],</div><div class="line">                                ue_ve_matrix(i,j));</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div></div><!-- fragment --><p>Case c). We simply ask, whether the neighbor is coarser. If not, then it is neither coarser nor finer, since any finer neighbor would have been treated above with case b). Of all the cases with the same refinement situation of our cell and the neighbor we want to treat only one half, so that each face is considered only once. Thus we have the additional condition, that the cell with the lower index does the work. In the rare case that both cells have the same index, the cell with lower level is selected.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!cell-&gt;neighbor_is_coarser(face_no) &amp;&amp;</div><div class="line">    (neighbor-&gt;index() &gt; cell-&gt;index() ||</div><div class="line">     (neighbor-&gt;level() &lt; cell-&gt;level() &amp;&amp;</div><div class="line">      neighbor-&gt;index() == cell-&gt;index())))</div><div class="line">  {</div></div><!-- fragment --><p>Here we know, that the neighbor is not coarser so we can use the usual <code>neighbor_of_neighbor</code> function. However, we could also use the more general <code>neighbor_face_no</code> function.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor2=cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">  ue_vi_matrix = 0;</div><div class="line">  ui_ve_matrix = 0;</div><div class="line">  ue_ve_matrix = 0;</div><div class="line"></div><div class="line">  fe_v_face.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (cell, face_no);</div><div class="line">  fe_v_face_neighbor.reinit (neighbor, neighbor2);</div><div class="line"></div><div class="line">  dg.assemble_face_term2(fe_v_face,</div><div class="line">                         fe_v_face_neighbor,</div><div class="line">                         ui_vi_matrix,</div><div class="line">                         ue_vi_matrix,</div><div class="line">                         ui_ve_matrix,</div><div class="line">                         ue_ve_matrix);</div><div class="line"></div><div class="line">  neighbor-&gt;get_dof_indices (dofs_neighbor);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">      {</div><div class="line">        system_matrix.add(dofs[i], dofs_neighbor[j],</div><div class="line">                          ue_vi_matrix(i,j));</div><div class="line">        system_matrix.add(dofs_neighbor[i], dofs[j],</div><div class="line">                          ui_ve_matrix(i,j));</div><div class="line">        system_matrix.add(dofs_neighbor[i], dofs_neighbor[j],</div><div class="line">                          ue_ve_matrix(i,j));</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p>We do not need to consider case d), as those faces are treated 'from the other side within case b).</p>
<div class="fragment"><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">          system_matrix.add(dofs[i], dofs[j], ui_vi_matrix(i,j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        right_hand_side(dofs[i]) += cell_vector(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solver"></a> </p><h3><a class="el" href="classSolver.html">Solver</a></h3>
<p>For this simple problem we use the simple Richardson iteration again. The solver is completely unaffected by our anisotropic changes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGMethod&lt;dim&gt;::solve (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">  <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;&gt;</a>      solver (solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; preconditioner;</div><div class="line"></div><div class="line">  preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">  solver.solve (system_matrix, solution, right_hand_side,</div><div class="line">                preconditioner);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Refinement"></a> </p><h3>Refinement</h3>
<p>We refine the grid according to the same simple refinement criterion used in <a class="el" href="step_12.html">step-12</a>, namely an approximation to the gradient of the solution.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGMethod&lt;dim&gt;::refine_grid ()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> gradient_indicator (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>We approximate the gradient,</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDerivativeApproximation.html#ace2a9964b7da0d28c8184346902a6563">DerivativeApproximation::approximate_gradient</a> (mapping,</div><div class="line">                                               dof_handler,</div><div class="line">                                               solution2,</div><div class="line">                                               gradient_indicator);</div></div><!-- fragment --><p>and scale it to obtain an error indicator.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no=0; cell!=endc; ++cell, ++cell_no)</div><div class="line">  gradient_indicator(cell_no)*=std::pow(cell-&gt;diameter(), 1+1.0*dim/2);</div></div><!-- fragment --><p>Then we use this indicator to flag the 30 percent of the cells with highest error indicator to be refined.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                 gradient_indicator,</div><div class="line">                                                 0.3, 0.1);</div></div><!-- fragment --><p>Now the refinement flags are set for those cells with a large error indicator. If nothing is done to change this, those cells will be refined isotropically. If the <code>anisotropic</code> flag given to this function is set, we now call the set_anisotropic_flags() function, which uses the jump indicator to reset some of the refinement flags to anisotropic refinement.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (anisotropic)</div><div class="line">  set_anisotropic_flags();</div></div><!-- fragment --><p>Now execute the refinement considering anisotropic as well as isotropic refinement flags.</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">}</div></div><!-- fragment --><p>Once an error indicator has been evaluated and the cells with largest error are flagged for refinement we want to loop over the flagged cells again to decide whether they need isotropic refinement or whether anisotropic refinement is more appropriate. This is the anisotropic jump indicator explained in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGMethod&lt;dim&gt;::set_anisotropic_flags ()</div><div class="line">{</div></div><!-- fragment --><p>We want to evaluate the jump over faces of the flagged cells, so we need some objects to evaluate values of the solution on faces.</p>
<div class="fragment"><div class="line"><a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_update_flags</div><div class="line">  = <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_v_face (mapping, fe, face_quadrature, face_update_flags);</div><div class="line"><a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> fe_v_subface (mapping, fe, face_quadrature, face_update_flags);</div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_v_face_neighbor (mapping, fe, face_quadrature, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div></div><!-- fragment --><p>Now we need to loop over all active cells.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell=dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                               endc=dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div></div><!-- fragment --><p>We only need to consider cells which are flagged for refinement.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell-&gt;refine_flag_set())</div><div class="line">  {</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> jump;</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> area;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_no)</div><div class="line">      {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face = cell-&gt;face(face_no);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (!face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cell-&gt;neighbor(face_no).state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor = cell-&gt;neighbor(face_no);</div><div class="line"></div><div class="line">            std::vector&lt;double&gt; u (fe_v_face.n_quadrature_points);</div><div class="line">            std::vector&lt;double&gt; u_neighbor (fe_v_face.n_quadrature_points);</div></div><!-- fragment --><p>The four cases of different neighbor relations seen in the assembly routines are repeated much in the same way here.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (face-&gt;has_children())</div><div class="line">  {</div></div><!-- fragment --><p>The neighbor is refined. First we store the information, which of the neighbor's faces points in the direction of our current cell. This property is inherited to the children.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor2=cell-&gt;neighbor_face_no(face_no);</div></div><!-- fragment --><p>Now we loop over all subfaces,</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no=0; subface_no&lt;face-&gt;number_of_children(); ++subface_no)</div><div class="line">  {</div></div><!-- fragment --><p>get an iterator pointing to the cell behind the present subface...</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor_child = cell-&gt;neighbor_child_on_subface(face_no,subface_no);</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (!neighbor_child-&gt;has_children(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>... and reinit the respective <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and FESubFaceValues objects.</p>
<div class="fragment"><div class="line">fe_v_subface.reinit (cell, face_no, subface_no);</div><div class="line">fe_v_face_neighbor.reinit (neighbor_child, neighbor2);</div></div><!-- fragment --><p>We obtain the function values</p>
<div class="fragment"><div class="line">fe_v_subface.get_function_values(solution2, u);</div><div class="line">fe_v_face_neighbor.get_function_values(solution2, u_neighbor);</div></div><!-- fragment --><p>as well as the quadrature weights, multiplied by the Jacobian determinant.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v_subface.get_JxW_values ();</div></div><!-- fragment --><p>Now we loop over all quadrature points</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;fe_v_subface.n_quadrature_points; ++x)</div><div class="line">  {</div></div><!-- fragment --><p>and integrate the absolute value of the jump of the solution, i.e. the absolute value of the difference between the function value seen from the current cell and the neighboring cell, respectively. We know, that the first two faces are orthogonal to the first coordinate direction on the unit cell, the second two faces are orthogonal to the second coordinate direction and so on, so we accumulate these values into vectors with <code>dim</code> components.</p>
<div class="fragment"><div class="line">jump[face_no/2]+=std::fabs(u[x]-u_neighbor[x])*JxW[x];</div></div><!-- fragment --><p>We also sum up the scaled weights to obtain the measure of the face.</p>
<div class="fragment"><div class="line">            area[face_no/2]+=JxW[x];</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (!cell-&gt;neighbor_is_coarser(face_no))</div><div class="line">      {</div></div><!-- fragment --><p>Our current cell and the neighbor have the same refinement along the face under consideration. Apart from that, we do much the same as with one of the subcells in the above case.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor2=cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">    fe_v_face.reinit (cell, face_no);</div><div class="line">    fe_v_face_neighbor.reinit (neighbor, neighbor2);</div><div class="line"></div><div class="line">    fe_v_face.get_function_values(solution2, u);</div><div class="line">    fe_v_face_neighbor.get_function_values(solution2, u_neighbor);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v_face.get_JxW_values ();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;fe_v_face.n_quadrature_points; ++x)</div><div class="line">      {</div><div class="line">        jump[face_no/2]+=std::fabs(u[x]-u_neighbor[x])*JxW[x];</div><div class="line">        area[face_no/2]+=JxW[x];</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="comment">//i.e. neighbor is coarser than cell</span></div><div class="line">  {</div></div><!-- fragment --><p>Now the neighbor is actually coarser. This case is new, in that it did not occur in the assembly routine. Here, we have to consider it, but this is not overly complicated. We simply use the <code>neighbor_of_coarser_neighbor</code> function, which again takes care of anisotropic refinement and non-standard face orientation by itself.</p>
<div class="fragment"><div class="line">              std::pair&lt;unsigned int,unsigned int&gt; neighbor_face_subface</div><div class="line">                = cell-&gt;neighbor_of_coarser_neighbor(face_no);</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor_face_subface.first&lt;<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::faces_per_cell</a>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor_face_subface.second&lt;neighbor-&gt;face(neighbor_face_subface.first)-&gt;number_of_children(),</div><div class="line">                      <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor-&gt;neighbor_child_on_subface(neighbor_face_subface.first, neighbor_face_subface.second)</div><div class="line">                      == cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">              fe_v_face.reinit (cell, face_no);</div><div class="line">              fe_v_subface.reinit (neighbor, neighbor_face_subface.first,</div><div class="line">                                   neighbor_face_subface.second);</div><div class="line"></div><div class="line">              fe_v_face.get_function_values(solution2, u);</div><div class="line">              fe_v_subface.get_function_values(solution2, u_neighbor);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v_face.get_JxW_values ();</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;fe_v_face.n_quadrature_points; ++x)</div><div class="line">                {</div><div class="line">                  jump[face_no/2]+=std::fabs(u[x]-u_neighbor[x])*JxW[x];</div><div class="line">                  area[face_no/2]+=JxW[x];</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now we analyze the size of the mean jumps, which we get dividing the jumps by the measure of the respective faces.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> average_jumps[dim];</div><div class="line"><span class="keywordtype">double</span> sum_of_average_jumps=0.;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">  {</div><div class="line">    average_jumps[i] = jump(i)/area(i);</div><div class="line">    sum_of_average_jumps += average_jumps[i];</div><div class="line">  }</div></div><!-- fragment --><p>Now we loop over the <code>dim</code> coordinate directions of the unit cell and compare the average jump over the faces orthogonal to that direction with the average jumps over faces orthogonal to the remaining direction(s). If the first is larger than the latter by a given factor, we refine only along hat axis. Otherwise we leave the refinement flag unchanged, resulting in isotropic refinement.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">          <span class="keywordflow">if</span> (average_jumps[i] &gt; anisotropic_threshold_ratio*(sum_of_average_jumps-average_jumps[i]))</div><div class="line">            cell-&gt;set_refine_flag(<a class="code" href="classRefinementCase.html">RefinementCase&lt;dim&gt;::cut_axis</a>(i));</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheRest"></a> </p><h3>The Rest</h3>
<p>The remaining part of the program is again unmodified. Only the creation of the original triangulation is changed in order to reproduce the new domain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGMethod&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::string refine_type;</div><div class="line">  <span class="keywordflow">if</span> (anisotropic)</div><div class="line">    refine_type=<span class="stringliteral">&quot;.aniso&quot;</span>;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    refine_type=<span class="stringliteral">&quot;.iso&quot;</span>;</div><div class="line"></div><div class="line">  std::string filename = <span class="stringliteral">&quot;grid-&quot;</span>;</div><div class="line">  filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  filename += refine_type + <span class="stringliteral">&quot;.eps&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Writing grid to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;...&quot;</span> &lt;&lt; std::endl;</div><div class="line">  std::ofstream eps_output (filename.c_str());</div><div class="line"></div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a7e31485bb55254bfa5cd3ab55f8d1748">write_eps</a> (triangulation, eps_output);</div><div class="line"></div><div class="line">  filename = <span class="stringliteral">&quot;grid-&quot;</span>;</div><div class="line">  filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  filename += refine_type + <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Writing grid to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;...&quot;</span> &lt;&lt; std::endl;</div><div class="line">  std::ofstream gnuplot_grid_output (filename.c_str());</div><div class="line"></div><div class="line">  grid_out.write_gnuplot (triangulation, gnuplot_grid_output);</div><div class="line"></div><div class="line">  filename = <span class="stringliteral">&quot;sol-&quot;</span>;</div><div class="line">  filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  filename += refine_type + <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;...&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  std::ofstream gnuplot_output (filename.c_str());</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.add_data_vector (solution2, <span class="stringliteral">&quot;u&quot;</span>);</div><div class="line"></div><div class="line">  data_out.build_patches (degree);</div><div class="line"></div><div class="line">  data_out.write_gnuplot(gnuplot_output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DGMethod&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        {</div></div><!-- fragment --><p>Create the rectangular domain.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1,p2;</div><div class="line">p1(0)=0;</div><div class="line">p1(0)=-1;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">  p2(i)=1.;</div></div><!-- fragment --><p>Adjust the number of cells in different directions to obtain completely isotropic cells for the original mesh.</p>
<div class="fragment"><div class="line">            std::vector&lt;unsigned int&gt; repetitions(dim,1);</div><div class="line">            repetitions[0]=2;</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation,</div><div class="line">                                                       repetitions,</div><div class="line">                                                       p1,</div><div class="line">                                                       p2);</div><div class="line"></div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (5-dim);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid ();</div><div class="line"></div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">                  &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classTimer.html">Timer</a> assemble_timer;</div><div class="line">        assemble_system2 ();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time of assemble_system2: &quot;</span></div><div class="line">                  &lt;&lt; assemble_timer()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        solve (solution2);</div><div class="line"></div><div class="line">        output_results (cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step30;</div></div><!-- fragment --><p>If you want to run the program in 3D, simply change the following line to <code>const unsigned int dim = 3;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">{</div></div><!-- fragment --><p>First, we perform a run with isotropic refinement.</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Performing a &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot;D run with isotropic refinement...&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line">  DGMethod&lt;dim&gt; dgmethod_iso(<span class="keyword">false</span>);</div><div class="line">  dgmethod_iso.run ();</div><div class="line">}</div><div class="line"></div><div class="line">{</div></div><!-- fragment --><p>Now we do a second run, this time with anisotropic refinement.</p>
<div class="fragment"><div class="line">        std::cout &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;Performing a &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot;D run with anisotropic refinement...&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;--------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line">        DGMethod&lt;dim&gt; dgmethod_aniso(<span class="keyword">true</span>);</div><div class="line">        dgmethod_aniso.run ();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of this program consist of the console output, the eps files containing the grids, and the grids and solutions given in gnuplot format. </p><div class="fragment"><div class="line">Performing a 2D run with isotropic refinement...</div><div class="line">------------------------------------------------</div><div class="line">Cycle 0:</div><div class="line">   Number of active cells:       128</div><div class="line">   Number of degrees of freedom: 512</div><div class="line">Time of assemble_system2: 0.040003</div><div class="line">Writing grid to &lt;grid-0.iso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-0.iso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-0.iso.gnuplot&gt;...</div><div class="line">Cycle 1:</div><div class="line">   Number of active cells:       239</div><div class="line">   Number of degrees of freedom: 956</div><div class="line">Time of assemble_system2: 0.072005</div><div class="line">Writing grid to &lt;grid-1.iso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-1.iso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-1.iso.gnuplot&gt;...</div><div class="line">Cycle 2:</div><div class="line">   Number of active cells:       491</div><div class="line">   Number of degrees of freedom: 1964</div><div class="line">Time of assemble_system2: 0.144009</div><div class="line">Writing grid to &lt;grid-2.iso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-2.iso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-2.iso.gnuplot&gt;...</div><div class="line">Cycle 3:</div><div class="line">   Number of active cells:       1031</div><div class="line">   Number of degrees of freedom: 4124</div><div class="line">Time of assemble_system2: 0.296019</div><div class="line">Writing grid to &lt;grid-3.iso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-3.iso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-3.iso.gnuplot&gt;...</div><div class="line">Cycle 4:</div><div class="line">   Number of active cells:       2027</div><div class="line">   Number of degrees of freedom: 8108</div><div class="line">Time of assemble_system2: 0.576036</div><div class="line">Writing grid to &lt;grid-4.iso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-4.iso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-4.iso.gnuplot&gt;...</div><div class="line">Cycle 5:</div><div class="line">   Number of active cells:       4019</div><div class="line">   Number of degrees of freedom: 16076</div><div class="line">Time of assemble_system2: 1.13607</div><div class="line">Writing grid to &lt;grid-5.iso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-5.iso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-5.iso.gnuplot&gt;...</div><div class="line"></div><div class="line">Performing a 2D run with anisotropic refinement...</div><div class="line">--------------------------------------------------</div><div class="line">Cycle 0:</div><div class="line">   Number of active cells:       128</div><div class="line">   Number of degrees of freedom: 512</div><div class="line">Time of assemble_system2: 0.040003</div><div class="line">Writing grid to &lt;grid-0.aniso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-0.aniso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-0.aniso.gnuplot&gt;...</div><div class="line">Cycle 1:</div><div class="line">   Number of active cells:       171</div><div class="line">   Number of degrees of freedom: 684</div><div class="line">Time of assemble_system2: 0.048003</div><div class="line">Writing grid to &lt;grid-1.aniso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-1.aniso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-1.aniso.gnuplot&gt;...</div><div class="line">Cycle 2:</div><div class="line">   Number of active cells:       255</div><div class="line">   Number of degrees of freedom: 1020</div><div class="line">Time of assemble_system2: 0.072005</div><div class="line">Writing grid to &lt;grid-2.aniso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-2.aniso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-2.aniso.gnuplot&gt;...</div><div class="line">Cycle 3:</div><div class="line">   Number of active cells:       397</div><div class="line">   Number of degrees of freedom: 1588</div><div class="line">Time of assemble_system2: 0.16401</div><div class="line">Writing grid to &lt;grid-3.aniso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-3.aniso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-3.aniso.gnuplot&gt;...</div><div class="line">Cycle 4:</div><div class="line">   Number of active cells:       658</div><div class="line">   Number of degrees of freedom: 2632</div><div class="line">Time of assemble_system2: 0.192012</div><div class="line">Writing grid to &lt;grid-4.aniso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-4.aniso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-4.aniso.gnuplot&gt;...</div><div class="line">Cycle 5:</div><div class="line">   Number of active cells:       1056</div><div class="line">   Number of degrees of freedom: 4224</div><div class="line">Time of assemble_system2: 0.304019</div><div class="line">Writing grid to &lt;grid-5.aniso.eps&gt;...</div><div class="line">Writing grid to &lt;grid-5.aniso.gnuplot&gt;...</div><div class="line">Writing solution to &lt;sol-5.aniso.gnuplot&gt;...</div></div><!-- fragment --><p>This text output shows the reduction in the number of cells which results from the successive application of anisotropic refinement. After the last refinement step the savings have accumulated so much, that almost four times as many cells and thus dofs are needed in the isotropic case. The time needed for assembly scales with a similar factor.</p>
<p>Now we show the solutions on the mesh after one and after five adaptive refinement steps for both the isotropic (left) and anisotropic refinement algorithms (right).</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-30.sol-1.iso.png"/>
</div>
 <p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-30.sol-1.aniso.png"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-30.sol-5.iso.png"/>
</div>
 <p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-30.sol-5.aniso.png"/>
</div>
   </td></tr>
</table>
<p>We see, that the solution on the anisotropically refined mesh is very similar to the solution obtained on the isotropically refined mesh. Thus the anisotropic indicator seems to effectively select the appropriate cells for anisotropic refinement. This observation is strengthened by the plot of the an adapted anisotropic grid, e.g. the grid after three refinement steps.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-30.grid-3.aniso.png"/>
</div>
<p>In the whole left part of the domain refinement is only performed along the y-axis of cells. In the right part of the domain the refinement is dominated by isotropic refinement, as the anisotropic feature of the solution - the jump from one to zero - is not well aligned with the mesh. However, at the bottom and leftmost parts of the quarter circle this jumps becomes more and more aligned with the mesh and the refinement algorithm reacts by creating anisotropic cells of increasing aspect ratio.</p>
<p>It might seem that the necessary alignment of anisotropic features and the coarse mesh can decrease performance significantly for real world problems. However, that is not always the case. Considering boundary layers in compressible viscous flows, for example, the mesh is always aligned with the anisotropic features, thus anisotropic refinement will almost always increase the efficiency of computations on adapted grids for these cases.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2007 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Tobias Leicht, 2007</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q1.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_richardson.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition_block.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/derivative_approximation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step30</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RHS:  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;double&gt; &amp;values,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues:  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;double&gt; &amp;values,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Beta</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Beta () {}</div><div class="line">    <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                     std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;values) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RHS&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void) points;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size()==points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(),points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;values.size(); ++i)</div><div class="line">      values[i]=0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Beta&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size()==points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(),points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;points.size(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (points[i](0) &gt; 0)</div><div class="line">          {</div><div class="line">            values[i](0) = -points[i](1);</div><div class="line">            values[i](1) = points[i](0);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            values[i] = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div><div class="line">            values[i](0) = -points[i](1);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size()==points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(),points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;values.size(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (points[i](0)&lt;0.5)</div><div class="line">          values[i]=1.;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          values[i]=0.;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>DGTransportEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    DGTransportEquation();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_cell_term(<span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">                            <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;cell_vector) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_boundary_term(<span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">                                <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;cell_vector) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_face_term2(<span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_v_neighbor,</div><div class="line">                             <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">                             <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ue_vi_matrix,</div><div class="line">                             <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_ve_matrix,</div><div class="line">                             <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ue_ve_matrix) <span class="keyword">const</span>;</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Beta&lt;dim&gt; beta_function;</div><div class="line">    <span class="keyword">const</span> RHS&lt;dim&gt; rhs_function;</div><div class="line">    <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  DGTransportEquation&lt;dim&gt;::DGTransportEquation ()</div><div class="line">    :</div><div class="line">    beta_function (),</div><div class="line">    rhs_function (),</div><div class="line">    boundary_function ()</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGTransportEquation&lt;dim&gt;::assemble_cell_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;cell_vector)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt; &gt; beta (fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">    std::vector&lt;double&gt; rhs (fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">    beta_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), beta);</div><div class="line">    rhs_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">            ui_vi_matrix(i,j) -= beta[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>]*fe_v.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)*</div><div class="line">                                 fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                 JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line"></div><div class="line">          cell_vector(i) += rhs[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] * fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) * JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGTransportEquation&lt;dim&gt;::assemble_boundary_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;cell_vector)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a> ();</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt; &gt; beta (fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">    std::vector&lt;double&gt; g(fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">    beta_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), beta);</div><div class="line">    boundary_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), g);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta_n=beta[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] * normals[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        <span class="keywordflow">if</span> (beta_n&gt;0)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">              ui_vi_matrix(i,j) += beta_n *</div><div class="line">                                   fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">            cell_vector(i) -= beta_n *</div><div class="line">                              g[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] *</div><div class="line">                              fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                              JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGTransportEquation&lt;dim&gt;::assemble_face_term2(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_v,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_v_neighbor,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_vi_matrix,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ue_vi_matrix,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ui_ve_matrix,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;ue_ve_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a> ();</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt; &gt; beta (fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">    beta_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), beta);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta_n=beta[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] * normals[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        <span class="keywordflow">if</span> (beta_n&gt;0)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">                ui_vi_matrix(i,j) += beta_n *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">                ui_ve_matrix(k,j) -= beta_n *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                ue_vi_matrix(i,l) += beta_n *</div><div class="line">                                     fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(l,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                ue_ve_matrix(k,l) -= beta_n *</div><div class="line">                                     fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(l,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>DGMethod</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    DGMethod (<span class="keyword">const</span> <span class="keywordtype">bool</span> anisotropic);</div><div class="line">    ~DGMethod ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system1 ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system2 ();</div><div class="line">    <span class="keywordtype">void</span> solve (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution);</div><div class="line">    <span class="keywordtype">void</span> refine_grid ();</div><div class="line">    <span class="keywordtype">void</span> set_anisotropic_flags ();</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   degree;</div><div class="line">    <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> anisotropic_threshold_ratio;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> anisotropic;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution2;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       right_hand_side;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> DGTransportEquation&lt;dim&gt; dg;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  DGMethod&lt;dim&gt;::DGMethod (<span class="keyword">const</span> <span class="keywordtype">bool</span> anisotropic)</div><div class="line">    :</div><div class="line">    mapping (),</div><div class="line">    degree(1),</div><div class="line">    fe (degree),</div><div class="line">    dof_handler (triangulation),</div><div class="line">    anisotropic_threshold_ratio(3.),</div><div class="line">    anisotropic(anisotropic),</div><div class="line">    quadrature (degree+1),</div><div class="line">    face_quadrature (degree+1),</div><div class="line">    dg ()</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  DGMethod&lt;dim&gt;::~DGMethod ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGMethod&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                             dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                             (<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::faces_per_cell</a></div><div class="line">                              *<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::max_children_per_face</a>+1)*fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> (dof_handler, sparsity_pattern);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">    solution2.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    right_hand_side.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGMethod&lt;dim&gt;::assemble_system2 ()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; dofs (dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; dofs_neighbor (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="line">                                     | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="line">                                     | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="line">                                     | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="line">                                          | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="line">                                          | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="line">                                          | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> neighbor_face_update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_v (</div><div class="line">      mapping, fe, quadrature, update_flags);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_v_face (</div><div class="line">      mapping, fe, face_quadrature, face_update_flags);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> fe_v_subface (</div><div class="line">      mapping, fe, face_quadrature, face_update_flags);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_v_face_neighbor (</div><div class="line">      mapping, fe, face_quadrature, neighbor_face_update_flags);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ui_vi_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ue_vi_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ui_ve_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ue_ve_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>  cell_vector (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        ui_vi_matrix = 0;</div><div class="line">        cell_vector = 0;</div><div class="line"></div><div class="line">        fe_v.reinit (cell);</div><div class="line"></div><div class="line">        dg.assemble_cell_term(fe_v,</div><div class="line">                              ui_vi_matrix,</div><div class="line">                              cell_vector);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (dofs);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_no)</div><div class="line">          {</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face=</div><div class="line">              cell-&gt;face(face_no);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                fe_v_face.reinit (cell, face_no);</div><div class="line"></div><div class="line">                dg.assemble_boundary_term(fe_v_face,</div><div class="line">                                          ui_vi_matrix,</div><div class="line">                                          cell_vector);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cell-&gt;neighbor(face_no).state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>,</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor=</div><div class="line">                  cell-&gt;neighbor(face_no);</div><div class="line">                <span class="keywordflow">if</span> (face-&gt;has_children())</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor2=</div><div class="line">                      cell-&gt;neighbor_face_no(face_no);</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no=0;</div><div class="line">                         subface_no&lt;face-&gt;number_of_children(); ++subface_no)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor_child</div><div class="line">                          = cell-&gt;neighbor_child_on_subface (face_no, subface_no);</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (!neighbor_child-&gt;has_children(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">                        ue_vi_matrix = 0;</div><div class="line">                        ui_ve_matrix = 0;</div><div class="line">                        ue_ve_matrix = 0;</div><div class="line"></div><div class="line">                        fe_v_subface.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (cell, face_no, subface_no);</div><div class="line">                        fe_v_face_neighbor.reinit (neighbor_child, neighbor2);</div><div class="line"></div><div class="line">                        dg.assemble_face_term2(fe_v_subface,</div><div class="line">                                               fe_v_face_neighbor,</div><div class="line">                                               ui_vi_matrix,</div><div class="line">                                               ue_vi_matrix,</div><div class="line">                                               ui_ve_matrix,</div><div class="line">                                               ue_ve_matrix);</div><div class="line"></div><div class="line">                        neighbor_child-&gt;get_dof_indices (dofs_neighbor);</div><div class="line"></div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                            {</div><div class="line">                              system_matrix.add(dofs[i], dofs_neighbor[j],</div><div class="line">                                                ue_vi_matrix(i,j));</div><div class="line">                              system_matrix.add(dofs_neighbor[i], dofs[j],</div><div class="line">                                                ui_ve_matrix(i,j));</div><div class="line">                              system_matrix.add(dofs_neighbor[i], dofs_neighbor[j],</div><div class="line">                                                ue_ve_matrix(i,j));</div><div class="line">                            }</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">if</span> (!cell-&gt;neighbor_is_coarser(face_no) &amp;&amp;</div><div class="line">                        (neighbor-&gt;index() &gt; cell-&gt;index() ||</div><div class="line">                         (neighbor-&gt;level() &lt; cell-&gt;level() &amp;&amp;</div><div class="line">                          neighbor-&gt;index() == cell-&gt;index())))</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor2=cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">                        ue_vi_matrix = 0;</div><div class="line">                        ui_ve_matrix = 0;</div><div class="line">                        ue_ve_matrix = 0;</div><div class="line"></div><div class="line">                        fe_v_face.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (cell, face_no);</div><div class="line">                        fe_v_face_neighbor.reinit (neighbor, neighbor2);</div><div class="line"></div><div class="line">                        dg.assemble_face_term2(fe_v_face,</div><div class="line">                                               fe_v_face_neighbor,</div><div class="line">                                               ui_vi_matrix,</div><div class="line">                                               ue_vi_matrix,</div><div class="line">                                               ui_ve_matrix,</div><div class="line">                                               ue_ve_matrix);</div><div class="line"></div><div class="line">                        neighbor-&gt;get_dof_indices (dofs_neighbor);</div><div class="line"></div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                            {</div><div class="line">                              system_matrix.add(dofs[i], dofs_neighbor[j],</div><div class="line">                                                ue_vi_matrix(i,j));</div><div class="line">                              system_matrix.add(dofs_neighbor[i], dofs[j],</div><div class="line">                                                ui_ve_matrix(i,j));</div><div class="line">                              system_matrix.add(dofs_neighbor[i], dofs_neighbor[j],</div><div class="line">                                                ue_ve_matrix(i,j));</div><div class="line">                            }</div><div class="line">                      }</div><div class="line"></div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            system_matrix.add(dofs[i], dofs[j], ui_vi_matrix(i,j));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          right_hand_side(dofs[i]) += cell_vector(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGMethod&lt;dim&gt;::solve (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution)</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">    <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;&gt;</a>      solver (solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; preconditioner;</div><div class="line"></div><div class="line">    preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"></div><div class="line">    solver.solve (system_matrix, solution, right_hand_side,</div><div class="line">                  preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGMethod&lt;dim&gt;::refine_grid ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> gradient_indicator (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceDerivativeApproximation.html#ace2a9964b7da0d28c8184346902a6563">DerivativeApproximation::approximate_gradient</a> (mapping,</div><div class="line">                                                   dof_handler,</div><div class="line">                                                   solution2,</div><div class="line">                                                   gradient_indicator);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no=0; cell!=endc; ++cell, ++cell_no)</div><div class="line">      gradient_indicator(cell_no)*=std::pow(cell-&gt;diameter(), 1+1.0*dim/2);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                     gradient_indicator,</div><div class="line">                                                     0.3, 0.1);</div><div class="line">    <span class="keywordflow">if</span> (anisotropic)</div><div class="line">      set_anisotropic_flags();</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGMethod&lt;dim&gt;::set_anisotropic_flags ()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_update_flags</div><div class="line">      = <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_v_face (mapping, fe, face_quadrature, face_update_flags);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> fe_v_subface (mapping, fe, face_quadrature, face_update_flags);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_v_face_neighbor (mapping, fe, face_quadrature, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell=dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                                   endc=dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;refine_flag_set())</div><div class="line">        {</div><div class="line">          <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> jump;</div><div class="line">          <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> area;</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_no)</div><div class="line">            {</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::face_iterator</a> face = cell-&gt;face(face_no);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (!face-&gt;at_boundary())</div><div class="line">                {</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cell-&gt;neighbor(face_no).state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor = cell-&gt;neighbor(face_no);</div><div class="line"></div><div class="line">                  std::vector&lt;double&gt; u (fe_v_face.n_quadrature_points);</div><div class="line">                  std::vector&lt;double&gt; u_neighbor (fe_v_face.n_quadrature_points);</div><div class="line"></div><div class="line">                  <span class="keywordflow">if</span> (face-&gt;has_children())</div><div class="line">                    {</div><div class="line">                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor2=cell-&gt;neighbor_face_no(face_no);</div><div class="line">                      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface_no=0; subface_no&lt;face-&gt;number_of_children(); ++subface_no)</div><div class="line">                        {</div><div class="line">                          <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> neighbor_child = cell-&gt;neighbor_child_on_subface(face_no,subface_no);</div><div class="line">                          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (!neighbor_child-&gt;has_children(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                          fe_v_subface.reinit (cell, face_no, subface_no);</div><div class="line">                          fe_v_face_neighbor.reinit (neighbor_child, neighbor2);</div><div class="line">                          fe_v_subface.get_function_values(solution2, u);</div><div class="line">                          fe_v_face_neighbor.get_function_values(solution2, u_neighbor);</div><div class="line">                          <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v_subface.get_JxW_values ();</div><div class="line">                          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;fe_v_subface.n_quadrature_points; ++x)</div><div class="line">                            {</div><div class="line">                              jump[face_no/2]+=std::fabs(u[x]-u_neighbor[x])*JxW[x];</div><div class="line">                              area[face_no/2]+=JxW[x];</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                  <span class="keywordflow">else</span></div><div class="line">                    {</div><div class="line">                      <span class="keywordflow">if</span> (!cell-&gt;neighbor_is_coarser(face_no))</div><div class="line">                        {</div><div class="line">                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neighbor2=cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">                          fe_v_face.reinit (cell, face_no);</div><div class="line">                          fe_v_face_neighbor.reinit (neighbor, neighbor2);</div><div class="line"></div><div class="line">                          fe_v_face.get_function_values(solution2, u);</div><div class="line">                          fe_v_face_neighbor.get_function_values(solution2, u_neighbor);</div><div class="line"></div><div class="line">                          <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v_face.get_JxW_values ();</div><div class="line"></div><div class="line">                          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;fe_v_face.n_quadrature_points; ++x)</div><div class="line">                            {</div><div class="line">                              jump[face_no/2]+=std::fabs(u[x]-u_neighbor[x])*JxW[x];</div><div class="line">                              area[face_no/2]+=JxW[x];</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                      <span class="keywordflow">else</span> <span class="comment">//i.e. neighbor is coarser than cell</span></div><div class="line">                        {</div><div class="line">                          std::pair&lt;unsigned int,unsigned int&gt; neighbor_face_subface</div><div class="line">                            = cell-&gt;neighbor_of_coarser_neighbor(face_no);</div><div class="line">                          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor_face_subface.first&lt;<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::faces_per_cell</a>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor_face_subface.second&lt;neighbor-&gt;face(neighbor_face_subface.first)-&gt;number_of_children(),</div><div class="line">                                  <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (neighbor-&gt;neighbor_child_on_subface(neighbor_face_subface.first, neighbor_face_subface.second)</div><div class="line">                                  == cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">                          fe_v_face.reinit (cell, face_no);</div><div class="line">                          fe_v_subface.reinit (neighbor, neighbor_face_subface.first,</div><div class="line">                                               neighbor_face_subface.second);</div><div class="line"></div><div class="line">                          fe_v_face.get_function_values(solution2, u);</div><div class="line">                          fe_v_subface.get_function_values(solution2, u_neighbor);</div><div class="line"></div><div class="line">                          <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v_face.get_JxW_values ();</div><div class="line"></div><div class="line">                          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x&lt;fe_v_face.n_quadrature_points; ++x)</div><div class="line">                            {</div><div class="line">                              jump[face_no/2]+=std::fabs(u[x]-u_neighbor[x])*JxW[x];</div><div class="line">                              area[face_no/2]+=JxW[x];</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">          <span class="keywordtype">double</span> average_jumps[dim];</div><div class="line">          <span class="keywordtype">double</span> sum_of_average_jumps=0.;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">            {</div><div class="line">              average_jumps[i] = jump(i)/area(i);</div><div class="line">              sum_of_average_jumps += average_jumps[i];</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">            <span class="keywordflow">if</span> (average_jumps[i] &gt; anisotropic_threshold_ratio*(sum_of_average_jumps-average_jumps[i]))</div><div class="line">              cell-&gt;set_refine_flag(<a class="code" href="classRefinementCase.html">RefinementCase&lt;dim&gt;::cut_axis</a>(i));</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGMethod&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::string refine_type;</div><div class="line">    <span class="keywordflow">if</span> (anisotropic)</div><div class="line">      refine_type=<span class="stringliteral">&quot;.aniso&quot;</span>;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      refine_type=<span class="stringliteral">&quot;.iso&quot;</span>;</div><div class="line"></div><div class="line">    std::string filename = <span class="stringliteral">&quot;grid-&quot;</span>;</div><div class="line">    filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    filename += refine_type + <span class="stringliteral">&quot;.eps&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Writing grid to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;...&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::ofstream eps_output (filename.c_str());</div><div class="line"></div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a7e31485bb55254bfa5cd3ab55f8d1748">write_eps</a> (triangulation, eps_output);</div><div class="line"></div><div class="line">    filename = <span class="stringliteral">&quot;grid-&quot;</span>;</div><div class="line">    filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    filename += refine_type + <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Writing grid to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;...&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::ofstream gnuplot_grid_output (filename.c_str());</div><div class="line"></div><div class="line">    grid_out.write_gnuplot (triangulation, gnuplot_grid_output);</div><div class="line"></div><div class="line">    filename = <span class="stringliteral">&quot;sol-&quot;</span>;</div><div class="line">    filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    filename += refine_type + <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;...&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::ofstream gnuplot_output (filename.c_str());</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.add_data_vector (solution2, <span class="stringliteral">&quot;u&quot;</span>);</div><div class="line"></div><div class="line">    data_out.build_patches (degree);</div><div class="line"></div><div class="line">    data_out.write_gnuplot(gnuplot_output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DGMethod&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1,p2;</div><div class="line">            p1(0)=0;</div><div class="line">            p1(0)=-1;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">              p2(i)=1.;</div><div class="line">            std::vector&lt;unsigned int&gt; repetitions(dim,1);</div><div class="line">            repetitions[0]=2;</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation,</div><div class="line">                                                       repetitions,</div><div class="line">                                                       p1,</div><div class="line">                                                       p2);</div><div class="line"></div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (5-dim);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid ();</div><div class="line"></div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">                  &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classTimer.html">Timer</a> assemble_timer;</div><div class="line">        assemble_system2 ();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time of assemble_system2: &quot;</span></div><div class="line">                  &lt;&lt; assemble_timer()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        solve (solution2);</div><div class="line"></div><div class="line">        output_results (cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step30;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Performing a &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot;D run with isotropic refinement...&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line">        DGMethod&lt;dim&gt; dgmethod_iso(<span class="keyword">false</span>);</div><div class="line">        dgmethod_iso.run ();</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;Performing a &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot;D run with anisotropic refinement...&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;--------------------------------------------------&quot;</span> &lt;&lt; std::endl;</div><div class="line">        DGMethod&lt;dim&gt; dgmethod_aniso(<span class="keyword">true</span>);</div><div class="line">        dgmethod_aniso.run ();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
