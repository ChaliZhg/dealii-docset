<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-39 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-39 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Thelocalintegrators">The local integrators</a>
        <li><a href="#Themainclass">The main class</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a></p>
<p>In this program, we use the interior penalty method and Nitsche's weak boundary conditions to solve Poisson's equation. We use multigrid methods on locally refined meshes, which are generated using a bulk criterion and a standard error estimator based on cell and face residuals. All operators are implemented using the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> interface.</p>
<p>Like in <a class="el" href="step_12.html">step-12</a>, the discretization relies on finite element spaces, which are polynomial inside the mesh cells <img class="formulaInl" alt="$K\in \mathbb T_h$" src="form_3230.png"/>, but have no continuity between cells. Since such functions have two values on each interior face <img class="formulaInl" alt="$F\in \mathbb F_h^i$" src="form_3231.png"/>, one from each side, we define mean value and jump operators as follows: let <em>K</em><sub>1</sub> and <em>K</em><sub>2</sub> be the two cells sharing a face, and let the traces of functions <em>u<sub>i</sub></em> and the outer normal vectors <b>n</b><em><sub>i</sub></em> be labeled accordingly. Then, on the face, we let </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \{\!\{ u \}\!\} = \frac{u_1 + u_2}2 \]" src="form_3232.png"/>
</p>
<p>Note, that if such an expression contains a normal vector, the averaging operator turns into a jump. The interior penalty method for the problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\Delta u = f \text{ in }\Omega \qquad u = u^D \text{ on } \partial\Omega \]" src="form_3233.png"/>
</p>
<p> becomes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{multline*} \sum_{K\in \mathbb T_h} (\nabla u, \nabla v)_K \\ + \sum_{F \in F_h^i} \biggl\{4\sigma_F (\{\!\{ u \mathbf n\}\!\}, \{\!\{ v \mathbf n \}\!\})_F - 2 (\{\!\{ \nabla u \}\!\},\{\!\{ v\mathbf n \}\!\})_F - 2 (\{\!\{ \nabla v \}\!\},\{\!\{ u\mathbf n \}\!\})_F \biggr\} \\ + \sum_{F \in F_h^b} \biggl\{2\sigma_F (u, v)_F - (\partial_n u,v)_F - (\partial_n v,u)_F \biggr\} \\ = (f, v)_\Omega + \sum_{F \in F_h^b} \biggl\{ 2\sigma_F (u^D, v)_F - (\partial_n v,u^D)_F \biggr\}. \end{multline*}" src="form_3234.png"/>
</p>
<p>Here, <img class="formulaInl" alt="$\sigma_F$" src="form_3235.png"/> is the penalty parameter, which is chosen as follows: for a face <em>F</em> of a cell <em>K</em>, compute the value </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sigma_{F,K} = p(p+1) \frac{|F|_{d-1}}{|K|_d}, \]" src="form_3236.png"/>
</p>
<p> where <em>p</em> is the polynomial degree of the finite element functions and <img class="formulaInl" alt="$|\cdot|_d$" src="form_3237.png"/> and <img class="formulaInl" alt="$|\cdot|_{d-1}$" src="form_3238.png"/> denote the <img class="formulaInl" alt="$d$" src="form_301.png"/> and <img class="formulaInl" alt="$d-1$" src="form_3239.png"/> dimensional Hausdorff measure of the corresponding object. If the face is at the boundary, choose <img class="formulaInl" alt="$\sigma_F = \sigma_{F,K}$" src="form_3240.png"/>. For an interior face, we take the average of the two values at this face.</p>
<p>In our finite element program, we distinguish three different integrals, corresponding to the sums over cells, interior faces and boundary faces above. Since the <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop</a> organizes the sums for us, we only need to implement the integrals over each mesh element. The class MatrixIntegrator below has these three functions for the left hand side of the formula, the class RHSIntegrator for the right.</p>
<p>As we will see below, even the error estimate is of the same structure, since it can be written as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \eta^2 &amp;= \eta_K^2 + \eta_F^2 + \eta_B^2 \\ \eta_K^2 &amp;= \sum_{K\in \mathbb T_h} h^2 \|f + \Delta u_h\|^2 \\ \eta_F^2 &amp;= \sum_{F \in F_h^i} \biggl\{ 4 \sigma_F \| \{\!\{u_h\mathbf n\}\!\} \|^2 + h \|\{\!\{\partial_n u_h\}\!\}\|^2 \biggr\} \\ \eta_B^2 &amp;= \sum_{F \in F_h^b} 2\sigma_F \| u_h-u^D \|^2. \end{align*}" src="form_3241.png"/>
</p>
<p>Thus, the functions for assembling matrices, right hand side and error estimates below exhibit that these loops are all generic and can be programmed in the same way.</p>
<p>This program is related to <a class="el" href="step_12.html">step-12</a>, in that it uses <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> and discontinuous Galerkin methods. While there, we solved an advection problem, here it is a diffusion problem. Here, we also use multigrid preconditioning and a theoretically justified error estimator, see Karakashian and Pascal (2003). The multilevel scheme was discussed in detail in Kanschat (2004). The adaptive iteration and its convergence have been discussed (for triangular meshes) in Hoppe, Kanschat, and Warburton (2009). <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The include files for the linear algebra: A regular <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, which in turn will include the necessary files for <a class="el" href="classSparsityPattern.html">SparsityPattern</a> and <a class="el" href="classVector.html">Vector</a> classes.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition_block.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div></div><!-- fragment --><p>Include files for setting up the mesh</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div></div><!-- fragment --><p>Include files for <a class="el" href="classFiniteElement.html">FiniteElement</a> classes and <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgp.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div></div><!-- fragment --><p>The include files for using the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/dof_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/integration_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/assembler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/loop.h&gt;</span></div></div><!-- fragment --><p>The include file for local integrators associated with the Laplacian</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/integrators/laplace.h&gt;</span></div></div><!-- fragment --><p>Support for multigrid methods</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/multigrid.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_transfer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_coarse.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_smoother.h&gt;</span></div></div><!-- fragment --><p>Finally, we take our exact solution from the library as well as quadrature and additional tools.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>All classes of the deal.II library are in the namespace dealii. In order to save typing, we tell the compiler to search names in there as well.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step39</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>This is the function we use to set the boundary values and also the exact solution we compare to.</p>
<div class="fragment"><div class="line"><a class="code" href="classFunctions_1_1SlitSingularityFunction.html">Functions::SlitSingularityFunction&lt;2&gt;</a> exact_solution;</div></div><!-- fragment --><p><a class="anchor" id="Thelocalintegrators"></a> </p><h3>The local integrators</h3>
<p><a class="el" href="namespaceMeshWorker.html">MeshWorker</a> separates local integration from the loops over cells and faces. Thus, we have to write local integration classes for generating matrices, the right hand side and the error estimator.</p>
<p>All these classes have the same three functions for integrating over cells, boundary faces and interior faces, respectively. All the information needed for the local integration is provided by MeshWorker::IntegrationInfo&lt;dim&gt;. Note that the signature of the functions cannot be changed, because it is expected by <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">MeshWorker::integration_loop()</a>.</p>
<p>The first class defining local integrators is responsible for computing cell and face matrices. It is used to assemble the global matrix as well as the level matrices.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MatrixIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a44cc05e3e905a8cd5af4c12d3026ea2a">cell</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a796bd92a5f7d1fd3f555f5b8a85569cb">boundary</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a6aab57ca24b0fd3e9a1614b5a6cb49e2">face</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">            <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>On each cell, we integrate the Dirichlet form. We use the library of ready made integrals in <a class="el" href="namespaceLocalIntegrators.html" title="Library of integrals over cells and faces. ">LocalIntegrators</a> to avoid writing these loops ourselves. Similarly, we implement Nitsche boundary conditions and the interior penalty fluxes between cells.</p>
<p>The boundary and flux terms need a penalty parameter, which should be adjusted to the cell size and the polynomial degree. A safe choice of this parameter for constant coefficients can be found in <a class="el" href="namespaceLocalIntegrators_1_1Laplace.html#aa920ce4642983b9cb2fbf996b75d3c52">LocalIntegrators::Laplace::compute_penalty()</a> and we use this below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MatrixIntegrator&lt;dim&gt;::cell(</div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">false</span>).matrix, info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MatrixIntegrator&lt;dim&gt;::boundary(</div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).get_fe().tensor_degree();</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#af88167a13d65d1367d093a798a847263">LocalIntegrators::Laplace::nitsche_matrix</a>(</div><div class="line">    dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">false</span>).matrix, info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#aa920ce4642983b9cb2fbf996b75d3c52">LocalIntegrators::Laplace::compute_penalty</a>(dinfo, dinfo, deg, deg));</div><div class="line">}</div></div><!-- fragment --><p>Interior faces use the interior penalty method</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MatrixIntegrator&lt;dim&gt;::face(</div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).get_fe().tensor_degree();</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#acf43744b2ca29cbf871cf63054bd3436">LocalIntegrators::Laplace::ip_matrix</a>(</div><div class="line">    dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">false</span>).matrix, dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">true</span>).matrix,</div><div class="line">    dinfo2.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">true</span>).matrix, dinfo2.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">false</span>).matrix,</div><div class="line">    info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0), info2.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#aa920ce4642983b9cb2fbf996b75d3c52">LocalIntegrators::Laplace::compute_penalty</a>(dinfo1, dinfo2, deg, deg));</div><div class="line">}</div></div><!-- fragment --><p>The second local integrator builds the right hand side. In our example, the right hand side function is zero, such that only the boundary condition is set here in weak form.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RHSIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a44cc05e3e905a8cd5af4c12d3026ea2a">cell</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a796bd92a5f7d1fd3f555f5b8a85569cb">boundary</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a6aab57ca24b0fd3e9a1614b5a6cb49e2">face</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">            <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RHSIntegrator&lt;dim&gt;::cell(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RHSIntegrator&lt;dim&gt;::boundary(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;local_vector = dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#af80df9fc19df1713b3d41690f9c71527">vector</a>(0).block(0);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; boundary_values(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">  exact_solution.<a class="code" href="classFunctions_1_1SlitSingularityFunction.html#aab24543bcf43a9536c552a1fc8f156fa">value_list</a>(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = 2. * deg * (deg+1) * dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">      local_vector(i) += (- fe.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,k) * penalty * boundary_values[k]</div><div class="line">                          + (fe.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(k) * fe.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,k)) * boundary_values[k])</div><div class="line">                         * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RHSIntegrator&lt;dim&gt;::face(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;,</div><div class="line">                              <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;,</div><div class="line">                              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;,</div><div class="line">                              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{}</div></div><!-- fragment --><p>The third local integrator is responsible for the contributions to the error estimate. This is the standard energy estimator due to Karakashian and Pascal (2003).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Estimator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a44cc05e3e905a8cd5af4c12d3026ea2a">cell</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a796bd92a5f7d1fd3f555f5b8a85569cb">boundary</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a6aab57ca24b0fd3e9a1614b5a6cb49e2">face</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">            <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>The cell contribution is the Laplacian of the discrete solution, since the right hand side is zero.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Estimator&lt;dim&gt;::cell(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;2,dim&gt; &gt; &amp;DDuh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a1a8ad93d124bf3e0d3ed03863c08def6">hessians</a>[0][0];</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> t = dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;diameter() * <a class="code" href="classSymmetricTensor.html#a05096e7bc18fa734eae3bd1a5f08138e">trace</a>(DDuh[k]);</div><div class="line">      dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) +=  t*t * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">    }</div><div class="line">  dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">}</div></div><!-- fragment --><p>At the boundary, we use simply a weighted form of the boundary residual, namely the norm of the difference between the finite element solution and the correct boundary condition.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Estimator&lt;dim&gt;::boundary(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; boundary_values(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">  exact_solution.<a class="code" href="classFunctions_1_1SlitSingularityFunction.html#aab24543bcf43a9536c552a1fc8f156fa">value_list</a>(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = 2. * deg * (deg+1) * dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">    dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) += penalty * (boundary_values[k] - uh[k]) * (boundary_values[k] - uh[k])</div><div class="line">                      * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">  dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">}</div></div><!-- fragment --><p>Finally, on interior faces, the estimator consists of the jumps of the solution and its normal derivative, weighted appropriately.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Estimator&lt;dim&gt;::face(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">                          <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">                          <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">                          <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh1 = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh2 = info2.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;Duh1 = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#abf4e7bf5672c085b36dbcedc1918d2f4">gradients</a>[0][0];</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;Duh2 = info2.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#abf4e7bf5672c085b36dbcedc1918d2f4">gradients</a>[0][0];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty1 = deg * (deg+1) * dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty2 = deg * (deg+1) * dinfo2.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo2.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = penalty1 + penalty2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h = dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> diff1 = uh1[k] - uh2[k];</div><div class="line">      <span class="keywordtype">double</span> diff2 = fe.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(k) * Duh1[k] - fe.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(k) * Duh2[k];</div><div class="line">      dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) += (penalty * diff1*diff1 + h * diff2*diff2)</div><div class="line">                         * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">    }</div><div class="line">  dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">  dinfo2.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0);</div><div class="line">}</div></div><!-- fragment --><p>Finally we have an integrator for the error. Since the energy norm for discontinuous Galerkin problems not only involves the difference of the gradient inside the cells, but also the jump terms across faces and at the boundary, we cannot just use <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference()</a>. Instead, we use the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> interface to compute the error ourselves.</p>
<p>There are several different ways to define this energy norm, but all of them are equivalent to each other uniformly with mesh size (some not uniformly with polynomial degree). Here, we choose </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \|u\|_{1,h} = \sum_{K\in \mathbb T_h} \|\nabla u\|_K^2 + \sum_{F \in F_h^i} 4\sigma_F\|\{\!\{ u \mathbf n\}\!\}\|^2_F + \sum_{F \in F_h^b} 2\sigma_F\|u\|^2_F \]" src="form_3242.png"/>
</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ErrorIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a44cc05e3e905a8cd5af4c12d3026ea2a">cell</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a796bd92a5f7d1fd3f555f5b8a85569cb">boundary</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a6aab57ca24b0fd3e9a1614b5a6cb49e2">face</a>(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">            <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>Here we have the integration on cells. There is currently no good interface in <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> that would allow us to access values of regular functions in the quadrature points. Thus, we have to create the vectors for the exact function's values and gradients inside the cell integrator. After that, everything is as before and we just add up the squares of the differences.</p>
<p>Additionally to computing the error in the energy norm, we use the capability of the mesh worker to compute two functionals at the same time and compute the <em>L<sup>2</sup></em>-error in the same loop. Obviously, this one does not have any jump terms and only appears in the integration on cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ErrorIntegrator&lt;dim&gt;::cell(</div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; exact_gradients(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">  std::vector&lt;double&gt; exact_values(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">  exact_solution.gradient_list(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), exact_gradients);</div><div class="line">  exact_solution.<a class="code" href="classFunctions_1_1SlitSingularityFunction.html#aab24543bcf43a9536c552a1fc8f156fa">value_list</a>(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), exact_values);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;Duh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#abf4e7bf5672c085b36dbcedc1918d2f4">gradients</a>[0][0];</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> diff = exact_gradients[k][d] - Duh[k][d];</div><div class="line">          sum += diff*diff;</div><div class="line">        }</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> diff = exact_values[k] - uh[k];</div><div class="line">      dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) +=  sum * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">      dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(1) +=  diff*diff * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">    }</div><div class="line">  dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">  dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(1) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(1));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ErrorIntegrator&lt;dim&gt;::boundary(</div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; exact_values(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">  exact_solution.<a class="code" href="classFunctions_1_1SlitSingularityFunction.html#aab24543bcf43a9536c552a1fc8f156fa">value_list</a>(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), exact_values);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = 2. * deg * (deg+1) * dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> diff = exact_values[k] - uh[k];</div><div class="line">      dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) += penalty * diff * diff * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">    }</div><div class="line">  dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ErrorIntegrator&lt;dim&gt;::face(</div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh1 = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh2 = info2.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty1 = deg * (deg+1) * dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty2 = deg * (deg+1) * dinfo2.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo2.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = penalty1 + penalty2;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> diff = uh1[k] - uh2[k];</div><div class="line">      dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) += (penalty * diff*diff)</div><div class="line">                         * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">    }</div><div class="line">  dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">  dinfo2.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainclass"></a> </p><h3>The main class</h3>
<p>This class does the main job, like in previous examples. For a description of the functions declared here, please refer to the implementation below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InteriorPenaltyProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> CellInfo;</div><div class="line"></div><div class="line">  InteriorPenaltyProblem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_matrix ();</div><div class="line">  <span class="keywordtype">void</span> assemble_mg_matrix ();</div><div class="line">  <span class="keywordtype">void</span> assemble_right_hand_side ();</div><div class="line">  <span class="keywordtype">void</span> error ();</div><div class="line">  <span class="keywordtype">double</span> estimate ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div></div><!-- fragment --><p>The member objects related to the discretization are here.</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        triangulation;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>      mapping;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div></div><!-- fragment --><p>Then, we have the matrices and vectors related to the global discrete system.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       right_hand_side;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>  estimates;</div></div><!-- fragment --><p>Finally, we have a group of sparsity patterns and sparse matrices related to the multilevel preconditioner. First, we have a level matrix and its sparsity pattern.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_matrix;</div></div><!-- fragment --><p>When we perform multigrid with local smoothing on locally refined meshes, additional matrices are required; see Kanschat (2004). Here is the sparsity pattern for these edge matrices. We only need one, because the pattern of the up matrix is the transpose of that of the down matrix. Actually, we do not care too much about these details, since the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> is filling these matrices.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_dg_interface;</div></div><!-- fragment --><p>The flux matrix at the refinement edge, coupling fine level degrees of freedom to coarse level.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_matrix_dg_down;</div></div><!-- fragment --><p>The transpose of the flux matrix at the refinement edge, coupling coarse level degrees of freedom to fine level.</p>
<div class="fragment"><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_matrix_dg_up;</div><div class="line">};</div></div><!-- fragment --><p>The constructor simply sets up the coarse grid and the <a class="el" href="classDoFHandler.html">DoFHandler</a>. The <a class="el" href="classFiniteElement.html">FiniteElement</a> is provided as a parameter to allow flexibility.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">InteriorPenaltyProblem&lt;dim&gt;::InteriorPenaltyProblem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe)</div><div class="line">  :</div><div class="line">  triangulation (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices),</div><div class="line">  mapping(),</div><div class="line">  fe(fe),</div><div class="line">  dof_handler(triangulation),</div><div class="line">  estimates(1)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a5114625911496e4f51758fe00562a14a">GridGenerator::hyper_cube_slit</a>(triangulation, -1, 1);</div><div class="line">}</div></div><!-- fragment --><p>In this function, we set up the dimension of the linear system and the sparsity patterns for the global matrix as well as the level matrices.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">InteriorPenaltyProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div></div><!-- fragment --><p>First, we use the finite element to distribute degrees of freedom over the mesh and number them.</p>
<div class="fragment"><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#aef4dba3640a019e25c5742e067d7986e">distribute_mg_dofs</a>(fe);</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs = dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div></div><!-- fragment --><p>Then, we already know the size of the vectors representing finite element functions.</p>
<div class="fragment"><div class="line">solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(n_dofs);</div><div class="line">right_hand_side.reinit(n_dofs);</div></div><!-- fragment --><p>Next, we set up the sparsity pattern for the global matrix. Since we do not know the row sizes in advance, we first fill a temporary <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> object and copy it to the regular <a class="el" href="classSparsityPattern.html">SparsityPattern</a> once it is complete.</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_dofs);</div><div class="line"><a class="code" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">sparsity.copy_from(dsp);</div><div class="line">matrix.reinit(sparsity);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>();</div></div><!-- fragment --><p>The global system is set up, now we attend to the level matrices. We resize all matrix objects to hold one matrix per level.</p>
<div class="fragment"><div class="line">mg_matrix.resize(0, n_levels-1);</div><div class="line">mg_matrix.clear_elements();</div><div class="line">mg_matrix_dg_up.resize(0, n_levels-1);</div><div class="line">mg_matrix_dg_up.clear_elements();</div><div class="line">mg_matrix_dg_down.resize(0, n_levels-1);</div><div class="line">mg_matrix_dg_down.clear_elements();</div></div><!-- fragment --><p>It is important to update the sparsity patterns after <code>clear()</code> was called for the level matrices, since the matrices lock the sparsity pattern through the <a class="el" href="classSmartPointer.html">SmartPointer</a> and <a class="el" href="classSubscriptor.html">Subscriptor</a> mechanism.</p>
<div class="fragment"><div class="line">mg_sparsity.resize(0, n_levels-1);</div><div class="line">mg_sparsity_dg_interface.resize(0, n_levels-1);</div></div><!-- fragment --><p>Now all objects are prepared to hold one sparsity pattern or matrix per level. What's left is setting up the sparsity patterns on each level.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=mg_sparsity.min_level();</div><div class="line">     level&lt;=mg_sparsity.max_level(); ++level)</div><div class="line">  {</div></div><!-- fragment --><p>These are roughly the same lines as above for the global matrix, now for each level.</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line"><a class="code" href="namespaceMGTools.html#a1a1273930a0c3cd4a537063b26a2a95f">MGTools::make_flux_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line">mg_sparsity[level].copy_from(dsp);</div><div class="line">mg_matrix[level].reinit(mg_sparsity[level]);</div></div><!-- fragment --><p>Additionally, we need to initialize the transfer matrices at the refinement edge between levels. They are stored at the index referring to the finer of the two indices, thus there is no such object on level 0.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (level&gt;0)</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp;</div><div class="line">          dsp.<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level-1), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#aa242701df963b91f9139020fe79b1196">MGTools::make_flux_sparsity_pattern_edge</a>(dof_handler, dsp, level);</div><div class="line">          mg_sparsity_dg_interface[level].copy_from(dsp);</div><div class="line">          mg_matrix_dg_up[level].reinit(mg_sparsity_dg_interface[level]);</div><div class="line">          mg_matrix_dg_down[level].reinit(mg_sparsity_dg_interface[level]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In this function, we assemble the global system matrix, where by global we indicate that this is the matrix of the discrete system we solve and it is covering the whole mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">InteriorPenaltyProblem&lt;dim&gt;::assemble_matrix()</div><div class="line">{</div></div><!-- fragment --><p>First, we need t set up the object providing the values we integrate. This object contains all <a class="el" href="classFEValues.html">FEValues</a> and <a class="el" href="classFEFaceValues.html">FEFaceValues</a> objects needed and also maintains them automatically such that they always point to the current cell. To this end, we need to tell it first, where and what to compute. Since we are not doing anything fancy, we can rely on their standard choice for quadrature rules.</p>
<p>Since their default update flags are minimal, we add what we need additionally, namely the values and gradients of shape functions on all objects (cells, boundary and interior faces). Afterwards, we are ready to initialize the container, which will create all necessary <a class="el" href="classFEValuesBase.html">FEValuesBase</a> objects for integration.</p>
<div class="fragment"><div class="line"><a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line"><a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>;</div><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div></div><!-- fragment --><p>This is the object into which we integrate local data. It is filled by the local integration routines in MatrixIntegrator and then used by the assembler to distribute the information into the global matrix.</p>
<div class="fragment"><div class="line"><a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div></div><!-- fragment --><p>Furthermore, we need an object that assembles the local matrix into the global matrix. These assembler objects have all the knowledge of the structures of the target object, in this case a <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, possible constraints and the mesh structure.</p>
<div class="fragment"><div class="line"><a class="code" href="classMeshWorker_1_1Assembler_1_1MatrixSimple.html">MeshWorker::Assembler::MatrixSimple&lt;SparseMatrix&lt;double&gt;</a> &gt; assembler;</div><div class="line">assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MatrixSimple.html#a16aa7c79a160c3f8531fe77531965df6">initialize</a>(matrix);</div></div><!-- fragment --><p>Now comes the part we coded ourselves, the local integrator. This is the only part which is problem dependent.</p>
<div class="fragment"><div class="line">MatrixIntegrator&lt;dim&gt; integrator;</div></div><!-- fragment --><p>Now, we throw everything into a <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop()</a>, which here traverses all active cells of the mesh, computes cell and face matrices and assembles them into the global matrix. We use the variable <code>dof_handler</code> here in order to use the global numbering of degrees of freedom.</p>
<div class="fragment"><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt;(</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">    dof_info, info_box,</div><div class="line">    integrator, assembler);</div><div class="line">}</div></div><!-- fragment --><p>Now, we do the same for the level matrices. Not too surprisingly, this function looks like a twin of the previous one. Indeed, there are only two minor differences.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">InteriorPenaltyProblem&lt;dim&gt;::assemble_mg_matrix()</div><div class="line">{</div><div class="line">  <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>;</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div></div><!-- fragment --><p>Obviously, the assembler needs to be replaced by one filling level matrices. Note that it automatically fills the edge matrices as well.</p>
<div class="fragment"><div class="line"><a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html">MeshWorker::Assembler::MGMatrixSimple&lt;SparseMatrix&lt;double&gt;</a> &gt; assembler;</div><div class="line">assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_matrix);</div><div class="line">assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#a1fce17a3ff22b59c0f023fd9a58e43f6">initialize_fluxes</a>(mg_matrix_dg_up, mg_matrix_dg_down);</div><div class="line"></div><div class="line">MatrixIntegrator&lt;dim&gt; integrator;</div></div><!-- fragment --><p>Here is the other difference to the previous function: we run over all cells, not only the active ones. And we use functions ending on <code>_mg</code> since we need the degrees of freedom on each level, not the global numbering.</p>
<div class="fragment"><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt; (</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">    dof_info, info_box,</div><div class="line">    integrator, assembler);</div><div class="line">}</div></div><!-- fragment --><p>Here we have another clone of the assemble function. The difference to assembling the system matrix consists in that we assemble a vector here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">InteriorPenaltyProblem&lt;dim&gt;::assemble_right_hand_side()</div><div class="line">{</div><div class="line">  <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>;</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div></div><!-- fragment --><p>Since this assembler allows us to fill several vectors, the interface is a little more complicated as above. The pointers to the vectors have to be stored in a <a class="el" href="classAnyData.html">AnyData</a> object. While this seems to cause two extra lines of code here, it actually comes handy in more complex applications.</p>
<div class="fragment"><div class="line">  <a class="code" href="classMeshWorker_1_1Assembler_1_1ResidualSimple.html">MeshWorker::Assembler::ResidualSimple&lt;Vector&lt;double&gt;</a> &gt; assembler;</div><div class="line">  <a class="code" href="classAnyData.html">AnyData</a> data;</div><div class="line">  data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>*&gt;(&amp;right_hand_side, <span class="stringliteral">&quot;RHS&quot;</span>);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1ResidualSimple.html#affc8d054d00d3838c2ab8d8adbd5ccb5">initialize</a>(data);</div><div class="line"></div><div class="line">  RHSIntegrator&lt;dim&gt; integrator;</div><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt;(</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">    dof_info, info_box,</div><div class="line">    integrator, assembler);</div><div class="line"></div><div class="line">  right_hand_side *= -1.;</div><div class="line">}</div></div><!-- fragment --><p>Now that we have coded all functions building the discrete linear system, it is about time that we actually solve it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">InteriorPenaltyProblem&lt;dim&gt;::solve()</div><div class="line">{</div></div><!-- fragment --><p>The solver of choice is conjugate gradient.</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> control(1000, 1.e-12);</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a> &gt; solver(control);</div></div><!-- fragment --><p>Now we are setting up the components of the multilevel preconditioner. First, we need transfer between grid levels. The object we are using here generates sparse matrices for these transfers.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; mg_transfer;</div><div class="line">mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a2302c0b6ee91b59d006b21c7d3f00025">build_matrices</a>(dof_handler);</div></div><!-- fragment --><p>Then, we need an exact solver for the matrix on the coarsest level.</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a> (mg_matrix[0]);</div><div class="line"><a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a> &gt; mg_coarse;</div><div class="line">mg_coarse.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div></div><!-- fragment --><p>While transfer and coarse grid solver are pretty much generic, more flexibility is offered for the smoother. First, we choose Gauss-Seidel as our smoothing method.</p>
<div class="fragment"><div class="line"><a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;Vector&lt;double&gt;</a> &gt; mem;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; RELAXATION;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;RELAXATION, Vector&lt;double&gt;</a> &gt;</div><div class="line">mg_smoother;</div><div class="line">RELAXATION::AdditionalData smoother_data(1.);</div><div class="line">mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrix, smoother_data);</div></div><!-- fragment --><p>Do two smoothing steps on each level.</p>
<div class="fragment"><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div></div><!-- fragment --><p>Since the SOR method is not symmetric, but we use conjugate gradient iteration below, here is a trick to make the multilevel preconditioner a symmetric operator even for nonsymmetric smoothers.</p>
<div class="fragment"><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p>The smoother class optionally implements the variable V-cycle, which we do not want here.</p>
<div class="fragment"><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#ae35e1ca776c5e1ce40149510e2207f36">set_variable</a>(<span class="keyword">false</span>);</div></div><!-- fragment --><p>Finally, we must wrap our matrices in an object having the required multiplication functions.</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a> &gt; mgmatrix(mg_matrix);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a> &gt; mgdown(mg_matrix_dg_down);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a> &gt; mgup(mg_matrix_dg_up);</div></div><!-- fragment --><p>Now, we are ready to set up the V-cycle operator and the multilevel preconditioner.</p>
<div class="fragment"><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a> &gt; <a class="code" href="namespacemg.html">mg</a>(mgmatrix,</div><div class="line">                              mg_coarse, mg_transfer,</div><div class="line">                              mg_smoother, mg_smoother);</div></div><!-- fragment --><p>Let us not forget the edge matrices needed because of the adaptive refinement.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_flux_matrices(mgdown, mgup);</div></div><!-- fragment --><p>After all preparations, wrap the <a class="el" href="classMultigrid.html">Multigrid</a> object into another object, which can be used as a regular preconditioner,</p>
<div class="fragment"><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>,</div><div class="line">               <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; &gt;</div><div class="line">               preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>and use it to solve the system.</p>
<div class="fragment"><div class="line">  solver.solve(matrix, solution, right_hand_side, preconditioner);</div><div class="line">}</div></div><!-- fragment --><p>Another clone of the assemble function. The big difference to the previous ones is here that we also have an input vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">InteriorPenaltyProblem&lt;dim&gt;::estimate()</div><div class="line">{</div></div><!-- fragment --><p>The results of the estimator are stored in a vector with one entry per cell. Since cells in deal.II are not numbered, we have to create our own numbering in order to use this vector.</p>
<p>On the other hand, somebody might have used the user indices already. So, let's be good citizens and save them before tampering with them.</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; old_user_indices;</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices</a>(old_user_indices);</div><div class="line"></div><div class="line">estimates.block(0).reinit(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">     cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell,++i)</div><div class="line">  cell-&gt;set_user_index(i);</div></div><!-- fragment --><p>This starts like before,</p>
<div class="fragment"><div class="line"><a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a>()+1;</div><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a2ccc96521da795a762213a979c581138">initialize_gauss_quadrature</a>(n_gauss_points, n_gauss_points+1, n_gauss_points);</div></div><!-- fragment --><p>but now we need to notify the info box of the finite element function we want to evaluate in the quadrature points. First, we create an <a class="el" href="classAnyData.html">AnyData</a> object with this vector, which is the solution we just computed.</p>
<div class="fragment"><div class="line"><a class="code" href="classAnyData.html">AnyData</a> solution_data;</div><div class="line">solution_data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>*&gt;(&amp;solution, <span class="stringliteral">&quot;solution&quot;</span>);</div></div><!-- fragment --><p>Then, we tell the Meshworker::VectorSelector for cells, that we need the second derivatives of this solution (to compute the Laplacian). Therefore, the Boolean arguments selecting function values and first derivatives a false, only the last one selecting second derivatives is true.</p>
<div class="fragment"><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#ac2d837236f8a481331a3b5fb9f28898d">cell_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div></div><!-- fragment --><p>On interior and boundary faces, we need the function values and the first derivatives, but not second derivatives.</p>
<div class="fragment"><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7d704e8c204409401eccbd3ffbade4e0">boundary_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aae8e0b03e68c8f78090033b22ae7c4f8">face_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p>And we continue as before, with the exception that the default update flags are already adjusted to the values and derivatives we requested above.</p>
<div class="fragment"><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aefd53d6be1d70953af6dca9090310d24">add_update_flags_boundary</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping, solution_data, solution);</div><div class="line"></div><div class="line"><a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div></div><!-- fragment --><p>The assembler stores one number per cell, but else this is the same as in the computation of the right hand side.</p>
<div class="fragment"><div class="line"><a class="code" href="classMeshWorker_1_1Assembler_1_1CellsAndFaces.html">MeshWorker::Assembler::CellsAndFaces&lt;double&gt;</a> assembler;</div><div class="line"><a class="code" href="classAnyData.html">AnyData</a> out_data;</div><div class="line">out_data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>*&gt;(&amp;estimates, <span class="stringliteral">&quot;cells&quot;</span>);</div><div class="line">assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1CellsAndFaces.html#a79b368b14edd85f14b30e8efad299279">initialize</a>(out_data, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">Estimator&lt;dim&gt; integrator;</div><div class="line">MeshWorker::integration_loop&lt;dim, dim&gt; (</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">  dof_info, info_box,</div><div class="line">  integrator, assembler);</div></div><!-- fragment --><p>Right before we return the result of the error estimate, we restore the old user indices.</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a12a2359968a027a8b14ae381c8886d30">load_user_indices</a>(old_user_indices);</div><div class="line">  <span class="keywordflow">return</span> estimates.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0).l2_norm();</div><div class="line">}</div></div><!-- fragment --><p>Here we compare our finite element solution with the (known) exact solution and compute the mean quadratic error of the gradient and the function itself. This function is a clone of the estimation function right above.</p>
<p>Since we compute the error in the energy and the <em>L<sup>2</sup></em>-norm, respectively, our block vector needs two blocks here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">InteriorPenaltyProblem&lt;dim&gt;::error()</div><div class="line">{</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> errors(2);</div><div class="line">  errors.block(0).reinit(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  errors.block(1).reinit(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">       cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell,++i)</div><div class="line">    cell-&gt;set_user_index(i);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a>()+1;</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a2ccc96521da795a762213a979c581138">initialize_gauss_quadrature</a>(n_gauss_points, n_gauss_points+1, n_gauss_points);</div><div class="line"></div><div class="line">  <a class="code" href="classAnyData.html">AnyData</a> solution_data;</div><div class="line">  solution_data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>*&gt;(&amp;solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#ac2d837236f8a481331a3b5fb9f28898d">cell_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7d704e8c204409401eccbd3ffbade4e0">boundary_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aae8e0b03e68c8f78090033b22ae7c4f8">face_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aae049a9cef81c6fcd743c3681e53d008">add_update_flags_cell</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aefd53d6be1d70953af6dca9090310d24">add_update_flags_boundary</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping, solution_data, solution);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1Assembler_1_1CellsAndFaces.html">MeshWorker::Assembler::CellsAndFaces&lt;double&gt;</a> assembler;</div><div class="line">  <a class="code" href="classAnyData.html">AnyData</a> out_data;</div><div class="line">  out_data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>* &gt;(&amp;errors, <span class="stringliteral">&quot;cells&quot;</span>);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1CellsAndFaces.html#a79b368b14edd85f14b30e8efad299279">initialize</a>(out_data, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  ErrorIntegrator&lt;dim&gt; integrator;</div><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt; (</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">    dof_info, info_box,</div><div class="line">    integrator, assembler);</div><div class="line"></div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;energy-error: &quot;</span> &lt;&lt; errors.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0).l2_norm() &lt;&lt; std::endl;</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;L2-error:     &quot;</span> &lt;&lt; errors.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).l2_norm() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Create graphical output. We produce the filename by collating the name from its various components, including the refinement cycle that we output with two digits.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> InteriorPenaltyProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;sol-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle,2) +</div><div class="line">                               <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line"></div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;...&quot;</span></div><div class="line">          &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">  std::ofstream gnuplot_output (filename.c_str());</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.add_data_vector (solution, <span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">  data_out.add_data_vector (estimates.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), <span class="stringliteral">&quot;est&quot;</span>);</div><div class="line"></div><div class="line">  data_out.build_patches ();</div><div class="line"></div><div class="line">  data_out.write_gnuplot(gnuplot_output);</div><div class="line">}</div></div><!-- fragment --><p>And finally the adaptive loop, more or less like in previous examples.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::run(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps)</div><div class="line">  {</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Element: &quot;</span> &lt;&lt; fe.get_name() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s&lt;n_steps; ++s)</div><div class="line">      {</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Step &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">if</span> (estimates.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0).size() == 0)</div><div class="line">          triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridRefinement.html#a40f710b99d29b38baa84400c945baa3c">GridRefinement::refine_and_coarsen_fixed_fraction</a> (triangulation,</div><div class="line">                                                               estimates.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0),</div><div class="line">                                                               0.5, 0.0);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">          }</div><div class="line"></div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Triangulation &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; cells, &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;DoFHandler &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; <span class="stringliteral">&quot; dofs, level dofs&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">          deallog &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(l);</div><div class="line">        deallog &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Assemble matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_matrix();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Assemble multilevel matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_mg_matrix();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_right_hand_side();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Solve&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line">        error();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Estimate &quot;</span> &lt;&lt; estimate() &lt;&lt; std::endl;</div><div class="line">        output_results(s);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step39;</div><div class="line"></div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line">      std::ofstream logfile(<span class="stringliteral">&quot;deallog&quot;</span>);</div><div class="line">      deallog.<a class="code" href="classLogStream.html#ac074d18eeb2a4c6a3b3a8b742c2a15ca">attach</a>(logfile);</div><div class="line">      <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;2&gt;</a> fe1(3);</div><div class="line">      InteriorPenaltyProblem&lt;2&gt; test1(fe1);</div><div class="line">      test1.run(12);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Logfileoutput"></a></p><h2>Logfile output</h2>
<p>First, the program produces the usual logfile here stored in <code>deallog</code>. It reads (with omission of intermediate steps)</p>
<div class="fragment"><div class="line">DEAL::Element: <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;2&gt;</a>(3)</div><div class="line">DEAL::Step 0</div><div class="line">DEAL::Triangulation 4 cells, 1 levels</div><div class="line">DEAL::DoFHandler 64 dofs, level dofs 64</div><div class="line">DEAL::Assemble matrix</div><div class="line">DEAL::Assemble multilevel matrix</div><div class="line">DEAL::Assemble right hand side</div><div class="line">DEAL::Solve</div><div class="line">DEAL:cg::Starting value 27.1275</div><div class="line">DEAL:cg::Convergence step 1 value 1.97998e-14</div><div class="line">DEAL::Error    0.161172</div><div class="line">DEAL::Estimate 1.35839</div><div class="line">DEAL::Writing solution to &lt;sol-00.gnuplot&gt;...</div><div class="line">DEAL::</div><div class="line">DEAL::Step 1</div><div class="line">DEAL::Triangulation 10 cells, 2 levels</div><div class="line">DEAL::DoFHandler 160 dofs, level dofs 64 128</div><div class="line">DEAL::Assemble matrix</div><div class="line">DEAL::Assemble multilevel matrix</div><div class="line">DEAL::Assemble right hand side</div><div class="line">DEAL::Solve</div><div class="line">DEAL:cg::Starting value 35.5356</div><div class="line">DEAL:cg::Convergence step 14 value 3.21479e-13</div><div class="line">DEAL::Error    0.164760</div><div class="line">DEAL::Estimate 1.08528</div><div class="line">DEAL::Writing solution to &lt;sol-01.gnuplot&gt;...</div><div class="line">DEAL::</div><div class="line">DEAL::Step 2</div><div class="line">DEAL::Triangulation 16 cells, 2 levels</div><div class="line">DEAL::DoFHandler 256 dofs, level dofs 64 256</div><div class="line">DEAL::Assemble matrix</div><div class="line">DEAL::Assemble multilevel matrix</div><div class="line">DEAL::Assemble right hand side</div><div class="line">DEAL::Solve</div><div class="line">DEAL:cg::Starting value 37.0552</div><div class="line">DEAL:cg::Convergence step 14 value 6.05416e-13</div><div class="line">DEAL::Error    0.113503</div><div class="line">DEAL::Estimate 0.990460</div><div class="line">DEAL::Writing solution to &lt;sol-02.gnuplot&gt;...</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">DEAL::Step 10</div><div class="line">DEAL::Triangulation 124 cells, 9 levels</div><div class="line">DEAL::DoFHandler 1984 dofs, level dofs 64 256 512 512 256 256 256 256 256</div><div class="line">DEAL::Assemble matrix</div><div class="line">DEAL::Assemble multilevel matrix</div><div class="line">DEAL::Assemble right hand side</div><div class="line">DEAL::Solve</div><div class="line">DEAL:cg::Starting value 38.5798</div><div class="line">DEAL:cg::Convergence step 17 value 2.64999e-13</div><div class="line">DEAL::Error    0.0101278</div><div class="line">DEAL::Estimate 0.0957571</div><div class="line">DEAL::Writing solution to &lt;sol-10.gnuplot&gt;...</div><div class="line">DEAL::</div><div class="line">DEAL::Step 11</div><div class="line">DEAL::Triangulation 163 cells, 10 levels</div><div class="line">DEAL::DoFHandler 2608 dofs, level dofs 64 256 768 576 512 256 256 256 256 256</div><div class="line">DEAL::Assemble matrix</div><div class="line">DEAL::Assemble multilevel matrix</div><div class="line">DEAL::Assemble right hand side</div><div class="line">DEAL::Solve</div><div class="line">DEAL:cg::Starting value 44.1721</div><div class="line">DEAL:cg::Convergence step 17 value 3.18657e-13</div><div class="line">DEAL::Error    0.00716962</div><div class="line">DEAL::Estimate 0.0681646</div><div class="line">DEAL::Writing solution to &lt;sol-11.gnuplot&gt;...</div><div class="line">DEAL::</div></div><!-- fragment --><p>This log for instance shows that the number of conjugate gradient iteration steps is constant at approximately 17.</p>
<p><a class="anchor" id="Postprocessingofthelogfile"></a></p><h2>Postprocessing of the logfile</h2>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-39-convergence.png"/>
</div>
<p> Using the perl script <code>postprocess.pl</code>, we extract relevant data into <code>output.dat</code>, which can be used to plot graphs with <code>gnuplot</code>. The graph above for instance was produced with</p>
<div class="fragment"><div class="line"><span class="keyword">set</span> style data linespoints</div><div class="line"><span class="keyword">set</span> logscale</div><div class="line"><span class="keyword">set</span> xrange [50:3000]</div><div class="line">plot <span class="stringliteral">&quot;output.dat&quot;</span> <span class="keyword">using</span> 2:3 title <span class="stringliteral">&quot;error&quot;</span>, <span class="stringliteral">&quot;&quot;</span> <span class="keyword">using</span> 2:4 title <span class="stringliteral">&quot;estimate&quot;</span>, \</div><div class="line">     <span class="stringliteral">&quot;&quot;</span> <span class="keyword">using</span> 2:(3000*@f$2**-1.5) title <span class="stringliteral">&quot;3rd order&quot;</span></div></div><!-- fragment --><p> <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2010 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Guido Kanschat, Texas A&amp;M University, 2009</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition_block.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgp.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/dof_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/integration_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/assembler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/loop.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/integrators/laplace.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/multigrid.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_transfer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_coarse.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_smoother.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step39</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFunctions_1_1SlitSingularityFunction.html">Functions::SlitSingularityFunction&lt;2&gt;</a> exact_solution;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MatrixIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> cell(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> boundary(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">                  <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> face(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">              <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MatrixIntegrator&lt;dim&gt;::cell(</div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">false</span>).matrix, info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MatrixIntegrator&lt;dim&gt;::boundary(</div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).get_fe().tensor_degree();</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#af88167a13d65d1367d093a798a847263">LocalIntegrators::Laplace::nitsche_matrix</a>(</div><div class="line">      dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">false</span>).matrix, info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#aa920ce4642983b9cb2fbf996b75d3c52">LocalIntegrators::Laplace::compute_penalty</a>(dinfo, dinfo, deg, deg));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MatrixIntegrator&lt;dim&gt;::face(</div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).get_fe().tensor_degree();</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#acf43744b2ca29cbf871cf63054bd3436">LocalIntegrators::Laplace::ip_matrix</a>(</div><div class="line">      dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">false</span>).matrix, dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">true</span>).matrix,</div><div class="line">      dinfo2.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">true</span>).matrix, dinfo2.<a class="code" href="classMeshWorker_1_1LocalResults.html#afdae422206740b2f5a14fd562c27e6ca">matrix</a>(0,<span class="keyword">false</span>).matrix,</div><div class="line">      info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0), info2.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#aa920ce4642983b9cb2fbf996b75d3c52">LocalIntegrators::Laplace::compute_penalty</a>(dinfo1, dinfo2, deg, deg));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RHSIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> cell(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> boundary(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> face(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">              <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RHSIntegrator&lt;dim&gt;::cell(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RHSIntegrator&lt;dim&gt;::boundary(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;local_vector = dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#af80df9fc19df1713b3d41690f9c71527">vector</a>(0).block(0);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; boundary_values(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">    exact_solution.<a class="code" href="classFunctions_1_1SlitSingularityFunction.html#aab24543bcf43a9536c552a1fc8f156fa">value_list</a>(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = 2. * deg * (deg+1) * dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">        local_vector(i) += (- fe.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,k) * penalty * boundary_values[k]</div><div class="line">                            + (fe.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(k) * fe.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,k)) * boundary_values[k])</div><div class="line">                           * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RHSIntegrator&lt;dim&gt;::face(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;,</div><div class="line">                                <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;,</div><div class="line">                                <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;,</div><div class="line">                                <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Estimator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> cell(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> boundary(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> face(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">              <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Estimator&lt;dim&gt;::cell(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;2,dim&gt; &gt; &amp;DDuh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a1a8ad93d124bf3e0d3ed03863c08def6">hessians</a>[0][0];</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> t = dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;diameter() * trace(DDuh[k]);</div><div class="line">        dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) +=  t*t * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">      }</div><div class="line">    dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Estimator&lt;dim&gt;::boundary(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; boundary_values(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">    exact_solution.<a class="code" href="classFunctions_1_1SlitSingularityFunction.html#aab24543bcf43a9536c552a1fc8f156fa">value_list</a>(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = 2. * deg * (deg+1) * dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">      dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) += penalty * (boundary_values[k] - uh[k]) * (boundary_values[k] - uh[k])</div><div class="line">                        * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">    dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Estimator&lt;dim&gt;::face(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">                            <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">                            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">                            <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh1 = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh2 = info2.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;Duh1 = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#abf4e7bf5672c085b36dbcedc1918d2f4">gradients</a>[0][0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;Duh2 = info2.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#abf4e7bf5672c085b36dbcedc1918d2f4">gradients</a>[0][0];</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty1 = deg * (deg+1) * dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty2 = deg * (deg+1) * dinfo2.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo2.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = penalty1 + penalty2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h = dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> diff1 = uh1[k] - uh2[k];</div><div class="line">        <span class="keywordtype">double</span> diff2 = fe.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(k) * Duh1[k] - fe.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(k) * Duh2[k];</div><div class="line">        dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) += (penalty * diff1*diff1 + h * diff2*diff2)</div><div class="line">                           * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">      }</div><div class="line">    dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">    dinfo2.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ErrorIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> cell(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> boundary(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo, <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> face(<a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">              <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">              <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ErrorIntegrator&lt;dim&gt;::cell(</div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt; exact_gradients(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">    std::vector&lt;double&gt; exact_values(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">    exact_solution.gradient_list(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), exact_gradients);</div><div class="line">    exact_solution.<a class="code" href="classFunctions_1_1SlitSingularityFunction.html#aab24543bcf43a9536c552a1fc8f156fa">value_list</a>(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), exact_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;Duh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#abf4e7bf5672c085b36dbcedc1918d2f4">gradients</a>[0][0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> sum = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> diff = exact_gradients[k][d] - Duh[k][d];</div><div class="line">            sum += diff*diff;</div><div class="line">          }</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> diff = exact_values[k] - uh[k];</div><div class="line">        dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) +=  sum * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">        dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(1) +=  diff*diff * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">      }</div><div class="line">    dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">    dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(1) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ErrorIntegrator&lt;dim&gt;::boundary(</div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; exact_values(fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">    exact_solution.<a class="code" href="classFunctions_1_1SlitSingularityFunction.html#aab24543bcf43a9536c552a1fc8f156fa">value_list</a>(fe.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), exact_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh = info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = 2. * deg * (deg+1) * dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> diff = exact_values[k] - uh[k];</div><div class="line">        dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) += penalty * diff * diff * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">      }</div><div class="line">    dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ErrorIntegrator&lt;dim&gt;::face(</div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo1,</div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> &amp;dinfo2,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info1,</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info2)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh1 = info1.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;uh2 = info2.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#afb909cb1bef4fa870b7cc10f3fe6da49">values</a>[0][0];</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg = fe.<a class="code" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a>().tensor_degree();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty1 = deg * (deg+1) * dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo1.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty2 = deg * (deg+1) * dinfo2.<a class="code" href="classMeshWorker_1_1DoFInfo.html#abe132f9c608609ab4cd529548b3fc8f5">face</a>-&gt;measure() / dinfo2.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;measure();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = penalty1 + penalty2;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k=0; k&lt;fe.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> diff = uh1[k] - uh2[k];</div><div class="line">        dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) += (penalty * diff*diff)</div><div class="line">                           * fe.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(k);</div><div class="line">      }</div><div class="line">    dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = std::sqrt(dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0));</div><div class="line">    dinfo2.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0) = dinfo1.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac0364286d1e6e15977806b99083c6d63">value</a>(0);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InteriorPenaltyProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> CellInfo;</div><div class="line"></div><div class="line">    InteriorPenaltyProblem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_matrix ();</div><div class="line">    <span class="keywordtype">void</span> assemble_mg_matrix ();</div><div class="line">    <span class="keywordtype">void</span> assemble_right_hand_side ();</div><div class="line">    <span class="keywordtype">void</span> error ();</div><div class="line">    <span class="keywordtype">double</span> estimate ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        triangulation;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>      mapping;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       right_hand_side;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>  estimates;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_dg_interface;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_matrix_dg_down;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a> &gt; mg_matrix_dg_up;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::InteriorPenaltyProblem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe)</div><div class="line">    :</div><div class="line">    triangulation (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices),</div><div class="line">    mapping(),</div><div class="line">    fe(fe),</div><div class="line">    dof_handler(triangulation),</div><div class="line">    estimates(1)</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a5114625911496e4f51758fe00562a14a">GridGenerator::hyper_cube_slit</a>(triangulation, -1, 1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#aef4dba3640a019e25c5742e067d7986e">distribute_mg_dofs</a>(fe);</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs = dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(n_dofs);</div><div class="line">    right_hand_side.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(n_dofs);</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity.copy_from(dsp);</div><div class="line">    matrix.reinit(sparsity);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>();</div><div class="line">    mg_matrix.resize(0, n_levels-1);</div><div class="line">    mg_matrix.clear_elements();</div><div class="line">    mg_matrix_dg_up.resize(0, n_levels-1);</div><div class="line">    mg_matrix_dg_up.clear_elements();</div><div class="line">    mg_matrix_dg_down.resize(0, n_levels-1);</div><div class="line">    mg_matrix_dg_down.clear_elements();</div><div class="line">    mg_sparsity.resize(0, n_levels-1);</div><div class="line">    mg_sparsity_dg_interface.resize(0, n_levels-1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=mg_sparsity.min_level();</div><div class="line">         level&lt;=mg_sparsity.max_level(); ++level)</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a1a1273930a0c3cd4a537063b26a2a95f">MGTools::make_flux_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line">        mg_sparsity[level].copy_from(dsp);</div><div class="line">        mg_matrix[level].reinit(mg_sparsity[level]);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (level&gt;0)</div><div class="line">          {</div><div class="line">            <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp;</div><div class="line">            dsp.<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level-1), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">            <a class="code" href="namespaceMGTools.html#aa242701df963b91f9139020fe79b1196">MGTools::make_flux_sparsity_pattern_edge</a>(dof_handler, dsp, level);</div><div class="line">            mg_sparsity_dg_interface[level].copy_from(dsp);</div><div class="line">            mg_matrix_dg_up[level].reinit(mg_sparsity_dg_interface[level]);</div><div class="line">            mg_matrix_dg_down[level].reinit(mg_sparsity_dg_interface[level]);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::assemble_matrix()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1MatrixSimple.html">MeshWorker::Assembler::MatrixSimple&lt;SparseMatrix&lt;double&gt;</a> &gt; assembler;</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MatrixSimple.html#a16aa7c79a160c3f8531fe77531965df6">initialize</a>(matrix);</div><div class="line"></div><div class="line">    MatrixIntegrator&lt;dim&gt; integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt;(</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">      dof_info, info_box,</div><div class="line">      integrator, assembler);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::assemble_mg_matrix()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html">MeshWorker::Assembler::MGMatrixSimple&lt;SparseMatrix&lt;double&gt;</a> &gt; assembler;</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_matrix);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#a1fce17a3ff22b59c0f023fd9a58e43f6">initialize_fluxes</a>(mg_matrix_dg_up, mg_matrix_dg_down);</div><div class="line"></div><div class="line">    MatrixIntegrator&lt;dim&gt; integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt; (</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">      dof_info, info_box,</div><div class="line">      integrator, assembler);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::assemble_right_hand_side()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1ResidualSimple.html">MeshWorker::Assembler::ResidualSimple&lt;Vector&lt;double&gt;</a> &gt; assembler;</div><div class="line">    <a class="code" href="classAnyData.html">AnyData</a> data;</div><div class="line">    data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>*&gt;(&amp;right_hand_side, <span class="stringliteral">&quot;RHS&quot;</span>);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1ResidualSimple.html#affc8d054d00d3838c2ab8d8adbd5ccb5">initialize</a>(data);</div><div class="line"></div><div class="line">    RHSIntegrator&lt;dim&gt; integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt;(</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">      dof_info, info_box,</div><div class="line">      integrator, assembler);</div><div class="line"></div><div class="line">    right_hand_side *= -1.;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> control(1000, 1.e-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a> &gt; solver(control);</div><div class="line"></div><div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; mg_transfer;</div><div class="line">    mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a2302c0b6ee91b59d006b21c7d3f00025">build_matrices</a>(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a> (mg_matrix[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a> &gt; mg_coarse;</div><div class="line">    mg_coarse.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    <a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;Vector&lt;double&gt;</a> &gt; mem;</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; RELAXATION;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;RELAXATION, Vector&lt;double&gt;</a> &gt;</div><div class="line">    mg_smoother;</div><div class="line">    RELAXATION::AdditionalData smoother_data(1.);</div><div class="line">    mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrix, smoother_data);</div><div class="line"></div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#ae35e1ca776c5e1ce40149510e2207f36">set_variable</a>(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a> &gt; mgmatrix(mg_matrix);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a> &gt; mgdown(mg_matrix_dg_down);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a> &gt; mgup(mg_matrix_dg_up);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a> &gt; <a class="code" href="namespacemg.html">mg</a>(mgmatrix,</div><div class="line">                                  mg_coarse, mg_transfer,</div><div class="line">                                  mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_flux_matrices(mgdown, mgup);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>,</div><div class="line">                   <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a> &gt; &gt;</div><div class="line">                   preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line">    solver.solve(matrix, solution, right_hand_side, preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::estimate()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; old_user_indices;</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices</a>(old_user_indices);</div><div class="line"></div><div class="line">    estimates.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0).reinit(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">         cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell,++i)</div><div class="line">      cell-&gt;set_user_index(i);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a>()+1;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a2ccc96521da795a762213a979c581138">initialize_gauss_quadrature</a>(n_gauss_points, n_gauss_points+1, n_gauss_points);</div><div class="line"></div><div class="line">    <a class="code" href="classAnyData.html">AnyData</a> solution_data;</div><div class="line">    solution_data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a>*&gt;(&amp;solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#ac2d837236f8a481331a3b5fb9f28898d">cell_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7d704e8c204409401eccbd3ffbade4e0">boundary_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aae8e0b03e68c8f78090033b22ae7c4f8">face_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aefd53d6be1d70953af6dca9090310d24">add_update_flags_boundary</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping, solution_data, solution);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1CellsAndFaces.html">MeshWorker::Assembler::CellsAndFaces&lt;double&gt;</a> assembler;</div><div class="line">    <a class="code" href="classAnyData.html">AnyData</a> out_data;</div><div class="line">    out_data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>*&gt;(&amp;estimates, <span class="stringliteral">&quot;cells&quot;</span>);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1CellsAndFaces.html#a79b368b14edd85f14b30e8efad299279">initialize</a>(out_data, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    Estimator&lt;dim&gt; integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt; (</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">      dof_info, info_box,</div><div class="line">      integrator, assembler);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a12a2359968a027a8b14ae381c8886d30">load_user_indices</a>(old_user_indices);</div><div class="line">    <span class="keywordflow">return</span> estimates.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0).l2_norm();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::error()</div><div class="line">  {</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> errors(2);</div><div class="line">    errors.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0).reinit(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    errors.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).reinit(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">         cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell,++i)</div><div class="line">      cell-&gt;set_user_index(i);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a>()+1;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a2ccc96521da795a762213a979c581138">initialize_gauss_quadrature</a>(n_gauss_points, n_gauss_points+1, n_gauss_points);</div><div class="line"></div><div class="line">    <a class="code" href="classAnyData.html">AnyData</a> solution_data;</div><div class="line">    solution_data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>*&gt;(&amp;solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#ac2d837236f8a481331a3b5fb9f28898d">cell_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7d704e8c204409401eccbd3ffbade4e0">boundary_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aae8e0b03e68c8f78090033b22ae7c4f8">face_selector</a>.<a class="code" href="classMeshWorker_1_1VectorSelector.html#aef1fc2a6ae5d2f756a72e8d2557972a8">add</a>(<span class="stringliteral">&quot;solution&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aae049a9cef81c6fcd743c3681e53d008">add_update_flags_cell</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#aefd53d6be1d70953af6dca9090310d24">add_update_flags_boundary</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping, solution_data, solution);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1CellsAndFaces.html">MeshWorker::Assembler::CellsAndFaces&lt;double&gt;</a> assembler;</div><div class="line">    <a class="code" href="classAnyData.html">AnyData</a> out_data;</div><div class="line">    out_data.<a class="code" href="classAnyData.html#a5949f684f8ce7ccce9d45e65af32580c">add</a>&lt;<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>* &gt;(&amp;errors, <span class="stringliteral">&quot;cells&quot;</span>);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1CellsAndFaces.html#a79b368b14edd85f14b30e8efad299279">initialize</a>(out_data, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    ErrorIntegrator&lt;dim&gt; integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt; (</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">      dof_info, info_box,</div><div class="line">      integrator, assembler);</div><div class="line"></div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;energy-error: &quot;</span> &lt;&lt; errors.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0).l2_norm() &lt;&lt; std::endl;</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;L2-error:     &quot;</span> &lt;&lt; errors.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).l2_norm() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> InteriorPenaltyProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;sol-&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle,2) +</div><div class="line">                                 <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line"></div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;...&quot;</span></div><div class="line">            &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">    std::ofstream gnuplot_output (filename.c_str());</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.add_data_vector (solution, <span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">    data_out.add_data_vector (estimates.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), <span class="stringliteral">&quot;est&quot;</span>);</div><div class="line"></div><div class="line">    data_out.build_patches ();</div><div class="line"></div><div class="line">    data_out.write_gnuplot(gnuplot_output);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  InteriorPenaltyProblem&lt;dim&gt;::run(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps)</div><div class="line">  {</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Element: &quot;</span> &lt;&lt; fe.get_name() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0; s&lt;n_steps; ++s)</div><div class="line">      {</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Step &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">if</span> (estimates.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0).size() == 0)</div><div class="line">          triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridRefinement.html#a40f710b99d29b38baa84400c945baa3c">GridRefinement::refine_and_coarsen_fixed_fraction</a> (triangulation,</div><div class="line">                                                               estimates.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0),</div><div class="line">                                                               0.5, 0.0);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">          }</div><div class="line"></div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Triangulation &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; cells, &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;DoFHandler &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; <span class="stringliteral">&quot; dofs, level dofs&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">          deallog &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(l);</div><div class="line">        deallog &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Assemble matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_matrix();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Assemble multilevel matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_mg_matrix();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_right_hand_side();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Solve&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line">        error();</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Estimate &quot;</span> &lt;&lt; estimate() &lt;&lt; std::endl;</div><div class="line">        output_results(s);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step39;</div><div class="line"></div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line">      std::ofstream logfile(<span class="stringliteral">&quot;deallog&quot;</span>);</div><div class="line">      deallog.<a class="code" href="classLogStream.html#ac074d18eeb2a4c6a3b3a8b742c2a15ca">attach</a>(logfile);</div><div class="line">      <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;2&gt;</a> fe1(3);</div><div class="line">      InteriorPenaltyProblem&lt;2&gt; test1(fe1);</div><div class="line">      test1.run(12);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
