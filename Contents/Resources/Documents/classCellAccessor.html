<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: CellAccessor&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classCellAccessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CellAccessor&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a><a class="el" href="group__grid.html">Grid classes</a> &raquo; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> &raquo;  &#124; <a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tria__accessor_8h_source.html">deal.II/grid/tria_accessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CellAccessor&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCellAccessor__inherit__graph.svg" width="936" height="84"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a821bacffe6e9828642c83cf2b2baf13e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a821bacffe6e9828642c83cf2b2baf13e">AccessorData</a></td></tr>
<tr class="separator:a821bacffe6e9828642c83cf2b2baf13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014f2d38d74b3c488440ec17637f7abc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a014f2d38d74b3c488440ec17637f7abc">Container</a></td></tr>
<tr class="separator:a014f2d38d74b3c488440ec17637f7abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classTriaAccessor"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classTriaAccessor')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classTriaAccessor.html">TriaAccessor&lt; dim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:ae36ecc7bf941b520c8820fece0ed2afd inherit pub_types_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae36ecc7bf941b520c8820fece0ed2afd">AccessorData</a></td></tr>
<tr class="separator:ae36ecc7bf941b520c8820fece0ed2afd inherit pub_types_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a2d282e19d1d72abc52bb3bfddf551f30 inherit pub_types_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a2d282e19d1d72abc52bb3bfddf551f30">LocalData</a></td></tr>
<tr class="separator:a2d282e19d1d72abc52bb3bfddf551f30 inherit pub_types_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a026b9553c7d56c103147d3e9a6d9a0ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a026b9553c7d56c103147d3e9a6d9a0ed">CellAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *<a class="el" href="classCellAccessor.html#a027532e7f473fac2812a92e4066e29f5">parent</a>=nullptr, const int <a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a>=-1, const int <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a> *local_data=nullptr)</td></tr>
<tr class="separator:a026b9553c7d56c103147d3e9a6d9a0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3fbe765bc2a08b056175f8f52da568"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#acb3fbe765bc2a08b056175f8f52da568">CellAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt; &amp;cell_accessor)</td></tr>
<tr class="separator:acb3fbe765bc2a08b056175f8f52da568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34931ab97b3e7c7da47388b30c36707"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:ab34931ab97b3e7c7da47388b30c36707"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab34931ab97b3e7c7da47388b30c36707">CellAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:ab34931ab97b3e7c7da47388b30c36707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdfe299bf81ce75210d54e3f47684fb"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:aecdfe299bf81ce75210d54e3f47684fb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aecdfe299bf81ce75210d54e3f47684fb">CellAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:aecdfe299bf81ce75210d54e3f47684fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing sub-objects and neighbors</div></td></tr>
<tr class="memitem:abacf4d5819d5f9e96d0e597cd92ce41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abacf4d5819d5f9e96d0e597cd92ce41e">child</a> (const unsigned int i) const</td></tr>
<tr class="separator:abacf4d5819d5f9e96d0e597cd92ce41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbd3c4ad4199b251691162f6bacaff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim-1, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a1bbd3c4ad4199b251691162f6bacaff8">face</a> (const unsigned int i) const</td></tr>
<tr class="separator:a1bbd3c4ad4199b251691162f6bacaff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393ecccb4d12de31be253b60740befe9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a393ecccb4d12de31be253b60740befe9">face_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:a393ecccb4d12de31be253b60740befe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54844a9be3a35e62aaabc8d43ad1f8b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a54844a9be3a35e62aaabc8d43ad1f8b8">neighbor_child_on_subface</a> (const unsigned int face_no, const unsigned int subface_no) const</td></tr>
<tr class="separator:a54844a9be3a35e62aaabc8d43ad1f8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f316701ed0595b5dbb8033024e378f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae3f316701ed0595b5dbb8033024e378f">neighbor</a> (const unsigned int i) const</td></tr>
<tr class="separator:ae3f316701ed0595b5dbb8033024e378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace11c052823b53f0ee5566696c3fcdab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ace11c052823b53f0ee5566696c3fcdab">neighbor_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:ace11c052823b53f0ee5566696c3fcdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99179c09d5c58f6c62c6aceaecbe3ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae99179c09d5c58f6c62c6aceaecbe3ca">neighbor_level</a> (const unsigned int i) const</td></tr>
<tr class="separator:ae99179c09d5c58f6c62c6aceaecbe3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab264cec6e84153df51c1108a518c49fb"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab264cec6e84153df51c1108a518c49fb">neighbor_of_neighbor</a> (const unsigned int <a class="el" href="classCellAccessor.html#ae3f316701ed0595b5dbb8033024e378f">neighbor</a>) const</td></tr>
<tr class="separator:ab264cec6e84153df51c1108a518c49fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14bba7dcdb9957770752910daef243f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa14bba7dcdb9957770752910daef243f">neighbor_is_coarser</a> (const unsigned int <a class="el" href="classCellAccessor.html#ae3f316701ed0595b5dbb8033024e378f">neighbor</a>) const</td></tr>
<tr class="separator:aa14bba7dcdb9957770752910daef243f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653454d4633329469aaea5a27d61e2de"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a653454d4633329469aaea5a27d61e2de">neighbor_of_coarser_neighbor</a> (const unsigned int <a class="el" href="classCellAccessor.html#ae3f316701ed0595b5dbb8033024e378f">neighbor</a>) const</td></tr>
<tr class="separator:a653454d4633329469aaea5a27d61e2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e8dae65320c8d718b6fc88394293d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a036e8dae65320c8d718b6fc88394293d">neighbor_face_no</a> (const unsigned int <a class="el" href="classCellAccessor.html#ae3f316701ed0595b5dbb8033024e378f">neighbor</a>) const</td></tr>
<tr class="separator:a036e8dae65320c8d718b6fc88394293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with periodic neighbors</div></td></tr>
<tr class="memitem:a5b60dfb7926e4a9d39c2208b0f86b256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5b60dfb7926e4a9d39c2208b0f86b256">has_periodic_neighbor</a> (const unsigned int i) const</td></tr>
<tr class="separator:a5b60dfb7926e4a9d39c2208b0f86b256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b7281609d7b0b1a5f436515c385964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a12b7281609d7b0b1a5f436515c385964">periodic_neighbor</a> (const unsigned int i) const</td></tr>
<tr class="separator:a12b7281609d7b0b1a5f436515c385964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cbc0468b12ad483b1cb395bc625a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af2cbc0468b12ad483b1cb395bc625a61">neighbor_or_periodic_neighbor</a> (const unsigned int i) const</td></tr>
<tr class="separator:af2cbc0468b12ad483b1cb395bc625a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3395f4ebb63aa30e1a0aac7fdbb5953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa3395f4ebb63aa30e1a0aac7fdbb5953">periodic_neighbor_child_on_subface</a> (const unsigned int face_no, const unsigned int subface_no) const</td></tr>
<tr class="separator:aa3395f4ebb63aa30e1a0aac7fdbb5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98496895de96d67cea5392c3aade826"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ac98496895de96d67cea5392c3aade826">periodic_neighbor_of_coarser_periodic_neighbor</a> (const unsigned face_no) const</td></tr>
<tr class="separator:ac98496895de96d67cea5392c3aade826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c3888e028fcfafd86b1eef59e73505"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab1c3888e028fcfafd86b1eef59e73505">periodic_neighbor_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:ab1c3888e028fcfafd86b1eef59e73505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fa397b3b27f4cda613208d127f0a98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a64fa397b3b27f4cda613208d127f0a98">periodic_neighbor_level</a> (const unsigned int i) const</td></tr>
<tr class="separator:a64fa397b3b27f4cda613208d127f0a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92a480d8d1b269b21d95c7cc3c0a033"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af92a480d8d1b269b21d95c7cc3c0a033">periodic_neighbor_of_periodic_neighbor</a> (const unsigned int i) const</td></tr>
<tr class="separator:af92a480d8d1b269b21d95c7cc3c0a033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdf47567f70bac8826dcd7e5782f968"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#afbdf47567f70bac8826dcd7e5782f968">periodic_neighbor_face_no</a> (const unsigned int i) const</td></tr>
<tr class="separator:afbdf47567f70bac8826dcd7e5782f968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab737948031be71ea02495126a177ed8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab737948031be71ea02495126a177ed8a">periodic_neighbor_is_coarser</a> (const unsigned int i) const</td></tr>
<tr class="separator:ab737948031be71ea02495126a177ed8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with boundary indicators</div></td></tr>
<tr class="memitem:a4b683043741a1167de1ab9dbda0e54f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a4b683043741a1167de1ab9dbda0e54f7">at_boundary</a> (const unsigned int i) const</td></tr>
<tr class="separator:a4b683043741a1167de1ab9dbda0e54f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4c08cb6a4ced3f610d9789d02ad202"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ace4c08cb6a4ced3f610d9789d02ad202">at_boundary</a> () const</td></tr>
<tr class="separator:ace4c08cb6a4ced3f610d9789d02ad202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fee6d28c03cd3ba90263ecb0e268b3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9fee6d28c03cd3ba90263ecb0e268b3a">has_boundary_lines</a> () const</td></tr>
<tr class="separator:a9fee6d28c03cd3ba90263ecb0e268b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with refinement indicators</div></td></tr>
<tr class="memitem:a902048fc67583f356fd3278a7d2aa8de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a902048fc67583f356fd3278a7d2aa8de">refine_flag_set</a> () const</td></tr>
<tr class="separator:a902048fc67583f356fd3278a7d2aa8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8359d5342b4ae7ae8b74fc3f4a1558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">set_refine_flag</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; ref_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a8c8359d5342b4ae7ae8b74fc3f4a1558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ccb325d746a81fa4a8542d698b89c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad5ccb325d746a81fa4a8542d698b89c7">clear_refine_flag</a> () const</td></tr>
<tr class="separator:ad5ccb325d746a81fa4a8542d698b89c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13778ea9fe696b3d59ed6c779dafc6c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a13778ea9fe696b3d59ed6c779dafc6c7">flag_for_face_refinement</a> (const unsigned int face_no, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim-1 &gt; &amp;face_refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim-1 &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a13778ea9fe696b3d59ed6c779dafc6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3fa84168f193c7877ff90b70bcee83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aeb3fa84168f193c7877ff90b70bcee83">flag_for_line_refinement</a> (const unsigned int line_no) const</td></tr>
<tr class="separator:aeb3fa84168f193c7877ff90b70bcee83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448d8dc9bdecab5a250ed5ecb899ded9"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a448d8dc9bdecab5a250ed5ecb899ded9">subface_case</a> (const unsigned int face_no) const</td></tr>
<tr class="separator:a448d8dc9bdecab5a250ed5ecb899ded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4910a26c4458ce0dd444e6b7bec2564"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae4910a26c4458ce0dd444e6b7bec2564">coarsen_flag_set</a> () const</td></tr>
<tr class="separator:ae4910a26c4458ce0dd444e6b7bec2564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de037c4860dcaceb4f9429b981b715e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a6de037c4860dcaceb4f9429b981b715e">set_coarsen_flag</a> () const</td></tr>
<tr class="separator:a6de037c4860dcaceb4f9429b981b715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fd137b13ff401f168ea0433cb18e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab9fd137b13ff401f168ea0433cb18e49">clear_coarsen_flag</a> () const</td></tr>
<tr class="separator:ab9fd137b13ff401f168ea0433cb18e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with material indicators</div></td></tr>
<tr class="memitem:ae4769702cd7ab67a61b25778ea3021b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae4769702cd7ab67a61b25778ea3021b2">material_id</a> () const</td></tr>
<tr class="separator:ae4769702cd7ab67a61b25778ea3021b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861d3679d23d3f4365f724c9cfe5fd77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a861d3679d23d3f4365f724c9cfe5fd77">set_material_id</a> (const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> new_material_id) const</td></tr>
<tr class="separator:a861d3679d23d3f4365f724c9cfe5fd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b49d85f8793f5a95d6c50797c07be2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2b49d85f8793f5a95d6c50797c07be2b">recursively_set_material_id</a> (const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> new_material_id) const</td></tr>
<tr class="separator:a2b49d85f8793f5a95d6c50797c07be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with subdomain indicators</div></td></tr>
<tr class="memitem:ae06835414c3c3f3359974f2c75a88033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae06835414c3c3f3359974f2c75a88033">subdomain_id</a> () const</td></tr>
<tr class="separator:ae06835414c3c3f3359974f2c75a88033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56098dab68574f96b42779d68c54269d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a56098dab68574f96b42779d68c54269d">set_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> new_subdomain_id) const</td></tr>
<tr class="separator:a56098dab68574f96b42779d68c54269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c84842b2847744da6e48fbcabf777ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id</a> () const</td></tr>
<tr class="separator:a2c84842b2847744da6e48fbcabf777ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfad9f24d9ddbc86883614639d4886d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2bfad9f24d9ddbc86883614639d4886d">set_level_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> new_level_subdomain_id) const</td></tr>
<tr class="separator:a2bfad9f24d9ddbc86883614639d4886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0108d0f1a0710c1e6d9b98f7cb2768fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0108d0f1a0710c1e6d9b98f7cb2768fa">recursively_set_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> new_subdomain_id) const</td></tr>
<tr class="separator:a0108d0f1a0710c1e6d9b98f7cb2768fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with codim 1 cell orientation</div></td></tr>
<tr class="memitem:ae146ea059e9c27cb3e040b92d5c4e152"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae146ea059e9c27cb3e040b92d5c4e152">direction_flag</a> () const</td></tr>
<tr class="separator:ae146ea059e9c27cb3e040b92d5c4e152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b8ec35236bea8ee91a72bbd19762fe"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">active_cell_index</a> () const</td></tr>
<tr class="separator:ad4b8ec35236bea8ee91a72bbd19762fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a594e870d1b725fed0c5231596709b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af7a594e870d1b725fed0c5231596709b">parent_index</a> () const</td></tr>
<tr class="separator:af7a594e870d1b725fed0c5231596709b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027532e7f473fac2812a92e4066e29f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a027532e7f473fac2812a92e4066e29f5">parent</a> () const</td></tr>
<tr class="separator:a027532e7f473fac2812a92e4066e29f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other functions</div></td></tr>
<tr class="memitem:a5f73f52e426005fba81e672ba9254a26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5f73f52e426005fba81e672ba9254a26">active</a> () const</td></tr>
<tr class="separator:a5f73f52e426005fba81e672ba9254a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a3ff6217f3b5b4537f6a101560f493"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a87a3ff6217f3b5b4537f6a101560f493">is_locally_owned</a> () const</td></tr>
<tr class="separator:a87a3ff6217f3b5b4537f6a101560f493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6b3c485d88ed58114d1b470bb3693f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9e6b3c485d88ed58114d1b470bb3693f">is_locally_owned_on_level</a> () const</td></tr>
<tr class="separator:a9e6b3c485d88ed58114d1b470bb3693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54375bf8f17e51501a4da7a2fac852ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a54375bf8f17e51501a4da7a2fac852ae">is_ghost</a> () const</td></tr>
<tr class="separator:a54375bf8f17e51501a4da7a2fac852ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef398493764dee787a796b436826847b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aef398493764dee787a796b436826847b">is_artificial</a> () const</td></tr>
<tr class="separator:aef398493764dee787a796b436826847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8a0465d3d7145513463b6a4a215fbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#adb8a0465d3d7145513463b6a4a215fbc">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:adb8a0465d3d7145513463b6a4a215fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155270eb9a66a7c366be5c8db4430acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a155270eb9a66a7c366be5c8db4430acb">set_neighbor</a> (const unsigned int i, const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; &amp;pointer) const</td></tr>
<tr class="separator:a155270eb9a66a7c366be5c8db4430acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7d5ec9cac8af95a136554501ea4f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellId.html">CellId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aee7d5ec9cac8af95a136554501ea4f0a">id</a> () const</td></tr>
<tr class="separator:aee7d5ec9cac8af95a136554501ea4f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classTriaAccessor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classTriaAccessor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classTriaAccessor.html">TriaAccessor&lt; dim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:adcbbfa481886d095df724cef84d92286 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#adcbbfa481886d095df724cef84d92286">TriaAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *parent=nullptr, const int <a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a>=-1, const int <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a> *local_data=nullptr)</td></tr>
<tr class="separator:adcbbfa481886d095df724cef84d92286 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf81fa90cc1506bbdf6a54fb0626985 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeaf81fa90cc1506bbdf6a54fb0626985">TriaAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:aeaf81fa90cc1506bbdf6a54fb0626985 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397500f10867aa69f4a731cc9ab2de53 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a397500f10867aa69f4a731cc9ab2de53">TriaAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:a397500f10867aa69f4a731cc9ab2de53 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0b77c3f3c1de1f604d456d0718efc0 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeb0b77c3f3c1de1f604d456d0718efc0">used</a> () const</td></tr>
<tr class="separator:aeb0b77c3f3c1de1f604d456d0718efc0 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b363d9cf3b6911d41223c9ed5d82daa inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1b363d9cf3b6911d41223c9ed5d82daa">extent_in_direction</a> (const unsigned int axis) const</td></tr>
<tr class="separator:a1b363d9cf3b6911d41223c9ed5d82daa inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09623959e21c50be31d6e40b508c39b4 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a09623959e21c50be31d6e40b508c39b4">extent_in_direction</a> (const unsigned int axis) const</td></tr>
<tr class="separator:a09623959e21c50be31d6e40b508c39b4 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f33cb96e76ff07eaf0052427907aeb3 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7f33cb96e76ff07eaf0052427907aeb3">extent_in_direction</a> (const unsigned int axis) const</td></tr>
<tr class="separator:a7f33cb96e76ff07eaf0052427907aeb3 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295994b8090ca189dc51504d24a6c96a inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">typename ::internal::Triangulation::Iterators&lt; dim, spacedim &gt;::vertex_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a295994b8090ca189dc51504d24a6c96a">vertex_iterator</a> (const unsigned int i) const</td></tr>
<tr class="separator:a295994b8090ca189dc51504d24a6c96a inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81afd26d765a4cec094b25767b8dd42a inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a81afd26d765a4cec094b25767b8dd42a">vertex_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:a81afd26d765a4cec094b25767b8dd42a inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6518eb0cf5fccc5926470128415d9 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3dd6518eb0cf5fccc5926470128415d9">vertex</a> (const unsigned int i) const</td></tr>
<tr class="separator:a3dd6518eb0cf5fccc5926470128415d9 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ad1381ed45b14e434afffb25638be1 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">typename ::internal::Triangulation::Iterators&lt; dim, spacedim &gt;::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a89ad1381ed45b14e434afffb25638be1">line</a> (const unsigned int i) const</td></tr>
<tr class="separator:a89ad1381ed45b14e434afffb25638be1 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450f0e6e00b9711650f59143e2085d95 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a450f0e6e00b9711650f59143e2085d95">line_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:a450f0e6e00b9711650f59143e2085d95 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c530d9dd449bcd816a81d923af2b5b9 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">typename ::internal::Triangulation::Iterators&lt; dim, spacedim &gt;::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6c530d9dd449bcd816a81d923af2b5b9">quad</a> (const unsigned int i) const</td></tr>
<tr class="separator:a6c530d9dd449bcd816a81d923af2b5b9 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f77d56ddde728b892e3c736a28cd0c inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab3f77d56ddde728b892e3c736a28cd0c">quad_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:ab3f77d56ddde728b892e3c736a28cd0c inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452389bb368ba37c9c5542ef956526ee inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a452389bb368ba37c9c5542ef956526ee">face_orientation</a> (const unsigned int face) const</td></tr>
<tr class="separator:a452389bb368ba37c9c5542ef956526ee inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90f5ff1a44cb8a6e08196dac6cdb22e inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip</a> (const unsigned int face) const</td></tr>
<tr class="separator:ad90f5ff1a44cb8a6e08196dac6cdb22e inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f831f5ca8626677089f94af9be43a5b inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation</a> (const unsigned int face) const</td></tr>
<tr class="separator:a2f831f5ca8626677089f94af9be43a5b inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aaa41d4d6e0942d888efc21ca5d6c7 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a08aaa41d4d6e0942d888efc21ca5d6c7">line_orientation</a> (const unsigned int <a class="el" href="classTriaAccessor.html#a89ad1381ed45b14e434afffb25638be1">line</a>) const</td></tr>
<tr class="separator:a08aaa41d4d6e0942d888efc21ca5d6c7 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce77fc45536beea670a0b5c1d91539c inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4ce77fc45536beea670a0b5c1d91539c">has_children</a> () const</td></tr>
<tr class="separator:a4ce77fc45536beea670a0b5c1d91539c inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634bf3e1c46e9ba87dfafa8c869e8972 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a634bf3e1c46e9ba87dfafa8c869e8972">n_children</a> () const</td></tr>
<tr class="separator:a634bf3e1c46e9ba87dfafa8c869e8972 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1e25935669a4b310671a26e9dcbd2 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0c1e25935669a4b310671a26e9dcbd2">number_of_children</a> () const</td></tr>
<tr class="separator:aa0c1e25935669a4b310671a26e9dcbd2 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39e613fd2e2c22bdc8ba340068e5713 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa39e613fd2e2c22bdc8ba340068e5713">max_refinement_depth</a> () const</td></tr>
<tr class="separator:aa39e613fd2e2c22bdc8ba340068e5713 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92719204d8ba105424f465336ddb915 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af92719204d8ba105424f465336ddb915">child</a> (const unsigned int i) const</td></tr>
<tr class="separator:af92719204d8ba105424f465336ddb915 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b513e2ff62a8add4d1316bd28f15897 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6b513e2ff62a8add4d1316bd28f15897">isotropic_child</a> (const unsigned int i) const</td></tr>
<tr class="separator:a6b513e2ff62a8add4d1316bd28f15897 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a4a753f2ef5b2615a7e2fec21e0dec inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae6a4a753f2ef5b2615a7e2fec21e0dec">refinement_case</a> () const</td></tr>
<tr class="separator:ae6a4a753f2ef5b2615a7e2fec21e0dec inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7551fc85831a3fd4d5cd339b81d8c6 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acd7551fc85831a3fd4d5cd339b81d8c6">child_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:acd7551fc85831a3fd4d5cd339b81d8c6 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adec5f5b7786cf43e6011d03cc7903a inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8adec5f5b7786cf43e6011d03cc7903a">isotropic_child_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:a8adec5f5b7786cf43e6011d03cc7903a inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b4887416074f2ecdcd06512e864e48 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">boundary_id</a> () const</td></tr>
<tr class="separator:af2b4887416074f2ecdcd06512e864e48 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga654de9ccd776b524a27cd64bded48e14 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga654de9ccd776b524a27cd64bded48e14">set_boundary_id</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const</td></tr>
<tr class="separator:ga654de9ccd776b524a27cd64bded48e14 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0304fb253839c45e64b60460ab040ae inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa0304fb253839c45e64b60460ab040ae">set_all_boundary_ids</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const</td></tr>
<tr class="separator:gaa0304fb253839c45e64b60460ab040ae inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211333148f7b1190db625ce91b23b65 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af211333148f7b1190db625ce91b23b65">at_boundary</a> () const</td></tr>
<tr class="separator:af211333148f7b1190db625ce91b23b65 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7b3e39b0fd9e68a1b729fb62943828 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aaa7b3e39b0fd9e68a1b729fb62943828">get_boundary</a> () const</td></tr>
<tr class="separator:aaa7b3e39b0fd9e68a1b729fb62943828 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f7767290ec8dcd1e4780efd9aa818f inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a16f7767290ec8dcd1e4780efd9aa818f">get_manifold</a> () const</td></tr>
<tr class="separator:a16f7767290ec8dcd1e4780efd9aa818f inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c28dbcfefe0ffe1e51fe315c3565f94 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id</a> () const</td></tr>
<tr class="separator:a6c28dbcfefe0ffe1e51fe315c3565f94 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbeb21da36433dc2ec117b9694ca2557 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>) const</td></tr>
<tr class="separator:gafbeb21da36433dc2ec117b9694ca2557 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160a26ce22b36607556bcdcc20bc6d61 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>) const</td></tr>
<tr class="separator:ga160a26ce22b36607556bcdcc20bc6d61 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa91f3e086777b02a2f6eef7ac19ebb inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6aa91f3e086777b02a2f6eef7ac19ebb">user_flag_set</a> () const</td></tr>
<tr class="separator:a6aa91f3e086777b02a2f6eef7ac19ebb inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda85b6637fefd5db3d37ad7729fcb1 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6dda85b6637fefd5db3d37ad7729fcb1">set_user_flag</a> () const</td></tr>
<tr class="separator:a6dda85b6637fefd5db3d37ad7729fcb1 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff7c1bc2b4fc8abcd9b3ef44b5f485 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">clear_user_flag</a> () const</td></tr>
<tr class="separator:a59ff7c1bc2b4fc8abcd9b3ef44b5f485 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d791b3769c77bcfd1c56748a6c56fa inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a63d791b3769c77bcfd1c56748a6c56fa">recursively_set_user_flag</a> () const</td></tr>
<tr class="separator:a63d791b3769c77bcfd1c56748a6c56fa inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b22f28a2baf2dd90b5309c3f0136af inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a50b22f28a2baf2dd90b5309c3f0136af">recursively_clear_user_flag</a> () const</td></tr>
<tr class="separator:a50b22f28a2baf2dd90b5309c3f0136af inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965091ec2c6ba6ed838a2479dd8110f inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3965091ec2c6ba6ed838a2479dd8110f">clear_user_data</a> () const</td></tr>
<tr class="separator:a3965091ec2c6ba6ed838a2479dd8110f inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaaa0940be75dd7436769b55538aaac inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aceaaa0940be75dd7436769b55538aaac">set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:aceaaa0940be75dd7436769b55538aaac inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd20837028286220f0b2ba9b0d4b219 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1fd20837028286220f0b2ba9b0d4b219">clear_user_pointer</a> () const</td></tr>
<tr class="separator:a1fd20837028286220f0b2ba9b0d4b219 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3700f2ce7587b2fbcaf85753c79bf40 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer</a> () const</td></tr>
<tr class="separator:ad3700f2ce7587b2fbcaf85753c79bf40 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484e590959847d514d42814efa3e25c2 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a484e590959847d514d42814efa3e25c2">recursively_set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:a484e590959847d514d42814efa3e25c2 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04d1802d9b1e8923dcfef41ea624edc inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad04d1802d9b1e8923dcfef41ea624edc">recursively_clear_user_pointer</a> () const</td></tr>
<tr class="separator:ad04d1802d9b1e8923dcfef41ea624edc inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cca979ccf43e19af78dcb91d19cfd87 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a0cca979ccf43e19af78dcb91d19cfd87">set_user_index</a> (const unsigned int p) const</td></tr>
<tr class="separator:a0cca979ccf43e19af78dcb91d19cfd87 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1e59ae7328b4c75c69720826736c0 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a97a1e59ae7328b4c75c69720826736c0">clear_user_index</a> () const</td></tr>
<tr class="separator:a97a1e59ae7328b4c75c69720826736c0 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a24da10289811179abbfb57253e9d3 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ac7a24da10289811179abbfb57253e9d3">user_index</a> () const</td></tr>
<tr class="separator:ac7a24da10289811179abbfb57253e9d3 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ae29be30ad5a259b1cd942e7d9e9d inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a309ae29be30ad5a259b1cd942e7d9e9d">recursively_set_user_index</a> (const unsigned int p) const</td></tr>
<tr class="separator:a309ae29be30ad5a259b1cd942e7d9e9d inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429e559fb261a631942d54c897243abb inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a429e559fb261a631942d54c897243abb">recursively_clear_user_index</a> () const</td></tr>
<tr class="separator:a429e559fb261a631942d54c897243abb inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e85725edb5d2bb43da61796f2fbbb9 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0e85725edb5d2bb43da61796f2fbbb9">diameter</a> () const</td></tr>
<tr class="separator:af0e85725edb5d2bb43da61796f2fbbb9 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a088728d7acb727fdc13bb6664d91a inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49a088728d7acb727fdc13bb6664d91a">extent_in_direction</a> (const unsigned int axis) const</td></tr>
<tr class="separator:a49a088728d7acb727fdc13bb6664d91a inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b268c743742c3c9ab159ff916d9236 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a99b268c743742c3c9ab159ff916d9236">minimum_vertex_distance</a> () const</td></tr>
<tr class="separator:a99b268c743742c3c9ab159ff916d9236 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49df04630565a833e168e9cab074305e inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49df04630565a833e168e9cab074305e">intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;coordinates) const</td></tr>
<tr class="separator:a49df04630565a833e168e9cab074305e inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3213234c2c543ba86eb71c716c917972 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3213234c2c543ba86eb71c716c917972">center</a> (const bool respect_manifold=false, const bool use_laplace_transformation=false) const</td></tr>
<tr class="separator:a3213234c2c543ba86eb71c716c917972 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cc737f4b28f8d28a576d2e3d32ef9f inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a56cc737f4b28f8d28a576d2e3d32ef9f">barycenter</a> () const</td></tr>
<tr class="separator:a56cc737f4b28f8d28a576d2e3d32ef9f inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cecb2b7c9a1644fb5fd44bbba40ab0c inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a9cecb2b7c9a1644fb5fd44bbba40ab0c">measure</a> () const</td></tr>
<tr class="separator:a9cecb2b7c9a1644fb5fd44bbba40ab0c inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689c9bb532bb02e21d58eeabc83ef908 inherit pub_methods_classTriaAccessor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a689c9bb532bb02e21d58eeabc83ef908">is_translation_of</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt; &amp;o) const</td></tr>
<tr class="separator:a689c9bb532bb02e21d58eeabc83ef908 inherit pub_methods_classTriaAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:ae826bd9e6c976638366d9993e6a6c7c0 inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a> () const</td></tr>
<tr class="separator:ae826bd9e6c976638366d9993e6a6c7c0 inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bebfc1e42324fbf595487e1bf668a22 inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a> () const</td></tr>
<tr class="separator:a6bebfc1e42324fbf595487e1bf668a22 inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75f0d6c68a1a67ea03bd4727c29529 inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5f75f0d6c68a1a67ea03bd4727c29529">state</a> () const</td></tr>
<tr class="separator:a5f75f0d6c68a1a67ea03bd4727c29529 inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379811efcfa7e6fb3531a014fdf33d5d inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a379811efcfa7e6fb3531a014fdf33d5d">get_triangulation</a> () const</td></tr>
<tr class="separator:a379811efcfa7e6fb3531a014fdf33d5d inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga16aa31339ad8a04d0dd9804bd6a6cd5e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga16aa31339ad8a04d0dd9804bd6a6cd5e">ExcRefineCellNotActive</a> ()</td></tr>
<tr class="separator:ga16aa31339ad8a04d0dd9804bd6a6cd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91016baf726910b3713f9e2eed357da6"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga91016baf726910b3713f9e2eed357da6">ExcCellFlaggedForRefinement</a> ()</td></tr>
<tr class="separator:ga91016baf726910b3713f9e2eed357da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21ef6ff9c287e2240bab86cdfa1414ae"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga21ef6ff9c287e2240bab86cdfa1414ae">ExcCellFlaggedForCoarsening</a> ()</td></tr>
<tr class="separator:ga21ef6ff9c287e2240bab86cdfa1414ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0dd9ea78cda7d19b9997bae1bf1d5fe0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0dd9ea78cda7d19b9997bae1bf1d5fe0">neighbor_of_neighbor_internal</a> (const unsigned int <a class="el" href="classCellAccessor.html#ae3f316701ed0595b5dbb8033024e378f">neighbor</a>) const</td></tr>
<tr class="separator:a0dd9ea78cda7d19b9997bae1bf1d5fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c380d489670714b30a3812801a1a53"><td class="memTemplParams" colspan="2">template&lt;int dim_, int spacedim_&gt; </td></tr>
<tr class="memitem:a96c380d489670714b30a3812801a1a53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a96c380d489670714b30a3812801a1a53">point_inside_codim</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim_ &gt; &amp;p) const</td></tr>
<tr class="separator:a96c380d489670714b30a3812801a1a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a3fcd7ae82e0aa33d326dc65bf45d36f8 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a3fcd7ae82e0aa33d326dc65bf45d36f8">TriaAccessorBase</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *parent=nullptr, const int <a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a>=-1, const int <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a> *=nullptr)</td></tr>
<tr class="separator:a3fcd7ae82e0aa33d326dc65bf45d36f8 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f2c7a72b6e0e7e36b9cff8533465ef inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a29f2c7a72b6e0e7e36b9cff8533465ef">TriaAccessorBase</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a29f2c7a72b6e0e7e36b9cff8533465ef inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436333e85278d0d4f3feb80abc2db97c inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a436333e85278d0d4f3feb80abc2db97c">copy_from</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a436333e85278d0d4f3feb80abc2db97c inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94225748a277e277ba31e3c40cad9bb1 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a94225748a277e277ba31e3c40cad9bb1">operator=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a94225748a277e277ba31e3c40cad9bb1 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4644115f0c10a4e07462029211274 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a7cd4644115f0c10a4e07462029211274">operator&lt;</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;other) const</td></tr>
<tr class="separator:a7cd4644115f0c10a4e07462029211274 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eea1999560f3131c3564c780ffacc38 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a2eea1999560f3131c3564c780ffacc38">operator=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> *)</td></tr>
<tr class="separator:a2eea1999560f3131c3564c780ffacc38 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fce14be63f6000f7b5d70618dc14b inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af88fce14be63f6000f7b5d70618dc14b">operator==</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:af88fce14be63f6000f7b5d70618dc14b inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044710b90a02f1d4e6c2e39c00f51ee7 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a044710b90a02f1d4e6c2e39c00f51ee7">operator!=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:a044710b90a02f1d4e6c2e39c00f51ee7 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05057502f25e21b64d4354494978cd4 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1Triangulation_1_1TriaObjects.html">internal::Triangulation::TriaObjects</a>&lt;::<a class="el" href="classinternal_1_1Triangulation_1_1TriaObject.html">internal::Triangulation::TriaObject</a>&lt; structdim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#aa05057502f25e21b64d4354494978cd4">objects</a> () const</td></tr>
<tr class="separator:aa05057502f25e21b64d4354494978cd4 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a24bd66635320e66d1dff07e3cb26e1 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5a24bd66635320e66d1dff07e3cb26e1">operator++</a> ()</td></tr>
<tr class="separator:a5a24bd66635320e66d1dff07e3cb26e1 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d4f1dc476691cf77e88f2c3ed15afe inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a85d4f1dc476691cf77e88f2c3ed15afe">operator--</a> ()</td></tr>
<tr class="separator:a85d4f1dc476691cf77e88f2c3ed15afe inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af5a1905db026aca6765b8a3a86dee7d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af5a1905db026aca6765b8a3a86dee7d3">set_active_cell_index</a> (const unsigned int <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">active_cell_index</a>)</td></tr>
<tr class="separator:af5a1905db026aca6765b8a3a86dee7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f559666292ef3769b136e0a1516dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ac7f559666292ef3769b136e0a1516dfd">set_parent</a> (const unsigned int <a class="el" href="classCellAccessor.html#af7a594e870d1b725fed0c5231596709b">parent_index</a>)</td></tr>
<tr class="separator:ac7f559666292ef3769b136e0a1516dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab75196e96aafda94a0a96d833fdc84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2ab75196e96aafda94a0a96d833fdc84">set_direction_flag</a> (const bool new_direction_flag) const</td></tr>
<tr class="separator:a2ab75196e96aafda94a0a96d833fdc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4f085f243b833b2d99cb97f649038d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abb4f085f243b833b2d99cb97f649038d">operator=</a> (const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;)</td></tr>
<tr class="separator:abb4f085f243b833b2d99cb97f649038d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplParams" colspan="2"><a id="abe9e690d5d7904f804316e15362a2191"></a>
template&lt;int , int &gt; </td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Triangulation</b></td></tr>
<tr class="separator:abe9e690d5d7904f804316e15362a2191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:ac97bc3b07691e1a0ba9f32074642ae66 inherit pub_static_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ac97bc3b07691e1a0ba9f32074642ae66">space_dimension</a> = spacedim</td></tr>
<tr class="separator:ac97bc3b07691e1a0ba9f32074642ae66 inherit pub_static_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ed55a8362723639a14d083d9e745c inherit pub_static_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a> = dim</td></tr>
<tr class="separator:a125ed55a8362723639a14d083d9e745c inherit pub_static_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e42860babc727fc028adfb9a3200b7 inherit pub_static_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> = structdim</td></tr>
<tr class="separator:a35e42860babc727fc028adfb9a3200b7 inherit pub_static_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a66324ab281f0488f99fec29b1ffdda2b inherit pro_types_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a></td></tr>
<tr class="separator:a66324ab281f0488f99fec29b1ffdda2b inherit pro_types_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:aeec476ccc498e89a9814bdf05888cc7a inherit pro_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriaAccessor_1_1PresentLevelType.html">internal::TriaAccessor::PresentLevelType</a>&lt; structdim, dim &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#aeec476ccc498e89a9814bdf05888cc7a">present_level</a></td></tr>
<tr class="separator:aeec476ccc498e89a9814bdf05888cc7a inherit pro_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf2d985abdb2c9a43ab97722305f34 inherit pro_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a11cf2d985abdb2c9a43ab97722305f34">present_index</a></td></tr>
<tr class="separator:a11cf2d985abdb2c9a43ab97722305f34 inherit pro_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d14a2d30b3298a8ebab41c0e005f1eb inherit pro_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a9d14a2d30b3298a8ebab41c0e005f1eb">tria</a></td></tr>
<tr class="separator:a9d14a2d30b3298a8ebab41c0e005f1eb inherit pro_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class CellAccessor&lt; dim, spacedim &gt;</h3>

<p>This class allows access to a cell: a line in one dimension, a quad in two dimension, etc.</p>
<p>The following refers to any dimension:</p>
<p>This class allows access to a <code>cell</code>, which is a line in 1D and a quad in 2D. Cells have more functionality than lines or quads by themselves, for example they can be flagged for refinement, they have neighbors, they have the possibility to check whether they are at the boundary etc. This class offers access to all this data.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998, 1999, 2000 </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l02282">2282</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a821bacffe6e9828642c83cf2b2baf13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821bacffe6e9828642c83cf2b2baf13e">&#9670;&nbsp;</a></span>AccessorData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim,dim,spacedim&gt;::<a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate the AccessorData type into the present class. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l02288">2288</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a014f2d38d74b3c488440ec17637f7abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014f2d38d74b3c488440ec17637f7abc">&#9670;&nbsp;</a></span>Container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html#a014f2d38d74b3c488440ec17637f7abc">Container</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define the type of the container this is part of. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l02293">2293</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a026b9553c7d56c103147d3e9a6d9a0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026b9553c7d56c103147d3e9a6d9a0ed">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a> *&#160;</td>
          <td class="paramname"><em>local_data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="acb3fbe765bc2a08b056175f8f52da568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3fbe765bc2a08b056175f8f52da568">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_accessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="ab34931ab97b3e7c7da47388b30c36707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34931ab97b3e7c7da47388b30c36707">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion constructor. This constructor exists to make certain constructs simpler to write in dimension independent code. For example, it allows assigning a face iterator to a line iterator, an operation that is useful in 2d but doesn't make any sense in 3d. The constructor here exists for the purpose of making the code conform to C++ but it will unconditionally abort; in other words, assigning a face iterator to a line iterator is better put into an if-statement that checks that the dimension is two, and assign to a quad iterator in 3d (an operator that, without this constructor would be illegal if we happen to compile for 2d). </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03207">3207</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="aecdfe299bf81ce75210d54e3f47684fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdfe299bf81ce75210d54e3f47684fb">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another conversion operator between objects that don't make sense, just like the previous one. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03237">3237</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abacf4d5819d5f9e96d0e597cd92ce41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacf4d5819d5f9e96d0e597cd92ce41e">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::child </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the <code>ith</code> child. Overloaded version which returns a more reasonable iterator class. </p>

</div>
</div>
<a id="a1bbd3c4ad4199b251691162f6bacaff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbd3c4ad4199b251691162f6bacaff8">&#9670;&nbsp;</a></span>face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim-1,dim,spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the <code>ith</code> face of this cell. </p>

</div>
</div>
<a id="a393ecccb4d12de31be253b60740befe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393ecccb4d12de31be253b60740befe9">&#9670;&nbsp;</a></span>face_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the (global) index of the <code>ith</code> face of this cell.</p>
<dl class="section note"><dt>Note</dt><dd>Despite the name, the index returned here is only global in the sense that it is specific to a particular <a class="el" href="classTriangulation.html">Triangulation</a> object or, in the case the triangulation is actually of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, specific to that part of the distributed triangulation stored on the current processor. </dd></dl>

</div>
</div>
<a id="a54844a9be3a35e62aaabc8d43ad1f8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54844a9be3a35e62aaabc8d43ad1f8b8">&#9670;&nbsp;</a></span>neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to that cell that neighbors the present cell on the given face and subface number.</p>
<p>To succeed, the present cell must not be further refined, and the neighbor on the given face must be further refined exactly once; the returned cell is then a child of that neighbor.</p>
<p>The function may not be called in 1d, since there we have no subfaces. The implementation of this function is rather straightforward in 2d, by first determining which face of the neighbor cell the present cell is bordering on (this is what the <code>neighbor_of_neighbor</code> function does), and then asking <code>GeometryInfo::child_cell_on_subface</code> for the index of the child.</p>
<p>However, the situation is more complicated in 3d, since there faces may have more than one orientation, and we have to use <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> for both this and the neighbor cell to figure out which cell we want to have.</p>
<p>This can lead to surprising results: if we are sitting on a cell and are asking for a cell behind subface <code>sf</code>, then this means that we are considering the subface for the face in the natural direction for the present cell. However, if the face as seen from this cell has <code><a class="el" href="classTriaAccessor.html#a452389bb368ba37c9c5542ef956526ee">face_orientation()</a>==false</code>, then the child of the face that separates the present cell from the neighboring cell's child is not necessarily the <code>sf-th</code> child of the face of this cell. This is so because the <code>subface_no</code> on a cell corresponds to the subface with respect to the intrinsic ordering of the present cell, whereas children of face iterators are computed with respect to the intrinsic ordering of faces; these two orderings are only identical if the face orientation is <code>true</code>, and reversed otherwise.</p>
<p>Similarly, effects of <code><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip()</a>==true</code> and <code><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation()</a>==true()</code>, both of which indicate a non-standard face have to be considered.</p>
<p>Fortunately, this is only very rarely of concern, since usually one simply wishes to loop over all finer neighbors at a given face of an active cell. Only in the process of refinement of a <a class="el" href="classTriangulation.html">Triangulation</a> we want to set neighbor information for both our child cells and the neighbor's children. Since we can respect orientation of faces from our current cell in that case, we do NOT respect face_orientation, face_flip and face_rotation of the present cell within this function, i.e. the returned neighbor's child is behind subface <code>subface</code> concerning the intrinsic ordering of the given face. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02252">2252</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ae3f316701ed0595b5dbb8033024e378f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f316701ed0595b5dbb8033024e378f">&#9670;&nbsp;</a></span>neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the <code>ith</code> neighbor. If the neighbor does not exist, i.e., if the <code>ith</code> face of the current object is at the boundary, then an invalid iterator is returned.</p>
<p>The neighbor of a cell has at most the same level as this cell. For example, consider the following situation: </p><div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p>Here, if you are on the top right cell and you ask for its left neighbor (which is, according to the conventions spelled out in the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class, its <em>zeroth</em> neighbor), then you will get the mother cell of the four small cells at the top left. In other words, the cell you get as neighbor has the same refinement level as the one you're on right now (the top right one) and it may have children.</p>
<p>On the other hand, if you were at the top right cell of the four small cells at the top left, and you asked for the right neighbor (which is associated with index <code>i=1</code>), then you would get the large cell at the top right which in this case has a lower refinement level and no children of its own. </p>

</div>
</div>
<a id="ace11c052823b53f0ee5566696c3fcdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace11c052823b53f0ee5566696c3fcdab">&#9670;&nbsp;</a></span>neighbor_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index of the <code>ith</code> neighbor. If the neighbor does not exist, its index is -1. </p>

</div>
</div>
<a id="ae99179c09d5c58f6c62c6aceaecbe3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99179c09d5c58f6c62c6aceaecbe3ca">&#9670;&nbsp;</a></span>neighbor_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the level of the <code>ith</code> neighbor. If the neighbor does not exist, its level is -1. </p>

</div>
</div>
<a id="ab264cec6e84153df51c1108a518c49fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab264cec6e84153df51c1108a518c49fb">&#9670;&nbsp;</a></span>neighbor_of_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the how-many'th neighbor this cell is of <code>cell-&gt;neighbor(neighbor)</code>, i.e. return the <code>face_no</code> such that <code>cell-&gt;neighbor(neighbor)-&gt;neighbor(face_no)==cell</code>. This function is the right one if you want to know how to get back from a neighbor to the present cell.</p>
<p>Note that this operation is only useful if the neighbor is not coarser than the present cell. If the neighbor is coarser this function throws an exception. Use the <code>neighbor_of_coarser_neighbor</code> function in that case. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01741">1741</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="aa14bba7dcdb9957770752910daef243f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14bba7dcdb9957770752910daef243f">&#9670;&nbsp;</a></span>neighbor_is_coarser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_is_coarser </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return, whether the neighbor is coarser then the present cell. This is important in case of ansiotropic refinement where this information does not depend on the levels of the cells.</p>
<p>Note, that in an anisotropic setting, a cell can only be coarser than another one at a given face, not on a general basis. The face of the finer cell is contained in the corresponding face of the coarser cell, the finer face is either a child or a grandchild of the coarser face. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01754">1754</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a653454d4633329469aaea5a27d61e2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653454d4633329469aaea5a27d61e2de">&#9670;&nbsp;</a></span>neighbor_of_coarser_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, unsigned int &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_coarser_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a generalization of the <code>neighbor_of_neighbor</code> function for the case of a coarser neighbor. It returns a pair of numbers, face_no and subface_no, with the following property, if the neighbor is not refined: <code>cell-&gt;neighbor(neighbor)-&gt;neighbor_child_on_subface(face_no, subface_no)==cell</code>. In 3D, a coarser neighbor can still be refined. In that case subface_no denotes the child index of the neighbors face that relates to our face: <code>cell-&gt;neighbor(neighbor)-&gt;face(face_no)-&gt;child(subface_no)==cell-&gt;face(neighbor)</code>. This case in 3d and how it can happen is discussed in the introduction of the <a class="el" href="step_30.html">step-30</a> tutorial program.</p>
<p>This function is impossible for <code>dim==1</code>. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01763">1763</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a036e8dae65320c8d718b6fc88394293d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e8dae65320c8d718b6fc88394293d">&#9670;&nbsp;</a></span>neighbor_face_no()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_face_no </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a generalization of the <code>neighbor_of_neighbor</code> and the <code>neighbor_of_coarser_neighbor</code> functions. It checks whether the neighbor is coarser or not and calls the respective function. In both cases, only the face_no is returned. </p>

</div>
</div>
<a id="a5b60dfb7926e4a9d39c2208b0f86b256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b60dfb7926e4a9d39c2208b0f86b256">&#9670;&nbsp;</a></span>has_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::has_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the cell has a periodic neighbor at its <code>ith</code> face, this function returns true, otherwise, the returned value is false. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01914">1914</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a12b7281609d7b0b1a5f436515c385964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b7281609d7b0b1a5f436515c385964">&#9670;&nbsp;</a></span>periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a cell with its <code>ith</code> face at a periodic boundary, see <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">the entry for periodic boundaries</a>, this function returns an iterator to the cell on the other side of the periodic boundary. If there is no periodic boundary at the <code>ith</code> face, an exception will be thrown. In order to avoid running into an exception, check the result of <a class="el" href="classCellAccessor.html#a5b60dfb7926e4a9d39c2208b0f86b256">has_periodic_neighbor()</a> for the <code>ith</code> face prior to using this function. The behavior of <a class="el" href="classCellAccessor.html#a12b7281609d7b0b1a5f436515c385964">periodic_neighbor()</a> is similar to <a class="el" href="classCellAccessor.html#ae3f316701ed0595b5dbb8033024e378f">neighbor()</a>, in the sense that the returned cell has at most the same level of refinement as the current cell. On distributed meshes, by calling <a class="el" href="classTriangulation.html#a9539cda687eeb08c602bceac11807987">Triangulation::add_periodicity()</a>, we can make sure that the element on the other side of the periodic boundary exists in this rank as a ghost cell or a locally owned cell. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01952">1952</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="af2cbc0468b12ad483b1cb395bc625a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cbc0468b12ad483b1cb395bc625a61">&#9670;&nbsp;</a></span>neighbor_or_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_or_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a cell whose <code>ith</code> face is not at a boundary, this function returns the same result as <a class="el" href="classCellAccessor.html#ae3f316701ed0595b5dbb8033024e378f">neighbor()</a>. If the <code>ith</code> face is at a periodic boundary this function returns the same result as <a class="el" href="classCellAccessor.html#a12b7281609d7b0b1a5f436515c385964">periodic_neighbor()</a>. If neither of the aforementioned conditions are met, i.e. the <code>ith</code> face is on a nonperiodic boundary, an exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01981">1981</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="aa3395f4ebb63aa30e1a0aac7fdbb5953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3395f4ebb63aa30e1a0aac7fdbb5953">&#9670;&nbsp;</a></span>periodic_neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the periodic neighbor of the cell at a given face and subface number. The general guidelines for using this function is similar to the function <a class="el" href="classCellAccessor.html#a54844a9be3a35e62aaabc8d43ad1f8b8">neighbor_child_on_subface()</a>. The implementation of this function is consistent with <a class="el" href="classCellAccessor.html#ac98496895de96d67cea5392c3aade826">periodic_neighbor_of_coarser_periodic_neighbor()</a>. For instance, assume that we are sitting on a cell named <code>cell1</code>, whose neighbor behind the <code>ith</code> face is one level coarser. Let us name this coarser neighbor <code>cell2</code>. Then, by calling <a class="el" href="classCellAccessor.html#ac98496895de96d67cea5392c3aade826">periodic_neighbor_of_coarser_periodic_neighbor()</a>, from <code>cell1</code>, we get a <code>face_num</code> and a <code>subface_num</code>. Now, if we call <a class="el" href="classCellAccessor.html#aa3395f4ebb63aa30e1a0aac7fdbb5953">periodic_neighbor_child_on_subface()</a> from cell2, with the above face_num and subface_num, we get an iterator to <code>cell1</code>. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01998">1998</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ac98496895de96d67cea5392c3aade826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98496895de96d67cea5392c3aade826">&#9670;&nbsp;</a></span>periodic_neighbor_of_coarser_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, unsigned int &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_of_coarser_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a generalization of <a class="el" href="classCellAccessor.html#af92a480d8d1b269b21d95c7cc3c0a033">periodic_neighbor_of_periodic_neighbor()</a> for those cells which have a coarser periodic neighbor. The returned pair of numbers can be used in <a class="el" href="classCellAccessor.html#aa3395f4ebb63aa30e1a0aac7fdbb5953">periodic_neighbor_child_on_subface()</a> to get back to the current cell. In other words, the following assertion should be true, for a cell with coarser periodic neighbor: cell-&gt;periodic_neighbor(i)-&gt;periodic_neighbor_child_on_subface(face_no, subface_no)==cell </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02051">2051</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab1c3888e028fcfafd86b1eef59e73505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c3888e028fcfafd86b1eef59e73505">&#9670;&nbsp;</a></span>periodic_neighbor_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the index of the periodic neighbor at the <code>ith</code> face of the current cell. If there is no periodic neighbor at the given face, the returned value is -1. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02111">2111</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a64fa397b3b27f4cda613208d127f0a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fa397b3b27f4cda613208d127f0a98">&#9670;&nbsp;</a></span>periodic_neighbor_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the level of the periodic neighbor at the <code>ith</code> face of the current cell. If there is no periodic neighbor at the given face, the returned value is -1. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02120">2120</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="af92a480d8d1b269b21d95c7cc3c0a033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92a480d8d1b269b21d95c7cc3c0a033">&#9670;&nbsp;</a></span>periodic_neighbor_of_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_of_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a cell with a periodic neighbor at its <code>ith</code> face, this function returns the face number of that periodic neighbor such that the current cell is the periodic neighbor of that neighbor. In other words the following assertion holds for those cells which have a periodic neighbor with the same or a higher level of refinement as the current cell: <code>{cell-&gt;periodic_neighbor(i)-&gt;</code> periodic_neighbor(cell-&gt;periodic_neighbor_of_periodic_neighbor(i))==cell} For the cells with a coarser periodic neighbor, one should use <a class="el" href="classCellAccessor.html#ac98496895de96d67cea5392c3aade826">periodic_neighbor_of_coarser_periodic_neighbor()</a> and <a class="el" href="classCellAccessor.html#aa3395f4ebb63aa30e1a0aac7fdbb5953">periodic_neighbor_child_on_subface()</a> to get back to the current cell. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02129">2129</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="afbdf47567f70bac8826dcd7e5782f968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdf47567f70bac8826dcd7e5782f968">&#9670;&nbsp;</a></span>periodic_neighbor_face_no()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_face_no </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a cell has a periodic neighbor at its <code>ith</code> face, this function returns the face number of the periodic neighbor, which is connected to the <code>ith</code> face of this cell. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02138">2138</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab737948031be71ea02495126a177ed8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab737948031be71ea02495126a177ed8a">&#9670;&nbsp;</a></span>periodic_neighbor_is_coarser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_is_coarser </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns true if the element on the other side of the periodic boundary is coarser and returns false otherwise. The implementation allows this function to work in the case of anisotropic refinement. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02168">2168</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a4b683043741a1167de1ab9dbda0e54f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b683043741a1167de1ab9dbda0e54f7">&#9670;&nbsp;</a></span>at_boundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the <code>ith</code> vertex or face (depending on the dimension) is part of the boundary. This is true, if the <code>ith</code> neighbor does not exist. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02221">2221</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ace4c08cb6a4ced3f610d9789d02ad202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4c08cb6a4ced3f610d9789d02ad202">&#9670;&nbsp;</a></span>at_boundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the cell is at the boundary. Being at the boundary is defined by one face being on the boundary. Note that this does not catch cases where only one vertex of a quad or of a hex is at the boundary, or where only one line of a hex is at the boundary while the interiors of all faces are in the interior of the domain. For the latter case, the <code>has_boundary_lines</code> function is the right one to ask. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01423">1423</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a9fee6d28c03cd3ba90263ecb0e268b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fee6d28c03cd3ba90263ecb0e268b3a">&#9670;&nbsp;</a></span>has_boundary_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::has_boundary_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a slight variation to the <code>at_boundary</code> function: for 1 and 2 dimensions, it is equivalent, for three dimensions it returns whether at least one of the 12 lines of the hexahedron is at a boundary. This, of course, includes the case where a whole face is at the boundary, but also some other cases. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02233">2233</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a902048fc67583f356fd3278a7d2aa8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902048fc67583f356fd3278a7d2aa8de">&#9670;&nbsp;</a></span>refine_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::refine_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <code>RefinementCase&lt;dim&gt;</code> this cell was flagged to be refined with. The return value of this function can be compared to a bool to check if this cell is flagged for any kind of refinement. For example, if you have previously called cell-&gt;<a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">set_refine_flag()</a> for a cell, then you will enter the 'if' block in the following snippet:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell-&gt;refine_flag_set())</div><div class="line">{</div><div class="line">  <span class="comment">// yes, this cell is marked for refinement.</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a8c8359d5342b4ae7ae8b74fc3f4a1558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8359d5342b4ae7ae8b74fc3f4a1558">&#9670;&nbsp;</a></span>set_refine_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_refine_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td>
          <td class="paramname"><em>ref_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag the cell pointed to for refinement. This function is only allowed for active cells. Keeping the default value for <code>ref_case</code> will mark this cell for isotropic refinement.</p>
<p>If you choose anisotropic refinement, for example by passing as argument one of the flags RefinementCase::cut_x, RefinementCase::cut_y, RefinementCase::cut_z, or a combination of these, then keep in mind that refining in x-, y-, or z-direction happens with regard to the <em>local</em> coordinate system of the cell. In other words, these flags determine which edges and faces of the cell will be cut into new edges and faces. On the other hand, this process is independent of how the cell is oriented within the <em>global</em> coordinate system, and you should not assume any particular orientation of the cell's local coordinate system within the global coordinate system of the space it lives in. </p>

</div>
</div>
<a id="ad5ccb325d746a81fa4a8542d698b89c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ccb325d746a81fa4a8542d698b89c7">&#9670;&nbsp;</a></span>clear_refine_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::clear_refine_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the refinement flag. </p>

</div>
</div>
<a id="a13778ea9fe696b3d59ed6c779dafc6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13778ea9fe696b3d59ed6c779dafc6c7">&#9670;&nbsp;</a></span>flag_for_face_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::flag_for_face_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim-1&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify the refinement flag of the cell to ensure (at least) the given refinement case <code>face_refinement_case</code> at face <code>face_no</code>, taking into account orientation, flip and rotation of the face. Return, whether the refinement flag had to be modified. This function is only allowed for active cells. </p>

</div>
</div>
<a id="aeb3fa84168f193c7877ff90b70bcee83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3fa84168f193c7877ff90b70bcee83">&#9670;&nbsp;</a></span>flag_for_line_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::flag_for_line_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify the refinement flag of the cell to ensure that line <code>face_no</code> will be refined. Return, whether the refinement flag had to be modified. This function is only allowed for active cells. </p>

</div>
</div>
<a id="a448d8dc9bdecab5a250ed5ecb899ded9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448d8dc9bdecab5a250ed5ecb899ded9">&#9670;&nbsp;</a></span>subface_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::subface_case </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the SubfaceCase of face <code>face_no</code>. Note that this is not identical to asking <code>cell-&gt;face(face_no)-&gt;<a class="el" href="classTriaAccessor.html#ae6a4a753f2ef5b2615a7e2fec21e0dec">refinement_case()</a></code> since the latter returns a <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim-1&gt; and thus only considers one (anisotropic) refinement, whereas this function considers the complete refinement situation including possible refinement of the face's children. This function may only be called for active cells in 2d and 3d. </p>

</div>
</div>
<a id="ae4910a26c4458ce0dd444e6b7bec2564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4910a26c4458ce0dd444e6b7bec2564">&#9670;&nbsp;</a></span>coarsen_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::coarsen_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the coarsen flag is set or not. </p>

</div>
</div>
<a id="a6de037c4860dcaceb4f9429b981b715e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de037c4860dcaceb4f9429b981b715e">&#9670;&nbsp;</a></span>set_coarsen_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_coarsen_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag the cell pointed to for coarsening. This function is only allowed for active cells. </p>

</div>
</div>
<a id="ab9fd137b13ff401f168ea0433cb18e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fd137b13ff401f168ea0433cb18e49">&#9670;&nbsp;</a></span>clear_coarsen_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::clear_coarsen_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the coarsen flag. </p>

</div>
</div>
<a id="ae4769702cd7ab67a61b25778ea3021b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4769702cd7ab67a61b25778ea3021b2">&#9670;&nbsp;</a></span>material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::material_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the material id of this cell.</p>
<p>For a typical use of this function, see the <a class="el" href="step_28.html">step-28</a> tutorial program.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossMaterialId">glossary</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01445">1445</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a861d3679d23d3f4365f724c9cfe5fd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861d3679d23d3f4365f724c9cfe5fd77">&#9670;&nbsp;</a></span>set_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>new_material_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the material id of this cell.</p>
<p>For a typical use of this function, see the <a class="el" href="step_28.html">step-28</a> tutorial program.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossMaterialId">glossary</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01454">1454</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a2b49d85f8793f5a95d6c50797c07be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b49d85f8793f5a95d6c50797c07be2b">&#9670;&nbsp;</a></span>recursively_set_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::recursively_set_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>new_material_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the material id of this cell and all its children (and grand- children, and so on) to the given value.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossMaterialId">glossary</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01464">1464</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ae06835414c3c3f3359974f2c75a88033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06835414c3c3f3359974f2c75a88033">&#9670;&nbsp;</a></span>subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::subdomain_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the subdomain id of this cell.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossSubdomainId">glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The subdomain of a cell is a property only defined for active cells, i.e., cells that are not further refined. Consequently, you can only call this function if the cell it refers to has no children. For multigrid methods in parallel, it is also important to know which processor owns non-active cells, and for this you can call <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id()</a>. </dd></dl>

</div>
</div>
<a id="a56098dab68574f96b42779d68c54269d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56098dab68574f96b42779d68c54269d">&#9670;&nbsp;</a></span>set_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the subdomain id of this cell.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossSubdomainId">glossary</a> for more information. This function should not be called if you use a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>The subdomain of a cell is a property only defined for active cells, i.e., cells that are not further refined. Consequently, you can only call this function if the cell it refers to has no children. For multigrid methods in parallel, it is also important to know which processor owns non-active cells, and for this you can call <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01477">1477</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a2c84842b2847744da6e48fbcabf777ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c84842b2847744da6e48fbcabf777ad">&#9670;&nbsp;</a></span>level_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::level_subdomain_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the level subdomain id of this cell. This is used for parallel multigrid. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01488">1488</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a2bfad9f24d9ddbc86883614639d4886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfad9f24d9ddbc86883614639d4886d">&#9670;&nbsp;</a></span>set_level_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_level_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_level_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the level subdomain id of this cell. This is used for parallel multigrid. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01498">1498</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a0108d0f1a0710c1e6d9b98f7cb2768fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0108d0f1a0710c1e6d9b98f7cb2768fa">&#9670;&nbsp;</a></span>recursively_set_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::recursively_set_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the subdomain id of this cell (if it is active) or all its terminal children (and grand-children, and so on, as long as they have no children of their own) to the given value. Since the subdomain id is a concept that is only defined for cells that are active (i.e., have no children of their own), this function only sets the subdomain ids for all children and grand children of this cell that are actually active, skipping intermediate child cells.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossSubdomainId">glossary</a> for more information. This function should not be called if you use a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object since there the subdomain id is implicitly defined by which processor you're on. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01600">1600</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ae146ea059e9c27cb3e040b92d5c4e152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae146ea059e9c27cb3e040b92d5c4e152">&#9670;&nbsp;</a></span>direction_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::direction_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the orientation of this cell.</p>
<p>For the meaning of this flag, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a>. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01507">1507</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ad4b8ec35236bea8ee91a72bbd19762fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b8ec35236bea8ee91a72bbd19762fe">&#9670;&nbsp;</a></span>active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::active_cell_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the how many-th active cell the current cell is (assuming the current cell is indeed active). This is useful, for example, if you are accessing the elements of a vector with as many entries as there are active cells. Such vectors are used for estimating the error on each cell of a triangulation, for specifying refinement criteria passed to the functions in <a class="el" href="namespaceGridRefinement.html">GridRefinement</a>, and for generating cell-wise output.</p>
<p>The function throws an exception if the current cell is not active.</p>
<dl class="section note"><dt>Note</dt><dd>If the triangulation this function is called on is of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, then active cells may be locally owned, ghost cells, or artificial (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>, <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>, and <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a>). This function counts over all of them, including ghost and artificial active cells. This implies that the index returned by this function uniquely identifies a cell within the triangulation on a single processor, but does not uniquely identify the cell among the (parts of the) triangulation that is shared among processors. If you would like to identify active cells across processors, you need to consider the <a class="el" href="classCellId.html">CellId</a> of a cell returned by <a class="el" href="classCellAccessor.html#aee7d5ec9cac8af95a136554501ea4f0a">CellAccessor::id()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01576">1576</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="af7a594e870d1b725fed0c5231596709b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a594e870d1b725fed0c5231596709b">&#9670;&nbsp;</a></span>parent_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::parent_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index of the parent of this cell within the level of the triangulation to which the parent cell belongs. The level of the parent is of course one lower than that of the present cell. If the parent does not exist (i.e., if the object is at the coarsest level of the mesh hierarchy), an exception is generated. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01561">1561</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a027532e7f473fac2812a92e4066e29f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027532e7f473fac2812a92e4066e29f5">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the parent. If the parent does not exist (i.e., if the object is at the coarsest level of the mesh hierarchy), an exception is generated. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01586">1586</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a5f73f52e426005fba81e672ba9254a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f73f52e426005fba81e672ba9254a26">&#9670;&nbsp;</a></span>active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether the cell has children (this is the criterion for activity of a cell).</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossActive">glossary</a> for more information. </p>

</div>
</div>
<a id="a87a3ff6217f3b5b4537f6a101560f493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a3ff6217f3b5b4537f6a101560f493">&#9670;&nbsp;</a></span>is_locally_owned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_locally_owned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this cell is owned by the current processor or is owned by another processor. The function always returns true if applied to an object of type <a class="el" href="classTriangulation.html">Triangulation</a>, but may yield false if the triangulation is of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGhostCell">glossary</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module for more information.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The returned value is equal to <code>!is_ghost() &amp;&amp; !is_artificial()</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whether a cell is a ghost cell, artificial, or is locally owned or is a property that only pertains to cells that are active. Consequently, you can only call this function if the cell it refers to has no children. </dd></dl>

</div>
</div>
<a id="a9e6b3c485d88ed58114d1b470bb3693f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6b3c485d88ed58114d1b470bb3693f">&#9670;&nbsp;</a></span>is_locally_owned_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_locally_owned_on_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if either the <a class="el" href="classTriangulation.html">Triangulation</a> is not distributed or if <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id()</a> is equal to the id of the current processor. </p>

</div>
</div>
<a id="a54375bf8f17e51501a4da7a2fac852ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54375bf8f17e51501a4da7a2fac852ae">&#9670;&nbsp;</a></span>is_ghost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_ghost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this cell exists in the global mesh but (i) is owned by another processor, i.e. has a subdomain_id different from the one the current processor owns and (ii) is adjacent to a cell owned by the current processor.</p>
<p>This function only makes sense if the triangulation used is of kind <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. In all other cases, the returned value is always false.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGhostCell">glossary</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module for more information.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The returned value is equal to <code>!is_locally_owned() &amp;&amp; !is_artificial()</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whether a cell is a ghost cell, artificial, or is locally owned or is a property that only pertains to cells that are active. Consequently, you can only call this function if the cell it refers to has no children. </dd></dl>

</div>
</div>
<a id="aef398493764dee787a796b436826847b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef398493764dee787a796b436826847b">&#9670;&nbsp;</a></span>is_artificial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_artificial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this cell is artificial, i.e. it isn't one of the cells owned by the current processor, and it also doesn't border on one. As a consequence, it exists in the mesh to ensure that each processor has all coarse mesh cells and that the 2:1 ratio of neighboring cells is maintained, but it is not one of the cells we should work on on the current processor. In particular, there is no guarantee that this cell isn't, in fact, further refined on one of the other processors.</p>
<p>This function only makes sense if the triangulation used is of kind <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. In all other cases, the returned value is always false.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossArtificialCell">glossary</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module for more information.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The returned value is equal to <code>!is_ghost() &amp;&amp; !is_locally_owned()</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whether a cell is a ghost cell, artificial, or is locally owned is a property that only pertains to cells that are active. Consequently, you can only call this function if the cell it refers to has no children. </dd></dl>

</div>
</div>
<a id="adb8a0465d3d7145513463b6a4a215fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8a0465d3d7145513463b6a4a215fbc">&#9670;&nbsp;</a></span>point_inside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether the point <code>p</code> is inside this cell. Points on the boundary are counted as being inside the cell.</p>
<p>Note that this function assumes that the mapping between unit cell and real cell is (bi-, tri-)linear, i.e. that faces in 2d and edges in 3d are straight lines. If you have higher order transformations, results may be different as to whether a point is in- or outside the cell in real space.</p>
<p>In case of codim&gt;0, the point is first projected to the manifold where the cell is embedded and then check if this projection is inside the cell. </p>

</div>
</div>
<a id="a155270eb9a66a7c366be5c8db4430acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155270eb9a66a7c366be5c8db4430acb">&#9670;&nbsp;</a></span>set_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the neighbor <code>i</code> of this cell to the cell pointed to by <code>pointer</code>.</p>
<p>This function shouldn't really be public (but needs to for various reasons in order not to make a long list of functions friends): it modifies internal data structures and may leave things. Do not use it from application codes. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01612">1612</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="aee7d5ec9cac8af95a136554501ea4f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7d5ec9cac8af95a136554501ea4f0a">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellId.html">CellId</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a unique ID for the current cell. This ID is constructed from the path in the hierarchy from the coarse father cell and works correctly in parallel computations using objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. This function is therefore useful in providing a unique identifier for cells (active or not) that also works for parallel triangulations. See the documentation of the <a class="el" href="classCellId.html">CellId</a> class for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This operation takes O(level) time to compute. In most practical cases, the number of levels of a triangulation will depend logarithmically on the number of cells in the triangulation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01641">1641</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a0dd9ea78cda7d19b9997bae1bf1d5fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd9ea78cda7d19b9997bae1bf1d5fe0">&#9670;&nbsp;</a></span>neighbor_of_neighbor_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_neighbor_internal </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function assumes that the neighbor is not coarser than the current cell. In this case it returns the <a class="el" href="classCellAccessor.html#ab264cec6e84153df51c1108a518c49fb">neighbor_of_neighbor()</a> value. If, however, the neighbor is coarser this function returns an <code>invalid_unsigned_int</code>.</p>
<p>This function is not for public use. Use the function <a class="el" href="classCellAccessor.html#ab264cec6e84153df51c1108a518c49fb">neighbor_of_neighbor()</a> instead which throws an exception if called for a coarser neighbor. If neighbor is indeed coarser (you get to know this by e.g. the <a class="el" href="classCellAccessor.html#aa14bba7dcdb9957770752910daef243f">neighbor_is_coarser()</a> function) then the <a class="el" href="classCellAccessor.html#a653454d4633329469aaea5a27d61e2de">neighbor_of_coarser_neighbor()</a> function should be call. If you'd like to know only the <code>face_no</code> which is required to get back from the neighbor to the present cell then simply use the <a class="el" href="classCellAccessor.html#a036e8dae65320c8d718b6fc88394293d">neighbor_face_no()</a> function which can be used for coarser as well as non-coarser neighbors. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01679">1679</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a96c380d489670714b30a3812801a1a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c380d489670714b30a3812801a1a53">&#9670;&nbsp;</a></span>point_inside_codim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int dim_, int spacedim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::point_inside_codim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As for any codim&gt;0 we can use a similar code and c++ does not allow partial templates. we use this auxiliary function that is then called from point_inside. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01388">1388</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="af5a1905db026aca6765b8a3a86dee7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a1905db026aca6765b8a3a86dee7d3">&#9670;&nbsp;</a></span>set_active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_active_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>active_cell_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the active cell index of a cell. This is done at the end of refinement. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01536">1536</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ac7f559666292ef3769b136e0a1516dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f559666292ef3769b136e0a1516dfd">&#9670;&nbsp;</a></span>set_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_parent </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>parent_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the parent of a cell. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01548">1548</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a2ab75196e96aafda94a0a96d833fdc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab75196e96aafda94a0a96d833fdc84">&#9670;&nbsp;</a></span>set_direction_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_direction_flag </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>new_direction_flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the orientation of this cell.</p>
<p>For the meaning of this flag, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a>. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01520">1520</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="abb4f085f243b833b2d99cb97f649038d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4f085f243b833b2d99cb97f649038d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. This is normally used in a context like <code>iterator a,b; *a=*b;</code>. Since the meaning is to copy the object pointed to by <code>b</code> to the object pointed to by <code>a</code> and since accessors are not real but virtual objects, this operation is not useful for iterators on triangulations. We declare this function here private, thus it may not be used from outside. Furthermore it is not implemented and will give a linker error if used anyway. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/grid/<a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/grid/<a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
