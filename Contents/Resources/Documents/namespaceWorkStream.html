<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: WorkStream Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">WorkStream Namespace Reference<div class="ingroups"><a class="el" href="group__Parallel.html">Parallel computing</a> &raquo; <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0c5d332d74a4df80784140218896b169"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a0c5d332d74a4df80784140218896b169"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> (const std::vector&lt; std::vector&lt; Iterator &gt; &gt; &amp;colored_iterators, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned int chunk_size=8)</td></tr>
<tr class="separator:a0c5d332d74a4df80784140218896b169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a7dc1160c09f1fee6b2a5a4d0d3fa3f4e">run</a> (const Iterator &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;end, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned int chunk_size=8)</td></tr>
<tr class="separator:a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f054e2848cf513aec9e5e4eb115bef4"><td class="memTemplParams" colspan="2">template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a2f054e2848cf513aec9e5e4eb115bef4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a2f054e2848cf513aec9e5e4eb115bef4">run</a> (const Iterator &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;end, MainClass &amp;main_object, void(MainClass::*worker)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;), void(MainClass::*copier)(const CopyData &amp;), const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned int queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned int chunk_size=8)</td></tr>
<tr class="separator:a2f054e2848cf513aec9e5e4eb115bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace whose main template function supports running multiple threads each of which operates on a subset of the given range of objects. The class uses the Intel Threading Building Blocks (TBB) to load balance the individual subranges onto the available threads. For a lengthy discussion of the rationale of this class, see the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. It is used in the tutorial first in <a class="el" href="step_9.html">step-9</a>, and again in <a class="el" href="step_13.html">step-13</a>, <a class="el" href="step_14.html">step-14</a>, <a class="el" href="step_32.html">step-32</a> and others.</p>
<p>The class is built on the following premise: One frequently has some work that needs to be done on a sequence of objects; a prototypical example is assembling cell contributions to a system matrix or right hand side. In many such examples, part of the work can be done entirely independently and in parallel, possibly using several processor cores on a machine with shared memory. However, some other part of this work may need to be synchronised and be done in order. In the example of assembling a matrix, the computation of local contributions can be done entirely in parallel, but copying the local contributions into the global matrix requires some care: First, several threads can't write at the same time, but need to synchronise writing using a mutex; secondly, we want the order in which local contributions are added to the global matrix to be always the same because floating point addition is not commutative and adding local contributions to the global matrix in different orders leads to subtly different results that can affect the number of iterations for iterative solvers as well as the round-off error in the solution in random ways. Consequently, we want to ensure that only one thread at a time writes into the global matrix, and that results are copied in a stable and reproducible order.</p>
<p>This class implements a framework for this work model. It works with a stream of objects given by an iterator range, runs a worker function in parallel on all of these objects and then passes each object to a postprocessor function that runs sequentially and gets objects in exactly the order in which they appear in the input iterator range. None of the synchronisation work is exposed to the user of this class.</p>
<p>Internally, the range given to the <a class="el" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run()</a> function of this class is split into a sequence of "items", which are then distributed according to some internal algorithm onto the number of available threads. An item is an element of the range of iterators on which we are to operate; for example, for the purpose of assembling matrices or evaluating error indicators, an item could be a cell. The TBB library determines how many threads are created (typically as many as there are processor cores), but the number of items that may be active at any given time is specified by the argument to the constructor. It should be bigger or equal to the number of processor cores - the default is four times the number of cores on the current system.</p>
<p>Items are created upon request by the TBB whenever one of the worker threads is idle or is expected to become idle. It is then handed off to a worker function, typically a member function of a main class. These worker functions are run in parallel on a number of threads, and there is no guarantee that they are asked to work on items in any particular order, in particular not necessarily in the order in which items are generated from the iterator range.</p>
<p>Typically, worker functions need additional data, for example <a class="el" href="classFEValues.html">FEValues</a> objects, input data vectors, etc, some of which can not be shared among threads. To this end, the <a class="el" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run()</a> function takes another template argument, ScratchData, which designates a type objects of which are stored with each item and which threads can use as private data without having to share them with other threads. The <a class="el" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run()</a> function takes an additional argument with an object of type ScratchData that is going to be copied for the arguments passed to each of the worker functions.</p>
<p>In addition, worker functions store their results in objects of template type CopyData. These are then handed off to a separate function, called copier, that may use the stored results to transfer them into permanent storage. For example, it may copy the results of local contributions to a matrix computed by a worker function into the global matrix. In contrast to the worker function, however, only one instance of the copier is run at any given time; it can therefore safely copy local contributions into the global matrix without the need to lock the global object using a mutex or similar means. Furthermore, it is guaranteed that the copier is run with CopyData objects in the same order in which their associated items were created; consequently, even if worker threads may compute results in unspecified order, the copier always receives the results in exactly the same order as the items were created.</p>
<p>Once an item is processed by the copier, it is deleted and the ScratchData and CopyData objects that were used in its computation are considered unused and may be re-used for the next invocation of the worker function, on this or another thread.</p>
<p>The member variables in ScratchData and CopyData can be accessed independently of other concurrent uses of copies of these data structures. Therefore, it is perfectly fine to resize auxiliary data structures associated with ScratchData and CopyData to different lengths on each cell. For example, a vector holding densities at each quadrature point which is used with <a class="el" href="namespaceLocalIntegrators_1_1L2.html#a8f1bef9e8fe15148294b8ac6da83c2ae">LocalIntegrators::L2::weighted_mass_matrix()</a> to assemble the local matrix could be resized to the corresponding number of quadrature points of the current cell in <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. Similarly, local stiffness matrix in CopyData can be resized in accordance with the number of local DoFs on the current cell.</p>
<p>The functions in this namespace only really work in parallel when multithread mode was selected during deal.II configuration. Otherwise they simply work on each item sequentially.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2007, 2008, 2009, 2013. Bruno Turcksin, 2013. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a0c5d332d74a4df80784140218896b169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5d332d74a4df80784140218896b169">&#9670;&nbsp;</a></span>run() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Iterator &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>colored_iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2*<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is one of two main functions of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept, doing work as described in the introduction to this namespace. It corresponds to implementation 3 of the paper by Turcksin, Kronbichler and Bangerth, see <a class="el" href="DEALGlossary.html#workstream_paper">workstream_paper</a>. As such, it takes not a range of iterators described by a begin and end iterator, but a "colored" graph of iterators where each color represents cells for which writing the cell contributions into the global object does not conflict (in other words, these cells are not neighbors). Each "color" is represented by std::vectors of cells. The first argument to this function, a set of sets of cells (which are represent as a vector of vectors, for efficiency), is typically constructed by calling <a class="el" href="namespaceGraphColoring.html#a670720d11f544a762592112ae5213876">GraphColoring::make_graph_coloring()</a>. See there for more information.</p>
<p>This function that can be used for worker and copier objects that are either pointers to non-member functions or objects that allow to be called with an operator(), for example objects created by std::bind.</p>
<p>The two data types <code>ScratchData</code> and <code>CopyData</code> need to have a working copy constructor. <code>ScratchData</code> is only used in the <code>worker</code> function, while <code>CopyData</code> is the object passed from the <code>worker</code> to the <code>copier</code>.</p>
<p>The <code>queue_length</code> argument indicates the number of items that can be live at any given time. Each item consists of <code>chunk_size</code> elements of the input stream that will be worked on by the worker and copier functions one after the other on the same thread.</p>
<dl class="section note"><dt>Note</dt><dd>If your data objects are large, or their constructors are expensive, it is helpful to keep in mind that <code>queue_length</code> copies of the <code>ScratchData</code> object and <code>queue_length*chunk_size</code> copies of the <code>CopyData</code> object are generated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01106">1106</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc1160c09f1fee6b2a5a4d0d3fa3f4e">&#9670;&nbsp;</a></span>run() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2*<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is one of two main functions of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept, doing work as described in the introduction to this namespace. It corresponds to implementation 2 of the paper by Turcksin, Kronbichler and Bangerth (see <a class="el" href="DEALGlossary.html#workstream_paper">workstream_paper</a>).</p>
<p>This function that can be used for worker and copier objects that are either pointers to non-member functions or objects that allow to be called with an operator(), for example objects created by std::bind. If the copier is an empty function, it is ignored in the pipeline.</p>
<p>The argument passed as <code>end</code> must be convertible to the same type as <code>begin</code>, but doesn't have to be of the same type itself. This allows to write code like <code>WorkStream().run(dof_handler.begin_active(), dof_handler.end(), ...</code> where the first is of type <a class="el" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler::active_cell_iterator</a> whereas the second is of type DoFHandler::raw_cell_iterator.</p>
<p>The two data types <code>ScratchData</code> and <code>CopyData</code> need to have a working copy constructor. <code>ScratchData</code> is only used in the <code>worker</code> function, while <code>CopyData</code> is the object passed from the <code>worker</code> to the <code>copier</code>.</p>
<p>The <code>queue_length</code> argument indicates the number of items that can be live at any given time. Each item consists of <code>chunk_size</code> elements of the input stream that will be worked on by the worker and copier functions one after the other on the same thread.</p>
<dl class="section note"><dt>Note</dt><dd>If your data objects are large, or their constructors are expensive, it is helpful to keep in mind that <code>queue_length</code> copies of the <code>ScratchData</code> object and <code>queue_length*chunk_size</code> copies of the <code>CopyData</code> object are generated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00994">994</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a2f054e2848cf513aec9e5e4eb115bef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f054e2848cf513aec9e5e4eb115bef4">&#9670;&nbsp;</a></span>run() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;)&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CopyData &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2*<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a variant of one of the two main functions of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept, doing work as described in the introduction to this namespace. It corresponds to implementation 2 of the paper by Turcksin, Kronbichler and Bangerth (see <a class="el" href="DEALGlossary.html#workstream_paper">workstream_paper</a>).</p>
<p>This is the function that can be used for worker and copier functions that are member functions of a class. If the copier is an empty function, it is ignored in the pipeline.</p>
<p>The argument passed as <code>end</code> must be convertible to the same type as <code>begin</code>, but doesn't have to be of the same type itself. This allows to write code like <code>WorkStream().run(dof_handler.begin_active(), dof_handler.end(), ...</code> where the first is of type <a class="el" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler::active_cell_iterator</a> whereas the second is of type DoFHandler::raw_cell_iterator.</p>
<p>The <code>queue_length</code> argument indicates the number of items that can be live at any given time. Each item consists of <code>chunk_size</code> elements of the input stream that will be worked on by the worker and copier functions one after the other on the same thread.</p>
<dl class="section note"><dt>Note</dt><dd>If your data objects are large, or their constructors are expensive, it is helpful to keep in mind that <code>queue_length</code> copies of the <code>ScratchData</code> object and <code>queue_length*chunk_size</code> copies of the <code>CopyData</code> object are generated. </dd></dl>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01217">1217</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
