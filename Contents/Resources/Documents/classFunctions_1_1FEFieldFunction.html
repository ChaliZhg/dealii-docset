<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Functions::FEFieldFunction&lt; dim, DoFHandlerType, VectorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFunctions.html">Functions</a></li><li class="navelem"><a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctions_1_1FEFieldFunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Functions::FEFieldFunction&lt; dim, DoFHandlerType, VectorType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__field__function_8h_source.html">deal.II/numerics/fe_field_function.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Functions::FEFieldFunction&lt; dim, DoFHandlerType, VectorType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFunctions_1_1FEFieldFunction__inherit__graph.svg" width="468" height="326"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9ab8a8ad973ccc27c2e30a97b131ae5b"><td class="memItemLeft" align="right" valign="top">typedef VectorTools::ExcPointNotAvailableHere&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a9ab8a8ad973ccc27c2e30a97b131ae5b">ExcPointNotAvailableHere</a></td></tr>
<tr class="separator:a9ab8a8ad973ccc27c2e30a97b131ae5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6cea91369868d379fbd92beb0d368c99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a6cea91369868d379fbd92beb0d368c99">FEFieldFunction</a> (const DoFHandlerType &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#ae0d77692484493a0c2c836f045e9eec6">dh</a>, const VectorType &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#ac16c620c58be395b9c2a79484667ebd6">data_vector</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#af1fe1814b55cbea129b17972634a02c4">mapping</a>=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#af1fe1814b55cbea129b17972634a02c4">mapping</a>)</td></tr>
<tr class="separator:a6cea91369868d379fbd92beb0d368c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0206a45c90d523792eea8bd725d14788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a0206a45c90d523792eea8bd725d14788">set_active_cell</a> (const typename DoFHandlerType::active_cell_iterator &amp;newcell)</td></tr>
<tr class="separator:a0206a45c90d523792eea8bd725d14788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe6caca665fe6fe8815277a883b9b0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#acbe6caca665fe6fe8815277a883b9b0c">vector_value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;values) const</td></tr>
<tr class="separator:acbe6caca665fe6fe8815277a883b9b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7214b0963ff8ce16371ba0c9a3e40f23"><td class="memItemLeft" align="right" valign="top">virtual VectorType::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a7214b0963ff8ce16371ba0c9a3e40f23">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component=0) const</td></tr>
<tr class="separator:a7214b0963ff8ce16371ba0c9a3e40f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef70563aeedf035286b5784637c02ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a0ef70563aeedf035286b5784637c02ff">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; typename VectorType::value_type &gt; &amp;values, const unsigned int component=0) const</td></tr>
<tr class="separator:a0ef70563aeedf035286b5784637c02ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2b77793983b3851e66986bd0440b06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a8e2b77793983b3851e66986bd0440b06">vector_value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:a8e2b77793983b3851e66986bd0440b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab558c1dbe0dbea795626d083bb162fb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ab558c1dbe0dbea795626d083bb162fb1">vector_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:ab558c1dbe0dbea795626d083bb162fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa762ff112a8c08190731c4dd731ddbbc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#aa762ff112a8c08190731c4dd731ddbbc">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component=0) const</td></tr>
<tr class="separator:aa762ff112a8c08190731c4dd731ddbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf78e24a88ef86dbe453093b5156dc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a8bf78e24a88ef86dbe453093b5156dc9">vector_gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;p, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt; &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:a8bf78e24a88ef86dbe453093b5156dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f90a990d4520c9bd650a9a88a0c498"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a66f90a990d4520c9bd650a9a88a0c498">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt; &gt; &amp;gradients, const unsigned int component=0) const</td></tr>
<tr class="separator:a66f90a990d4520c9bd650a9a88a0c498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00aa2634eb71a970efc386a9894156d"><td class="memItemLeft" align="right" valign="top">virtual VectorType::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#af00aa2634eb71a970efc386a9894156d">laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component=0) const</td></tr>
<tr class="separator:af00aa2634eb71a970efc386a9894156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc120fdc8753fb5637a6f6595e2f8c97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#adc120fdc8753fb5637a6f6595e2f8c97">vector_laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;values) const</td></tr>
<tr class="separator:adc120fdc8753fb5637a6f6595e2f8c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59761ccb79de86214f6292dd671fb5af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a59761ccb79de86214f6292dd671fb5af">laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; typename VectorType::value_type &gt; &amp;values, const unsigned int component=0) const</td></tr>
<tr class="separator:a59761ccb79de86214f6292dd671fb5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60974ae1132bcf519d1408a6f802993b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a60974ae1132bcf519d1408a6f802993b">vector_laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:a60974ae1132bcf519d1408a6f802993b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9753264dce559c83e425113255c25bc5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a9753264dce559c83e425113255c25bc5">compute_point_locations</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;cells, std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; &amp;qpoints, std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;maps) const</td></tr>
<tr class="separator:a9753264dce559c83e425113255c25bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFunction"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFunction')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFunction.html">Function&lt; dim, VectorType::value_type &gt;</a></td></tr>
<tr class="memitem:a64e0444dbd116d8973d4c273b674c78c inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a64e0444dbd116d8973d4c273b674c78c">Function</a> (const unsigned int <a class="el" href="classFunction.html#aa568b98591fc2bda09b28539789aef7d">n_components</a>=1, const VectorType::value_type initial_time=0.0)</td></tr>
<tr class="separator:a64e0444dbd116d8973d4c273b674c78c inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd5482e6631815bf133d5713a32218c inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#adbd5482e6631815bf133d5713a32218c">~Function</a> ()=0</td></tr>
<tr class="separator:adbd5482e6631815bf133d5713a32218c inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cd7842d43168754914691c7e5223af inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunction.html">Function</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a53cd7842d43168754914691c7e5223af">operator=</a> (const <a class="el" href="classFunction.html">Function</a> &amp;f)</td></tr>
<tr class="separator:a53cd7842d43168754914691c7e5223af inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4077e15018afc886cad3a0aacf84fe inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a7b4077e15018afc886cad3a0aacf84fe">vector_values</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; std::vector&lt; VectorType::value_type &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:a7b4077e15018afc886cad3a0aacf84fe inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7191ac63b2c509006816292f0534746d inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a7191ac63b2c509006816292f0534746d">vector_gradients</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorType::value_type &gt; &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:a7191ac63b2c509006816292f0534746d inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44403c420008a656ca4b2b67b8fef612 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a44403c420008a656ca4b2b67b8fef612">hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component=0) const</td></tr>
<tr class="separator:a44403c420008a656ca4b2b67b8fef612 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9c5f366e9199c3a58c19e8c59438ff inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a8f9c5f366e9199c3a58c19e8c59438ff">vector_hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:a8f9c5f366e9199c3a58c19e8c59438ff inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e54059d18d0c219e21960e10468ed8 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a10e54059d18d0c219e21960e10468ed8">hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt; &gt; &amp;values, const unsigned int component=0) const</td></tr>
<tr class="separator:a10e54059d18d0c219e21960e10468ed8 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4066baf55f52f5e16e416248a295a26e inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a4066baf55f52f5e16e416248a295a26e">vector_hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt; &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:a4066baf55f52f5e16e416248a295a26e inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443e7821eff5166d3a412ee31cf3bb97 inherit pub_methods_classFunction"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a443e7821eff5166d3a412ee31cf3bb97">memory_consumption</a> () const</td></tr>
<tr class="separator:a443e7821eff5166d3a412ee31cf3bb97 inherit pub_methods_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFunctionTime"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFunctionTime')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFunctionTime.html">FunctionTime&lt; Number &gt;</a></td></tr>
<tr class="memitem:afd664d1ab89910d8cffb428a9e9777fc inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#afd664d1ab89910d8cffb428a9e9777fc">FunctionTime</a> (const Number initial_time=Number(0.0))</td></tr>
<tr class="separator:afd664d1ab89910d8cffb428a9e9777fc inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23694f544121f225f67047e31de055b5 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a23694f544121f225f67047e31de055b5">~FunctionTime</a> ()</td></tr>
<tr class="separator:a23694f544121f225f67047e31de055b5 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () const</td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (const Number new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772 inherit pub_methods_classFunctionTime"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (const Number delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772 inherit pub_methods_classFunctionTime"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ac064b53b80a8a18f039f04398f9d7993"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; typename DoFHandlerType::active_cell_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ac064b53b80a8a18f039f04398f9d7993">cell_hint_t</a></td></tr>
<tr class="separator:ac064b53b80a8a18f039f04398f9d7993"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac7aceb2981554349a0fa62c8aca82ae1"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ac7aceb2981554349a0fa62c8aca82ae1">get_reference_coordinates</a> (const typename DoFHandlerType::active_cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;point) const</td></tr>
<tr class="separator:ac7aceb2981554349a0fa62c8aca82ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae0d77692484493a0c2c836f045e9eec6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const DoFHandlerType, <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ae0d77692484493a0c2c836f045e9eec6">dh</a></td></tr>
<tr class="separator:ae0d77692484493a0c2c836f045e9eec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16c620c58be395b9c2a79484667ebd6"><td class="memItemLeft" align="right" valign="top">const VectorType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ac16c620c58be395b9c2a79484667ebd6">data_vector</a></td></tr>
<tr class="separator:ac16c620c58be395b9c2a79484667ebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fe1814b55cbea129b17972634a02c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#af1fe1814b55cbea129b17972634a02c4">mapping</a></td></tr>
<tr class="separator:af1fe1814b55cbea129b17972634a02c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193ac0154cad97a0f1f26fe9640c0904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ac064b53b80a8a18f039f04398f9d7993">cell_hint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a193ac0154cad97a0f1f26fe9640c0904">cell_hint</a></td></tr>
<tr class="separator:a193ac0154cad97a0f1f26fe9640c0904"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classFunction"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classFunction')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classFunction.html">Function&lt; dim, VectorType::value_type &gt;</a></td></tr>
<tr class="memitem:aa568b98591fc2bda09b28539789aef7d inherit pub_attribs_classFunction"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aa568b98591fc2bda09b28539789aef7d">n_components</a></td></tr>
<tr class="separator:aa568b98591fc2bda09b28539789aef7d inherit pub_attribs_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classFunction"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classFunction')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classFunction.html">Function&lt; dim, VectorType::value_type &gt;</a></td></tr>
<tr class="memitem:afd612335927c8fb14c9a851ac4ac1e8b inherit pub_static_attribs_classFunction"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#afd612335927c8fb14c9a851ac4ac1e8b">dimension</a></td></tr>
<tr class="separator:afd612335927c8fb14c9a851ac4ac1e8b inherit pub_static_attribs_classFunction"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt;<br />
class Functions::FEFieldFunction&lt; dim, DoFHandlerType, VectorType &gt;</h3>

<p>This is an interpolation function for the given dof handler and the given solution vector. The points at which this function can be evaluated MUST be inside the domain of the dof handler, but except from this, no other requirement is given. This function is rather slow, as it needs to construct a quadrature object for the point (or set of points) where you want to evaluate your finite element function. In order to do so, it needs to find out where the points lie.</p>
<p>If you know in advance in which cell your points lie, you can accelerate things a bit, by calling set_active_cell before asking for values or gradients of the function. If you don't do this, and your points don't lie in the cell that is currently stored, the function GridTools::find_cell_around_point is called to find out where the point is. You can specify an optional mapping to use when looking for points in the grid. If you don't do so, this function uses a Q1 mapping.</p>
<p>Once the <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> knows where the points lie, it creates a quadrature formula for those points, and calls <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> or <a class="el" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">FEValues::get_function_gradients</a> with the given quadrature points.</p>
<p>If you only need the quadrature points but not the values of the finite element function (you might want this for the adjoint interpolation), you can also use the function <code>compute_point_locations</code> alone.</p>
<p>An example of how to use this function is the following:</p>
<div class="fragment"><div class="line"><span class="comment">// Generate two triangulations</span></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_1;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_2;</div><div class="line"></div><div class="line"><span class="comment">// Read the triangulations from files, or build them up, or get them</span></div><div class="line"><span class="comment">// from some place. Assume that tria_2 is *entirely* included in tria_1.</span></div><div class="line"></div><div class="line"><span class="comment">// Associate a dof handler and a solution to the first triangulation</span></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dh1 (tria_1);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_1;</div><div class="line"></div><div class="line"><span class="comment">// Do the same with the second</span></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dh2 (tria_2);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_2;</div><div class="line"></div><div class="line"><span class="comment">// Setup the system, assemble matrices, solve problems and get the</span></div><div class="line"><span class="comment">// nobel prize on the first domain...</span></div><div class="line"></div><div class="line"><span class="comment">// Now project it to the second domain</span></div><div class="line">FEFieldFunction&lt;dim&gt; fe_function_1 (dh_1, solution_1);</div><div class="line"><a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> (dh_2, constraints_2, quad, fe_function_1, solution_2);</div><div class="line"></div><div class="line"><span class="comment">// Or interpolate it...</span></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_3;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a> (dh_2, fe_function_1, solution_3);</div></div><!-- fragment --><p>The snippet of code above will work assuming that the second triangulation is entirely included in the first one.</p>
<p><a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> is designed to be an easy way to get the results of your computations across different, possibly non matching, grids. No knowledge of the location of the points is assumed in this class, which makes it rely entirely on the <a class="el" href="namespaceGridTools.html#aa57c66000d93c12c70f05995c0c3308f">GridTools::find_active_cell_around_point</a> utility for its job. However the class can be fed an "educated guess" of where the points that will be computed actually are by using the <a class="el" href="classFunctions_1_1FEFieldFunction.html#a0206a45c90d523792eea8bd725d14788">FEFieldFunction::set_active_cell</a> method, so if you have a smart way to tell where your points are, you will save a lot of computational time by letting this class know.</p>
<h3>Using <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></h3>
<p>When using this class with a parallel distributed triangulation object and evaluating the solution at a particular point, not every processor will own the cell at which the solution is evaluated. Rather, it may be that the cell in which this point is found is in fact a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). If the cell is artificial, we have no access to the solution there and functions that evaluate the solution at such a point will trigger an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a>. The same kind of exception will also be produced if the cell is a ghost cell: On such cells, one could in principle evaluate the solution, but it becomes easier if we do not allow to do so because then there is exactly one processor in a parallel distributed computation that can indeed evaluate the solution. Consequently, it is clear which processor is responsible for producing output if the point evaluation is done as a postprocessing step.</p>
<p>To deal with this situation, you will want to use code as follows when, for example, evaluating the solution at the origin (here using a parallel <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> vector to hold the solution): </p><div class="fragment"><div class="line"><a class="code" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction&lt;dim,DoFHandler&lt;dim&gt;</a>,<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&gt;</div><div class="line">  solution_function (dof_handler, solution);</div><div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> origin = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> solution_at_origin;</div><div class="line"><span class="keywordtype">bool</span>   point_found = <span class="keyword">true</span>;</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    solution_at_origin = solution_function.value (origin);</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> &amp;)</div><div class="line">  {</div><div class="line">    point_found = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (point_found == <span class="keyword">true</span>)</div><div class="line">  ...do something...;</div></div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>Luca Heltai, 2006, Markus Buerg, 2012, Wolfgang Bangerth, 2013 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00165">165</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9ab8a8ad973ccc27c2e30a97b131ae5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab8a8ad973ccc27c2e30a97b131ae5b">&#9670;&nbsp;</a></span>ExcPointNotAvailableHere</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VectorTools::ExcPointNotAvailableHere <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#a9ab8a8ad973ccc27c2e30a97b131ae5b">ExcPointNotAvailableHere</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000111">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00420">420</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="ac064b53b80a8a18f039f04398f9d7993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac064b53b80a8a18f039f04398f9d7993">&#9670;&nbsp;</a></span>cell_hint_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt;typename DoFHandlerType::active_cell_iterator &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#ac064b53b80a8a18f039f04398f9d7993">cell_hint_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef holding the local cell_hint. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00428">428</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6cea91369868d379fbd92beb0d368c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cea91369868d379fbd92beb0d368c99">&#9670;&nbsp;</a></span>FEFieldFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>data_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#af1fe1814b55cbea129b17972634a02c4">mapping</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a vector function. A smart pointers is stored to the dof handler, so you have to make sure that it make sense for the entire lifetime of this object. The number of components of this functions is equal to the number of components of the finite element object. If a mapping is specified, that is what is used to find out where the points lay. Otherwise the standard Q1 mapping is used. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0206a45c90d523792eea8bd725d14788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0206a45c90d523792eea8bd725d14788">&#9670;&nbsp;</a></span>set_active_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::set_active_cell </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandlerType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>newcell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current cell. If you know in advance where your points lie, you can tell this object by calling this function. This will speed things up a little. </p>

</div>
</div>
<a id="acbe6caca665fe6fe8815277a883b9b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe6caca665fe6fe8815277a883b9b0c">&#9670;&nbsp;</a></span>vector_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one vector value at the given point. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#a8e2b77793983b3851e66986bd0440b06">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a7214b0963ff8ce16371ba0c9a3e40f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7214b0963ff8ce16371ba0c9a3e40f23">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual VectorType::value_type <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the function at the given point. Unless there is only one component (i.e. the function is scalar), you should state the component you want to have evaluated; it defaults to zero, i.e. the first component. It is inefficient to use single points. If you need more than one at a time, use the vector_value_list function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a0ef70563aeedf035286b5784637c02ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef70563aeedf035286b5784637c02ff">&#9670;&nbsp;</a></span>value_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the specified component of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the points array. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#afc0acd3155a0c854dee816a096d88165">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a8e2b77793983b3851e66986bd0440b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2b77793983b3851e66986bd0440b06">&#9670;&nbsp;</a></span>vector_value_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the points array. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="ab558c1dbe0dbea795626d083bb162fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab558c1dbe0dbea795626d083bb162fb1">&#9670;&nbsp;</a></span>vector_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at the given point. It is inefficient to use single points. If you need more than one at a time, use the vector_value_list function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#aea958afc9352a3162c132d1991ade93f">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="aa762ff112a8c08190731c4dd731ddbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa762ff112a8c08190731c4dd731ddbbc">&#9670;&nbsp;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1,dim,typename VectorType::value_type&gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at the given point. It is inefficient to use single points. If you need more than one at a time, use the vector_value_list function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#ae0a836ba78787fed039c5a097bdda854">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a8bf78e24a88ef86dbe453093b5156dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf78e24a88ef86dbe453093b5156dc9">&#9670;&nbsp;</a></span>vector_gradient_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at all the given points. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#afab12066cc2972b2d6133828133abd12">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a66f90a990d4520c9bd650a9a88a0c498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f90a990d4520c9bd650a9a88a0c498">&#9670;&nbsp;</a></span>gradient_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at all the given points. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a4fca42e4d75fb372b3471ec5ee8ee920">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="af00aa2634eb71a970efc386a9894156d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00aa2634eb71a970efc386a9894156d">&#9670;&nbsp;</a></span>laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual VectorType::value_type <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of a given component at point <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a0218f83588d457a979bf7b707af87aef">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="adc120fdc8753fb5637a6f6595e2f8c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc120fdc8753fb5637a6f6595e2f8c97">&#9670;&nbsp;</a></span>vector_laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of all components at point <code>p</code> and store them in <code>values</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#aecbc8a4b0970df27f3f1d469ef9dc76b">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a59761ccb79de86214f6292dd671fb5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59761ccb79de86214f6292dd671fb5af">&#9670;&nbsp;</a></span>laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of one component at a set of points.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a2bf52de05ee9c500b80c473c94dea21b">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a60974ae1132bcf519d1408a6f802993b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60974ae1132bcf519d1408a6f802993b">&#9670;&nbsp;</a></span>vector_laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::vector_laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacians of all components at a set of points.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that does not lie in a locally owned cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#af669dc796c14520460f76704d79c08a6">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a9753264dce559c83e425113255c25bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9753264dce559c83e425113255c25bc5">&#9670;&nbsp;</a></span>compute_point_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::compute_point_locations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>qpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create quadrature rules. This function groups the points into blocks that live in the same cell, and fills up three vectors: <code>cells</code>, <code>qpoints</code> and <code>maps</code>. The first is a list of the cells that contain the points, the second is a list of quadrature points matching each cell of the first list, and the third contains the index of the given quadrature points, i.e., <code>points</code>[maps[3][4]] ends up as the 5th quadrature point in the 4th cell. This is where optimization would help. This function returns the number of cells that contain the given set of points. </p>

</div>
</div>
<a id="ac7aceb2981554349a0fa62c8aca82ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7aceb2981554349a0fa62c8aca82ae1">&#9670;&nbsp;</a></span>get_reference_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::get_reference_coordinates </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandlerType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a cell, return the reference coordinates of the given point within this cell if it indeed lies within the cell. Otherwise return an uninitialized boost::optional object. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae0d77692484493a0c2c836f045e9eec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d77692484493a0c2c836f045e9eec6">&#9670;&nbsp;</a></span>dh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const DoFHandlerType,<a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a>&lt;dim, DoFHandlerType, VectorType&gt; &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::dh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the dof handler. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00433">433</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="ac16c620c58be395b9c2a79484667ebd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16c620c58be395b9c2a79484667ebd6">&#9670;&nbsp;</a></span>data_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorType&amp; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::data_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to the actual data vector. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00438">438</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="af1fe1814b55cbea129b17972634a02c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1fe1814b55cbea129b17972634a02c4">&#9670;&nbsp;</a></span>mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMapping.html">Mapping</a>&lt;dim&gt;&amp; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to the mapping being used. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00443">443</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="a193ac0154cad97a0f1f26fe9640c0904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193ac0154cad97a0f1f26fe9640c0904">&#9670;&nbsp;</a></span>cell_hint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename DoFHandlerType = DoFHandler&lt;dim&gt;, typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ac064b53b80a8a18f039f04398f9d7993">cell_hint_t</a> <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, DoFHandlerType, VectorType &gt;::cell_hint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The latest cell hint. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00448">448</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deal.II/numerics/<a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
