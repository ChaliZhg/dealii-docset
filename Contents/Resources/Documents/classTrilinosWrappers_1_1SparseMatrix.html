<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TrilinosWrappers::SparseMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></li><li class="navelem"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTrilinosWrappers_1_1SparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TrilinosWrappers::SparseMatrix Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__TrilinosWrappers.html">TrilinosWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trilinos__sparse__matrix_8h_source.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TrilinosWrappers::SparseMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTrilinosWrappers_1_1SparseMatrix__inherit__graph.svg" width="182" height="123"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTrilinosWrappers_1_1SparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afe482aa470fc1e948eabce22fbe0bad6"><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a></td></tr>
<tr class="separator:afe482aa470fc1e948eabce22fbe0bad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bbbe25812a885629f61c0adb78161d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a></td></tr>
<tr class="separator:af2bbbe25812a885629f61c0adb78161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7cd05f0a29cf3725d7323c961938e5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a></td></tr>
<tr class="separator:a2b7cd05f0a29cf3725d7323c961938e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0bc8a994f8441b1089b01d1eb2b1f"><td class="memItemLeft" align="right" valign="top">typedef TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2b0bc8a994f8441b1089b01d1eb2b1f">value_type</a></td></tr>
<tr class="separator:ae2b0bc8a994f8441b1089b01d1eb2b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization.</div></td></tr>
<tr class="memitem:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a637dbbd4e8ca9fc07a447c8f31e21647">SparseMatrix</a> ()</td></tr>
<tr class="separator:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3900dae374f5a71e5134840682662d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab3900dae374f5a71e5134840682662d8">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a>, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a>, const unsigned int n_max_entries_per_row)</td></tr>
<tr class="separator:ab3900dae374f5a71e5134840682662d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944e51f3f5f0202024e04b679172ec9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a944e51f3f5f0202024e04b679172ec9e">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a>, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a>, const std::vector&lt; unsigned int &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a944e51f3f5f0202024e04b679172ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2b62a80dac30c548e1d20c3e77beae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0b2b62a80dac30c548e1d20c3e77beae">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;InputSparsityPattern)</td></tr>
<tr class="separator:a0b2b62a80dac30c548e1d20c3e77beae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2377111964e6c6945cefc8886ffc1b64"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2377111964e6c6945cefc8886ffc1b64">~SparseMatrix</a> ()</td></tr>
<tr class="separator:a2377111964e6c6945cefc8886ffc1b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ca8e186fe3c61e03a52369437157e"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a614ca8e186fe3c61e03a52369437157e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a> (const SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:a614ca8e186fe3c61e03a52369437157e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602232080f91baba93c85684937765d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a602232080f91baba93c85684937765d5">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern)</td></tr>
<tr class="separator:a602232080f91baba93c85684937765d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbc81d639cb5c12f2e2b59072e64f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5cbc81d639cb5c12f2e2b59072e64f39">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;sparse_matrix)</td></tr>
<tr class="separator:a5cbc81d639cb5c12f2e2b59072e64f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688b87cdf4067fc28483d5385b1dabda"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a688b87cdf4067fc28483d5385b1dabda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a688b87cdf4067fc28483d5385b1dabda">reinit</a> (const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const double drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr)</td></tr>
<tr class="separator:a688b87cdf4067fc28483d5385b1dabda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743888addc7cfd057c70ceff1e03cc02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a743888addc7cfd057c70ceff1e03cc02">reinit</a> (const Epetra_CrsMatrix &amp;input_matrix, const bool copy_values=true)</td></tr>
<tr class="separator:a743888addc7cfd057c70ceff1e03cc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an Epetra_Map description</div></td></tr>
<tr class="memitem:a439ef5bbec8d78559d0b1b83cd45921e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a439ef5bbec8d78559d0b1b83cd45921e">SparseMatrix</a> (const Epetra_Map &amp;parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_max_entries_per_row=0) 1</td></tr>
<tr class="separator:a439ef5bbec8d78559d0b1b83cd45921e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75e4f48c786721c01b03ee93279b19a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac75e4f48c786721c01b03ee93279b19a">SparseMatrix</a> (const Epetra_Map &amp;parallel_partitioning, const std::vector&lt; unsigned int &gt; &amp;n_entries_per_row) 1</td></tr>
<tr class="separator:ac75e4f48c786721c01b03ee93279b19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd1ca502a778202b00aebeec70cfce9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aabd1ca502a778202b00aebeec70cfce9">SparseMatrix</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_max_entries_per_row=0) 1</td></tr>
<tr class="separator:aabd1ca502a778202b00aebeec70cfce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21edfb5a4fc3243526f2531d0283e9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae21edfb5a4fc3243526f2531d0283e9f">SparseMatrix</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const std::vector&lt; unsigned int &gt; &amp;n_entries_per_row) 1</td></tr>
<tr class="separator:ae21edfb5a4fc3243526f2531d0283e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e97c95de408a61ee1fc8f272484c83"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ab9e97c95de408a61ee1fc8f272484c83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9e97c95de408a61ee1fc8f272484c83">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const SparsityPatternType &amp;sparsity_pattern, const bool exchange_data=false) 1</td></tr>
<tr class="separator:ab9e97c95de408a61ee1fc8f272484c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190ec04ad7c8ebdd29a5cf5eebd6a62f"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a190ec04ad7c8ebdd29a5cf5eebd6a62f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a190ec04ad7c8ebdd29a5cf5eebd6a62f">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const SparsityPatternType &amp;sparsity_pattern, const bool exchange_data=false) 1</td></tr>
<tr class="separator:a190ec04ad7c8ebdd29a5cf5eebd6a62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e521bdc023c29921d6f3362623d8347"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a4e521bdc023c29921d6f3362623d8347"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4e521bdc023c29921d6f3362623d8347">reinit</a> (const Epetra_Map &amp;parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const double drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr) 1</td></tr>
<tr class="separator:a4e521bdc023c29921d6f3362623d8347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1618d2492ea33d57af615c26ff889173"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a1618d2492ea33d57af615c26ff889173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1618d2492ea33d57af615c26ff889173">reinit</a> (const Epetra_Map &amp;row_parallel_partitioning, const Epetra_Map &amp;col_parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const double drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr) 1</td></tr>
<tr class="separator:a1618d2492ea33d57af615c26ff889173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an IndexSet description</div></td></tr>
<tr class="memitem:abf1eceecf61d5aacdb1192a6a0bded7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abf1eceecf61d5aacdb1192a6a0bded7e">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const unsigned int n_max_entries_per_row=0)</td></tr>
<tr class="separator:abf1eceecf61d5aacdb1192a6a0bded7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d44ae4cf732744c50027c8d36f2a758"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9d44ae4cf732744c50027c8d36f2a758">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; unsigned int &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a9d44ae4cf732744c50027c8d36f2a758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60748f3e8d3fbea4b3a4c192ff7d8455"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a60748f3e8d3fbea4b3a4c192ff7d8455">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_max_entries_per_row=0)</td></tr>
<tr class="separator:a60748f3e8d3fbea4b3a4c192ff7d8455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128b8b864bec45fa1115e43206861f22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a128b8b864bec45fa1115e43206861f22">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const MPI_Comm &amp;communicator, const std::vector&lt; unsigned int &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a128b8b864bec45fa1115e43206861f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5f926afa37ddbe5ffe18ecb1f037a8"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:abb5f926afa37ddbe5ffe18ecb1f037a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abb5f926afa37ddbe5ffe18ecb1f037a8">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const SparsityPatternType &amp;sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const bool exchange_data=false)</td></tr>
<tr class="separator:abb5f926afa37ddbe5ffe18ecb1f037a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2ec0234fcfe5687d53d6d3fb834600"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a8f2ec0234fcfe5687d53d6d3fb834600"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8f2ec0234fcfe5687d53d6d3fb834600">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const SparsityPatternType &amp;sparsity_pattern, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const bool exchange_data=false)</td></tr>
<tr class="separator:a8f2ec0234fcfe5687d53d6d3fb834600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4023e59f650260e3002a7a7ec2548313"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a4023e59f650260e3002a7a7ec2548313"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4023e59f650260e3002a7a7ec2548313">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const double drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr)</td></tr>
<tr class="separator:a4023e59f650260e3002a7a7ec2548313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7443128fe3987f117365d755839f62"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a2f7443128fe3987f117365d755839f62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2f7443128fe3987f117365d755839f62">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const MPI_Comm &amp;communicator=MPI_COMM_WORLD, const double drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr)</td></tr>
<tr class="separator:a2f7443128fe3987f117365d755839f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information on the matrix</div></td></tr>
<tr class="memitem:ab9cf2620cc3350eb189597bd2831570a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a> () const</td></tr>
<tr class="separator:ab9cf2620cc3350eb189597bd2831570a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371d418cc093230813c36578f32f0966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a> () const</td></tr>
<tr class="separator:a371d418cc093230813c36578f32f0966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a8c1f20e048f5a7b9711218779fad5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2a8c1f20e048f5a7b9711218779fad5">local_size</a> () const</td></tr>
<tr class="separator:ac2a8c1f20e048f5a7b9711218779fad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557eb5dabea73fb2d3e2ba70226cdfcf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a557eb5dabea73fb2d3e2ba70226cdfcf">local_range</a> () const</td></tr>
<tr class="separator:a557eb5dabea73fb2d3e2ba70226cdfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998d6f1a926b04ec7c1a967f46775282"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a998d6f1a926b04ec7c1a967f46775282">in_local_range</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> index) const</td></tr>
<tr class="separator:a998d6f1a926b04ec7c1a967f46775282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d73bf5ba9422c98651107cc9dfbac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae26d73bf5ba9422c98651107cc9dfbac">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:ae26d73bf5ba9422c98651107cc9dfbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245c41459e8f4100994de6dfb876fdf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa245c41459e8f4100994de6dfb876fdf">row_length</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row) const</td></tr>
<tr class="separator:aa245c41459e8f4100994de6dfb876fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a559b1529540ca031728b25f63962c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a91a559b1529540ca031728b25f63962c">is_compressed</a> () const</td></tr>
<tr class="separator:a91a559b1529540ca031728b25f63962c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0241e5308043f439e44bf1285a0ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3b0241e5308043f439e44bf1285a0ac6">memory_consumption</a> () const</td></tr>
<tr class="separator:a3b0241e5308043f439e44bf1285a0ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b528da50ca77670b997382dc38a77b"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a14b528da50ca77670b997382dc38a77b">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:a14b528da50ca77670b997382dc38a77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying entries</div></td></tr>
<tr class="memitem:ae2e30c191f788f4e668df2a51fc0aad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2e30c191f788f4e668df2a51fc0aad3">operator=</a> (const double d)</td></tr>
<tr class="separator:ae2e30c191f788f4e668df2a51fc0aad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e58c65baa9a70517d6dcd6d3371a525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5e58c65baa9a70517d6dcd6d3371a525">clear</a> ()</td></tr>
<tr class="separator:a5e58c65baa9a70517d6dcd6d3371a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ef7c7e43574dacfdbdd6d007708a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a77ef7c7e43574dacfdbdd6d007708a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0279858faded0f95d78c901b4e655317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> j, const TrilinosScalar value)</td></tr>
<tr class="separator:a0279858faded0f95d78c901b4e655317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4eb1ed3db64694a143ff796028ed36f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae4eb1ed3db64694a143ff796028ed36f">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;full_matrix, const bool elide_zero_values=false)</td></tr>
<tr class="separator:ae4eb1ed3db64694a143ff796028ed36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e7e8afef3f71bc0c685bd4b84fd69e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a03e7e8afef3f71bc0c685bd4b84fd69e">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;full_matrix, const bool elide_zero_values=false)</td></tr>
<tr class="separator:a03e7e8afef3f71bc0c685bd4b84fd69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1793ec909cb013dc94609e65f72acfe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1793ec909cb013dc94609e65f72acfe2">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;col_indices, const std::vector&lt; TrilinosScalar &gt; &amp;values, const bool elide_zero_values=false)</td></tr>
<tr class="separator:a1793ec909cb013dc94609e65f72acfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade30f1a23f008a75ce91f3aba272b7bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ade30f1a23f008a75ce91f3aba272b7bb">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> *col_indices, const TrilinosScalar *values, const bool elide_zero_values=false)</td></tr>
<tr class="separator:ade30f1a23f008a75ce91f3aba272b7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2822f0aed012ede4516df69f53d0d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> j, const TrilinosScalar value)</td></tr>
<tr class="separator:ac2822f0aed012ede4516df69f53d0d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6253cdd3795e76d753099065189078ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6253cdd3795e76d753099065189078ee">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;full_matrix, const bool elide_zero_values=true)</td></tr>
<tr class="separator:a6253cdd3795e76d753099065189078ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87b4a845b1c52815be6447e24341e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8b87b4a845b1c52815be6447e24341e4">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;full_matrix, const bool elide_zero_values=true)</td></tr>
<tr class="separator:a8b87b4a845b1c52815be6447e24341e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fd0cf7019f1ead364e4cf4b806202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aad1fd0cf7019f1ead364e4cf4b806202">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;col_indices, const std::vector&lt; TrilinosScalar &gt; &amp;values, const bool elide_zero_values=true)</td></tr>
<tr class="separator:aad1fd0cf7019f1ead364e4cf4b806202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2468a28250ecc0ef4989b66dacdea55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa2468a28250ecc0ef4989b66dacdea55">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> *col_indices, const TrilinosScalar *values, const bool elide_zero_values=true, const bool col_indices_are_sorted=false)</td></tr>
<tr class="separator:aa2468a28250ecc0ef4989b66dacdea55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b02a77bbf81ac8ee1dbf558e1b1d849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1b02a77bbf81ac8ee1dbf558e1b1d849">operator*=</a> (const TrilinosScalar factor)</td></tr>
<tr class="separator:a1b02a77bbf81ac8ee1dbf558e1b1d849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a74de71c2fa3233b48ee71a3daf72dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a7a74de71c2fa3233b48ee71a3daf72dd">operator/=</a> (const TrilinosScalar factor)</td></tr>
<tr class="separator:a7a74de71c2fa3233b48ee71a3daf72dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce2618df5a059715d3d55c83f085763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9ce2618df5a059715d3d55c83f085763">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;source)</td></tr>
<tr class="separator:a9ce2618df5a059715d3d55c83f085763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bac02815f056cd6b235367edf83d31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2bac02815f056cd6b235367edf83d31">add</a> (const TrilinosScalar factor, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad45ff31c2149fd2db87e1a9f81598915">matrix</a>)</td></tr>
<tr class="separator:ae2bac02815f056cd6b235367edf83d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1c4f2ee1e8ae2fadf5102c320c54cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4e1c4f2ee1e8ae2fadf5102c320c54cd">clear_row</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> row, const TrilinosScalar new_diag_value=0)</td></tr>
<tr class="separator:a4e1c4f2ee1e8ae2fadf5102c320c54cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900a42baea388ebcc9b4c7bcf96f71b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a900a42baea388ebcc9b4c7bcf96f71b4">clear_rows</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;rows, const TrilinosScalar new_diag_value=0)</td></tr>
<tr class="separator:a900a42baea388ebcc9b4c7bcf96f71b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7a578fb46241991114a6ffa99cd3fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1a7a578fb46241991114a6ffa99cd3fe">transpose</a> ()</td></tr>
<tr class="separator:a1a7a578fb46241991114a6ffa99cd3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Entry Access</div></td></tr>
<tr class="memitem:acd63c0d5ac1357d24b5fa7ffa4b1d3c7"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#acd63c0d5ac1357d24b5fa7ffa4b1d3c7">operator()</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> j) const</td></tr>
<tr class="separator:acd63c0d5ac1357d24b5fa7ffa4b1d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e40cf415aa2630fd0f56e1878eadb4"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a92e40cf415aa2630fd0f56e1878eadb4">el</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> j) const</td></tr>
<tr class="separator:a92e40cf415aa2630fd0f56e1878eadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe41a4a1feb344a2281a85d138d679ee"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> i) const</td></tr>
<tr class="separator:abe41a4a1feb344a2281a85d138d679ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiplications</div></td></tr>
<tr class="memitem:a2697cc4cb0be492f39f95ad8a816d7d4"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a2697cc4cb0be492f39f95ad8a816d7d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2697cc4cb0be492f39f95ad8a816d7d4">vmult</a> (VectorType &amp;dst, const VectorType &amp;src) const</td></tr>
<tr class="separator:a2697cc4cb0be492f39f95ad8a816d7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa425707a71a23a5173391d0ee4b524f"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:aaa425707a71a23a5173391d0ee4b524f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aaa425707a71a23a5173391d0ee4b524f">Tvmult</a> (VectorType &amp;dst, const VectorType &amp;src) const</td></tr>
<tr class="separator:aaa425707a71a23a5173391d0ee4b524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6792587fa97254fae30dea0e8d770f0c"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a6792587fa97254fae30dea0e8d770f0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6792587fa97254fae30dea0e8d770f0c">vmult_add</a> (VectorType &amp;dst, const VectorType &amp;src) const</td></tr>
<tr class="separator:a6792587fa97254fae30dea0e8d770f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849653e0230720b0f0ab58591974c0f2"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a849653e0230720b0f0ab58591974c0f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a849653e0230720b0f0ab58591974c0f2">Tvmult_add</a> (VectorType &amp;dst, const VectorType &amp;src) const</td></tr>
<tr class="separator:a849653e0230720b0f0ab58591974c0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b716fe0b4b65ef23126b029d8ef3087"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1b716fe0b4b65ef23126b029d8ef3087">matrix_norm_square</a> (const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:a1b716fe0b4b65ef23126b029d8ef3087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47feb069f2be4e95d4ba409d0d3ad1df"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a47feb069f2be4e95d4ba409d0d3ad1df">matrix_scalar_product</a> (const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:a47feb069f2be4e95d4ba409d0d3ad1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cc837a7a60b5ec8c9214d028362287"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a84cc837a7a60b5ec8c9214d028362287">residual</a> (<a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;x, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;b) const</td></tr>
<tr class="separator:a84cc837a7a60b5ec8c9214d028362287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6be3c067b100548ed41d30f2cf8155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe6be3c067b100548ed41d30f2cf8155">mmult</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;V=<a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a>()) const</td></tr>
<tr class="separator:afe6be3c067b100548ed41d30f2cf8155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ca350d47c82ab902bd43fad5ddcda3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af1ca350d47c82ab902bd43fad5ddcda3">Tmmult</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;V=<a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a>()) const</td></tr>
<tr class="separator:af1ca350d47c82ab902bd43fad5ddcda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix norms</div></td></tr>
<tr class="memitem:a1e599d765970ef68e126aa9d5e93583e"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1e599d765970ef68e126aa9d5e93583e">l1_norm</a> () const</td></tr>
<tr class="separator:a1e599d765970ef68e126aa9d5e93583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bb09f66dde1c1969a23b4cccd17f04"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a32bb09f66dde1c1969a23b4cccd17f04">linfty_norm</a> () const</td></tr>
<tr class="separator:a32bb09f66dde1c1969a23b4cccd17f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26df1c42b8f8973246287cfee4d20b4"><td class="memItemLeft" align="right" valign="top">TrilinosScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa26df1c42b8f8973246287cfee4d20b4">frobenius_norm</a> () const</td></tr>
<tr class="separator:aa26df1c42b8f8973246287cfee4d20b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to underlying Trilinos data</div></td></tr>
<tr class="memitem:a2706d65ed111bced458694502fc56a3c"><td class="memItemLeft" align="right" valign="top">const Epetra_CrsMatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2706d65ed111bced458694502fc56a3c">trilinos_matrix</a> () const</td></tr>
<tr class="separator:a2706d65ed111bced458694502fc56a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5601f390c0d339f5e087cf29951906d8"><td class="memItemLeft" align="right" valign="top">const Epetra_CrsGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5601f390c0d339f5e087cf29951906d8">trilinos_sparsity_pattern</a> () const</td></tr>
<tr class="separator:a5601f390c0d339f5e087cf29951906d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3eaace275a4aee474a435310f9d01d"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0d3eaace275a4aee474a435310f9d01d">domain_partitioner</a> () const 1</td></tr>
<tr class="separator:a0d3eaace275a4aee474a435310f9d01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44e6e1a555a948be14488da585df8df"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad44e6e1a555a948be14488da585df8df">range_partitioner</a> () const 1</td></tr>
<tr class="separator:ad44e6e1a555a948be14488da585df8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08f051d19a7c0bc086563304451f601"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab08f051d19a7c0bc086563304451f601">row_partitioner</a> () const 1</td></tr>
<tr class="separator:ab08f051d19a7c0bc086563304451f601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4254a36d7d0888daf031dbcbccce8c12"><td class="memItemLeft" align="right" valign="top">const Epetra_Map &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4254a36d7d0888daf031dbcbccce8c12">col_partitioner</a> () const 1</td></tr>
<tr class="separator:a4254a36d7d0888daf031dbcbccce8c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Partitioners</div></td></tr>
<tr class="memitem:a95be9f345182496414c8f74f81ad9502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a95be9f345182496414c8f74f81ad9502">locally_owned_domain_indices</a> () const</td></tr>
<tr class="separator:a95be9f345182496414c8f74f81ad9502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4255ce516797c98c4448a293ee4f523f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4255ce516797c98c4448a293ee4f523f">locally_owned_range_indices</a> () const</td></tr>
<tr class="separator:a4255ce516797c98c4448a293ee4f523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a53bc4c91231034a9924a89cb45bea7df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a53bc4c91231034a9924a89cb45bea7df">begin</a> () const</td></tr>
<tr class="separator:a53bc4c91231034a9924a89cb45bea7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432dd81dc9b1c3446d2b35dd902af016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a432dd81dc9b1c3446d2b35dd902af016">begin</a> ()</td></tr>
<tr class="separator:a432dd81dc9b1c3446d2b35dd902af016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46e2e5d966499c1b4e9da1798445eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae46e2e5d966499c1b4e9da1798445eef">end</a> () const</td></tr>
<tr class="separator:ae46e2e5d966499c1b4e9da1798445eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818f02479da77b15b295090b8d379bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a818f02479da77b15b295090b8d379bb5">end</a> ()</td></tr>
<tr class="separator:a818f02479da77b15b295090b8d379bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad11df47057376b44f5e495727ea9d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aad11df47057376b44f5e495727ea9d72">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> r) const</td></tr>
<tr class="separator:aad11df47057376b44f5e495727ea9d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac801a93ef57d40f3fbe36ca10909e47f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac801a93ef57d40f3fbe36ca10909e47f">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> r)</td></tr>
<tr class="separator:ac801a93ef57d40f3fbe36ca10909e47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d0dcda5cd5cfd144526471a8c99d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77d0dcda5cd5cfd144526471a8c99d9a">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> r) const</td></tr>
<tr class="separator:a77d0dcda5cd5cfd144526471a8c99d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4773e90eb187a3432dd2b69fe28273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aba4773e90eb187a3432dd2b69fe28273">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> r)</td></tr>
<tr class="separator:aba4773e90eb187a3432dd2b69fe28273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input/Output</div></td></tr>
<tr class="memitem:ad2297e8c999fc04057a3c2370b0db96c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad2297e8c999fc04057a3c2370b0db96c">write_ascii</a> ()</td></tr>
<tr class="separator:ad2297e8c999fc04057a3c2370b0db96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4270ebaea8467f2862cf2baf38986815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4270ebaea8467f2862cf2baf38986815">print</a> (std::ostream &amp;out, const bool write_extended_trilinos_info=false) const</td></tr>
<tr class="separator:a4270ebaea8467f2862cf2baf38986815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga901bfb2d586a7b24aa2ea6748ddeda0f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga901bfb2d586a7b24aa2ea6748ddeda0f">ExcTrilinosError</a> (int arg1)</td></tr>
<tr class="separator:ga901bfb2d586a7b24aa2ea6748ddeda0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404df71ebd77d72441809d6ca158e34a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga404df71ebd77d72441809d6ca158e34a">ExcInvalidIndex</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> arg1, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> arg2)</td></tr>
<tr class="separator:ga404df71ebd77d72441809d6ca158e34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57437d4404c9d4ec3d5bc253c8d7178d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga57437d4404c9d4ec3d5bc253c8d7178d">ExcSourceEqualsDestination</a> ()</td></tr>
<tr class="separator:ga57437d4404c9d4ec3d5bc253c8d7178d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc8d2e8a46e7a26923bbd7376ff8a89a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacc8d2e8a46e7a26923bbd7376ff8a89a">ExcMatrixNotCompressed</a> ()</td></tr>
<tr class="separator:gacc8d2e8a46e7a26923bbd7376ff8a89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fed0209dc52771eedc974084c6699b"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga90fed0209dc52771eedc974084c6699b">ExcAccessToNonLocalElement</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> arg1, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> arg2, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> arg3, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> arg4)</td></tr>
<tr class="separator:ga90fed0209dc52771eedc974084c6699b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad244fff0df45011cb2acd7a079871a46"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad244fff0df45011cb2acd7a079871a46">ExcAccessToNonPresentElement</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> arg1, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> arg2)</td></tr>
<tr class="separator:gad244fff0df45011cb2acd7a079871a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a536e7d727e8394586b4c2dde99b39ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a536e7d727e8394586b4c2dde99b39ba3">prepare_add</a> ()</td></tr>
<tr class="separator:a536e7d727e8394586b4c2dde99b39ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a6620012e379b4c660fb4431d817fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a68a6620012e379b4c660fb4431d817fb">prepare_set</a> ()</td></tr>
<tr class="separator:a68a6620012e379b4c660fb4431d817fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af9c62a3b1623b747484f591cfafd3141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af9c62a3b1623b747484f591cfafd3141">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;)</td></tr>
<tr class="separator:af9c62a3b1623b747484f591cfafd3141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa3fb36823ad53496b2e655fd047aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3fa3fb36823ad53496b2e655fd047aaf">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;)</td></tr>
<tr class="separator:a3fa3fb36823ad53496b2e655fd047aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a90cf60f415387029c911e71407677b42"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Epetra_Map &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a90cf60f415387029c911e71407677b42">column_space_map</a></td></tr>
<tr class="separator:a90cf60f415387029c911e71407677b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45ff31c2149fd2db87e1a9f81598915"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Epetra_FECrsMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad45ff31c2149fd2db87e1a9f81598915">matrix</a></td></tr>
<tr class="separator:ad45ff31c2149fd2db87e1a9f81598915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee7e1991cf28e0f72f6b70b24638860"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Epetra_CrsMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5ee7e1991cf28e0f72f6b70b24638860">nonlocal_matrix</a></td></tr>
<tr class="separator:a5ee7e1991cf28e0f72f6b70b24638860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84494c005bca0842be9d457b6774a86"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Epetra_Export &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab84494c005bca0842be9d457b6774a86">nonlocal_matrix_exporter</a></td></tr>
<tr class="separator:ab84494c005bca0842be9d457b6774a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1d6236f2215737135912c25cc993b0"><td class="memItemLeft" align="right" valign="top">Epetra_CombineMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3c1d6236f2215737135912c25cc993b0">last_action</a></td></tr>
<tr class="separator:a3c1d6236f2215737135912c25cc993b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896761c5d6156507d191a404ca7dc8c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a896761c5d6156507d191a404ca7dc8c3">compressed</a></td></tr>
<tr class="separator:a896761c5d6156507d191a404ca7dc8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0eb72d666c41a0ac3c16def795c0c99b">BlockMatrixBase&lt; SparseMatrix &gt;</a></td></tr>
<tr class="separator:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a wrapper to use the Trilinos distributed sparse matrix class Epetra_FECrsMatrix. This is precisely the kind of matrix we deal with all the time - we most likely get it from some assembly process, where also entries not locally owned might need to be written and hence need to be forwarded to the owner process. This class is designed to be used in a distributed memory architecture with an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> compiler on the bottom, but works equally well also for serial processes. The only requirement for this class to work is that Trilinos has been installed with the same compiler as is used for generating deal.II.</p>
<p>The interface of this class is modeled after the existing <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> class in deal.II. It has almost the same member functions, and is often exchangeable. However, since Trilinos only supports a single scalar type (double), it is not templated, and only works with doubles.</p>
<p>Note that Trilinos only guarantees that operations do what you expect if the functions <code>GlobalAssemble</code> has been called after matrix assembly. Therefore, you need to call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">SparseMatrix::compress()</a> before you actually use the matrix. This also calls <code>FillComplete</code> that compresses the storage format for sparse matrices by discarding unused elements. Trilinos allows to continue with assembling the matrix after calls to these functions, though.</p>
<h3>Thread safety of Trilinos matrices</h3>
<p>When writing into Trilinos matrices from several threads in shared memory, several things must be kept in mind as there is no built-in locks in this class to prevent data races. Simultaneous access to the same matrix row at the same time can lead to data races and must be explicitly avoided by the user. However, it is possible to access <b>different</b> rows of the matrix from several threads simultaneously under the following three conditions: </p><ul>
<li>
The matrix uses only one <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process. </li>
<li>
The matrix has been initialized with the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit()</a> method with a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> (that includes the set of locally relevant rows, i.e., the rows that an assembly routine will possibly write into). </li>
<li>
The matrix has been initialized from a <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> object that in turn has been initialized with the reinit function specifying three index sets, one for the rows, one for the columns and for the larger set of <code>writeable_rows</code>, and the operation is an addition. At some point in the future, Trilinos support might be complete enough such that initializing from a <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> that has been filled by a function similar to <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> always results in a matrix that allows several processes to write into the same matrix row. However, Trilinos until version at least 11.12 does not correctly support this feature. </li>
</ul>
<p>Note that all other reinit methods and constructors of <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> will result in a matrix that needs to allocate off-processor entries on demand, which breaks thread-safety. Of course, using the respective reinit method for the block Trilinos sparsity pattern and block matrix also results in thread-safety.</p>
<dl class="section author"><dt>Author</dt><dd>Martin Kronbichler, Wolfgang Bangerth, 2008, 2009 </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00498">498</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afe482aa470fc1e948eabce22fbe0bad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe482aa470fc1e948eabce22fbe0bad6">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">TrilinosWrappers::SparseMatrix::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00504">504</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="af2bbbe25812a885629f61c0adb78161d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bbbe25812a885629f61c0adb78161d">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;false&gt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">TrilinosWrappers::SparseMatrix::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef for the iterator class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00525">525</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a2b7cd05f0a29cf3725d7323c961938e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7cd05f0a29cf3725d7323c961938e5">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;true&gt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">TrilinosWrappers::SparseMatrix::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef for the const iterator class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00530">530</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ae2b0bc8a994f8441b1089b01d1eb2b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0bc8a994f8441b1089b01d1eb2b1f">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2b0bc8a994f8441b1089b01d1eb2b1f">TrilinosWrappers::SparseMatrix::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a typedef in analogy to all the other container classes. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00535">535</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a637dbbd4e8ca9fc07a447c8f31e21647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637dbbd4e8ca9fc07a447c8f31e21647">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Generates an empty (zero-size) matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00233">233</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ab3900dae374f5a71e5134840682662d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3900dae374f5a71e5134840682662d8">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a matrix that is completely stored locally, having <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a> rows and <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a> columns.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00300">300</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a944e51f3f5f0202024e04b679172ec9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944e51f3f5f0202024e04b679172ec9e">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a matrix that is completely stored locally, having <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a> rows and <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a> columns.</p>
<p>The vector <code>n_entries_per_row</code> specifies the number of entries in each row. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00327">327</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a0b2b62a80dac30c548e1d20c3e77beae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2b62a80dac30c548e1d20c3e77beae">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>InputSparsityPattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a matrix from a Trilinos sparsity pattern object. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00413">413</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2377111964e6c6945cefc8886ffc1b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2377111964e6c6945cefc8886ffc1b64">&#9670;&nbsp;</a></span>~SparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::~<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Made virtual so that one can use pointers to this class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00429">429</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a439ef5bbec8d78559d0b1b83cd45921e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439ef5bbec8d78559d0b1b83cd45921e">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor using an Epetra_Map to describe the parallel partitioning. The parameter <code>n_max_entries_per_row</code> sets the number of nonzero entries in each row that will be allocated. Note that this number does not need to be exact, and it is even allowed that the actual matrix structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance of the matrix setup. However, there is no effect in the performance of matrix-vector products, since Trilinos reorganizes the matrix memory prior to use (in the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> step).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00247">247</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac75e4f48c786721c01b03ee93279b19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75e4f48c786721c01b03ee93279b19a">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now set a value of nonzeros for each matrix row. Since we know the number of elements in the matrix exactly in this case, we can already allocate the right amount of memory, which makes the creation process including the insertion of nonzero elements by the respective <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">SparseMatrix::reinit</a> call considerably faster.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00259">259</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aabd1ca502a778202b00aebeec70cfce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd1ca502a778202b00aebeec70cfce9">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map describes the parallel partitioning of the dofs associated with the matrix rows and the other one the partitioning of dofs in the matrix columns. Note that there is no real parallelism along the columns &ndash; the processor that owns a certain row always owns all the column elements, no matter how far they might be spread out. The second Epetra_Map is only used to specify the number of columns and for internal arrangements when doing matrix-vector products with vectors based on that column map.</p>
<p>The integer input <code>n_max_entries_per_row</code> defines the number of columns entries per row that will be allocated.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00273">273</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae21edfb5a4fc3243526f2531d0283e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21edfb5a4fc3243526f2531d0283e9f">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of degrees of freedom associated with matrix rows and the second one specifies the parallel distribution the dofs associated with columns in the matrix. The second map also provides information for the internal arrangement in matrix vector products (i.e., the distribution of vector this matrix is to be multiplied with), but is not used for the distribution of the columns &ndash; rather, all column elements of a row are stored on the same processor in any case. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00286">286</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="abf1eceecf61d5aacdb1192a6a0bded7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1eceecf61d5aacdb1192a6a0bded7e">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor using an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator to describe the parallel partitioning. The parameter <code>n_max_entries_per_row</code> sets the number of nonzero entries in each row that will be allocated. Note that this number does not need to be exact, and it is even allowed that the actual matrix structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance of the matrix setup. However, there is no effect in the performance of matrix- vector products, since Trilinos reorganizes the matrix memory prior to use (in the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> step). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00345">345</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a9d44ae4cf732744c50027c8d36f2a758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d44ae4cf732744c50027c8d36f2a758">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now set the number of nonzeros in each matrix row separately. Since we know the number of elements in the matrix exactly in this case, we can already allocate the right amount of memory, which makes the creation process including the insertion of nonzero elements by the respective <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">SparseMatrix::reinit</a> call considerably faster. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00361">361</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a60748f3e8d3fbea4b3a4c192ff7d8455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60748f3e8d3fbea4b3a4c192ff7d8455">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different <a class="el" href="classIndexSet.html">IndexSet</a> partitions for row and columns. This interface is meant to be used for generating rectangular matrices, where the first index set describes the parallel partitioning of the degrees of freedom associated with the matrix rows and the second one the partitioning of the matrix columns. The second index set specifies the partitioning of the vectors this matrix is to be multiplied with, not the distribution of the elements that actually appear in the matrix.</p>
<p>The parameter <code>n_max_entries_per_row</code> defines how much memory will be allocated for each row. This number does not need to be accurate, as the structure is reorganized in the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> call. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00377">377</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a128b8b864bec45fa1115e43206861f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128b8b864bec45fa1115e43206861f22">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of degrees of freedom associated with matrix rows and the second one specifies the parallel distribution the dofs associated with columns in the matrix. The second map also provides information for the internal arrangement in matrix vector products (i.e., the distribution of vector this matrix is to be multiplied with), but is not used for the distribution of the columns &ndash; rather, all column elements of a row are stored on the same processor in any case. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00395">395</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="af9c62a3b1623b747484f591cfafd3141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c62a3b1623b747484f591cfafd3141">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor is disabled. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a614ca8e186fe3c61e03a52369437157e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614ca8e186fe3c61e03a52369437157e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix with a deal.II sparsity pattern, i.e. it makes the Trilinos Epetra matrix know the position of nonzero entries according to the sparsity pattern. This function is meant for use in serial programs, where there is no need to specify how the matrix is going to be distributed among different processors. This function works in parallel, too, but it is recommended to manually specify the parallel partitioning of the matrix using an Epetra_Map. When run in parallel, it is currently necessary that each processor holds the sparsity_pattern structure because each processor sets its rows.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00800">800</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a602232080f91baba93c85684937765d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602232080f91baba93c85684937765d5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reinitializes the Trilinos sparse matrix from a (possibly distributed) Trilinos sparsity pattern.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock.</p>
<p>If you want to write to the matrix from several threads and use <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, you need to use this reinit method with a sparsity pattern that has been created with explicitly stating writeable rows. In all other cases, you cannot mix <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> with multithreaded writing into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00877">877</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a5cbc81d639cb5c12f2e2b59072e64f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbc81d639cb5c12f2e2b59072e64f39">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>sparse_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function copies the layout of <code>sparse_matrix</code> to the calling matrix. The values are not copied, but you can use <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9ce2618df5a059715d3d55c83f085763">copy_from()</a> for this.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00900">900</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a688b87cdf4067fc28483d5385b1dabda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688b87cdf4067fc28483d5385b1dabda">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix using the deal.II sparse matrix and the entries stored therein. It uses a threshold to copy only elements with modulus larger than the threshold (so zeros in the deal.II matrix can be filtered away).</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a deadlock.</p>
<dl class="section note"><dt>Note</dt><dd>If a different sparsity pattern is given in the last argument (i.e., one that differs from the one used in the sparse matrix given in the first argument), then the resulting Trilinos matrix will have the sparsity pattern so given. This of course also means that all entries in the given matrix that are not part of this separate sparsity pattern will in fact be dropped. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01025">1025</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a743888addc7cfd057c70ceff1e03cc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743888addc7cfd057c70ceff1e03cc02">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_CrsMatrix &amp;&#160;</td>
          <td class="paramname"><em>input_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function takes as input a Trilinos Epetra_CrsMatrix and copies its sparsity pattern. If so requested, even the content (values) will be copied. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01069">1069</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ab9e97c95de408a61ee1fc8f272484c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e97c95de408a61ee1fc8f272484c83">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is initializes the Trilinos Epetra matrix according to the specified sparsity_pattern, and also reassigns the matrix rows to different processes according to a user-supplied Epetra map. In programs following the style of the tutorial programs, this function (and the respective call for a rectangular matrix) are the natural way to initialize the matrix size, its distribution among the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processes (if run in parallel) as well as the location of non-zero elements. Trilinos stores the sparsity pattern internally, so it won't be needed any more after this call, in contrast to the deal.II own object. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. If the flag is not set, each processor just sets the elements in the sparsity pattern that belong to its rows.</p>
<p>If the sparsity pattern given to this function is of type DynamicSparsity pattern, then a matrix will be created that allows several threads to write into different rows of the matrix at the same also with <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, as opposed to most other <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit()</a> methods.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000071">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00818">818</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a190ec04ad7c8ebdd29a5cf5eebd6a62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190ec04ad7c8ebdd29a5cf5eebd6a62f">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function above, but now also reassigns the matrix rows and columns according to two user-supplied Epetra maps. To be used for rectangular matrices. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000072">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00858">858</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4e521bdc023c29921d6f3362623d8347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e521bdc023c29921d6f3362623d8347">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix using the deal.II sparse matrix and the entries stored therein. It uses a threshold to copy only elements with modulus larger than the threshold (so zeros in the deal.II matrix can be filtered away). In contrast to the other reinit function with deal.II sparse matrix argument, this function takes a parallel partitioning specified by the user instead of internally generating it.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000073">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01040">1040</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1618d2492ea33d57af615c26ff889173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1618d2492ea33d57af615c26ff889173">&#9670;&nbsp;</a></span>reinit() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Epetra_Map &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function with deal.II sparse matrix input above, but now takes Epetra maps for both the rows and the columns of the matrix. Chosen for rectangular matrices.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000074">Deprecated:</a></b></dt><dd>Use the respective method with <a class="el" href="classIndexSet.html">IndexSet</a> argument instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01054">1054</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="abb5f926afa37ddbe5ffe18ecb1f037a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5f926afa37ddbe5ffe18ecb1f037a8">&#9670;&nbsp;</a></span>reinit() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is initializes the Trilinos Epetra matrix according to the specified sparsity_pattern, and also reassigns the matrix rows to different processes according to a user-supplied index set and parallel communicator. In programs following the style of the tutorial programs, this function (and the respective call for a rectangular matrix) are the natural way to initialize the matrix size, its distribution among the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processes (if run in parallel) as well as the location of non-zero elements. Trilinos stores the sparsity pattern internally, so it won't be needed any more after this call, in contrast to the deal.II own object. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. If the flag is not set, each processor just sets the elements in the sparsity pattern that belong to its rows.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a id="a8f2ec0234fcfe5687d53d6d3fb834600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2ec0234fcfe5687d53d6d3fb834600">&#9670;&nbsp;</a></span>reinit() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function above, but now also reassigns the matrix rows and columns according to two user-supplied index sets. To be used for rectangular matrices. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00834">834</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4023e59f650260e3002a7a7ec2548313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4023e59f650260e3002a7a7ec2548313">&#9670;&nbsp;</a></span>reinit() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix using the deal.II sparse matrix and the entries stored therein. It uses a threshold to copy only elements with modulus larger than the threshold (so zeros in the deal.II matrix can be filtered away). In contrast to the other reinit function with deal.II sparse matrix argument, this function takes a parallel partitioning specified by the user instead of internally generating it.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a id="a2f7443128fe3987f117365d755839f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7443128fe3987f117365d755839f62">&#9670;&nbsp;</a></span>reinit() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function with deal.II sparse matrix input above, but now takes index sets for both the rows and the columns of the matrix. Chosen for rectangular matrices.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00925">925</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ab9cf2620cc3350eb189597bd2831570a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cf2620cc3350eb189597bd2831570a">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> TrilinosWrappers::SparseMatrix::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of rows in this matrix. </p>

</div>
</div>
<a id="a371d418cc093230813c36578f32f0966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371d418cc093230813c36578f32f0966">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> TrilinosWrappers::SparseMatrix::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of columns in this matrix. </p>

</div>
</div>
<a id="ac2a8c1f20e048f5a7b9711218779fad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a8c1f20e048f5a7b9711218779fad5">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TrilinosWrappers::SparseMatrix::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local dimension of the matrix, i.e. the number of rows stored on the present <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process. For sequential matrices, this number is the same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m()</a>, but for parallel matrices it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a557eb5dabea73fb2d3e2ba70226cdfcf">local_range()</a>. </p>

</div>
</div>
<a id="a557eb5dabea73fb2d3e2ba70226cdfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557eb5dabea73fb2d3e2ba70226cdfcf">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&gt; TrilinosWrappers::SparseMatrix::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which rows of this matrix are stored locally. The first number is the index of the first row stored, the second the index of the one past the last one that is stored locally. If this is a sequential matrix, then the result will be the pair (0,<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m()</a>), otherwise it will be a pair (i,i+n), where <code>n=<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2a8c1f20e048f5a7b9711218779fad5">local_size()</a></code>. </p>

</div>
</div>
<a id="a998d6f1a926b04ec7c1a967f46775282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998d6f1a926b04ec7c1a967f46775282">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TrilinosWrappers::SparseMatrix::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a557eb5dabea73fb2d3e2ba70226cdfcf">local_range()</a>. </p>

</div>
</div>
<a id="ae26d73bf5ba9422c98651107cc9dfbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26d73bf5ba9422c98651107cc9dfbac">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> TrilinosWrappers::SparseMatrix::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of nonzero elements of this matrix (summed over all <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processes). </p>

</div>
</div>
<a id="aa245c41459e8f4100994de6dfb876fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa245c41459e8f4100994de6dfb876fdf">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01390">1390</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a91a559b1529540ca031728b25f63962c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a559b1529540ca031728b25f63962c">&#9670;&nbsp;</a></span>is_compressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TrilinosWrappers::SparseMatrix::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the state of the matrix, i.e., whether <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> needs to be called after an operation requiring data exchange. A call to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is also needed when the method <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set()</a> has been called (even when working in serial). </p>

</div>
</div>
<a id="a3b0241e5308043f439e44bf1285a0ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0241e5308043f439e44bf1285a0ac6">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">SparseMatrix::size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. Note that only the memory reserved on the current processor is returned in case this is called in an MPI-based program. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02442">2442</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a14b528da50ca77670b997382dc38a77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b528da50ca77670b997382dc38a77b">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator object in use with this matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02484">2484</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae2e30c191f788f4e668df2a51fc0aad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e30c191f788f4e668df2a51fc0aad3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a matrix. Since this does usually not make much sense (should we set all matrix entries to this value? Only the nonzero entries of the sparsity pattern?), this operation is only allowed if the actual value to be assigned is zero. This operator only exists to allow for the obvious notation <code>matrix=0</code>, which sets all elements of the matrix to zero, but keeps the sparsity pattern previously used. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01798">1798</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a5e58c65baa9a70517d6dcd6d3371a525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e58c65baa9a70517d6dcd6d3371a525">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01157">1157</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a77ef7c7e43574dacfdbdd6d007708a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ef7c7e43574dacfdbdd6d007708a38">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This command does two things: </p><ul>
<li>
If the matrix was initialized without a sparsity pattern, elements have been added manually using the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set()</a> command. When this process is completed, a call to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> reorganizes the internal data structures (sparsity pattern) so that a fast access to data is possible in matrix-vector products. </li>
<li>
If the matrix structure has already been fixed (either by initialization with a sparsity pattern or by calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> during the setup phase), this command does the parallel exchange of data. This is necessary when we perform assembly on more than one (<a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>) process, because then some non-local row data will accumulate on nodes that belong to the current's processor element, but are actually held by another. This command is usually called after all elements have been traversed. </li>
</ul>
<p>In both cases, this function compresses the data structures and allows the resulting matrix to be used in all other operations like matrix- vector products. This is a collective operation, i.e., it needs to be run on all processors when used in parallel.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed objects</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01104">1104</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a0279858faded0f95d78c901b4e655317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0279858faded0f95d78c901b4e655317">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the element (<em>i,j</em>) to <code>value</code>.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has not been called, so the sparsity pattern will be extended. When <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called for the first time (or in case the matrix is initialized from a sparsity pattern), no new elements can be added and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>For the case that the matrix is constructed without a sparsity pattern and new matrix entries are added on demand, please note the following behavior imposed by the underlying Epetra_FECrsMatrix data structure: If the same matrix entry is inserted more than once, the matrix entries will be added upon calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> (since Epetra does not track values to the same entry before the final <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called), even if <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> is specified as argument to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a>. In the case you cannot make sure that matrix entries are only set once, initialize the matrix with a sparsity pattern to fix the matrix structure before inserting elements. </p>

</div>
</div>
<a id="ae4eb1ed3db64694a143ff796028ed36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4eb1ed3db64694a143ff796028ed36f">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has not been called, so the sparsity pattern will be extended. After <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has been called for the first time or the matrix has been initialized from a sparsity pattern, extending the sparsity pattern is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced.</p>
<p>For the case that the matrix is constructed without a sparsity pattern and new matrix entries are added on demand, please note the following behavior imposed by the underlying Epetra_FECrsMatrix data structure: If the same matrix entry is inserted more than once, the matrix entries will be added upon calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> (since Epetra does not track values to the same entry before the final <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called), even if <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> is specified as argument to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a>. In the case you cannot make sure that matrix entries are only set once, initialize the matrix with a sparsity pattern to fix the matrix structure before inserting elements. </p>

</div>
</div>
<a id="a03e7e8afef3f71bc0c685bd4b84fd69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e7e8afef3f71bc0c685bd4b84fd69e">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01414">1414</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1793ec909cb013dc94609e65f72acfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1793ec909cb013dc94609e65f72acfe2">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has not been called, so the sparsity pattern will be extended. After <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has been called for the first time or the matrix has been initialized from a sparsity pattern, extending the sparsity pattern is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced.</p>
<p>For the case that the matrix is constructed without a sparsity pattern and new matrix entries are added on demand, please note the following behavior imposed by the underlying Epetra_FECrsMatrix data structure: If the same matrix entry is inserted more than once, the matrix entries will be added upon calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> (since Epetra does not track values to the same entry before the final <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called), even if <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> is specified as argument to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a>. In the case you cannot make sure that matrix entries are only set once, initialize the matrix with a sparsity pattern to fix the matrix structure before inserting elements. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01432">1432</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ade30f1a23f008a75ce91f3aba272b7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade30f1a23f008a75ce91f3aba272b7bb">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has not been called, so the sparsity pattern will be extended. After <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has been called for the first time or the matrix has been initialized from a sparsity pattern, extending the sparsity pattern is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced.</p>
<p>For the case that the matrix is constructed without a sparsity pattern and new matrix entries are added on demand, please note the following behavior imposed by the underlying Epetra_FECrsMatrix data structure: If the same matrix entry is inserted more than once, the matrix entries will be added upon calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> (since Epetra does not track values to the same entry before the final <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called), even if <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> is specified as argument to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a>. In the case you cannot make sure that matrix entries are only set once, initialize the matrix with a sparsity pattern to fix the matrix structure before inserting elements. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01447">1447</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac2822f0aed012ede4516df69f53d0d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2822f0aed012ede4516df69f53d0d13">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>).</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern. Moreover, if <code>value</code> is not a finite number an exception is thrown. </p>

</div>
</div>
<a id="a6253cdd3795e76d753099065189078ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6253cdd3795e76d753099065189078ee">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01587">1587</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a8b87b4a845b1c52815be6447e24341e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b87b4a845b1c52815be6447e24341e4">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01603">1603</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aad1fd0cf7019f1ead364e4cf4b806202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1fd0cf7019f1ead364e4cf4b806202">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; TrilinosScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01621">1621</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aa2468a28250ecc0ef4989b66dacdea55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2468a28250ecc0ef4989b66dacdea55">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01636">1636</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1b02a77bbf81ac8ee1dbf558e1b1d849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b02a77bbf81ac8ee1dbf558e1b1d849">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01918">1918</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a7a74de71c2fa3233b48ee71a3daf72dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a74de71c2fa3233b48ee71a3daf72dd">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01930">1930</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a9ce2618df5a059715d3d55c83f085763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce2618df5a059715d3d55c83f085763">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given (Trilinos) matrix (sparsity pattern and entries). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00435">435</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae2bac02815f056cd6b235367edf83d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bac02815f056cd6b235367edf83d31">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>matrix</code> scaled by <code>factor</code> to this matrix, i.e. the matrix <code>factor*matrix</code> is added to <code>this</code>. If the sparsity pattern of the calling matrix does not contain all the elements in the sparsity pattern of the input matrix, this function will throw an exception. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01814">1814</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4e1c4f2ee1e8ae2fadf5102c320c54cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1c4f2ee1e8ae2fadf5102c320c54cd">&#9670;&nbsp;</a></span>clear_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all elements from this <code>row</code> by setting them to zero. The function does not modify the number of allocated nonzero entries, it only sets the entries to zero.</p>
<p>This operation is used in eliminating constraints (e.g. due to hanging nodes) and makes sure that we can write this modification to the matrix without having to read entries (such as the locations of non-zero elements) from it &mdash; without this operation, removing constraints on parallel matrices is a rather complicated procedure.</p>
<p>The second parameter can be used to set the diagonal entry of this row to a value different from zero. The default is to set it to zero.</p>
<dl class="section note"><dt>Note</dt><dd>If the matrix is stored in parallel across multiple processors using <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, this function only touches rows that are locally stored and simply ignores all other row indices. Further, in the context of parallel computations, you will get into trouble if you clear a row while other processors still have pending writes or additions into the same row. In other words, if another processor still wants to add something to an element of a row and you call this function to zero out the row, then the next time you call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> may add the remote value to the zero you just created. Consequently, you will want to call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> after you made the last modifications to a matrix and before starting to clear rows. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01176">1176</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a900a42baea388ebcc9b4c7bcf96f71b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900a42baea388ebcc9b4c7bcf96f71b4">&#9670;&nbsp;</a></span>clear_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TrilinosScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4e1c4f2ee1e8ae2fadf5102c320c54cd">clear_row()</a>, except that it works on a number of rows at once.</p>
<p>The second parameter can be used to set the diagonal entries of all cleared rows to something different from zero. Note that all of these diagonal entries get the same value &ndash; if you want different values for the diagonal entries, you have to set them by hand.</p>
<dl class="section note"><dt>Note</dt><dd>If the matrix is stored in parallel across multiple processors using <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, this function only touches rows that are locally stored and simply ignores all other row indices. Further, in the context of parallel computations, you will get into trouble if you clear a row while other processors still have pending writes or additions into the same row. In other words, if another processor still wants to add something to an element of a row and you call this function to zero out the row, then the next time you call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> may add the remote value to the zero you just created. Consequently, you will want to call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> after you made the last modifications to a matrix and before starting to clear rows. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01213">1213</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1a7a578fb46241991114a6ffa99cd3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7a578fb46241991114a6ffa99cd3fe">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an internal flag so that all operations performed by the matrix, i.e., multiplications, are done in transposed order. However, this does not reshape the matrix to transposed form directly, so care should be taken when using this flag.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this function any even number of times in succession will return the object to its original state. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01894">1894</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="acd63c0d5ac1357d24b5fa7ffa4b1d3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd63c0d5ac1357d24b5fa7ffa4b1d3c7">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the entry (<em>i,j</em>). This may be an expensive operation and you should always take care where to call this function. As in the deal.II sparse matrix class, we throw an exception if the respective entry doesn't exist in the sparsity pattern of this class, which is requested from Trilinos. Moreover, an exception will be thrown when the requested element is not saved on the calling process. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01223">1223</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a92e40cf415aa2630fd0f56e1878eadb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e40cf415aa2630fd0f56e1878eadb4">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the matrix entry (<em>i,j</em>). If this entry does not exist in the sparsity pattern, then zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used. On the other hand, if you want to be sure the entry exists, you should use operator() instead.</p>
<p>The lack of error checking in this function can also yield surprising results if you have a parallel matrix. In that case, just because you get a zero result from this function does not mean that either the entry does not exist in the sparsity pattern or that it does but has a value of zero. Rather, it could also be that it simply isn't stored on the current processor; in that case, it may be stored on a different processor, and possibly so with a nonzero value. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01299">1299</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="abe41a4a1feb344a2281a85d138d679ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe41a4a1feb344a2281a85d138d679ee">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic and it also throws an error if <em>(i,i)</em> is not element of the local matrix. See also the comment in <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01369">1369</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2697cc4cb0be492f39f95ad8a816d7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2697cc4cb0be492f39f95ad8a816d7d4">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; VectorType &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M*src</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several different vector objects, namely <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> as well as deal.II's own vector classes <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> and LinearAlgebra::distributed::Vector&lt;double&gt;.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02003">2003</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aaa425707a71a23a5173391d0ee4b524f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa425707a71a23a5173391d0ee4b524f">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; VectorType &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M<sup>T</sup>*src</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2697cc4cb0be492f39f95ad8a816d7d4">vmult()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several different vector objects, namely <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> as well as deal.II's own vector classes <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> and LinearAlgebra::distributed::Vector&lt;double&gt;.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02032">2032</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a6792587fa97254fae30dea0e8d770f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6792587fa97254fae30dea0e8d770f0c">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; VectorType &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding matrix-vector multiplication. Add <em>M*src</em> on <em>dst</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several different vector objects, namely <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> as well as deal.II's own vector classes <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> and LinearAlgebra::distributed::Vector&lt;double&gt;.</p>
<p>When using a vector of type <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, both vectors have to be distributed vectors generated using the same Map as was used for the matrix rows and columns in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class.</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> (i.e., <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> or <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>), this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02059">2059</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a849653e0230720b0f0ab58591974c0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849653e0230720b0f0ab58591974c0f2">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; VectorType &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding matrix-vector multiplication. Add <em>M<sup>T</sup>*src</em> to <em>dst</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6792587fa97254fae30dea0e8d770f0c">vmult_add()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several different vector objects, namely <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> as well as deal.II's own vector classes <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> and LinearAlgebra::distributed::Vector&lt;double&gt;.</p>
<p>When using a vector of type <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, both vectors have to be distributed vectors generated using the same Map as was used for the matrix rows and columns in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class.</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> (i.e., <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> or <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>), this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02084">2084</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1b716fe0b4b65ef23126b029d8ef3087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b716fe0b4b65ef23126b029d8ef3087">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector <img class="formulaInl" alt="$v$" src="form_987.png"/> with respect to the norm induced by this matrix, i.e., <img class="formulaInl" alt="$\left(v,Mv\right)$" src="form_988.png"/>. This is useful, e.g. in the finite element context, where the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></code> class used in deal.II (i.e. the original one, not the Trilinos wrapper class) since Trilinos doesn't support this operation and needs a temporary vector.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02108">2108</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a47feb069f2be4e95d4ba409d0d3ad1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47feb069f2be4e95d4ba409d0d3ad1df">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the matrix scalar product <img class="formulaInl" alt="$\left(u,Mv\right)$" src="form_980.png"/>.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></code> class used in deal.II (i.e. the original one, not the Trilinos wrapper class) since Trilinos doesn't support this operation and needs a temporary vector.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02123">2123</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a84cc837a7a60b5ec8c9214d028362287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cc837a7a60b5ec8c9214d028362287">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the residual of an equation <em>Mx=b</em>, where the residual is defined to be <em>r=b-Mx</em>. Write the residual into <code>dst</code>. The <em>l<sub>2</sub></em> norm of the residual vector is returned.</p>
<p>Source <em>x</em> and destination <em>dst</em> must not be the same vector.</p>
<p>Note that both vectors have to be distributed vectors generated using the same Map as was used for the matrix in case you work on a distributed memory architecture, using the interface in the <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">TrilinosWrappers::VectorBase</a> class (or one of the two derived classes <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>).</p>
<p>In case of a localized <a class="el" href="classTrilinosWrappers_1_1Vector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, and exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02139">2139</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="afe6be3c067b100548ed41d30f2cf8155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6be3c067b100548ed41d30f2cf8155">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication <code>C = A * B</code>, or, if an optional vector argument is given, <code>C = A * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and <code>B</code> have compatible sizes. The size of <code>C</code> will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix C will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02378">2378</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="af1ca350d47c82ab902bd43fad5ddcda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ca350d47c82ab902bd43fad5ddcda3">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classTrilinosWrappers_1_1VectorBase.html">VectorBase</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication with the transpose of <code>this</code>, i.e., <code>C = A<sup>T</sup> * B</code>, or, if an optional vector argument is given, <code>C = A<sup>T</sup> * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and <code>B</code> have compatible sizes. The size of <code>C</code> will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix C will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02391">2391</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1e599d765970ef68e126aa9d5e93583e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e599d765970ef68e126aa9d5e93583e">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <em>l</em><sub>1</sub>-norm of the matrix, that is <img class="formulaInl" alt="$|M|_1= \max_{\mathrm{all\ columns\ } j} \sum_{\mathrm{all\ rows\ } i} |M_{ij}|$" src="form_1128.png"/>, (max. sum of columns). This is the natural matrix norm that is compatible to the l1-norm for vectors, i.e. <img class="formulaInl" alt="$|Mv|_1 \leq |M|_1 |v|_1$" src="form_1129.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01946">1946</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a32bb09f66dde1c1969a23b4cccd17f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bb09f66dde1c1969a23b4cccd17f04">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the linfty-norm of the matrix, that is <img class="formulaInl" alt="$|M|_\infty=\max_{\mathrm{all\ rows\ } i}\sum_{\mathrm{all\ columns\ } j} |M_{ij}|$" src="form_1130.png"/>, (max. sum of rows). This is the natural matrix norm that is compatible to the linfty-norm of vectors, i.e. <img class="formulaInl" alt="$|Mv|_\infty \leq |M|_\infty |v|_\infty$" src="form_1107.png"/>. (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01955">1955</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aa26df1c42b8f8973246287cfee4d20b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26df1c42b8f8973246287cfee4d20b4">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosScalar <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the frobenius norm of the matrix, i.e. the square root of the sum of squares of all entries in the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01964">1964</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2706d65ed111bced458694502fc56a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2706d65ed111bced458694502fc56a3c">&#9670;&nbsp;</a></span>trilinos_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_CrsMatrix&amp; TrilinosWrappers::SparseMatrix::trilinos_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_CrsMatrix data. </p>

</div>
</div>
<a id="a5601f390c0d339f5e087cf29951906d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5601f390c0d339f5e087cf29951906d8">&#9670;&nbsp;</a></span>trilinos_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_CrsGraph&amp; TrilinosWrappers::SparseMatrix::trilinos_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_CrsGraph data that stores the sparsity pattern of the matrix. </p>

</div>
</div>
<a id="a0d3eaace275a4aee474a435310f9d01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3eaace275a4aee474a435310f9d01d">&#9670;&nbsp;</a></span>domain_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::domain_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the domain space of this matrix, i.e., the partitioning of the vectors this matrix has to be multiplied with.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a95be9f345182496414c8f74f81ad9502">locally_owned_domain_indices()</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02453">2453</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ad44e6e1a555a948be14488da585df8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44e6e1a555a948be14488da585df8df">&#9670;&nbsp;</a></span>range_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::range_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the range space of this matrix, i.e., the partitioning of the vectors that are result from matrix-vector products.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4255ce516797c98c4448a293ee4f523f">locally_owned_range_indices()</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02461">2461</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ab08f051d19a7c0bc086563304451f601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08f051d19a7c0bc086563304451f601">&#9670;&nbsp;</a></span>row_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::row_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the matrix rows. Equal to the partitioning of the range.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000077">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4255ce516797c98c4448a293ee4f523f">locally_owned_range_indices()</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02469">2469</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4254a36d7d0888daf031dbcbccce8c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4254a36d7d0888daf031dbcbccce8c12">&#9670;&nbsp;</a></span>col_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_Map &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::col_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_Map that sets the partitioning of the matrix columns. This is in general not equal to the partitioner Epetra_Map for the domain because of overlap in the matrix.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000078">Deprecated:</a></b></dt><dd>Usually not necessary. If desired, access it via the Epetra_CrsMatrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02477">2477</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a95be9f345182496414c8f74f81ad9502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95be9f345182496414c8f74f81ad9502">&#9670;&nbsp;</a></span>locally_owned_domain_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparseMatrix::locally_owned_domain_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the domain space of this matrix, i.e., the partitioning of the vectors this matrix has to be multiplied with. </p>

</div>
</div>
<a id="a4255ce516797c98c4448a293ee4f523f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4255ce516797c98c4448a293ee4f523f">&#9670;&nbsp;</a></span>locally_owned_range_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparseMatrix::locally_owned_range_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the range space of this matrix, i.e., the partitioning of the vectors that are result from matrix-vector products. </p>

</div>
</div>
<a id="a53bc4c91231034a9924a89cb45bea7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bc4c91231034a9924a89cb45bea7df">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first element of the matrix.</p>
<p>The elements accessed by iterators within each row are ordered in the way in which Trilinos stores them, though the implementation guarantees that all elements of one row are accessed before the elements of the next row. If your algorithm relies on visiting elements within one row, you will need to consult with the Trilinos documentation on the order in which it stores data. It is, however, generally not a good and long- term stable idea to rely on the order in which receive elements if you iterate over them.</p>
<p>When you iterate over the elements of a parallel matrix, you will only be able to access the locally owned rows. (You can access the other rows as well, but they will look empty.) In that case, you probably want to call the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a432dd81dc9b1c3446d2b35dd902af016">begin()</a> function that takes the row as an argument to limit the range of elements to loop over. </p>

</div>
</div>
<a id="a432dd81dc9b1c3446d2b35dd902af016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432dd81dc9b1c3446d2b35dd902af016">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="ae46e2e5d966499c1b4e9da1798445eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46e2e5d966499c1b4e9da1798445eef">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing the element past the last one of this matrix. </p>

</div>
</div>
<a id="a818f02479da77b15b295090b8d379bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818f02479da77b15b295090b8d379bb5">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="aad11df47057376b44f5e495727ea9d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad11df47057376b44f5e495727ea9d72">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first element of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. The returned iterator may not be dereferencable in that case if neither row <code>r</code> nor any of the following rows contain any nonzero entries.</p>
<p>The elements accessed by iterators within each row are ordered in the way in which Trilinos stores them, though the implementation guarantees that all elements of one row are accessed before the elements of the next row. If your algorithm relies on visiting elements within one row, you will need to consult with the Trilinos documentation on the order in which it stores data. It is, however, generally not a good and long- term stable idea to rely on the order in which receive elements if you iterate over them.</p>
<dl class="section note"><dt>Note</dt><dd>When you access the elements of a parallel matrix, you can only access the elements of rows that are actually stored locally. (You can access the other rows as well, but they will look empty.) Even then, if another processor has since written into, or added to, an element of the matrix that is stored on the current processor, then you will still see the old value of this entry unless you have called <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> between modifying the matrix element on the remote processor and accessing it on the current processor. See the documentation of the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> function for more information. </dd></dl>

</div>
</div>
<a id="ac801a93ef57d40f3fbe36ca10909e47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac801a93ef57d40f3fbe36ca10909e47f">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="a77d0dcda5cd5cfd144526471a8c99d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d0dcda5cd5cfd144526471a8c99d9a">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2b7cd05f0a29cf3725d7323c961938e5">const_iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing the element past the last one of row <code>r</code> , or past the end of the entire sparsity pattern if none of the rows after <code>r</code> contain any entries at all.</p>
<p>Note that the end iterator is not necessarily dereferencable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a id="aba4773e90eb187a3432dd2b69fe28273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4773e90eb187a3432dd2b69fe28273">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af2bbbe25812a885629f61c0adb78161d">iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afe482aa470fc1e948eabce22fbe0bad6">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="ad2297e8c999fc04057a3c2370b0db96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2297e8c999fc04057a3c2370b0db96c">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::write_ascii </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract Trilinos object that helps view in ASCII other Trilinos objects. Currently this function is not implemented. TODO: Not implemented. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02404">2404</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4270ebaea8467f2862cf2baf38986815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4270ebaea8467f2862cf2baf38986815">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>write_extended_trilinos_info</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the matrix to the given stream, using the format <code>(line,col) value</code>, i.e. one nonzero entry of the matrix per line. The optional flag outputs the sparsity pattern in Trilinos style, where the data is sorted according to the processor number when printed to the stream, as well as a summary of the matrix like the global size. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02415">2415</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a536e7d727e8394586b4c2dde99b39ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536e7d727e8394586b4c2dde99b39ba3">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For some matrix storage formats, in particular for the PETSc distributed blockmatrices, set and add operations on individual elements can not be freely mixed. Rather, one has to synchronize operations when one wants to switch from setting elements to adding to elements. <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> automatically synchronizes the access by calling this helper function for each block. This function ensures that the matrix is in a state that allows adding elements; if it previously already was in this state, the function does nothing. </p>

</div>
</div>
<a id="a68a6620012e379b4c660fb4431d817fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a6620012e379b4c660fb4431d817fb">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a536e7d727e8394586b4c2dde99b39ba3">prepare_add()</a> but prepare the matrix for setting elements if the representation of elements in this class requires such an operation. </p>

</div>
</div>
<a id="a3fa3fb36823ad53496b2e655fd047aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa3fb36823ad53496b2e655fd047aaf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&amp; TrilinosWrappers::SparseMatrix::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator= is disabled. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0eb72d666c41a0ac3c16def795c0c99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb72d666c41a0ac3c16def795c0c99b">&#9670;&nbsp;</a></span>BlockMatrixBase< SparseMatrix ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>To allow calling protected <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a536e7d727e8394586b4c2dde99b39ba3">prepare_add()</a> and <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a68a6620012e379b4c660fb4431d817fb">prepare_set()</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02046">2046</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a90cf60f415387029c911e71407677b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cf60f415387029c911e71407677b42">&#9670;&nbsp;</a></span>column_space_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;Epetra_Map&gt; TrilinosWrappers::SparseMatrix::column_space_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the user-supplied Epetra Trilinos mapping of the matrix columns that assigns parts of the matrix to the individual processes. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02003">2003</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ad45ff31c2149fd2db87e1a9f81598915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45ff31c2149fd2db87e1a9f81598915">&#9670;&nbsp;</a></span>matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;Epetra_FECrsMatrix&gt; TrilinosWrappers::SparseMatrix::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sparse matrix object in Trilinos to be used for finite element based problems which allows for assembling into non-local elements. The actual type, a sparse matrix, is set in the constructor. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02010">2010</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a5ee7e1991cf28e0f72f6b70b24638860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee7e1991cf28e0f72f6b70b24638860">&#9670;&nbsp;</a></span>nonlocal_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;Epetra_CrsMatrix&gt; TrilinosWrappers::SparseMatrix::nonlocal_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sparse matrix object in Trilinos to be used for collecting the non- local elements if the matrix was constructed from a Trilinos sparsity pattern with the respective option. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02017">2017</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ab84494c005bca0842be9d457b6774a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84494c005bca0842be9d457b6774a86">&#9670;&nbsp;</a></span>nonlocal_matrix_exporter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;Epetra_Export&gt; TrilinosWrappers::SparseMatrix::nonlocal_matrix_exporter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An export object used to communicate the nonlocal matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02022">2022</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a3c1d6236f2215737135912c25cc993b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1d6236f2215737135912c25cc993b0">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CombineMode TrilinosWrappers::SparseMatrix::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trilinos doesn't allow to mix additions to matrix entries and overwriting them (to make synchronisation of parallel computations simpler). The way we do it is to, for each access operation, store whether it is an insertion or an addition. If the previous one was of different type, then we first have to flush the Trilinos buffers; otherwise, we can simply go on. Luckily, Trilinos has an object for this which does already all the parallel communications in such a case, so we simply use their model, which stores whether the last operation was an addition or an insertion. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02035">2035</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a896761c5d6156507d191a404ca7dc8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896761c5d6156507d191a404ca7dc8c3">&#9670;&nbsp;</a></span>compressed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TrilinosWrappers::SparseMatrix::compressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A boolean variable to hold information on whether the vector is compressed or not. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l02041">2041</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/lac/<a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/lac/<a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
