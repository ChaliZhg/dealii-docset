<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilities Namespace Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceUtilities_1_1MPI"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html">MPI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1System"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1System.html">System</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1Trilinos"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1Trilinos.html">Trilinos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtilities_1_1fixed__int__power.html">fixed_int_power</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtilities_1_1fixed__int__power_3_01a_00_010_01_4.html">fixed_int_power&lt; a, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6195c5f009ea8c7c536c6ffdf108c32f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a> (const unsigned int value, const unsigned int digits=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a6195c5f009ea8c7c536c6ffdf108c32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cb23f1982e4aa0bec09b60903303ce"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a56cb23f1982e4aa0bec09b60903303ce"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">to_string</a> (const number value, const unsigned int digits=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a56cb23f1982e4aa0bec09b60903303ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c75f3b2b9de645e7432eba26e59499b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a9c75f3b2b9de645e7432eba26e59499b">needed_digits</a> (const unsigned int max_number)</td></tr>
<tr class="separator:a9c75f3b2b9de645e7432eba26e59499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8ff146c677d8a2408b88e4936f57d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#af7e8ff146c677d8a2408b88e4936f57d">string_to_int</a> (const std::string &amp;s)</td></tr>
<tr class="separator:af7e8ff146c677d8a2408b88e4936f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa22d290ce783e37587b6c879b926c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">dim_string</a> (const int dim, const int spacedim)</td></tr>
<tr class="separator:a21aa22d290ce783e37587b6c879b926c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af501c72fdc02dd969cd9d82d0f30642c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#af501c72fdc02dd969cd9d82d0f30642c">string_to_int</a> (const std::vector&lt; std::string &gt; &amp;s)</td></tr>
<tr class="separator:af501c72fdc02dd969cd9d82d0f30642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3177021843ad87857e6f8c5d98d29a5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ab3177021843ad87857e6f8c5d98d29a5">string_to_double</a> (const std::string &amp;s)</td></tr>
<tr class="separator:ab3177021843ad87857e6f8c5d98d29a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd7c2e406c4e77b2cbbd2d68d2251a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a4cd7c2e406c4e77b2cbbd2d68d2251a5">string_to_double</a> (const std::vector&lt; std::string &gt; &amp;s)</td></tr>
<tr class="separator:a4cd7c2e406c4e77b2cbbd2d68d2251a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df05a8daeaa7e2eaf7d0bb8e4dccd75"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a7df05a8daeaa7e2eaf7d0bb8e4dccd75">split_string_list</a> (const std::string &amp;s, const char delimiter=',')</td></tr>
<tr class="separator:a7df05a8daeaa7e2eaf7d0bb8e4dccd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5448c92da85de774d6274e9a27797443"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a5448c92da85de774d6274e9a27797443">break_text_into_lines</a> (const std::string &amp;original_text, const unsigned int width, const char delimiter=' ')</td></tr>
<tr class="separator:a5448c92da85de774d6274e9a27797443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37ad8cfa930cb1ff91d68562553fec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a6b37ad8cfa930cb1ff91d68562553fec">match_at_string_start</a> (const std::string &amp;name, const std::string &amp;pattern)</td></tr>
<tr class="separator:a6b37ad8cfa930cb1ff91d68562553fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbc4b2f7fb9ef31b841667a47ce3955"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a2dbc4b2f7fb9ef31b841667a47ce3955">get_integer_at_position</a> (const std::string &amp;name, const unsigned int position)</td></tr>
<tr class="separator:a2dbc4b2f7fb9ef31b841667a47ce3955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51121974cb2781c8bbb0ec281ece9f40"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a51121974cb2781c8bbb0ec281ece9f40">replace_in_string</a> (const std::string &amp;input, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="separator:a51121974cb2781c8bbb0ec281ece9f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca117b9cf9345b7ae7b72a075ddde116"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aca117b9cf9345b7ae7b72a075ddde116">trim</a> (const std::string &amp;input)</td></tr>
<tr class="separator:aca117b9cf9345b7ae7b72a075ddde116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6aef87ce08208501a4b524563836db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#acc6aef87ce08208501a4b524563836db">generate_normal_random_number</a> (const double a, const double sigma)</td></tr>
<tr class="separator:acc6aef87ce08208501a4b524563836db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a834c6b595ada6f8e73c78d9bbd8ec551">fixed_power</a> (const T t)</td></tr>
<tr class="separator:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0f9cd449850bf25160131cc4bc5668"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:aaa0f9cd449850bf25160131cc4bc5668"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aaa0f9cd449850bf25160131cc4bc5668">lower_bound</a> (Iterator first, Iterator last, const T &amp;val)</td></tr>
<tr class="separator:aaa0f9cd449850bf25160131cc4bc5668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , typename Comp &gt; </td></tr>
<tr class="memitem:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3c612c5ab6f6fe3937de5f82861d7533">lower_bound</a> (Iterator first, Iterator last, const T &amp;val, const Comp comp)</td></tr>
<tr class="separator:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d54ac427150430fe028da02c96f02a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a41d54ac427150430fe028da02c96f02a">reverse_permutation</a> (const std::vector&lt; unsigned int &gt; &amp;permutation)</td></tr>
<tr class="separator:a41d54ac427150430fe028da02c96f02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f352d23f380f72d348748f4c123df5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a1f352d23f380f72d348748f4c123df5c">invert_permutation</a> (const std::vector&lt; unsigned int &gt; &amp;permutation)</td></tr>
<tr class="separator:a1f352d23f380f72d348748f4c123df5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9c64e4192ad27000d69b2551a6cf0c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned long long int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aea9c64e4192ad27000d69b2551a6cf0c">reverse_permutation</a> (const std::vector&lt; unsigned long long int &gt; &amp;permutation)</td></tr>
<tr class="separator:aea9c64e4192ad27000d69b2551a6cf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b3d10971f505cf9f20ca8d289567ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned long long int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ab4b3d10971f505cf9f20ca8d289567ed">invert_permutation</a> (const std::vector&lt; unsigned long long int &gt; &amp;permutation)</td></tr>
<tr class="separator:ab4b3d10971f505cf9f20ca8d289567ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee8b31b876b891b70c12dc6a0923c41"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gadee8b31b876b891b70c12dc6a0923c41">ExcInvalidNumber2StringConversersion</a> (unsigned int arg1, unsigned int arg2)</td></tr>
<tr class="separator:gadee8b31b876b891b70c12dc6a0923c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac98d370fcc24eb633bfeababf1f545a6"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac98d370fcc24eb633bfeababf1f545a6">ExcInvalidNumber</a> (unsigned int arg1)</td></tr>
<tr class="separator:gac98d370fcc24eb633bfeababf1f545a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f23b3289d86463b6b31c38e30b77769"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8f23b3289d86463b6b31c38e30b77769">ExcCantConvertString</a> (std::string arg1)</td></tr>
<tr class="separator:ga8f23b3289d86463b6b31c38e30b77769"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace for utility functions that are not particularly specific to finite element computing or numerical programs, but nevertheless are needed in various contexts when writing applications.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a6195c5f009ea8c7c536c6ffdf108c32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6195c5f009ea8c7c536c6ffdf108c32f">&#9670;&nbsp;</a></span>int_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::int_to_string </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>digits</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a number <code>value</code> to a string, with as many digits as given to fill with leading zeros.</p>
<p>If the second parameter is left at its default value, the number is not padded with leading zeros. The result is then the same as if the standard C function <code>itoa()</code> had been called.</p>
<p>When calling this function signed integers are implicitly converted to unsigned integers and long integers might experience an overflow.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this function is discouraged and users should use <code><a class="el" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string()</a></code> instead. In its current implementation the function simply calls <code>to_string&lt;unsigned int&gt;()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00085">85</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a56cb23f1982e4aa0bec09b60903303ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cb23f1982e4aa0bec09b60903303ce">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::to_string </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>digits</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a number <code>value</code> to a string, with <code>digits</code> characters. The string is padded with leading zeros, after a possible minus sign. Therefore the total number of padding zeros is <code>digits</code> minus any signs, decimal points and digits of <code>value</code>.</p>
<p>If the second parameter is left at its default value, the number is not padded with leading zeros. The result is then the same as if the boost function <code>lexical_cast&lt;std::string&gt;()</code> had been called. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00092">92</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a9c75f3b2b9de645e7432eba26e59499b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c75f3b2b9de645e7432eba26e59499b">&#9670;&nbsp;</a></span>needed_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Utilities::needed_digits </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>max_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine how many digits are needed to represent numbers at most as large as the given number. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00171">171</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="af7e8ff146c677d8a2408b88e4936f57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8ff146c677d8a2408b88e4936f57d">&#9670;&nbsp;</a></span>string_to_int() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, convert it to an integer. Throw an assertion if that is not possible. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00192">192</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a21aa22d290ce783e37587b6c879b926c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aa22d290ce783e37587b6c879b926c">&#9670;&nbsp;</a></span>dim_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::dim_string </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>spacedim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string describing the dimensions of the object. Often, functions in the deal.II library as well as in user codes need to define a string containing the template dimensions of some objects defined using two template parameters: dim (the topological dimension of the object) and spacedim (the dimension of the embedding Euclidean space). Since in all deal.II classes, by default spacedim is equal to dimension, the above string is usually contracted to "&lt;dim&gt;", instead of "&lt;dim,spacedim&gt;". This function returns a string containing "dim" if dim is equal to spacedim, otherwise it returns "dim,spacedim". </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00161">161</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="af501c72fdc02dd969cd9d82d0f30642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af501c72fdc02dd969cd9d82d0f30642c">&#9670;&nbsp;</a></span>string_to_int() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Utilities::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of strings, convert it to a list of integers. Throw an assertion if that is not possible. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00219">219</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ab3177021843ad87857e6f8c5d98d29a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3177021843ad87857e6f8c5d98d29a5">&#9670;&nbsp;</a></span>string_to_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Utilities::string_to_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, convert it to an double. Throw an assertion if that is not possible. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00230">230</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a4cd7c2e406c4e77b2cbbd2d68d2251a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd7c2e406c4e77b2cbbd2d68d2251a5">&#9670;&nbsp;</a></span>string_to_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Utilities::string_to_double </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of strings, convert it to a list of doubles. Throw an assertion if that is not possible. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00257">257</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a7df05a8daeaa7e2eaf7d0bb8e4dccd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df05a8daeaa7e2eaf7d0bb8e4dccd75">&#9670;&nbsp;</a></span>split_string_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utilities::split_string_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>','</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string that contains text separated by a <code>delimiter</code>, split it into its components; for each component, remove leading and trailing spaces. The default value of the delimiter is a comma, so that the function splits comma separated lists of strings.</p>
<p>To make data input from tables simpler, if the input string ends in a delimiter (possibly followed by an arbitrary amount of whitespace), then this last delimiter is ignored. For example, </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a7df05a8daeaa7e2eaf7d0bb8e4dccd75">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc; def; ghi; &quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> yields the same 3-element list of output <code>{"abc","def","ghi"}</code> as you would get if the input had been </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a7df05a8daeaa7e2eaf7d0bb8e4dccd75">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc; def; ghi&quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a7df05a8daeaa7e2eaf7d0bb8e4dccd75">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc; def; ghi;&quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> As a consequence of this rule, a call like </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a7df05a8daeaa7e2eaf7d0bb8e4dccd75">Utilities::split_string_list</a>(<span class="stringliteral">&quot; ; &quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> yields a one-element list. Because of the trimming of whitespace, the single element is the empty string.</p>
<p>This function can digest the case that the delimiter is a space. In this case, it returns all words in the string. Combined with the rules above, this implies that </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a7df05a8daeaa7e2eaf7d0bb8e4dccd75">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc def ghi &quot;</span>, <span class="charliteral">&#39; &#39;</span>);</div></div><!-- fragment --><p> yields again the 3-element list of output <code>{"abc","def","ghi"}</code> from above despite the presence of space at the end of the string. Furthermore, </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a7df05a8daeaa7e2eaf7d0bb8e4dccd75">Utilities::split_string_list</a>(<span class="stringliteral">&quot;      &quot;</span>, <span class="charliteral">&#39; &#39;</span>);</div></div><!-- fragment --><p> yields an empty list regardless of the number of spaces in the string. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00268">268</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a5448c92da85de774d6274e9a27797443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5448c92da85de774d6274e9a27797443">&#9670;&nbsp;</a></span>break_text_into_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utilities::break_text_into_lines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a text, usually a documentation or something, and try to break it into individual lines of text at most <code>width</code> characters wide, by breaking at positions marked by <code>delimiter</code> in the text. If this is not possible, return the shortest lines that are longer than <code>width</code>. The default value of the delimiter is a space character. If original_text contains newline characters (<br />
), the string is split at these locations, too. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00316">316</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a6b37ad8cfa930cb1ff91d68562553fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b37ad8cfa930cb1ff91d68562553fec">&#9670;&nbsp;</a></span>match_at_string_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Utilities::match_at_string_start </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given pattern string appears in the first position of the string. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00393">393</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a2dbc4b2f7fb9ef31b841667a47ce3955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbc4b2f7fb9ef31b841667a47ce3955">&#9670;&nbsp;</a></span>get_integer_at_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, unsigned int &gt; Utilities::get_integer_at_position </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a (signed) integer starting at the position in <code>name</code> indicated by the second argument, and return this integer as a pair together with how many characters it takes up in the string.</p>
<p>If no integer can be read at the indicated position, return (-1,<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>) </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00409">409</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a51121974cb2781c8bbb0ec281ece9f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51121974cb2781c8bbb0ec281ece9f40">&#9670;&nbsp;</a></span>replace_in_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::replace_in_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string with all occurrences of <code>from</code> in <code>input</code> replaced by <code>to</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00115">115</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="aca117b9cf9345b7ae7b72a075ddde116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca117b9cf9345b7ae7b72a075ddde116">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string with all standard whitespace characters (including '<code>\t</code>', '<code>\n</code>', and '<code>\r</code>') at the beginning and end of <code>input</code> removed. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00134">134</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="acc6aef87ce08208501a4b524563836db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6aef87ce08208501a4b524563836db">&#9670;&nbsp;</a></span>generate_normal_random_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Utilities::generate_normal_random_number </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a random number from a normalized Gaussian probability distribution centered around <code>a</code> and with standard deviation <code>sigma</code>.</p>
<p>This function is reentrant, i.e., it can safely be called from multiple threads at the same time. In addition, each thread will get the same sequence of numbers every time. On the other hand, if you run <a class="el" href="classThreads_1_1Task.html">Threads::Task</a> objects via the Threading Building Blocks, then tasks will be assigned to mostly random threads, and may get a different sequence of random numbers in different runs of the program, since a previous task may already have consumed the first few random numbers generated for the thread you're on. If this is a problem, you need to create your own random number generator objects every time you want to start from a defined point.</p>
<dl class="section note"><dt>Note</dt><dd>Like the system function rand(), this function produces the same sequence of random numbers every time a program is started. This is an important property for debugging codes, but it makes it impossible to really verify statistics properties of a code. For rand(), you can call srand() to "seed" the random number generator to get different sequences of random numbers every time a program is called. However, this function does not allow seeding the random number generator. If you need this, as above, use one of the C++ or BOOST facilities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00453">453</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a834c6b595ada6f8e73c78d9bbd8ec551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834c6b595ada6f8e73c78d9bbd8ec551">&#9670;&nbsp;</a></span>fixed_power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::fixed_power </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate a fixed power, provided as a template argument, of a number.</p>
<p>This function provides an efficient way to calculate things like <code>t^N</code> where <code>N</code> is a known number at compile time.</p>
<p>Use this function as in <code>fixed_power&lt;dim&gt; (n)</code>. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00592">592</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aaa0f9cd449850bf25160131cc4bc5668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0f9cd449850bf25160131cc4bc5668">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator Utilities::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimized replacement for <code>std::lower_bound</code> for searching within the range of column indices. Slashes execution time by approximately one half for the present application, partly because because the binary search is replaced by a linear search for small loop lengths.</p>
<p>Another reason for this function is rather obscure: when using the GCC libstdc++ function std::lower_bound, complexity is O(log(N)) as required. However, when using the debug version of the GCC libstdc++ as we do when running the testsuite, then std::lower_bound tests whether the sequence is in fact partitioned with respect to the pivot 'value' (i.e. in essence that the sequence is sorted as required for binary search to work). However, verifying this means that the complexity of std::lower_bound jumps to O(N); we call this function O(N) times below, making the overall complexity O(N**2). The consequence is that a few tests with big meshes completely run off the wall time limit for tests and fail with the libstdc++ debug mode</p>
<p>This function simply makes the assumption that the sequence is sorted, and we simply don't do the additional check. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00618">618</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a3c612c5ab6f6fe3937de5f82861d7533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c612c5ab6f6fe3937de5f82861d7533">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T , typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator Utilities::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same function as above, but taking an argument that is used to compare individual elements of the sequence of objects pointed to by the iterators. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00631">631</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a41d54ac427150430fe028da02c96f02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d54ac427150430fe028da02c96f02a">&#9670;&nbsp;</a></span>reverse_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; Utilities::reverse_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector <img class="formulaInl" alt="$p_0\ldots p_{N-1}$" src="form_506.png"/> where each <img class="formulaInl" alt="$p_i\in [0,N)$" src="form_507.png"/> and <img class="formulaInl" alt="$p_i\neq p_j$" src="form_508.png"/> for <img class="formulaInl" alt="$i\neq j$" src="form_509.png"/>), produce the reverse permutation <img class="formulaInl" alt="$q_i=N-1-p_i$" src="form_510.png"/>. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00472">472</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a1f352d23f380f72d348748f4c123df5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f352d23f380f72d348748f4c123df5c">&#9670;&nbsp;</a></span>invert_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; Utilities::invert_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector <img class="formulaInl" alt="$p_0\ldots p_{N-1}$" src="form_506.png"/> where each <img class="formulaInl" alt="$p_i\in [0,N)$" src="form_507.png"/> and <img class="formulaInl" alt="$p_i\neq p_j$" src="form_508.png"/> for <img class="formulaInl" alt="$i\neq j$" src="form_509.png"/>), produce the inverse permutation <img class="formulaInl" alt="$q_0\ldots q_{N-1}$" src="form_511.png"/> so that <img class="formulaInl" alt="$q_{p_i}=p_{q_i}=i$" src="form_512.png"/>. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00486">486</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="aea9c64e4192ad27000d69b2551a6cf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9c64e4192ad27000d69b2551a6cf0c">&#9670;&nbsp;</a></span>reverse_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned long long int &gt; Utilities::reverse_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector <img class="formulaInl" alt="$p_0\ldots p_{N-1}$" src="form_506.png"/> where each <img class="formulaInl" alt="$p_i\in [0,N)$" src="form_507.png"/> and <img class="formulaInl" alt="$p_i\neq p_j$" src="form_508.png"/> for <img class="formulaInl" alt="$i\neq j$" src="form_509.png"/>), produce the reverse permutation <img class="formulaInl" alt="$q_i=N-1-p_i$" src="form_510.png"/>. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00508">508</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ab4b3d10971f505cf9f20ca8d289567ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b3d10971f505cf9f20ca8d289567ed">&#9670;&nbsp;</a></span>invert_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned long long int &gt; Utilities::invert_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long long int &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector <img class="formulaInl" alt="$p_0\ldots p_{N-1}$" src="form_506.png"/> where each <img class="formulaInl" alt="$p_i\in [0,N)$" src="form_507.png"/> and <img class="formulaInl" alt="$p_i\neq p_j$" src="form_508.png"/> for <img class="formulaInl" alt="$i\neq j$" src="form_509.png"/>), produce the inverse permutation <img class="formulaInl" alt="$q_0\ldots q_{N-1}$" src="form_511.png"/> so that <img class="formulaInl" alt="$q_{p_i}=p_{q_i}=i$" src="form_512.png"/>. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00522">522</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
