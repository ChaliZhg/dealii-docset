<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-23 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-23 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Timediscretization">Time discretization</a>
      <ul>
        <li><a href="#MethodoflinesorRothesmethod">Method of lines or Rothe's method?</a>
        <li><a href="#Rothesmethod">Rothe's method!</a>
      </ul>
        <li><a href="#Spacediscretization">Space discretization</a>
        <li><a href="#Energyconservation">Energy conservation</a>
        <li><a href="#WhoareCourantFriedrichsandLewy">Who are Courant, Friedrichs, and Lewy?</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeWaveEquationcodeclass">The <code>WaveEquation</code> class</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeWaveEquationcodeclass">Implementation of the <code>WaveEquation</code> class</a>
      <ul>
        <li><a href="#WaveEquationsetup_system">WaveEquation::setup_system</a>
        <li><a href="#WaveEquationsolve_uandWaveEquationsolve_v">WaveEquation::solve_u and WaveEquation::solve_v</a>
        <li><a href="#WaveEquationoutput_results">WaveEquation::output_results</a>
        <li><a href="#WaveEquationrun">WaveEquation::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.28.html">video lecture 28</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>This is the first of a number of tutorial programs that will finally cover "real" time-dependent problems, not the slightly odd form of time dependence found in <a class="el" href="step_18.html">step-18</a> or the DAE model of <a class="el" href="step_21.html">step-21</a>. In particular, this program introduces the wave equation in a bounded domain. Later, <a class="el" href="step_24.html">step-24</a> will consider an example of absorbing boundary conditions, and <a class="el" href="step_25.html">step-25</a> a kind of nonlinear wave equation producing solutions called solitons.</p>
<p>The wave equation in its prototypical form reads as follows: find <img class="formulaInl" alt="$u(x,t), x\in\Omega, t\in[0,T]$" src="form_1916.png"/> that satisfies </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{\partial^2 u}{\partial t^2} - \Delta u &amp;=&amp; f \qquad \textrm{in}\ \Omega\times [0,T], \\ u(x,t) &amp;=&amp; g \qquad \textrm{on}\ \partial\Omega\times [0,T], \\ u(x,0) &amp;=&amp; u_0(x) \qquad \textrm{in}\ \Omega, \\ \frac{\partial u(x,0)}{\partial t} &amp;=&amp; u_1(x) \qquad \textrm{in}\ \Omega. \end{eqnarray*}" src="form_1917.png"/>
</p>
<p> Note that since this is an equation with second-order time derivatives, we need to pose two initial conditions, one for the value and one for the time derivative of the solution.</p>
<p>Physically, the equation describes the motion of an elastic medium. In 2-d, one can think of how a membrane moves if subjected to a force. The Dirichlet boundary conditions above indicate that the membrane is clamped at the boundary at a height <img class="formulaInl" alt="$g(x,t)$" src="form_1918.png"/> (this height might be moving as well &mdash; think of people holding a blanket and shaking it up and down). The first initial condition equals the initial deflection of the membrane, whereas the second one gives its velocity. For example, one could think of pushing the membrane down with a finger and then letting it go at <img class="formulaInl" alt="$t=0$" src="form_854.png"/> (nonzero deflection but zero initial velocity), or hitting it with a hammer at <img class="formulaInl" alt="$t=0$" src="form_854.png"/> (zero deflection but nonzero velocity). Both cases would induce motion in the membrane.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p><a class="anchor" id="MethodoflinesorRothesmethod"></a></p><h4>Method of lines or Rothe's method?</h4>
<p>There is a long-standing debate in the numerical analysis community over whether a discretization of time dependent equations should involve first discretizing the time variable leading to a stationary PDE at each time step that is then solved using standard finite element techniques (this is called the Rothe method), or whether one should first discretize the spatial variables, leading to a large system of ordinary differential equations that can then be handled by one of the usual ODE solvers (this is called the method of lines).</p>
<p>Both of these methods have advantages and disadvantages. Traditionally, people have preferred the method of lines, since it allows to use the very well developed machinery of high-order ODE solvers available for the rather stiff ODEs resulting from this approach, including step length control and estimation of the temporal error.</p>
<p>On the other hand, Rothe's method becomes awkward when using higher-order time stepping method, since one then has to write down a PDE that couples the solution of the present time step not only with that at the previous time step, but possibly also even earlier solutions, leading to a significant number of terms.</p>
<p>For these reasons, the method of lines was the method of choice for a long time. However, it has one big drawback: if we discretize the spatial variable first, leading to a large ODE system, we have to choose a mesh once and for all. If we are willing to do this, then this is a legitimate and probably superior approach.</p>
<p>If, on the other hand, we are looking at the wave equation and many other time dependent problems, we find that the character of a solution changes as time progresses. For example, for the wave equation, we may have a single wave travelling through the domain, where the solution is smooth or even constant in front of and behind the wave &mdash; adaptivity would be really useful for such cases, but the key is that the area where we need to refine the mesh changes from time step to time step!</p>
<p>If we intend to go that way, i.e. choose a different mesh for each time step (or set of time steps), then the method of lines is not appropriate any more: instead of getting one ODE system with a number of variables equal to the number of unknowns in the finite element mesh, our number of unknowns now changes all the time, a fact that standard ODE solvers are certainly not prepared to deal with at all. On the other hand, for the Rothe method, we just get a PDE for each time step that we may choose to discretize independently of the mesh used for the previous time step; this approach is not without perils and difficulties, but at least is a sensible and well-defined procedure.</p>
<p>For all these reasons, for the present program, we choose to use the Rothe method for discretization, i.e. we first discretize in time and then in space. We will not actually use adaptive meshes at all, since this involves a large amount of additional code, but we will comment on this some more in the <a href="#Results">results section below</a>.</p>
<p><a class="anchor" id="Rothesmethod"></a></p><h4>Rothe's method!</h4>
<p>Given these considerations, here is how we will proceed: let us first define a simple time stepping method for this second order problem, and then in a second step do the spatial discretization, i.e. we will follow Rothe's approach.</p>
<p>For the first step, let us take a little detour first: in order to discretize a second time derivative, we can either discretize it directly, or we can introduce an additional variable and transform the system into a first order system. In many cases, this turns out to be equivalent, but dealing with first order systems is often simpler. To this end, let us introduce </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ v = \frac{\partial u}{\partial t}, \]" src="form_1919.png"/>
</p>
<p> and call this variable the <em>velocity</em> for obvious reasons. We can then reformulate the original wave equation as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{\partial u}{\partial t} - v &amp;=&amp; 0 \qquad \textrm{in}\ \Omega\times [0,T], \\ \frac{\partial v}{\partial t} - \Delta u &amp;=&amp; f \qquad \textrm{in}\ \Omega\times [0,T], \\ u(x,t) &amp;=&amp; g \qquad \textrm{on}\ \partial\Omega\times [0,T], \\ u(x,0) &amp;=&amp; u_0(x) \qquad \textrm{in}\ \Omega, \\ v(x,0) &amp;=&amp; u_1(x) \qquad \textrm{in}\ \Omega. \end{eqnarray*}" src="form_1920.png"/>
</p>
<p> The advantage of this formulation is that it now only contains first time derivatives for both variables, for which it is simple to write down time stepping schemes. Note that we do not have boundary conditions for <img class="formulaInl" alt="$v$" src="form_987.png"/> at first. However, we could enforce <img class="formulaInl" alt="$v=\frac{\partial g}{\partial t}$" src="form_1921.png"/> on the boundary. It turns out in numerical examples that this is actually necessary: without doing so the solution doesn't look particularly wrong, but the Crank-Nicolson scheme does not conserve energy if one doesn't enforce these boundary conditions.</p>
<p>With this formulation, let us introduce the following time discretization where a superscript <img class="formulaInl" alt="$n$" src="form_73.png"/> indicates the number of a time step and <img class="formulaInl" alt="$k=t_n-t_{n-1}$" src="form_1922.png"/> is the length of the present time step: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{u^n - u^{n-1}}{k} - \left[\theta v^n + (1-\theta) v^{n-1}\right] &amp;=&amp; 0, \\ \frac{v^n - v^{n-1}}{k} - \Delta\left[\theta u^n + (1-\theta) u^{n-1}\right] &amp;=&amp; \theta f^n + (1-\theta) f^{n-1}. \end{eqnarray*}" src="form_1923.png"/>
</p>
<p> Note how we introduced a parameter <img class="formulaInl" alt="$\theta$" src="form_1363.png"/> here. If we chose <img class="formulaInl" alt="$\theta=0$" src="form_1924.png"/>, for example, the first equation would reduce to <img class="formulaInl" alt="$\frac{u^n - u^{n-1}}{k} - v^{n-1} = 0$" src="form_1925.png"/>, which is well-known as the forward or explicit Euler method. On the other hand, if we set <img class="formulaInl" alt="$\theta=1$" src="form_1926.png"/>, then we would get <img class="formulaInl" alt="$\frac{u^n - u^{n-1}}{k} - v^n = 0$" src="form_1927.png"/>, which corresponds to the backward or implicit Euler method. Both these methods are first order accurate methods. They are simple to implement, but they are not really very accurate.</p>
<p>The third case would be to choose <img class="formulaInl" alt="$\theta=\frac 12$" src="form_1928.png"/>. The first of the equations above would then read <img class="formulaInl" alt="$\frac{u^n - u^{n-1}}{k} - \frac 12 \left[v^n + v^{n-1}\right] = 0$" src="form_1929.png"/>. This method is known as the Crank-Nicolson method and has the advantage that it is second order accurate. In addition, it has the nice property that it preserves the energy in the solution (physically, the energy is the sum of the kinetic energy of the particles in the membrane plus the potential energy present due to the fact that it is locally stretched; this quantity is a conserved one in the continuous equation, but most time stepping schemes do not conserve it after time discretization). Since <img class="formulaInl" alt="$v^n$" src="form_1930.png"/> also appears in the equation for <img class="formulaInl" alt="$u^n$" src="form_1558.png"/>, the Crank-Nicolson scheme is also implicit.</p>
<p>In the program, we will leave <img class="formulaInl" alt="$\theta$" src="form_1363.png"/> as a parameter, so that it will be easy to play with it. The results section will show some numerical evidence comparing the different schemes.</p>
<p>The equations above (called the <em>semidiscretized</em> equations because we have only discretized the time, but not space), can be simplified a bit by eliminating <img class="formulaInl" alt="$v^n$" src="form_1930.png"/> from the first equation and rearranging terms. We then get </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left[ 1-k^2\theta^2\Delta \right] u^n &amp;=&amp; \left[ 1+k^2\theta(1-\theta)\Delta\right] u^{n-1} + k v^{n-1} + k^2\theta\left[\theta f^n + (1-\theta) f^{n-1}\right],\\ v^n &amp;=&amp; v^{n-1} + k\Delta\left[ \theta u^n + (1-\theta) u^{n-1}\right] + k\left[\theta f^n + (1-\theta) f^{n-1}\right]. \end{eqnarray*}" src="form_1931.png"/>
</p>
<p> In this form, we see that if we are given the solution <img class="formulaInl" alt="$u^{n-1},v^{n-1}$" src="form_1932.png"/> of the previous timestep, that we can then solve for the variables <img class="formulaInl" alt="$u^n,v^n$" src="form_1933.png"/> separately, i.e. one at a time. This is convenient. In addition, we recognize that the operator in the first equation is positive definite, and the second equation looks particularly simple.</p>
<p><a class="anchor" id="Spacediscretization"></a></p><h3>Space discretization</h3>
<p>We have now derived equations that relate the approximate (semi-discrete) solution <img class="formulaInl" alt="$u^n(x)$" src="form_1934.png"/> and its time derivative <img class="formulaInl" alt="$v^n(x)$" src="form_1935.png"/> at time <img class="formulaInl" alt="$t_n$" src="form_1936.png"/> with the solutions <img class="formulaInl" alt="$u^{n-1}(x),v^{n-1}(x)$" src="form_1937.png"/> of the previous time step at <img class="formulaInl" alt="$t_{n-1}$" src="form_1938.png"/>. The next step is to also discretize the spatial variable using the usual finite element methodology. To this end, we multiply each equation with a test function, integrate over the entire domain, and integrate by parts where necessary. This leads to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla u^{n-1},\nabla \varphi) + k(v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right], \\ (v^n,\varphi) &amp;=&amp; (v^{n-1},\varphi) - k\left[ \theta (\nabla u^n,\nabla\varphi) + (1-\theta) (\nabla u^{n-1},\nabla \varphi)\right] + k \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right]. \end{eqnarray*}" src="form_1939.png"/>
</p>
<p>It is then customary to approximate <img class="formulaInl" alt="$u^n(x) \approx u^n_h(x) = \sum_i U_i^n\phi_i^n(x)$" src="form_1940.png"/>, where <img class="formulaInl" alt="$\phi_i^n(x)$" src="form_1941.png"/> are the shape functions used for the discretization of the <img class="formulaInl" alt="$n$" src="form_73.png"/>-th time step and <img class="formulaInl" alt="$U_i^n$" src="form_1942.png"/> are the unknown nodal values of the solution. Similarly, <img class="formulaInl" alt="$v^n(x) \approx v^n_h(x) = \sum_i V_i^n\phi_i^n(x)$" src="form_1943.png"/>. Finally, we have the solutions of the previous time step, <img class="formulaInl" alt="$u^{n-1}(x) \approx u^{n-1}_h(x) = \sum_i U_i^{n-1}\phi_i^{n-1}(x)$" src="form_1944.png"/> and <img class="formulaInl" alt="$v^{n-1}(x) \approx v^{n-1}_h(x) = \sum_i V_i^{n-1}\phi_i^{n-1}(x)$" src="form_1945.png"/>. Note that since the solution of the previous time step has already been computed by the time we get to time step <img class="formulaInl" alt="$n$" src="form_73.png"/>, <img class="formulaInl" alt="$U^{n-1},V^{n-1}$" src="form_1946.png"/> are known. Furthermore, note that the solutions of the previous step may have been computed on a different mesh, so we have to use shape functions <img class="formulaInl" alt="$\phi^{n-1}_i(x)$" src="form_1947.png"/>.</p>
<p>If we plug these expansions into above equations and test with the test functions from the present mesh, we get the following linear system: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (M^n + k^2\theta^2 A^n)U^n &amp;=&amp; M^{n,n-1}U^{n-1} - k^2\theta(1-\theta) A^{n,n-1}U^{n-1} + kM^{n,n-1}V^{n-1} + k^2\theta \left[ \theta F^n + (1-\theta) F^{n-1} \right], \\ M^nV^n &amp;=&amp; M^{n,n-1}V^{n-1} - k\left[ \theta A^n U^n + (1-\theta) A^{n,n-1} U^{n-1}\right] + k \left[ \theta F^n + (1-\theta) F^{n-1} \right], \end{eqnarray*}" src="form_1948.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M^n_{ij} &amp;=&amp; (\phi_i^n, \phi_j^n), \\ A^n_{ij} &amp;=&amp; (\nabla\phi_i^n, \nabla\phi_j^n), \\ M^{n,n-1}_{ij} &amp;=&amp; (\phi_i^n, \phi_j^{n-1}), \\ A^{n,n-1}_{ij} &amp;=&amp; (\nabla\phi_i^n, \nabla\phi_j^{n-1}), \\ F^n_{i} &amp;=&amp; (f^n,\phi_i^n), \\ F^{n-1}_{i} &amp;=&amp; (f^{n-1},\phi_i^n). \end{eqnarray*}" src="form_1949.png"/>
</p>
<p>If we solve these two equations, we can move the solution one step forward and go on to the next time step.</p>
<p>It is worth noting that if we choose the same mesh on each time step (as we will in fact do in the program below), then we have the same shape functions on time step <img class="formulaInl" alt="$n$" src="form_73.png"/> and <img class="formulaInl" alt="$n-1$" src="form_1950.png"/>, i.e. <img class="formulaInl" alt="$\phi^n_i=\phi_i^{n-1}=\phi_i$" src="form_1951.png"/>. Consequently, we get <img class="formulaInl" alt="$M^n=M^{n,n-1}=M$" src="form_1952.png"/> and <img class="formulaInl" alt="$A^n=A^{n,n-1}=A$" src="form_1953.png"/>. On the other hand, if we had used different shape functions, then we would have to compute integrals that contain shape functions defined on two meshes. This is a somewhat messy process that we omit here, but that is treated in some detail in <a class="el" href="step_28.html">step-28</a>.</p>
<p>Under these conditions (i.e. a mesh that doesn't change), one can optimize the solution procedure a bit by basically eliminating the solution of the second linear system. We will discuss this in the introduction of the <a class="el" href="step_25.html">step-25</a> program.</p>
<p><a class="anchor" id="Energyconservation"></a></p><h3>Energy conservation</h3>
<p>One way to compare the quality of a time stepping scheme is to see whether the numerical approximation preserves conservation properties of the continuous equation. For the wave equation, the natural quantity to look at is the energy. By multiplying the wave equation by <img class="formulaInl" alt="$u_t$" src="form_1954.png"/>, integrating over <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>, and integrating by parts where necessary, we find that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{d}{d t} \left[\frac 12 \int_\Omega \left(\frac{\partial u}{\partial t}\right)^2 + (\nabla u)^2 \; dx\right] = \int_\Omega f \frac{\partial u}{\partial t} \; dx + \int_{\partial\Omega} n\cdot\nabla u \frac{\partial g}{\partial t} \; dx. \]" src="form_1955.png"/>
</p>
<p> By consequence, in absence of body forces and constant boundary values, we get that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E(t) = \frac 12 \int_\Omega \left(\frac{\partial u}{\partial t}\right)^2 + (\nabla u)^2 \; dx \]" src="form_1956.png"/>
</p>
<p> is a conserved quantity, i.e. one that doesn't change with time. We will compute this quantity after each time step. It is straightforward to see that if we replace <img class="formulaInl" alt="$u$" src="form_256.png"/> by its finite element approximation, and <img class="formulaInl" alt="$\frac{\partial u}{\partial t}$" src="form_1957.png"/> by the finite element approximation of the velocity <img class="formulaInl" alt="$v$" src="form_987.png"/>, then </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E(t_n) = \frac 12 \left&lt;V^n, M^n V^n\right&gt; + \frac 12 \left&lt;U^n, A^n U^n\right&gt;. \]" src="form_1958.png"/>
</p>
<p> As we will see in the results section, the Crank-Nicolson scheme does indeed conserve the energy, whereas neither the forward nor the backward Euler scheme do.</p>
<p><a class="anchor" id="WhoareCourantFriedrichsandLewy"></a></p><h3>Who are Courant, Friedrichs, and Lewy?</h3>
<p>One of the reasons why the wave equation is nasty to solve numerically is that explicit time discretizations are only stable if the time step is small enough. In particular, it is coupled to the spatial mesh width <img class="formulaInl" alt="$h$" src="form_720.png"/>. For the lowest order discretization we use here, the relationship reads </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ k\le \frac hc \]" src="form_1959.png"/>
</p>
<p> where <img class="formulaInl" alt="$c$" src="form_257.png"/> is the wave speed, which in our formulation of the wave equation has been normalized to one. Consequently, unless we use the implicit schemes with <img class="formulaInl" alt="$\theta&gt;0$" src="form_1960.png"/>, our solutions will not be numerically stable if we violate this restriction. Implicit schemes do not have this restriction for stability, but they become inaccurate if the time step is too large.</p>
<p>This condition was first recognized by Courant, Friedrichs, and Lewy &mdash; in 1928, long before computers become available for numerical computations! (This result appeared in the German language article R. Courant, K. Friedrichs and H. Lewy: <em>&Uuml;ber die partiellen Differenzengleichungen der mathematischen Physik</em>, Mathematische Annalen, vol. 100, no. 1, pages 32-74, 1928.) This condition on the time step is most frequently just referred to as the <em>CFL</em> condition. Intuitively, the CFL condition says that the time step must not be larger than the time it takes a wave to cross a single cell.</p>
<p>In the program, we will refine the square <img class="formulaInl" alt="$[-1,1]^2$" src="form_1961.png"/> seven times uniformly, giving a mesh size of <img class="formulaInl" alt="$h=\frac 1{64}$" src="form_1962.png"/>, which is what we set the time step to. The fact that we set the time step and mesh size individually in two different places is error prone: it is too easy to refine the mesh once more but forget to also adjust the time step. <a class="el" href="step_24.html">step-24</a> shows a better way how to keep these things in sync.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>Although the program has all the hooks to deal with nonzero initial and boundary conditions and body forces, we take a simple case where the domain is a square <img class="formulaInl" alt="$[-1,1]^2$" src="form_1961.png"/> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f &amp;=&amp; 0, \\ u_0 &amp;=&amp; 0, \\ u_1 &amp;=&amp; 0, \\ g &amp;=&amp; \left\{\begin{matrix}\sin (4\pi t) &amp;\qquad&amp; \text{for }\ t\le \frac 12, x=-1, -\frac 13&lt;y&lt;\frac 13 \\ 0 &amp;&amp;\text{otherwise} \end{matrix} \right. \end{eqnarray*}" src="form_1963.png"/>
</p>
<p> This corresponds to a membrane initially at rest and clamped all around, where someone is waving a part of the clamped boundary once up and down, thereby shooting a wave into the domain. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>We start with the usual assortment of include files that we've seen in so many of the previous tests:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Here are the only three include files of some new interest: The first one is already used, for example, for the <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> and <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> functions. However, we here use another function in that class, <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> to compute our initial values as the <img class="formulaInl" alt="$L^2$" src="form_700.png"/> projection of the continuous initial values. Furthermore, we use <a class="el" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">VectorTools::create_right_hand_side</a> to generate the integrals <img class="formulaInl" alt="$(f^n,\phi^n_i)$" src="form_1964.png"/>. These were previously always generated by hand in <code>assemble_system</code> or similar functions in application code. However, we're too lazy to do that here, so simply use a library function:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div></div><!-- fragment --><p>In a very similar vein, we are also too lazy to write the code to assemble mass and Laplace matrices, although it would have only taken copying the relevant code from any number of previous tutorial programs. Rather, we want to focus on the things that are truly new to this program and therefore use the <a class="el" href="namespaceMatrixCreator.html#a298a5ae54ecf4709eca32d9b81405274">MatrixCreator::create_mass_matrix</a> and <a class="el" href="namespaceMatrixCreator.html#a3bad504168eec644069f86b4612e4c7b">MatrixCreator::create_laplace_matrix</a> functions. They are declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div></div><!-- fragment --><p>Finally, here is an include file that contains all sorts of tool functions that one sometimes needs. In particular, we need the <a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> class that, given an integer argument, returns a string representation of it. It is particularly useful since it allows for a second parameter indicating the number of digits to which we want the result padded with leading zeros. We will use this to write output files that have the form <code>solution-XXX.gnuplot</code> where <code>XXX</code> denotes the number of the time step and always consists of three digits even if we are still in the single or double digit time steps.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step23</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeWaveEquationcodeclass"></a> </p><h3>The <code>WaveEquation</code> class</h3>
<p>Next comes the declaration of the main class. It's public interface of functions is like in most of the other tutorial programs. Worth mentioning is that we now have to store four matrices instead of one: the mass matrix <img class="formulaInl" alt="$M$" src="form_64.png"/>, the Laplace matrix <img class="formulaInl" alt="$A$" src="form_40.png"/>, the matrix <img class="formulaInl" alt="$M+k^2\theta^2A$" src="form_1965.png"/> used for solving for <img class="formulaInl" alt="$U^n$" src="form_1966.png"/>, and a copy of the mass matrix with boundary conditions applied used for solving for <img class="formulaInl" alt="$V^n$" src="form_1967.png"/>. Note that it is a bit wasteful to have an additional copy of the mass matrix around. We will discuss strategies for how to avoid this in the section on possible improvements.</p>
<p>Likewise, we need solution vectors for <img class="formulaInl" alt="$U^n,V^n$" src="form_1968.png"/> as well as for the corresponding vectors at the previous time step, <img class="formulaInl" alt="$U^{n-1},V^{n-1}$" src="form_1946.png"/>. The <code>system_rhs</code> will be used for whatever right hand side vector we have when solving one of the two linear systems in each time step. These will be solved in the two functions <code>solve_u</code> and <code>solve_v</code>.</p>
<p>Finally, the variable <code>theta</code> is used to indicate the parameter <img class="formulaInl" alt="$\theta$" src="form_1363.png"/> that is used to define which time stepping scheme to use, as explained in the introduction. The rest is self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>WaveEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  WaveEquation ();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> solve_u ();</div><div class="line">  <span class="keywordtype">void</span> solve_v ();</div><div class="line">  <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_u;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_v;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution_u, solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       old_solution_u, old_solution_v;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> time_step, time;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before we go on filling in the details of the main class, let us define the equation data corresponding to the problem, i.e. initial and boundary values for both the solution <img class="formulaInl" alt="$u$" src="form_256.png"/> and its time derivative <img class="formulaInl" alt="$v$" src="form_987.png"/>, as well as a right hand side class. We do so using classes derived from the <a class="el" href="classFunction.html">Function</a> class template that has been used many times before, so the following should not be a surprise.</p>
<p>Let's start with initial values and choose zero for both the value <img class="formulaInl" alt="$u$" src="form_256.png"/> as well as its time derivative, the velocity <img class="formulaInl" alt="$v$" src="form_987.png"/>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialValuesU () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialValuesV () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> InitialValuesU&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;/ *p* /,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void) component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> InitialValuesV&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;/ *p* /,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void) component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Secondly, we have the right hand side forcing term. Boring as we are, we choose zero here as well:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;/ *p* /,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void) component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Finally, we have boundary values for <img class="formulaInl" alt="$u$" src="form_256.png"/> and <img class="formulaInl" alt="$v$" src="form_987.png"/>. They are as described in the introduction, one being the time derivative of the other:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValuesU () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValuesV () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValuesU&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void) component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp;</div><div class="line">      (p[0] &lt; 0) &amp;&amp;</div><div class="line">      (p[1] &lt; 1./3) &amp;&amp;</div><div class="line">      (p[1] &gt; -1./3))</div><div class="line">    <span class="keywordflow">return</span> std::sin (this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValuesV&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void) component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp;</div><div class="line">      (p[0] &lt; 0) &amp;&amp;</div><div class="line">      (p[1] &lt; 1./3) &amp;&amp;</div><div class="line">      (p[1] &gt; -1./3))</div><div class="line">    <span class="keywordflow">return</span> (std::cos (this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>) *</div><div class="line">            4 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeWaveEquationcodeclass"></a> </p><h3>Implementation of the <code>WaveEquation</code> class</h3>
<p>The implementation of the actual logic is actually fairly short, since we relegate things like assembling the matrices and right hand side vectors to the library. The rest boils down to not much more than 130 lines of actual code, a significant fraction of which is boilerplate code that can be taken from previous example programs (e.g. the functions that solve linear systems, or that generate output).</p>
<p>Let's start with the constructor (for an explanation of the choice of time step, see the section on Courant, Friedrichs, and Lewy in the introduction):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">WaveEquation&lt;dim&gt;::WaveEquation () :</div><div class="line">  fe (1),</div><div class="line">  dof_handler (triangulation),</div><div class="line">  time_step (1./64),</div><div class="line">  time (time_step),</div><div class="line">  timestep_number (1),</div><div class="line">  theta (0.5)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationsetup_system"></a> </p><h4>WaveEquation::setup_system</h4>
<p>The next function is the one that sets up the mesh, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices and vectors at the beginning of the program, i.e. before the first time step. The first few lines are pretty much standard if you've read through the tutorial programs at least up to <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dsp);</div></div><!-- fragment --><p>Then comes a block where we have to initialize the 3 matrices we need in the course of the program: the mass matrix, the Laplace matrix, and the matrix <img class="formulaInl" alt="$M+k^2\theta^2A$" src="form_1965.png"/> used when solving for <img class="formulaInl" alt="$U^n$" src="form_1966.png"/> in each time step.</p>
<p>When setting up these matrices, note that they all make use of the same sparsity pattern object. Finally, the reason why matrices and sparsity patterns are separate objects in deal.II (unlike in many other finite element or linear algebra classes) becomes clear: in a significant fraction of applications, one has to hold several matrices that happen to have the same sparsity pattern, and there is no reason for them not to share this information, rather than re-building and wasting memory on it several times.</p>
<p>After initializing all of these matrices, we call library functions that build the Laplace and mass matrices. All they need is a <a class="el" href="classDoFHandler.html">DoFHandler</a> object and a quadrature formula object that is to be used for numerical integration. Note that in many respects these functions are better than what we would usually do in application programs, for example because they automatically parallelize building the matrices if multiple processors are available in a machine. The matrices for solving linear systems will be filled in the run() method because we need to re-apply boundary conditions every time step.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit (sparsity_pattern);</div><div class="line">laplace_matrix.reinit (sparsity_pattern);</div><div class="line">matrix_u.reinit (sparsity_pattern);</div><div class="line">matrix_v.reinit (sparsity_pattern);</div><div class="line"></div><div class="line"><a class="code" href="namespaceMatrixCreator.html#a298a5ae54ecf4709eca32d9b81405274">MatrixCreator::create_mass_matrix</a> (dof_handler, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                                   mass_matrix);</div><div class="line"><a class="code" href="namespaceMatrixCreator.html#a3bad504168eec644069f86b4612e4c7b">MatrixCreator::create_laplace_matrix</a> (dof_handler, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                                      laplace_matrix);</div></div><!-- fragment --><p>The rest of the function is spent on setting vector sizes to the correct value. The final line closes the hanging node constraints object. Since we work on a uniformly refined mesh, no constraints exist or have been computed (i.e. there was no need to call <a class="el" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> as in other programs), but we need a constraints object in one place further down below anyway.</p>
<div class="fragment"><div class="line">  solution_u.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_v.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_u.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  old_solution_v.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationsolve_uandWaveEquationsolve_v"></a> </p><h4>WaveEquation::solve_u and WaveEquation::solve_v</h4>
<p>The next two functions deal with solving the linear systems associated with the equations for <img class="formulaInl" alt="$U^n$" src="form_1966.png"/> and <img class="formulaInl" alt="$V^n$" src="form_1967.png"/>. Both are not particularly interesting as they pretty much follow the scheme used in all the previous tutorial programs.</p>
<p>One can make little experiments with preconditioners for the two matrices we have to invert. As it turns out, however, for the matrices at hand here, using Jacobi or SSOR preconditioners reduces the number of iterations necessary to solve the linear system slightly, but due to the cost of applying the preconditioner it is no win in terms of run-time. It is not much of a loss either, but let's keep it simple and just do without:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_u ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-8*system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">  cg.solve (matrix_u, solution_u, system_rhs,</div><div class="line">            <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   u-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_v ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-8*system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">  cg.solve (matrix_v, solution_v, system_rhs,</div><div class="line">            <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationoutput_results"></a> </p><h4>WaveEquation::output_results</h4>
<p>Likewise, the following function is pretty much what we've done before. The only thing worth mentioning is how here we generate a string representation of the time step number padded with leading zeros to 3 character length using the <a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> function's second argument.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution_u, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (timestep_number, 3) +</div><div class="line">                               <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line">  std::ofstream output (filename.c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WaveEquationrun"></a> </p><h4>WaveEquation::run</h4>
<p>The following is really the only interesting function of the program. It contains the loop over all time steps, but before we get to that we have to set up the grid, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices. In addition, we have to somehow get started with initial values. To this end, we use the <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> function that takes an object that describes a continuous function and computes the <img class="formulaInl" alt="$L^2$" src="form_700.png"/> projection of this function onto the finite element space described by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. Can't be any simpler than that:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  setup_system();</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> (dof_handler, constraints, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                        InitialValuesU&lt;dim&gt;(),</div><div class="line">                        old_solution_u);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> (dof_handler, constraints, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                        InitialValuesV&lt;dim&gt;(),</div><div class="line">                        old_solution_v);</div></div><!-- fragment --><p>The next thing is to loop over all the time steps until we reach the end time ( <img class="formulaInl" alt="$T=5$" src="form_1969.png"/> in this case). In each time step, we first have to solve for <img class="formulaInl" alt="$U^n$" src="form_1966.png"/>, using the equation <img class="formulaInl" alt="$(M^n + k^2\theta^2 A^n)U^n =$" src="form_1970.png"/> <img class="formulaInl" alt="$(M^{n,n-1} - k^2\theta(1-\theta) A^{n,n-1})U^{n-1} + kM^{n,n-1}V^{n-1} +$" src="form_1971.png"/> <img class="formulaInl" alt="$k\theta \left[k \theta F^n + k(1-\theta) F^{n-1} \right]$" src="form_1972.png"/>. Note that we use the same mesh for all time steps, so that <img class="formulaInl" alt="$M^n=M^{n,n-1}=M$" src="form_1952.png"/> and <img class="formulaInl" alt="$A^n=A^{n,n-1}=A$" src="form_1953.png"/>. What we therefore have to do first is to add up <img class="formulaInl" alt="$MU^{n-1} - k^2\theta(1-\theta) AU^{n-1} + kMV^{n-1}$" src="form_1973.png"/> and the forcing terms, and put the result into the <code>system_rhs</code> vector. (For these additions, we need a temporary vector that we declare before the loop to avoid repeated memory allocations in each time step.)</p>
<p>The one thing to realize here is how we communicate the time variable to the object describing the right hand side: each object derived from the <a class="el" href="classFunction.html">Function</a> class has a time field that can be set using the <a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">Function::set_time</a> and read by <a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">Function::get_time</a>. In essence, using this mechanism, all functions of space and time are therefore considered functions of space evaluated at a particular time. This matches well what we typically need in finite element programs, where we almost always work on a single time step at a time, and where it never happens that, for example, one would like to evaluate a space-time function for all times at any given spatial location.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (solution_u.size());</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> forcing_terms (solution_u.size());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; time&lt;=5; time+=time_step, ++timestep_number)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult (system_rhs, old_solution_u);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult (tmp, old_solution_v);</div><div class="line">    system_rhs.add (time_step, tmp);</div><div class="line"></div><div class="line">    laplace_matrix.vmult (tmp, old_solution_u);</div><div class="line">    system_rhs.add (-theta * (1-theta) * time_step * time_step, tmp);</div><div class="line"></div><div class="line">    RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">    rhs_function.set_time (time);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">VectorTools::create_right_hand_side</a> (dof_handler, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2),</div><div class="line">                                         rhs_function, tmp);</div><div class="line">    forcing_terms = tmp;</div><div class="line">    forcing_terms *= theta * time_step;</div><div class="line"></div><div class="line">    rhs_function.set_time (time-time_step);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">VectorTools::create_right_hand_side</a> (dof_handler, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2),</div><div class="line">                                         rhs_function, tmp);</div><div class="line"></div><div class="line">    forcing_terms.add ((1-theta) * time_step, tmp);</div><div class="line"></div><div class="line">    system_rhs.add (theta * time_step, forcing_terms);</div></div><!-- fragment --><p>After so constructing the right hand side vector of the first equation, all we have to do is apply the correct boundary values. As for the right hand side, this is a space-time function evaluated at a particular time, which we interpolate at boundary nodes and then use the result to apply boundary values as we usually do. The result is then handed off to the solve_u() function:</p>
<div class="fragment"><div class="line">{</div><div class="line">  BoundaryValuesU&lt;dim&gt; boundary_values_u_function;</div><div class="line">  boundary_values_u_function.set_time (time);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            boundary_values_u_function,</div><div class="line">                                            boundary_values);</div></div><!-- fragment --><p>The matrix for solve_u() is the same in every time steps, so one could think that it is enough to do this only once at the beginning of the simulation. However, since we need to apply boundary values to the linear system (which eliminate some matrix rows and columns and give contributions to the right hand side), we have to refill the matrix in every time steps before we actually apply boundary data. The actual content is very simple: it is the sum of the mass matrix and a weighted Laplace matrix:</p>
<div class="fragment"><div class="line">  matrix_u.copy_from (mass_matrix);</div><div class="line">  matrix_u.add (theta * theta * time_step * time_step, laplace_matrix);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      matrix_u,</div><div class="line">                                      solution_u,</div><div class="line">                                      system_rhs);</div><div class="line">}</div><div class="line">solve_u ();</div></div><!-- fragment --><p>The second step, i.e. solving for <img class="formulaInl" alt="$V^n$" src="form_1967.png"/>, works similarly, except that this time the matrix on the left is the mass matrix (which we copy again in order to be able to apply boundary conditions, and the right hand side is <img class="formulaInl" alt="$MV^{n-1} - k\left[ \theta A U^n + (1-\theta) AU^{n-1}\right]$" src="form_1974.png"/> plus forcing terms. Boundary values are applied in the same way as before, except that now we have to use the BoundaryValuesV class:</p>
<div class="fragment"><div class="line">laplace_matrix.vmult (system_rhs, solution_u);</div><div class="line">system_rhs *= -theta * time_step;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult (tmp, old_solution_v);</div><div class="line">system_rhs += tmp;</div><div class="line"></div><div class="line">laplace_matrix.vmult (tmp, old_solution_u);</div><div class="line">system_rhs.add (-time_step * (1-theta), tmp);</div><div class="line"></div><div class="line">system_rhs += forcing_terms;</div><div class="line"></div><div class="line">{</div><div class="line">  BoundaryValuesV&lt;dim&gt; boundary_values_v_function;</div><div class="line">  boundary_values_v_function.set_time (time);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            boundary_values_v_function,</div><div class="line">                                            boundary_values);</div><div class="line">  matrix_v.copy_from (mass_matrix);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      matrix_v,</div><div class="line">                                      solution_v,</div><div class="line">                                      system_rhs);</div><div class="line">}</div><div class="line">solve_v ();</div></div><!-- fragment --><p>Finally, after both solution components have been computed, we output the result, compute the energy in the solution, and go on to the next time step after shifting the present solution into the vectors that hold the solution at the previous time step. Note the function <a class="el" href="classSparseMatrix.html#a56d106dfe8792db57f2d6e60bdfe63e1">SparseMatrix::matrix_norm_square</a> that can compute <img class="formulaInl" alt="$\left&lt;V^n,MV^n\right&gt;$" src="form_1975.png"/> and <img class="formulaInl" alt="$\left&lt;U^n,AU^n\right&gt;$" src="form_1976.png"/> in one step, saving us the expense of a temporary vector and several lines of code:</p>
<div class="fragment"><div class="line">        output_results ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Total energy: &quot;</span></div><div class="line">                  &lt;&lt; (<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.matrix_norm_square (solution_v) +</div><div class="line">                      laplace_matrix.matrix_norm_square (solution_u)) / 2</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_u = solution_u;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>What remains is the main function of the program. There is nothing here that hasn't been shown in several of the previous programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step23;</div><div class="line"></div><div class="line">      WaveEquation&lt;2&gt; wave_equation_solver;</div><div class="line">      wave_equation_solver.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When the program is run, it produces the following output: </p><div class="fragment"><div class="line">Number of active cells: 16384</div><div class="line">Number of degrees of freedom: 16641</div><div class="line"></div><div class="line">Time step 1 at t=0.015625</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 22 CG iterations.</div><div class="line">   Total energy: 1.17887</div><div class="line">Time step 2 at t=0.03125</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 2.9655</div><div class="line">Time step 3 at t=0.046875</div><div class="line">   u-equation: 8 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 4.33761</div><div class="line">Time step 4 at t=0.0625</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 5.35499</div><div class="line">Time step 5 at t=0.078125</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 21 CG iterations.</div><div class="line">   Total energy: 6.18652</div><div class="line">Time step 6 at t=0.09375</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 6.6799</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Time step 31 at t=0.484375</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 21.9068</div><div class="line">Time step 32 at t=0.5</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.3394</div><div class="line">Time step 33 at t=0.515625</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Time step 319 at t=4.98438</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div><div class="line">Time step 320 at t=5</div><div class="line">   u-equation: 7 CG iterations.</div><div class="line">   v-equation: 20 CG iterations.</div><div class="line">   Total energy: 23.1019</div></div><!-- fragment --><p>What we see immediately is that the energy is a constant at least after <img class="formulaInl" alt="$t=\frac 12$" src="form_1977.png"/> (until which the boundary source term <img class="formulaInl" alt="$g$" src="form_36.png"/> is nonzero, injecting energy into the system).</p>
<p>In addition to the screen output, the program writes the solution of each time step to an output file. If we process them adequately and paste them into a movie, we get the following:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-23.movie.gif" alt="Animation of the solution of step 23."/>
</div>
<p>The movie shows the generated wave nice traveling through the domain and back, being reflected at the clamped boundary. Some numerical noise is trailing the wave, an artifact of a too-large mesh size that can be reduced by reducing the mesh width and the time step.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>If you want to explore a bit, try out some of the following things: </p><ul>
<li>
<p class="startli">Varying <img class="formulaInl" alt="$\theta$" src="form_1363.png"/>. This gives different time stepping schemes, some of which are stable while others are not. Take a look at how the energy evolves.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Different initial and boundary conditions, right hand sides.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">More complicated domains or more refined meshes. Remember that the time step needs to be bounded by the mesh width, so changing the mesh should always involve also changing the time step. We will come back to this issue in <a class="el" href="step_24.html">step-24</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Variable coefficients: In real media, the wave speed is often variable. In particular, the "real" wave equation in realistic media would read </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \rho(x) \frac{\partial^2 u}{\partial t^2} - \nabla \cdot a(x) \nabla u = f, \]" src="form_1978.png"/>
</p>
<p> where <img class="formulaInl" alt="$\rho(x)$" src="form_1979.png"/> is the density of the material, and <img class="formulaInl" alt="$a(x)$" src="form_1980.png"/> is related to the stiffness coefficient. The wave speed is then <img class="formulaInl" alt="$c=\sqrt{a/\rho}$" src="form_1981.png"/>.</p>
<p>To make such a change, we would have to compute the mass and Laplace matrices with a variable coefficient. Fortunately, this isn't too hard: the functions <a class="el" href="namespaceMatrixCreator.html#a3bad504168eec644069f86b4612e4c7b">MatrixCreator::create_laplace_matrix</a> and <a class="el" href="namespaceMatrixCreator.html#a298a5ae54ecf4709eca32d9b81405274">MatrixCreator::create_mass_matrix</a> have additional default parameters that can be used to pass non-constant coefficient functions to them. The required changes are therefore relatively small. On the other hand, care must be taken again to make sure the time step is within the allowed range.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">In the in-code comments, we discussed the fact that the matrices for solving for <img class="formulaInl" alt="$U^n$" src="form_1966.png"/> and <img class="formulaInl" alt="$V^n$" src="form_1967.png"/> need to be reset in every time because of boundary conditions, even though the actual content does not change. It is possible to avoid copying by not eliminating columns in the linear systems, which is implemented by appending a <code>false</code> argument to the call: </p><div class="fragment"><div class="line"><a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                    matrix_u,</div><div class="line">                                    solution_u,</div><div class="line">                                    system_rhs,</div><div class="line">                                    <span class="keyword">false</span>);</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">deal.II being a library that supports adaptive meshes it would of course be nice if this program supported change the mesh every few time steps. Given the structure of the solution &mdash; a wave that travels through the domain &mdash; it would seem appropriate if we only refined the mesh where the wave currently is, and not simply everywhere. It is intuitively clear that we should be able to save a significant amount of cells this way. (Though upon further thought one realizes that this is really only the case in the initial stages of the simulation. After some time, for wave phenomena, the domain is filled with reflections of the initial wave going in every direction and filling every corner of the domain. At this point, there is in general little one can gain using local mesh refinement.)</p>
<p>To make adaptively changing meshes possible, there are basically two routes. The "correct" way would be to go back to the weak form we get using Rothe's method. For example, the first of the two equations to be solved in each time step looked like this: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla u^{n-1},\nabla \varphi) + k(v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right]. \end{eqnarray*}" src="form_1982.png"/>
</p>
<p> Now, note that we solve for <img class="formulaInl" alt="$u^n$" src="form_1558.png"/> on mesh <img class="formulaInl" alt="${\mathbb T}^n$" src="form_1983.png"/>, and consequently the test functions <img class="formulaInl" alt="$\varphi$" src="form_94.png"/> have to be from the space <img class="formulaInl" alt="$V_h^n$" src="form_1984.png"/> as well. As discussed in the introduction, terms like <img class="formulaInl" alt="$(u^{n-1},\varphi)$" src="form_1985.png"/> then require us to integrate the solution of the previous step (which may have been computed on a different mesh <img class="formulaInl" alt="${\mathbb T}^{n-1}$" src="form_1986.png"/>) against the test functions of the current mesh, leading to a matrix <img class="formulaInl" alt="$M^{n,n-1}$" src="form_1987.png"/>. This process of integrating shape functions from different meshes is, at best, awkward. It can be done but because it is difficult to ensure that <img class="formulaInl" alt="${\mathbb T}^{n-1}$" src="form_1986.png"/> and <img class="formulaInl" alt="${\mathbb T}^{n}$" src="form_1988.png"/> differ by at most one level of refinement, one has to recursively match cells from both meshes. It is feasible to do this, but it leads to lengthy and not entirely obvious code.</p>
<p>The second approach is the following: whenever we change the mesh, we simply interpolate the solution from the last time step on the old mesh to the new mesh, using the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class. In other words, instead of the equation above, we would solve </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (u^n,\varphi) + k^2\theta^2(\nabla u^n,\nabla \varphi) &amp;=&amp; (I^n u^{n-1},\varphi) - k^2\theta(1-\theta)(\nabla I^n u^{n-1},\nabla \varphi) + k(I^n v^{n-1},\varphi) + k^2\theta \left[ \theta (f^n,\varphi) + (1-\theta) (f^{n-1},\varphi) \right], \end{eqnarray*}" src="form_1989.png"/>
</p>
<p> where <img class="formulaInl" alt="$I^n$" src="form_1990.png"/> interpolates a given function onto mesh <img class="formulaInl" alt="${\mathbb T}^n$" src="form_1983.png"/>. This is a much simpler approach because, in each time step, we no longer have to worry whether <img class="formulaInl" alt="$u^{n-1},v^{n-1}$" src="form_1932.png"/> were computed on the same mesh as we are using now or on a different mesh. Consequently, the only changes to the code necessary are the addition of a function that computes the error, marks cells for refinement, sets up a <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> object, transfers the solution to the new mesh, and rebuilds matrices and right hand side vectors on the new mesh. Neither the functions building the matrices and right hand sides, nor the solvers need to be changed.</p>
<p class="endli">While this second approach is, strictly speaking, not quite correct in the Rothe framework (it introduces an addition source of error, namely the interpolation), it is nevertheless what almost everyone solving time dependent equations does. We will use this method in <a class="el" href="step_31.html">step-31</a>, for example. </p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step23</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>WaveEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    WaveEquation ();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> solve_u ();</div><div class="line">    <span class="keywordtype">void</span> solve_v ();</div><div class="line">    <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> laplace_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_u;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> matrix_v;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution_u, solution_v;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       old_solution_u, old_solution_v;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time_step, time;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InitialValuesU () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InitialValuesV () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> InitialValuesU&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;<span class="comment">/*p*/</span>,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void) component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> InitialValuesV&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;<span class="comment">/*p*/</span>,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void) component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;<span class="comment">/*p*/</span>,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void) component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValuesU : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValuesU () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValuesV : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValuesV () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValuesU&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void) component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp;</div><div class="line">        (p[0] &lt; 0) &amp;&amp;</div><div class="line">        (p[1] &lt; 1./3) &amp;&amp;</div><div class="line">        (p[1] &gt; -1./3))</div><div class="line">      <span class="keywordflow">return</span> std::sin (this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValuesV&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void) component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() &lt;= 0.5) &amp;&amp;</div><div class="line">        (p[0] &lt; 0) &amp;&amp;</div><div class="line">        (p[1] &lt; 1./3) &amp;&amp;</div><div class="line">        (p[1] &gt; -1./3))</div><div class="line">      <span class="keywordflow">return</span> (std::cos (this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>() * 4 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>) *</div><div class="line">              4 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  WaveEquation&lt;dim&gt;::WaveEquation () :</div><div class="line">    fe (1),</div><div class="line">    dof_handler (triangulation),</div><div class="line">    time_step (1./64),</div><div class="line">    time (time_step),</div><div class="line">    timestep_number (1),</div><div class="line">    theta (0.5)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (7);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dsp);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit (sparsity_pattern);</div><div class="line">    laplace_matrix.reinit (sparsity_pattern);</div><div class="line">    matrix_u.reinit (sparsity_pattern);</div><div class="line">    matrix_v.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#a298a5ae54ecf4709eca32d9b81405274">MatrixCreator::create_mass_matrix</a> (dof_handler, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                                       mass_matrix);</div><div class="line">    <a class="code" href="namespaceMatrixCreator.html#a3bad504168eec644069f86b4612e4c7b">MatrixCreator::create_laplace_matrix</a> (dof_handler, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                                          laplace_matrix);</div><div class="line"></div><div class="line">    solution_u.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_v.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_u.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    old_solution_v.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_u ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-8*system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">    cg.solve (matrix_u, solution_u, system_rhs,</div><div class="line">              <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   u-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::solve_v ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-8*system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">    cg.solve (matrix_v, solution_v, system_rhs,</div><div class="line">              <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   v-equation: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution_u, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution_v, <span class="stringliteral">&quot;V&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (timestep_number, 3) +</div><div class="line">                                 <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line">    std::ofstream output (filename.c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WaveEquation&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> (dof_handler, constraints, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                          InitialValuesU&lt;dim&gt;(),</div><div class="line">                          old_solution_u);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> (dof_handler, constraints, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                          InitialValuesV&lt;dim&gt;(),</div><div class="line">                          old_solution_v);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (solution_u.size());</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> forcing_terms (solution_u.size());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; time&lt;=5; time+=time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult (system_rhs, old_solution_u);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult (tmp, old_solution_v);</div><div class="line">        system_rhs.add (time_step, tmp);</div><div class="line"></div><div class="line">        laplace_matrix.vmult (tmp, old_solution_u);</div><div class="line">        system_rhs.add (-theta * (1-theta) * time_step * time_step, tmp);</div><div class="line"></div><div class="line">        RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">        rhs_function.set_time (time);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">VectorTools::create_right_hand_side</a> (dof_handler, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2),</div><div class="line">                                             rhs_function, tmp);</div><div class="line">        forcing_terms = tmp;</div><div class="line">        forcing_terms *= theta * time_step;</div><div class="line"></div><div class="line">        rhs_function.set_time (time-time_step);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">VectorTools::create_right_hand_side</a> (dof_handler, <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2),</div><div class="line">                                             rhs_function, tmp);</div><div class="line"></div><div class="line">        forcing_terms.add ((1-theta) * time_step, tmp);</div><div class="line"></div><div class="line">        system_rhs.add (theta * time_step, forcing_terms);</div><div class="line"></div><div class="line">        {</div><div class="line">          BoundaryValuesU&lt;dim&gt; boundary_values_u_function;</div><div class="line">          boundary_values_u_function.set_time (time);</div><div class="line"></div><div class="line">          std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                                    0,</div><div class="line">                                                    boundary_values_u_function,</div><div class="line">                                                    boundary_values);</div><div class="line"></div><div class="line">          matrix_u.copy_from (mass_matrix);</div><div class="line">          matrix_u.add (theta * theta * time_step * time_step, laplace_matrix);</div><div class="line">          <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                              matrix_u,</div><div class="line">                                              solution_u,</div><div class="line">                                              system_rhs);</div><div class="line">        }</div><div class="line">        solve_u ();</div><div class="line"></div><div class="line"></div><div class="line">        laplace_matrix.vmult (system_rhs, solution_u);</div><div class="line">        system_rhs *= -theta * time_step;</div><div class="line"></div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.vmult (tmp, old_solution_v);</div><div class="line">        system_rhs += tmp;</div><div class="line"></div><div class="line">        laplace_matrix.vmult (tmp, old_solution_u);</div><div class="line">        system_rhs.add (-time_step * (1-theta), tmp);</div><div class="line"></div><div class="line">        system_rhs += forcing_terms;</div><div class="line"></div><div class="line">        {</div><div class="line">          BoundaryValuesV&lt;dim&gt; boundary_values_v_function;</div><div class="line">          boundary_values_v_function.set_time (time);</div><div class="line"></div><div class="line">          std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                                    0,</div><div class="line">                                                    boundary_values_v_function,</div><div class="line">                                                    boundary_values);</div><div class="line">          matrix_v.copy_from (mass_matrix);</div><div class="line">          <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                              matrix_v,</div><div class="line">                                              solution_v,</div><div class="line">                                              system_rhs);</div><div class="line">        }</div><div class="line">        solve_v ();</div><div class="line"></div><div class="line">        output_results ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Total energy: &quot;</span></div><div class="line">                  &lt;&lt; (<a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.matrix_norm_square (solution_v) +</div><div class="line">                      laplace_matrix.matrix_norm_square (solution_u)) / 2</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        old_solution_u = solution_u;</div><div class="line">        old_solution_v = solution_v;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step23;</div><div class="line"></div><div class="line">      WaveEquation&lt;2&gt; wave_equation_solver;</div><div class="line">      wave_equation_solver.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
