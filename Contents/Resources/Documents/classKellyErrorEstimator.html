<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: KellyErrorEstimator&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classKellyErrorEstimator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">KellyErrorEstimator&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="error__estimator_8h_source.html">deal.II/numerics/error_estimator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adc94d710b3db4967da1ea80bd7813a1e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> { <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a> = 0, 
<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea1a7f77da54520df51814d7a93306d6d1">face_diameter_over_twice_max_degree</a>, 
<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1eaf8f87cb31b00db990be93ff11809ea06">cell_diameter</a>
 }</td></tr>
<tr class="separator:adc94d710b3db4967da1ea80bd7813a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a971b0bfe57fa21867ed3c06794487e4b"><td class="memTemplParams" colspan="2">template&lt;typename InputVector , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a971b0bfe57fa21867ed3c06794487e4b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">estimate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;neumann_bc, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;error, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a971b0bfe57fa21867ed3c06794487e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe9063a9b7bbc9e4cfc9714fe4c7c22"><td class="memTemplParams" colspan="2">template&lt;typename InputVector , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:aefe9063a9b7bbc9e4cfc9714fe4c7c22"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#aefe9063a9b7bbc9e4cfc9714fe4c7c22">estimate</a> (const DoFHandlerType &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;neumann_bc, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;error, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:aefe9063a9b7bbc9e4cfc9714fe4c7c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec822dcb0c23ed50170f2fa5ae6034de"><td class="memTemplParams" colspan="2">template&lt;typename InputVector , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:aec822dcb0c23ed50170f2fa5ae6034de"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#aec822dcb0c23ed50170f2fa5ae6034de">estimate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;neumann_bc, const std::vector&lt; const InputVector *&gt; &amp;solutions, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;errors, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=0, const unsigned int n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:aec822dcb0c23ed50170f2fa5ae6034de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247585ae2c4b0732fc383aa59c85e915"><td class="memTemplParams" colspan="2">template&lt;typename InputVector , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a247585ae2c4b0732fc383aa59c85e915"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a247585ae2c4b0732fc383aa59c85e915">estimate</a> (const DoFHandlerType &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;neumann_bc, const std::vector&lt; const InputVector *&gt; &amp;solutions, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;errors, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=0, const unsigned int n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a247585ae2c4b0732fc383aa59c85e915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee09fa80bea85d15a0528c2ab54fe8c"><td class="memTemplParams" colspan="2">template&lt;typename InputVector , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a8ee09fa80bea85d15a0528c2ab54fe8c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a8ee09fa80bea85d15a0528c2ab54fe8c">estimate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;neumann_bc, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;error, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=0, const unsigned int n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a8ee09fa80bea85d15a0528c2ab54fe8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5581d889ffaef12690b560f03901b6a2"><td class="memTemplParams" colspan="2">template&lt;typename InputVector , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a5581d889ffaef12690b560f03901b6a2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a5581d889ffaef12690b560f03901b6a2">estimate</a> (const DoFHandlerType &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;neumann_bc, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;error, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a5581d889ffaef12690b560f03901b6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ae19b4f9c87ae459af58111b8968a"><td class="memTemplParams" colspan="2">template&lt;typename InputVector , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a0d0ae19b4f9c87ae459af58111b8968a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a0d0ae19b4f9c87ae459af58111b8968a">estimate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;neumann_bc, const std::vector&lt; const InputVector *&gt; &amp;solutions, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;errors, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=0, const unsigned int n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a0d0ae19b4f9c87ae459af58111b8968a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730f5717b9c41a8c0a7636ad211bd423"><td class="memTemplParams" colspan="2">template&lt;typename InputVector , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a730f5717b9c41a8c0a7636ad211bd423"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a730f5717b9c41a8c0a7636ad211bd423">estimate</a> (const DoFHandlerType &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;neumann_bc, const std::vector&lt; const InputVector *&gt; &amp;solutions, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;errors, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned int n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a730f5717b9c41a8c0a7636ad211bd423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1fb28e01276e9082ad2dc5a7ea9452b"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad1fb28e01276e9082ad2dc5a7ea9452b">ExcInvalidComponentMask</a> ()</td></tr>
<tr class="separator:gad1fb28e01276e9082ad2dc5a7ea9452b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8088f8f0621b6e0c2c1e10d4bd0ef682"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8088f8f0621b6e0c2c1e10d4bd0ef682">ExcInvalidCoefficient</a> ()</td></tr>
<tr class="separator:ga8088f8f0621b6e0c2c1e10d4bd0ef682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1668e8c549573962ee63e7a5e4e3afc"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac1668e8c549573962ee63e7a5e4e3afc">ExcInvalidBoundaryFunction</a> (<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> arg1, int arg2, int arg3)</td></tr>
<tr class="separator:gac1668e8c549573962ee63e7a5e4e3afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c67d3cd9d0f94b0c52b720cb4149885"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7c67d3cd9d0f94b0c52b720cb4149885">ExcIncompatibleNumberOfElements</a> (int arg1, int arg2)</td></tr>
<tr class="separator:ga7c67d3cd9d0f94b0c52b720cb4149885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad846092940058f98f169bb796751eab"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaad846092940058f98f169bb796751eab">ExcNoSolutions</a> ()</td></tr>
<tr class="separator:gaad846092940058f98f169bb796751eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class KellyErrorEstimator&lt; dim, spacedim &gt;</h3>

<p>Implementation of the error indicator by Kelly, De S. R. Gago, Zienkiewicz and Babuska and its modification for the hp-FEM. This error indicator tries to approximate the error per cell by integration of the jump of the gradient of the solution along the faces of each cell. It can be understood as a gradient recovery estimator; see the survey of Ainsworth and Oden, "A Posteriori Error Estimation in Finite Element Analysis" (Wiley, 2000) for a complete discussion.</p>
<p>In the original Kelly error estimator, the contribution of each face to the cell error is scaled with the cell diagonal. In the modified version, however, we employ a scaling factor which depends on the face diagonal and polynomial degrees of the adjacent elements. The choice between the two is done by means of the enumerator, defined within the class.</p>
<dl class="section note"><dt>Note</dt><dd>In spite of the name, Kelly estimator is not truly an a posteriori error estimator, even if applied to the Poisson problem only. It gives good hints for mesh refinement, but the estimate is not to be trusted. For higher order trial spaces the integrals computed here tend to zero faster than the error itself, thus ruling out the values as error estimators. However, the modified version discussed below can be utilised to obtain the reliable error estimator by adding the residual (volume) part.</dd></dl>
<p>The error estimator really only estimates the error for the generalized Poisson equation <img class="formulaInl" alt="$-\nabla\cdot a(x) \nabla u = f$" src="form_1168.png"/> with either Dirichlet boundary conditions or generalized Neumann boundary conditions involving the conormal derivative <img class="formulaInl" alt="$a\frac{du}{dn} = g$" src="form_1169.png"/>.</p>
<p>The error estimator returns a vector of estimated errors per cell which can be used to feed the GridRefinement::refine_fixed_fraction, GridRefinement::refine_fixed_number, and similar functions. This vector contains elements of data type <code>float</code>, rather than <code>double</code>, since accuracy is not important in the current context.</p>
<p>The full reference for the paper in which this error estimator is defined is as follows: </p><div class="fragment"><div class="line">@Article{KGZB83,</div><div class="line">  author =       {Kelly, D. W. and {De S. R. Gago}, J. P. and Zienkiewicz, O. C.</div><div class="line">                  and Babu\v{s}ka, I.},</div><div class="line">  title =        {A posteriori error analysis and adaptive processes</div><div class="line">                  in the finite element method: Part {I}--Error Analysis},</div><div class="line">  journal =      {Int. J. Num. Meth. Engrg.},</div><div class="line">  year =         {1983},</div><div class="line">  volume =       {19},</div><div class="line">  pages =        {1593--1619}</div><div class="line">}</div></div><!-- fragment --><h3>Implementation</h3>
<p>In principle, the implementation of the error estimation is simple: let </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \eta_K^2 = \sum_{F\in\partial K} c_F \int_{\partial K_F} \left[a \frac{\partial u_h}{\partial n}\right]^2 do \]" src="form_1170.png"/>
</p>
<p> be the error estimator for cell <img class="formulaInl" alt="$K$" src="form_57.png"/>. <img class="formulaInl" alt="$[\cdot]$" src="form_1171.png"/> denotes the jump of the argument at the face. In the paper of Ainsworth <img class="formulaInl" alt="$ c_F=\frac {h_K}{24} $" src="form_1172.png"/>, but this factor is a bit esoteric, stemming from interpolation estimates and stability constants which may hold for the Poisson problem, but may not hold for more general situations. Alternatively, we consider the case when <img class="formulaInl" alt="$ c_F=\frac {h_F}{2p_F} $" src="form_1173.png"/>, where <img class="formulaInl" alt="$ h_F $" src="form_1174.png"/> is face diagonal and <img class="formulaInl" alt="$ p_F=max(p^+,p^-) $" src="form_1175.png"/> is the maximum polynomial degree of adjacent elements; or <img class="formulaInl" alt="$c_F=h_K$" src="form_1176.png"/>. The choice between these factors is done by means of the enumerator, provided as the last argument in all functions.</p>
<p>To perform the integration, use is made of the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> classes. The integration is performed by looping over all cells and integrating over faces that are not yet treated. This way we avoid integration on faces twice, once for each time we visit one of the adjacent cells. In a second loop over all cells, we sum up the contributions of the faces (which are the integrated square of the jumps times some factor) of each cell and take the square root.</p>
<p>The integration is done using a quadrature formula on the face. For linear trial functions (FEQ1), <a class="el" href="classQGauss.html">QGauss</a> (with two points) or even the <a class="el" href="classQMidpoint.html">QMidpoint</a> rule will suffice. For higher order elements, it is necessary to utilize higher order quadrature formulae as well.</p>
<p>We store the contribution of each face in a <code>map</code>, as provided by the C++ standard library, with the iterator pointing to that face being the key into the map. When looping the second time over all cells, we have to sum up the contributions of the faces and take the square root. For the Kelly estimator, the multiplication with <img class="formulaInl" alt="$\frac {h_K}{24}$" src="form_1177.png"/> is done in the second loop. By doing so we avoid problems to decide with which <img class="formulaInl" alt="$h_K$" src="form_1178.png"/> to multiply, that of the cell on the one or that of the cell on the other side of the face. Whereas for the hp-estimator the <code>map</code> stores integrals multiplied by <img class="formulaInl" alt="$\frac {h_F}{2p_F}$" src="form_1179.png"/>, which are then summed in the second loop.</p>
<p><img class="formulaInl" alt="$h_K$" src="form_1178.png"/> ( <img class="formulaInl" alt="$h_F$" src="form_1180.png"/>) is taken to be the greatest length of the diagonals of the cell (face). For more or less uniform cells (faces) without deformed angles, this coincides with the diameter of the cell (face).</p>
<h3>Vector-valued functions</h3>
<p>If the finite element field for which the error is to be estimated is vector-valued, i.e. the finite element has more than one component, then all the above can be applied to all or only some components at the same time. The main function of this class takes a list of flags denoting the components for which components the error estimator is to be applied; by default, it is a list of only <code>trues</code>, meaning that all variables shall be treated.</p>
<p>In case the different components of a field have different physical meaning (for example velocity and pressure in the Stokes equations), it would be senseless to use the same coefficient for all components. In that case, you can pass a function with as many components as there are components in the finite element field and each component of the error estimator will then be weighted by the respective component in this coefficient function. In the other case, when all components have the same meaning (for example the displacements in Lame's equations of elasticity), you can specify a scalar coefficient which will then be used for all components.</p>
<h3>Boundary values</h3>
<p>If the face is at the boundary, i.e. there is no neighboring cell to which the jump in the gradiend could be computed, there are two possibilities: </p><ul>
<li>
<p class="startli">The face belongs to a Dirichlet boundary. Then the face is not considered, which can be justified looking at a dual problem technique and should hold exactly if the boundary can be approximated exactly by the finite element used (i.e. it is a linear boundary for linear finite elements, quadratic for isoparametric quadratic elements, etc). For boundaries which can not be exactly approximated, one should consider the difference <img class="formulaInl" alt="$z-z_h$" src="form_1181.png"/> on the face, <img class="formulaInl" alt="$z$" src="form_11.png"/> being a dual problem's solution which is zero at the true boundary and <img class="formulaInl" alt="$z_h$" src="form_1182.png"/> being an approximation, which in most cases will be zero on the numerical boundary. Since on the numerical boundary <img class="formulaInl" alt="$z$" src="form_11.png"/> will not be zero in general, we would get another term here, but this one is neglected for practical reasons, in the hope that the error made here will tend to zero faster than the energy error we wish to estimate.</p>
<p>Though no integration is necessary, in the list of face contributions we store a zero for this face, which makes summing up the contributions of the different faces to the cells easier.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The face belongs to a Neumann boundary. In this case, the contribution of the face <img class="formulaInl" alt="$F\in\partial K$" src="form_1183.png"/> looks like </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ n_F\int_F \left|g-a\frac{\partial u_h}{\partial n}\right|^2 ds \]" src="form_1184.png"/>
</p>
<p> where <img class="formulaInl" alt="$g$" src="form_36.png"/> is the Neumann boundary function, <img class="formulaInl" alt="$n_F=\frac {h_K}{24}$" src="form_1185.png"/> and <img class="formulaInl" alt="$n_F=\frac {h_F}{p}$" src="form_1186.png"/> for the Kelly and hp-estimator, respectively. If the finite element is vector- valued, then obviously the function denoting the Neumann boundary conditions needs to be vector-valued as well.</p>
<p class="endli"></p>
</li>
<li>
No other boundary conditions are considered. </li>
</ul>
<p>In practice, if you have Robin boundary conditions or are too lazy to accurately describe Neumann values, then this is rarely an issue: if you don't say anything in the map about a particular part of the boundary then the Kelly indicator will simply assume that the solution is correct on that part of the boundary and not touch it. Of course, if you have a have a Neumann or Robin boundary, that isn't quite true, there is going to be a difference between the normal derivative of the numerical solution and the Neumann values these normal derivatives should equal. So if we simply ignore those parts of the boundary, we'll underestimate the error. In practice, this rarely appears to be a problem &ndash; you may not refine the cell this time around but you'll probably refine it in the next refinement step and everything is good again. After all, for all problems but the Laplace equation, the Kelly indicator is only an indicator, not an estimator, and so the values it computes are not exact error representations anyway.</p>
<h3>Handling of hanging nodes</h3>
<p>The integration along faces with hanging nodes is quite tricky, since one of the elements has to be shifted one level up or down. See the documentation for the FESubFaceValues class for more information about technical issues regarding this topic.</p>
<p>In praxi, since we integrate over each face only once, we do this when we are on the coarser one of the two cells adjacent to a subface (a subface is defined to be the child of a face; seen from the coarse cell, it is a subface, while seen from the refined cell it is one of its faces). The reason is that finding neighborship information is a bit easier then, but that's all practical reasoning, nothing fundamental.</p>
<p>Since we integrate from the coarse side of the face, we have the mother face readily at hand and store the result of the integration over that mother face (being the sum of the integrals along the subfaces) in the abovementioned map of integrals as well. This consumes some memory more than needed, but makes the summing up of the face contributions to the cells easier, since then we have the information from all faces of all cells at hand and need not think about explicitly determining whether a face was refined or not. The same applies for boundary faces, see above.</p>
<h3>Multiple solution vectors</h3>
<p>In some cases, for example in time-dependent problems, one would like to compute the error estimates for several solution vectors on the same grid at once, with the same coefficients, boundary condition object, etc, e.g. for the solutions on several successive time steps. One could then call the functions of this class several times for each solution. However, the largest factor in the computation of the error estimates (in terms of computing time) is initialization of <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and FESubFaceValues objects, and iterating through all faces and subfaces. If the solution vectors live on the same grid, this effort can be reduced significantly by treating all solution vectors at the same time, initializing the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> objects only once per cell and for all solution vectors at once, and also only looping through the triangulation only once. For this reason, besides the <code>estimate</code> function in this class that takes a single input vector and returns a single output vector, there is also a function that accepts several in- and output vectors at the same time.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998, 1999, 2000, 2004, 2006, Denis Davydov, 2015; parallelization by Thomas Richter, 2000 </dd></dl>

<p class="definition">Definition at line <a class="el" href="error__estimator_8h_source.html#l00251">251</a> of file <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="adc94d710b3db4967da1ea80bd7813a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc94d710b3db4967da1ea80bd7813a1e">&#9670;&nbsp;</a></span>Strategy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">KellyErrorEstimator::Strategy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum type given to the class functions to decide on the scaling factors of the facial integrals. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383"></a>cell_diameter_over_24&#160;</td><td class="fielddoc"><p>Kelly error estimator with the factor <img class="formulaInl" alt="$\frac {h_K}{24}$" src="form_1177.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="adc94d710b3db4967da1ea80bd7813a1ea1a7f77da54520df51814d7a93306d6d1"></a>face_diameter_over_twice_max_degree&#160;</td><td class="fielddoc"><p>the boundary residual estimator with the factor <img class="formulaInl" alt="$\frac {h_F}{2 max(p^+,p^-)}$" src="form_1187.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="adc94d710b3db4967da1ea80bd7813a1eaf8f87cb31b00db990be93ff11809ea06"></a>cell_diameter&#160;</td><td class="fielddoc"><p>Kelly error estimator with the factor <img class="formulaInl" alt="$h_K$" src="form_1178.png"/>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="error__estimator_8h_source.html#l00258">258</a> of file <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a971b0bfe57fa21867ed3c06794487e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971b0bfe57fa21867ed3c06794487e4b">&#9670;&nbsp;</a></span>estimate() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector , typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the error estimator described above. You may give a coefficient, but there is a default value which denotes the constant coefficient with value one. The coefficient function may either be a scalar one, in which case it is used for all components of the finite element, or a vector-valued one with as many components as there are in the finite element; in the latter case, each component is weighted by the respective component in the coefficient.</p>
<p>You might give a list of components you want to evaluate, in case the finite element used by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object is vector-valued. You then have to set those entries to true in the bit-vector <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ) for which the respective component is to be used in the error estimator. The default is to use all components, which is done by either providing a bit-vector with all-set entries, or an empty bit-vector.</p>
<p>The <code>subdomain_id</code> parameter indicates whether we shall compute indicators for all cells (in case its value is the default, <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>), or only for the cells belonging to a certain subdomain with the given indicator. The latter case is used for parallel computations where all processor nodes have the global grid stored, and could well compute all the indicators for all cells themselves, but where it is more efficient to have each process compute only indicators for the cells it owns, and have them exchange the resulting information afterwards. This is in particular true for the case where meshes are very large and computing indicators for <em>every</em> cell is too expensive, while computing indicators for only local cells is acceptable. Note that if you only ask for the indicators of a certain subdomain to be computed, you must nevertheless make sure that this function has access to the correct node values of <em>all</em> degrees of freedom. This is since the function needs to access DoF values on neighboring cells as well, even if they belong to a different subdomain.</p>
<p>The <code>material_id</code> parameter has a similar meaning: if not set to its default value (which is <a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>), it means that indicators will only be computed for cells with this particular material id.</p>
<p>The <code>n_threads</code> parameter used to indicate the number of threads to be used to compute the error estimator. This parameter is now ignored, with the number of threads determined automatically. The parameter is retained for compatibility with old versions of the library.</p>
<p>The <code>strategy</code> parameter is used to choose the scaling factor for the integral over cell's faces.</p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="classDoFHandler.html">DoFHandler</a> object given as an argument to this function builds on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, this function skips computations on all cells that are not locally owned. In that case, the only valid value for the subdomain_id argument (besides the invalid value) is the subdomain id that is associated with the currently processor, as reported by <a class="el" href="classparallel_1_1Triangulation.html#a44ea82a097d8317c98fa422307aff874">parallel::distributed::Triangulation::locally_owned_subdomain()</a>. Even though nothing is computed on cells that we don't locally own, the error indicator vector must still have a length equal to the number of active cell in the mesh as reported by <a class="el" href="classparallel_1_1Triangulation.html#aa0ffe56b50623f7614a0a1a50b20d47e">parallel::distributed::Triangulation::n_locally_owned_active_cells()</a>. </dd></dl>

</div>
</div>
<a id="aefe9063a9b7bbc9e4cfc9714fe4c7c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe9063a9b7bbc9e4cfc9714fe4c7c22">&#9670;&nbsp;</a></span>estimate() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector , typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call the <code>estimate</code> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="aec822dcb0c23ed50170f2fa5ae6034de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec822dcb0c23ed50170f2fa5ae6034de">&#9670;&nbsp;</a></span>estimate() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector , typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const InputVector *&gt; &amp;&#160;</td>
          <td class="paramname"><em>solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as above, but accepts more than one solution vector and returns one error vector for each solution vector. For the reason of existence of this function, see the general documentation of this class.</p>
<p>Since we do not want to force the user of this function to copy around their solution vectors, the vector of solution vectors takes pointers to the solutions, rather than being a vector of vectors. This makes it simpler to have the solution vectors somewhere in memory, rather than to have them collected somewhere special. (Note that it is not possible to construct of vector of references, so we had to use a vector of pointers.) </p>

</div>
</div>
<a id="a247585ae2c4b0732fc383aa59c85e915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247585ae2c4b0732fc383aa59c85e915">&#9670;&nbsp;</a></span>estimate() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector , typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const InputVector *&gt; &amp;&#160;</td>
          <td class="paramname"><em>solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call the <code>estimate</code> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a8ee09fa80bea85d15a0528c2ab54fe8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee09fa80bea85d15a0528c2ab54fe8c">&#9670;&nbsp;</a></span>estimate() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector , typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to the set of functions above, except that this one takes a quadrature collection for hp finite element dof handlers. </p>

</div>
</div>
<a id="a5581d889ffaef12690b560f03901b6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5581d889ffaef12690b560f03901b6a2">&#9670;&nbsp;</a></span>estimate() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector , typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to the set of functions above, except that this one takes a quadrature collection for hp finite element dof handlers. </p>

</div>
</div>
<a id="a0d0ae19b4f9c87ae459af58111b8968a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0ae19b4f9c87ae459af58111b8968a">&#9670;&nbsp;</a></span>estimate() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector , typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const InputVector *&gt; &amp;&#160;</td>
          <td class="paramname"><em>solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to the set of functions above, except that this one takes a quadrature collection for hp finite element dof handlers. </p>

</div>
</div>
<a id="a730f5717b9c41a8c0a7636ad211bd423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730f5717b9c41a8c0a7636ad211bd423">&#9670;&nbsp;</a></span>estimate() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector , typename DoFHandlerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const InputVector *&gt; &amp;&#160;</td>
          <td class="paramname"><em>solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to the set of functions above, except that this one takes a quadrature collection for hp finite element dof handlers. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deal.II/numerics/<a class="el" href="error__estimator_8h_source.html">error_estimator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
