<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: internal::Triangulation::Implementation Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceinternal.html">internal</a></li><li class="navelem"><a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a></li><li class="navelem"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html">Implementation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structinternal_1_1Triangulation_1_1Implementation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">internal::Triangulation::Implementation Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation_1_1QuadComparator.html">QuadComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaef4ad66d955644480ca4b36413b09f7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aaef4ad66d955644480ca4b36413b09f7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#aaef4ad66d955644480ca4b36413b09f7">compute_number_cache</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const unsigned int level_objects, <a class="el" href="structinternal_1_1Triangulation_1_1NumberCache.html">internal::Triangulation::NumberCache</a>&lt; 1 &gt; &amp;number_cache)</td></tr>
<tr class="separator:aaef4ad66d955644480ca4b36413b09f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7a641a3ca27b5b96098ba94ad64233"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0c7a641a3ca27b5b96098ba94ad64233"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#a0c7a641a3ca27b5b96098ba94ad64233">compute_number_cache</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const unsigned int level_objects, <a class="el" href="structinternal_1_1Triangulation_1_1NumberCache.html">internal::Triangulation::NumberCache</a>&lt; 2 &gt; &amp;number_cache)</td></tr>
<tr class="separator:a0c7a641a3ca27b5b96098ba94ad64233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d8f084e208f0b2f1dc8ff6a21e4b7b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad0d8f084e208f0b2f1dc8ff6a21e4b7b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#ad0d8f084e208f0b2f1dc8ff6a21e4b7b">compute_number_cache</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const unsigned int level_objects, <a class="el" href="structinternal_1_1Triangulation_1_1NumberCache.html">internal::Triangulation::NumberCache</a>&lt; 3 &gt; &amp;number_cache)</td></tr>
<tr class="separator:ad0d8f084e208f0b2f1dc8ff6a21e4b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5ef3907828bcd2ee4427b0a49a3329"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a4b5ef3907828bcd2ee4427b0a49a3329"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#a4b5ef3907828bcd2ee4427b0a49a3329">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;v, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; 1 &gt; &gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a4b5ef3907828bcd2ee4427b0a49a3329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d6ea1cbc3606447cacbe227186b4b0"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a60d6ea1cbc3606447cacbe227186b4b0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#a60d6ea1cbc3606447cacbe227186b4b0">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;v, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; 2 &gt; &gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a60d6ea1cbc3606447cacbe227186b4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9a813cd34e18ef24e52d7c2aeac60"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a0ba9a813cd34e18ef24e52d7c2aeac60"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#a0ba9a813cd34e18ef24e52d7c2aeac60">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;v, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; 3 &gt; &gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a0ba9a813cd34e18ef24e52d7c2aeac60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc4b14dbf944c0ce2b0fca2fb1a5cca"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a7dc4b14dbf944c0ce2b0fca2fb1a5cca"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#a7dc4b14dbf944c0ce2b0fca2fb1a5cca">delete_children</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;triangulation, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt;::cell_iterator &amp;cell, std::vector&lt; unsigned int &gt; &amp;, std::vector&lt; unsigned int &gt; &amp;)</td></tr>
<tr class="separator:a7dc4b14dbf944c0ce2b0fca2fb1a5cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e1b784a826694834aeedc4899395fa"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a21e1b784a826694834aeedc4899395fa"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#a21e1b784a826694834aeedc4899395fa">create_children</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;triangulation, unsigned int &amp;next_unused_vertex, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt;::raw_line_iterator &amp;next_unused_line, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt;::raw_cell_iterator &amp;next_unused_cell, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a21e1b784a826694834aeedc4899395fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7ff663650edddebfc0c87126c3742e"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a2a7ff663650edddebfc0c87126c3742e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt;::DistortedCellList&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#a2a7ff663650edddebfc0c87126c3742e">execute_refinement</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;triangulation, const bool)</td></tr>
<tr class="separator:a2a7ff663650edddebfc0c87126c3742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d11e3a21b56526f483eb08fc04f9cfa"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a5d11e3a21b56526f483eb08fc04f9cfa"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt;::DistortedCellList&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#a5d11e3a21b56526f483eb08fc04f9cfa">execute_refinement</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;triangulation, const bool check_for_distorted_cells)</td></tr>
<tr class="separator:a5d11e3a21b56526f483eb08fc04f9cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bad74f0679fb13a989bde42c4a96d49"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a5bad74f0679fb13a989bde42c4a96d49"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, spacedim &gt;::DistortedCellList&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#a5bad74f0679fb13a989bde42c4a96d49">execute_refinement</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, spacedim &gt; &amp;triangulation, const bool check_for_distorted_cells)</td></tr>
<tr class="separator:a5bad74f0679fb13a989bde42c4a96d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6337bd819f612880380728bf56d5dff"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:aa6337bd819f612880380728bf56d5dff"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#aa6337bd819f612880380728bf56d5dff">prevent_distorted_boundary_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;)</td></tr>
<tr class="separator:aa6337bd819f612880380728bf56d5dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec3f39e71e9eb6f3e6b9357341316f5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:adec3f39e71e9eb6f3e6b9357341316f5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#adec3f39e71e9eb6f3e6b9357341316f5">prepare_refinement_dim_dependent</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;)</td></tr>
<tr class="separator:adec3f39e71e9eb6f3e6b9357341316f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6846d222287250b603db187e5f09b28"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad6846d222287250b603db187e5f09b28"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html#ad6846d222287250b603db187e5f09b28">coarsening_allowed</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:ad6846d222287250b603db187e5f09b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class into which we put many of the functions that implement functionality of the <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a> class. The main reason for this class is as follows: the majority of the functions in <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a> need to be implemented differently for dim==1, dim==2, and dim==3. However, their implementation is largly independent of the spacedim template parameter. So we would like to write things like</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classTriangulation.html#ab926104144af9f9f5ca8c0798308c68c">Triangulation&lt;1,spacedim&gt;::create_triangulation</a> (...) {...}</div></div><!-- fragment --><p>Unfortunately, C++ doesn't allow this: member functions of class templates have to be either not specialized at all, or fully specialized. No partial specialization is allowed. One possible solution would be to just duplicate the bodies of the functions and have equally implemented functions</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classTriangulation.html#ab926104144af9f9f5ca8c0798308c68c">Triangulation&lt;1,1&gt;::create_triangulation</a> (...) {...}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classTriangulation.html#ab926104144af9f9f5ca8c0798308c68c">Triangulation&lt;1,2&gt;::create_triangulation</a> (...) {...}</div></div><!-- fragment --><p>but that is clearly an unsatisfactory solution. Rather, what we do is introduce the current <a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html">Implementation</a> class in which we can write these functions as member templates over spacedim, i.e. we can have</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim_, <span class="keywordtype">int</span> spacedim_&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="structinternal_1_1Triangulation_1_1Implementation.html#a4b5ef3907828bcd2ee4427b0a49a3329">Triangulation&lt;dim_,spacedim_&gt;::Implementation::</a></div><div class="line"><a class="code" href="structinternal_1_1Triangulation_1_1Implementation.html#a4b5ef3907828bcd2ee4427b0a49a3329">           create_triangulation</a> (...,</div><div class="line">                                 <a class="code" href="classTriangulation.html">Triangulation&lt;1,spacedim&gt;</a> &amp;tria ) {...}</div></div><!-- fragment --><p>The outer template parameters are here unused, only the inner ones are of real interest.</p>
<p>One may ask why we put these functions into an class rather than an anonymous namespace, for example?</p>
<p>First, these implementation functions need to be friends of the <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a> class. It is simpler to make the entire class a friend rather than listing all members of an implementation namespace as friends of the <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a> class (there is no such thing as a "friend
namespace XXX" directive).</p>
<p>Ideally, we would make this class a member class of the Triangulation&lt;dim,spacedim&gt; class, since then our implementation functions have immediate access to the typedefs and static functions of the surrounding <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a> class. I.e., we do not have to write "typename
Triangulation&lt;dim,spacedim&gt;::active_cell_iterator" but can write "active_cell_iterator" right away. This is, in fact, the way it was implemented first, but we ran into a bug in gcc4.0: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classTriangulation.html">Triangulation</a> {</div><div class="line">  <span class="keyword">struct </span>Implementation;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTriaAccessor.html">TriaAccessor</a>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span><a class="code" href="classTriaAccessor.html">TriaAccessor</a> {</div><div class="line">  <span class="keyword">struct </span>Implementation;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTriangulation.html">Triangulation</a>;</div><div class="line">};</div></div><!-- fragment --><p>Here, friendship (per C++ standard) is supposed to extend to all members of the befriended class, including its '<a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html">Implementation</a>' member class. But gcc4.0 gets this wrong: the members of <a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html">Triangulation::Implementation</a> are not friends of <a class="el" href="classTriaAccessor.html">TriaAccessor</a> and the other way around. Ideally, one would fix this by saying </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classTriangulation.html">Triangulation</a> {</div><div class="line">  <span class="keyword">struct </span>Implementation;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTriaAccessor.html">TriaAccessor</a>;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>TriaAccessor::Implementation;   <span class="comment">// **</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span><a class="code" href="classTriaAccessor.html">TriaAccessor</a> {</div><div class="line">  <span class="keyword">struct </span>Implementation;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTriangulation.html">Triangulation</a>;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>Triangulation::Implementation;</div><div class="line">};</div></div><!-- fragment --><p> but that's not legal because in ** we don't know yet that <a class="el" href="classTriaAccessor.html">TriaAccessor</a> has a member class <a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html">Implementation</a> and so we can't make it a friend. The only way forward at this point was to make <a class="el" href="structinternal_1_1Triangulation_1_1Implementation.html">Implementation</a> a class in the internal namespace so that we can forward declare it and make it a friend of the respective other outer class &ndash; not quite what we wanted but the only way I could see to make it work... </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l01293">1293</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aaef4ad66d955644480ca4b36413b09f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef4ad66d955644480ca4b36413b09f7">&#9670;&nbsp;</a></span>compute_number_cache() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::compute_number_cache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level_objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1Triangulation_1_1NumberCache.html">internal::Triangulation::NumberCache</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>number_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a given <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a>, update that part of the number cache that relates to lines. For 1d, we have to deal with the fact that lines have levels, whereas for higher dimensions they do not.</p>
<p>The second argument indicates for how many levels the <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a> has objects, though the highest levels need not contain active cells if they have previously all been coarsened away. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l01308">1308</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a0c7a641a3ca27b5b96098ba94ad64233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7a641a3ca27b5b96098ba94ad64233">&#9670;&nbsp;</a></span>compute_number_cache() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::compute_number_cache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level_objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1Triangulation_1_1NumberCache.html">internal::Triangulation::NumberCache</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>number_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a given <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a>, update that part of the number cache that relates to quads. For 2d, we have to deal with the fact that quads have levels, whereas for higher dimensions they do not.</p>
<p>The second argument indicates for how many levels the <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a> has objects, though the highest levels need not contain active cells if they have previously all been coarsened away.</p>
<p>At the beginning of the function, we call the respective function to update the number cache for lines. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l01394">1394</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ad0d8f084e208f0b2f1dc8ff6a21e4b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d8f084e208f0b2f1dc8ff6a21e4b7b">&#9670;&nbsp;</a></span>compute_number_cache() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::compute_number_cache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level_objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1Triangulation_1_1NumberCache.html">internal::Triangulation::NumberCache</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>number_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a given <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a>, update that part of the number cache that relates to hexes. For 3d, we have to deal with the fact that hexes have levels, whereas for higher dimensions they do not.</p>
<p>The second argument indicates for how many levels the <a class="el" href="namespaceinternal_1_1Triangulation.html">Triangulation</a> has objects, though the highest levels need not contain active cells if they have previously all been coarsened away.</p>
<p>At the end of the function, we call the respective function to update the number cache for quads, which will in turn call the respective function for lines. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l01498">1498</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a4b5ef3907828bcd2ee4427b0a49a3329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5ef3907828bcd2ee4427b0a49a3329">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from given data. This function does this work for 1-dimensional triangulations independently of the actual space dimension. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l01597">1597</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a60d6ea1cbc3606447cacbe227186b4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d6ea1cbc3606447cacbe227186b4b0">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from given data. This function does this work for 2-dimensional triangulations independently of the actual space dimension. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l01801">1801</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a0ba9a813cd34e18ef24e52d7c2aeac60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba9a813cd34e18ef24e52d7c2aeac60">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from given data. This function does this work for 3-dimensional triangulations independently of the actual space dimension. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l02169">2169</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a7dc4b14dbf944c0ce2b0fca2fb1a5cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc4b14dbf944c0ce2b0fca2fb1a5cca">&#9670;&nbsp;</a></span>delete_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::delete_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actually delete a cell, or rather all its children, which is the main step for the coarsening process. This is the dimension dependent part of <code>execute_coarsening</code>. The second argument is a vector which gives for each line index the number of cells containing this line. This information is needed to decide whether a refined line may be coarsened or not in 3D. In 1D and 2D this argument is not needed and thus ignored. The same applies for the last argument and quads instead of lines. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l03062">3062</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a21e1b784a826694834aeedc4899395fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e1b784a826694834aeedc4899395fa">&#9670;&nbsp;</a></span>create_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::create_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>next_unused_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt;::raw_line_iterator &amp;&#160;</td>
          <td class="paramname"><em>next_unused_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt;::raw_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>next_unused_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create the children of a 2d cell. The arguments indicate the next free spots in the vertices, lines, and cells arrays.</p>
<p>The faces of the cell have to be refined already, whereas the inner lines in 2D will be created in this function. Therefore iterator pointers into the vectors of lines, quads and cells have to be passed, which point at (or "before") the reserved space. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l03859">3859</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a2a7ff663650edddebfc0c87126c3742e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7ff663650edddebfc0c87126c3742e">&#9670;&nbsp;</a></span>execute_refinement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTriangulation.html">Triangulation</a>&lt;1,spacedim&gt;::DistortedCellList internal::Triangulation::Implementation::execute_refinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that performs the refinement of a triangulation in 1d. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l04328">4328</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5d11e3a21b56526f483eb08fc04f9cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d11e3a21b56526f483eb08fc04f9cfa">&#9670;&nbsp;</a></span>execute_refinement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,spacedim&gt;::DistortedCellList internal::Triangulation::Implementation::execute_refinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>check_for_distorted_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that performs the refinement of a triangulation in 2d. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l04571">4571</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="a5bad74f0679fb13a989bde42c4a96d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bad74f0679fb13a989bde42c4a96d49">&#9670;&nbsp;</a></span>execute_refinement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTriangulation.html">Triangulation</a>&lt;3,spacedim&gt;::DistortedCellList internal::Triangulation::Implementation::execute_refinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>check_for_distorted_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that performs the refinement of a triangulation in 3d. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l04927">4927</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="aa6337bd819f612880380728bf56d5dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6337bd819f612880380728bf56d5dff">&#9670;&nbsp;</a></span>prevent_distorted_boundary_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::prevent_distorted_boundary_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>At the boundary of the domain, the new point on the face may be far inside the current cell, if the boundary has a strong curvature. If we allow anisotropic refinement here, the resulting cell may be strongly distorted. To prevent this, this function flags such cells for isotropic refinement. It is called automatically from prepare_coarsening_and_refinement().</p>
<p>This function does nothing in 1d (therefore the specialization). </p>

</div>
</div>
<a id="adec3f39e71e9eb6f3e6b9357341316f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec3f39e71e9eb6f3e6b9357341316f5">&#9670;&nbsp;</a></span>prepare_refinement_dim_dependent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void internal::Triangulation::Implementation::prepare_refinement_dim_dependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Some dimension dependent stuff for mesh smoothing.</p>
<p>At present, this function does nothing in 1d and 2D, but makes sure no two cells with a level difference greater than one share one line in 3D. This is a requirement needed for the interpolation of hanging nodes, since otherwise to steps of interpolation would be necessary. This would make the processes implemented in the <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a></code> class much more complex, since these two steps of interpolation do not commute. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l08683">8683</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ad6846d222287250b603db187e5f09b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6846d222287250b603db187e5f09b28">&#9670;&nbsp;</a></span>coarsening_allowed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool internal::Triangulation::Implementation::coarsening_allowed </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function for <code>fix_coarsen_flags</code>. Return whether coarsening of this cell is allowed. Coarsening can be forbidden if the neighboring cells are or will be refined twice along the common face. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l08868">8868</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/Users/xywei/Workspace/dealii/source/grid/<a class="el" href="grid_2tria_8cc_source.html">tria.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
