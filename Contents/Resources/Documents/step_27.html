<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-27 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-27 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Finiteelementcollections">Finite element collections</a>
        <li><a href="#ThehpDoFHandlerclassassociatingcellswithfiniteelementsandconstraints">The hp::DoFHandler class, associating cells with finite elements, and constraints</a>
        <li><a href="#Assemblingmatricesandvectorswithhpobjects">Assembling matrices and vectors with hp objects</a>
        <li><a href="#Asimpleindicatorforhprefinementandestimatingsmoothness">A simple indicator for hp refinement and estimating smoothness</a>
      <ul>
        <li><a href="#Theidea">The idea</a>
        <li><a href="#Whatwehavetodo">What we have to do</a>
        <li><a href="#Compensatingforanisotropy">Compensating for anisotropy</a>
        <li><a href="#Questionsaboutcellsizes">Questions about cell sizes</a>
      </ul>
        <li><a href="#Complicationswithlinearsystemsforhpdiscretizations">Complications with linear systems for hp discretizations</a>
      <ul>
        <li><a href="#Creatingthesparsitypattern">Creating the sparsity pattern</a>
        <li><a href="#Eliminatingconstraineddegreesoffreedom">Eliminating constrained degrees of freedom</a>
      </ul>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Themainclass">The main class</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Implementationofthemainclass">Implementation of the main class</a>
      <ul>
        <li><a href="#LaplaceProblemLaplaceProblem">LaplaceProblem::LaplaceProblem</a>
        <li><a href="#LaplaceProblemLaplaceProblem">LaplaceProblem::~LaplaceProblem</a>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#LaplaceProblempostprocess">LaplaceProblem::postprocess</a>
        <li><a href="#LaplaceProblemcreate_coarse_grid">LaplaceProblem::create_coarse_grid</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
        <li><a href="#LaplaceProblemestimate_smoothness">LaplaceProblem::estimate_smoothness</a>
      </ul>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program attempts to show how to use <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite element methods with deal.II. It solves the Laplace equation and so builds only on the first few tutorial programs, in particular on <a class="el" href="step_4.html">step-4</a> for dimension independent programming and <a class="el" href="step_6.html">step-6</a> for adaptive mesh refinement.</p>
<p>The <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite element method was proposed in the early 1980s by Babuska and Guo as an alternative to either (i) mesh refinement (i.e. decreasing the mesh parameter <img class="formulaInl" alt="$h$" src="form_720.png"/> in a finite element computation) or (ii) increasing the polynomial degree <img class="formulaInl" alt="$p$" src="form_202.png"/> used for shape functions. It is based on the observation that increasing the polynomial degree of the shape functions reduces the approximation error if the solution is sufficiently smooth. On the other hand, it is well known that even for the generally well-behaved class of elliptic problems, higher degrees of regularity can not be guaranteed in the vicinity of boundaries, corners, or where coefficients are discontinuous; consequently, the approximation can not be improved in these areas by increasing the polynomial degree <img class="formulaInl" alt="$p$" src="form_202.png"/> but only by refining the mesh, i.e. by reducing the mesh size <img class="formulaInl" alt="$h$" src="form_720.png"/>. These differing means to reduce the error have led to the notion of <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite elements, where the approximating finite element spaces are adapted to have a high polynomial degree <img class="formulaInl" alt="$p$" src="form_202.png"/> wherever the solution is sufficiently smooth, while the mesh width <img class="formulaInl" alt="$h$" src="form_720.png"/> is reduced at places wherever the solution lacks regularity. It was already realized in the first papers on this method that <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite elements can be a powerful tool that can guarantee that the error is reduced not only with some negative power of the number of degrees of freedom, but in fact exponentially.</p>
<p>In order to implement this method, we need several things above and beyond what a usual finite element program needs, and in particular above what we have introduced in the tutorial programs leading up to <a class="el" href="step_6.html">step-6</a>. In particular, we will have to discuss the following aspects: </p><ul>
<li>
<p class="startli">Instead of using the same finite element on all cells, we now will want a collection of finite element objects, and associate each cell with one of these objects in this collection.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Degrees of freedom will then have to be allocated on each cell depending on what finite element is associated with this particular cell. Constraints will have to generated in the same way as for hanging nodes, but now also including the case where two neighboring cells.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We will need to be able to assemble cell and face contributions to global matrices and right hand side vectors.</p>
<p class="endli"></p>
</li>
<li>
After solving the resulting linear system, we will want to analyze the solution. In particular, we will want to compute error indicators that tell us whether a given cell should be refined and/or whether the polynomial degree of the shape functions used on it should be increased. </li>
</ul>
<p>We will discuss all these aspects in the following subsections of this introduction. It will not come as a big surprise that most of these tasks are already well supported by functionality provided by the deal.II libraries, and that we will only have to provide the logic of what the program should do, not exactly how all this is going to happen.</p>
<p>In deal.II, the <img class="formulaInl" alt="$hp$" src="form_49.png"/> functionality is largely packaged into the hp namespace. This namespace provides classes that handle <img class="formulaInl" alt="$hp$" src="form_49.png"/> discretizations, assembling matrices and vectors, and other tasks. We will get to know many of them further down below. In addition, many of the functions in the <a class="el" href="namespaceDoFTools.html">DoFTools</a>, and <a class="el" href="namespaceVectorTools.html">VectorTools</a> namespaces accept <img class="formulaInl" alt="$hp$" src="form_49.png"/> objects in addition to the non- <img class="formulaInl" alt="$hp$" src="form_49.png"/> ones. Much of the <img class="formulaInl" alt="$hp$" src="form_49.png"/> implementation is also discussed in the <a class="el" href="group__hp.html">hp finite element support</a> documentation module and the links found there.</p>
<p>It may be worth giving a slightly larger perspective at the end of this first part of the introduction. <img class="formulaInl" alt="$hp$" src="form_49.png"/> functionality has been implemented in a number of different finite element packages (see, for example, the list of references cited in the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a>). However, by and large, most of these packages have implemented it only for the (i) the 2d case, and/or (ii) the discontinuous Galerkin method. The latter is a significant simplification because discontinuous finite elements by definition do not require continuity across faces between cells and therefore do not require the special treatment otherwise necessary whenever finite elements of different polynomial degree meet at a common face. In contrast, deal.II implements the most general case, i.e. it allows for continuous and discontinuous elements in 1d, 2d, and 3d, and automatically handles the resulting complexity. In particular, it handles computing the constraints (similar to hanging node constraints) of elements of different degree meeting at a face or edge. The many algorithmic and data structure techniques necessary for this are described in the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a> for those interested in such detail.</p>
<p>We hope that providing such a general implementation will help explore the potential of <img class="formulaInl" alt="$hp$" src="form_49.png"/> methods further.</p>
<p><a class="anchor" id="Finiteelementcollections"></a></p><h3>Finite element collections</h3>
<p>Now on again to the details of how to use the <img class="formulaInl" alt="$hp$" src="form_49.png"/> functionality in deal.II. The first aspect we have to deal with is that now we do not have only a single finite element any more that is used on all cells, but a number of different elements that cells can choose to use. For this, deal.II introduces the concept of a <em>finite element collection</em>, implemented in the class <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>. In essence, such a collection acts like an object of type <code>std::vector&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&gt;</code>, but with a few more bells and whistles and a memory management better suited to the task at hand. As we will later see, we will also use similar quadrature collections, and &mdash; although we don't use them here &mdash; there is also the concept of mapping collections. All of these classes are described in the <a class="el" href="group__hpcollection.html">hp Collections</a> overview.</p>
<p>In this tutorial program, we will use continuous Lagrange elements of orders 2 through 7 (in 2d) or 2 through 5 (in 3d). The collection of used elements can then be created as follows: </p><div class="fragment"><div class="line"><a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree=2; degree&lt;=max_degree; ++degree)</div><div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(degree));</div></div><!-- fragment --><p><a class="anchor" id="ThehpDoFHandlerclassassociatingcellswithfiniteelementsandconstraints"></a></p><h3>The <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> class, associating cells with finite elements, and constraints</h3>
<p>The next task we have to consider is what to do with the list of finite element objects we want to use. In previous tutorial programs, starting with <a class="el" href="step_2.html">step-2</a>, we have seen that the <a class="el" href="classDoFHandler.html">DoFHandler</a> class is responsible for making the connection between a mesh (described by a <a class="el" href="classTriangulation.html">Triangulation</a> object) and a finite element, by allocating the correct number of degrees of freedom for each vertex, face, edge, and cell of the mesh.</p>
<p>The situation here is a bit more complicated since we do not just have a single finite element object, but rather may want to use different elements on different cells. We therefore need two things: (i) a version of the <a class="el" href="classDoFHandler.html">DoFHandler</a> class that can deal with this situation, and (ii) a way to tell the DoF handler which element to use on which cell.</p>
<p>The first of these two things is implemented in the <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> class: rather than associating it with a triangulation and a single finite element object, it is associated with a triangulation and a finite element collection. The second part is achieved by a loop over all cells of this <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> and for each cell setting the index of the finite element within the collection that shall be used on this cell. We call the index of the finite element object within the collection that shall be used on a cell the cell's <em>active FE index</em> to indicate that this is the finite element that is active on this cell, whereas all the other elements of the collection are inactive on it. The general outline of this reads like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classhp_1_1DoFHandler.html">hp::DoFHandler&lt;dim&gt;</a> dof_handler (triangulation);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">     cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">  cell-&gt;set_active_fe_index (...);</div><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe_collection);</div></div><!-- fragment --><p>Dots in the call to <code>set_active_fe_index()</code> indicate that we will have to have some sort of strategy later on to decide which element to use on which cell; we will come back to this later. The main point here is that the first and last line of this code snippet is pretty much exactly the same as for the non- <img class="formulaInl" alt="$hp$" src="form_49.png"/> case.</p>
<p>Another complication arises from the fact that this time we do not simply have hanging nodes from local mesh refinement, but we also have to deal with the case that if there are two cells with different active finite element indices meeting at a face (for example a Q2 and a Q3 element) then we have to compute additional constraints on the finite element field to ensure that it is continuous. This is conceptually very similar to how we compute hanging node constraints, and in fact the code looks exactly the same: </p><div class="fragment"><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div><div class="line"><a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                         constraints);</div></div><!-- fragment --><p> In other words, the <a class="el" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> deals not only with hanging node constraints, but also with <img class="formulaInl" alt="$hp$" src="form_49.png"/> constraints at the same time.</p>
<p><a class="anchor" id="Assemblingmatricesandvectorswithhpobjects"></a></p><h3>Assembling matrices and vectors with hp objects</h3>
<p>Following this, we have to set up matrices and vectors for the linear system of the correct size and assemble them. Setting them up works in exactly the same way as for the non- <img class="formulaInl" alt="$hp$" src="form_49.png"/> case. Assembling requires a bit more thought.</p>
<p>The main idea is of course unchanged: we have to loop over all cells, assemble local contributions, and then copy them into the global objects. As discussed in some detail first in <a class="el" href="step_3.html">step-3</a>, deal.II has the <a class="el" href="classFEValues.html">FEValues</a> class that pulls finite element description, mapping, and quadrature formula together and aids in evaluating values and gradients of shape functions as well as other information on each of the quadrature points mapped to the real location of a cell. Every time we move on to a new cell we re-initialize this <a class="el" href="classFEValues.html">FEValues</a> object, thereby asking it to re-compute that part of the information that changes from cell to cell. It can then be used to sum up local contributions to bilinear form and right hand side.</p>
<p>In the context of <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite element methods, we have to deal with the fact that we do not use the same finite element object on each cell. In fact, we should not even use the same quadrature object for all cells, but rather higher order quadrature formulas for cells where we use higher order finite elements. Similarly, we may want to use higher order mappings on such cells as well.</p>
<p>To facilitate these considerations, deal.II has a class <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> that does what we need in the current context. The difference is that instead of a single finite element, quadrature formula, and mapping, it takes collections of these objects. It's use is very much like the regular <a class="el" href="classFEValues.html">FEValues</a> class, i.e. the interesting part of the loop over all cells would look like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values (mapping_collection,</div><div class="line">                                fe_collection,</div><div class="line">                                quadrature_collection,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa49a49d892021457f921318905c408e25">update_q_points</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    hp_fe_values.reinit (cell,</div><div class="line">                         cell-&gt;active_fe_index(),</div><div class="line">                         cell-&gt;active_fe_index(),</div><div class="line">                         cell-&gt;active_fe_index());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a4bc26790261f1f9f4cc7e8e69e3d7920">get_present_fe_values</a> ();</div><div class="line"></div><div class="line">    ...  <span class="comment">// assemble local contributions and copy them into global object</span></div><div class="line">  }</div></div><!-- fragment --><p>In this tutorial program, we will always use a Q1 mapping, so the mapping collection argument to the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> construction will be omitted. Inside the loop, we first initialize the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object for the current cell. The second, third and fourth arguments denote the index within their respective collections of the quadrature, mapping, and finite element objects we wish to use on this cell. These arguments can be omitted (and are in the program below), in which case <code>cell-&gt;active_fe_index()</code> is used for this index. The order of these arguments is chosen in this way because one may sometimes want to pick a different quadrature or mapping object from their respective collections, but hardly ever a different finite element than the one in use on this cell, i.e. one with an index different from <code>cell-&gt;active_fe_index()</code>. The finite element collection index is therefore the last default argument so that it can be conveniently omitted.</p>
<p>What this <code>reinit</code> call does is the following: the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> class checks whether it has previously already allocated a non- <img class="formulaInl" alt="$hp$" src="form_49.png"/> <a class="el" href="classFEValues.html">FEValues</a> object for this combination of finite element, quadrature, and mapping objects. If not, it allocates one. It then re-initializes this object for the current cell, after which there is now a <a class="el" href="classFEValues.html">FEValues</a> object for the selected finite element, quadrature and mapping usable on the current cell. A reference to this object is then obtained using the call <code>hp_fe_values.get_present_fe_values()</code>, and will be used in the usual fashion to assemble local contributions.</p>
<p><a class="anchor" id="Asimpleindicatorforhprefinementandestimatingsmoothness"></a></p><h3>A simple indicator for hp refinement and estimating smoothness</h3>
<p>One of the central pieces of the adaptive finite element method is that we inspect the computed solution (a posteriori) with an indicator that tells us which are the cells where the error is largest, and then refine them. In many of the other tutorial programs, we use the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class to get an indication of the size of the error on a cell, although we also discuss more complicated strategies in some programs, most importantly in <a class="el" href="step_14.html">step-14</a>.</p>
<p>In any case, as long as the decision is only "refine this cell" or "do not
refine this cell", the actual refinement step is not particularly challenging. However, here we have a code that is capable of hp refinement, i.e. we suddenly have two choices whenever we detect that the error on a certain cell is too large for our liking: we can refine the cell by splitting it into several smaller ones, or we can increase the polynomial degree of the shape functions used on it. How do we know which is the more promising strategy? Answering this question is the central problem in <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite element research at the time of this writing.</p>
<p>In short, the question does not appear to be settled in the literature at this time. There are a number of more or less complicated schemes that address it, but there is nothing like the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> that is universally accepted as a good, even if not optimal, indicator of the error. Most proposals use the fact that it is beneficial to increase the polynomial degree whenever the solution is locally smooth whereas it is better to refine the mesh wherever it is rough. However, the questions of how to determine the local smoothness of the solution as well as the decision when a solution is smooth enough to allow for an increase in <img class="formulaInl" alt="$p$" src="form_202.png"/> are certainly big and important ones.</p>
<p>In the following, we propose a simple estimator of the local smoothness of a solution. As we will see in the results section, this estimator has flaws, in particular as far as cells with local hanging nodes are concerned. We therefore do not intend to present the following ideas as a complete solution to the problem. Rather, it is intended as an idea to approach it that merits further research and investigation. In other words, we do not intend to enter a sophisticated proposal into the fray about answers to the general question. However, to demonstrate our approach to <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite elements, we need a simple indicator that does generate some useful information that is able to drive the simple calculations this tutorial program will perform.</p>
<p><a class="anchor" id="Theidea"></a></p><h4>The idea</h4>
<p>Our approach here is simple: for a function <img class="formulaInl" alt="$u({\bf x})$" src="form_2213.png"/> to be in the Sobolev space <img class="formulaInl" alt="$H^s(K)$" src="form_2214.png"/> on a cell <img class="formulaInl" alt="$K$" src="form_57.png"/>, it has to satisfy the condition </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_K |\nabla^s u({\bf x})|^2 \; d{\bf x} &lt; \infty. \]" src="form_2215.png"/>
</p>
<p> Assuming that the cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is not degenerate, i.e. that the mapping from the unit cell to cell <img class="formulaInl" alt="$K$" src="form_57.png"/> is sufficiently regular, above condition is of course equivalent to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\hat K} |\nabla^s \hat u(\hat{\bf x})|^2 \; d\hat{\bf x} &lt; \infty\,, \]" src="form_2216.png"/>
</p>
<p> where <img class="formulaInl" alt="$\hat u(\hat{\bf x})$" src="form_2217.png"/> is the function <img class="formulaInl" alt="$u({\bf x})$" src="form_2213.png"/> mapped back onto the unit cell <img class="formulaInl" alt="$\hat K$" src="form_165.png"/>. From here, we can do the following: first, let us define the Fourier series of <img class="formulaInl" alt="$\hat u$" src="form_2218.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat u(\hat{\bf x}) = \sum_{\bf k} \hat U_{\bf k}\,e^{-i {\bf k}\cdot \hat{\bf x}}, \]" src="form_2219.png"/>
</p>
<p> with Fourier vectors <img class="formulaInl" alt="${\bf k}=(k_x,k_y)$" src="form_2220.png"/> in 2d, <img class="formulaInl" alt="${\bf k}=(k_x,k_y,k_z)$" src="form_2221.png"/> in 3d, etc, and <img class="formulaInl" alt="$k_x,k_y,k_z=0,2\pi,4\pi,\ldots$" src="form_2222.png"/>. The coefficients of expansion <img class="formulaInl" alt="$\hat U_{\bf k}$" src="form_2223.png"/> can be obtained using <img class="formulaInl" alt="$L^2$" src="form_700.png"/>-orthogonality of the exponential basis </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\hat K} e^{-i {\bf m}\cdot \hat{\bf x}} e^{i {\bf n}\cdot \hat{\bf x}} d\hat{\bf x} = \delta_{\bf m \bf n}, \]" src="form_2224.png"/>
</p>
<p> that leads to the following expression </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat U_{\bf k} = \int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat u(\hat{\bf x}) d\hat{\bf x} \,. \]" src="form_2225.png"/>
</p>
<p> It becomes clear that we can then write the <img class="formulaInl" alt="$H^s$" src="form_2226.png"/> norm of <img class="formulaInl" alt="$\hat u$" src="form_2218.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\hat K} |\nabla^s \hat u(\hat{\bf x})|^2 \; d\hat{\bf x} = \int_{\hat K} \left| \sum_{\bf k} |{\bf k}|^s e^{-i{\bf k}\cdot \hat{\bf x}} \hat U_{\bf k} \right|^2 \; d\hat{\bf x} = \sum_{\bf k} |{\bf k}|^{2s} |\hat U_{\bf k}|^2. \]" src="form_2227.png"/>
</p>
<p> In other words, if this norm is to be finite (i.e. for <img class="formulaInl" alt="$\hat u(\hat{\bf x})$" src="form_2217.png"/> to be in <img class="formulaInl" alt="$H^s(\hat K)$" src="form_2228.png"/>), we need that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ |\hat U_{\bf k}| = {\cal O}\left(|{\bf k}|^{-\left(s+1/2+\frac{d-1}{2}+\epsilon\right)}\right). \]" src="form_2229.png"/>
</p>
<p> Put differently: the higher regularity <img class="formulaInl" alt="$s$" src="form_308.png"/> we want, the faster the Fourier coefficients have to go to zero. If you wonder where the additional exponent <img class="formulaInl" alt="$\frac{d-1}2$" src="form_2230.png"/> comes from: we would like to make use of the fact that <img class="formulaInl" alt="$\sum_l a_l &lt; \infty$" src="form_2231.png"/> if the sequence <img class="formulaInl" alt="$a_l = {\cal O}(l^{-1-\epsilon})$" src="form_2232.png"/> for any <img class="formulaInl" alt="$\epsilon&gt;0$" src="form_2233.png"/>. The problem is that we here have a summation not only over a single variable, but over all the integer multiples of <img class="formulaInl" alt="$2\pi$" src="form_2234.png"/> that are located inside the <img class="formulaInl" alt="$d$" src="form_301.png"/>-dimensional sphere, because we have vector components <img class="formulaInl" alt="$k_x, k_y, \ldots$" src="form_2235.png"/>. In the same way as we prove that the sequence <img class="formulaInl" alt="$a_l$" src="form_2236.png"/> above converges by replacing the sum by an integral over the entire line, we can replace our <img class="formulaInl" alt="$d$" src="form_301.png"/>-dimensional sum by an integral over <img class="formulaInl" alt="$d$" src="form_301.png"/>-dimensional space. Now we have to note that between distance <img class="formulaInl" alt="$|{\bf k}|$" src="form_2237.png"/> and <img class="formulaInl" alt="$|{\bf k}|+d|{\bf k}|$" src="form_2238.png"/>, there are, up to a constant, <img class="formulaInl" alt="$|{\bf k}|^{d-1}$" src="form_2239.png"/> modes, in much the same way as we can transform the volume element <img class="formulaInl" alt="$dx\;dy$" src="form_2240.png"/> into <img class="formulaInl" alt="$2\pi r\; dr$" src="form_2241.png"/>. Consequently, it is no longer <img class="formulaInl" alt="$|{\bf k}|^{2s}|\hat U_{\bf k}|^2$" src="form_2242.png"/> that has to decay as <img class="formulaInl" alt="${\cal O}(|{\bf k}|^{-1-\epsilon})$" src="form_2243.png"/>, but it is in fact <img class="formulaInl" alt="$|{\bf k}|^{2s}|\hat U_{\bf k}|^2 |{\bf k}|^{d-1}$" src="form_2244.png"/>. A comparison of exponents yields the result.</p>
<p>We can turn this around: Assume we are given a function <img class="formulaInl" alt="$\hat u$" src="form_2218.png"/> of unknown smoothness. Let us compute its Fourier coefficients <img class="formulaInl" alt="$\hat U_{\bf k}$" src="form_2223.png"/> and see how fast they decay. If they decay as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ |\hat U_{\bf k}| = {\cal O}(|{\bf k}|^{-\mu-\epsilon}), \]" src="form_2245.png"/>
</p>
<p> then consequently the function we had here was in <img class="formulaInl" alt="$H^{\mu-d/2}$" src="form_2246.png"/>.</p>
<p><a class="anchor" id="Whatwehavetodo"></a></p><h4>What we have to do</h4>
<p>So what do we have to do to estimate the local smoothness of <img class="formulaInl" alt="$u({\bf x})$" src="form_2213.png"/> on a cell <img class="formulaInl" alt="$K$" src="form_57.png"/>? Clearly, the first step is to compute the Fourier coefficients of our solution. Fourier series being infinite series, we simplify our task by only computing the first few terms of the series, such that <img class="formulaInl" alt="$|{\bf k}|\le 2\pi N$" src="form_2247.png"/> with a cut-off <img class="formulaInl" alt="$N$" src="form_104.png"/>. Let us parenthetically remark that we want to choose <img class="formulaInl" alt="$N$" src="form_104.png"/> large enough so that we capture at least the variation of those shape functions that vary the most. On the other hand, we should not choose <img class="formulaInl" alt="$N$" src="form_104.png"/> too large: clearly, a finite element function, being a polynomial, is in <img class="formulaInl" alt="$C^\infty$" src="form_2248.png"/> on any given cell, so the coefficients will have to decay exponentially at one point; since we want to estimate the smoothness of the function this polynomial approximates, not of the polynomial itself, we need to choose a reasonable cutoff for <img class="formulaInl" alt="$N$" src="form_104.png"/>. Either way, computing this series is not particularly hard: from the definition </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat U_{\bf k} = \int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat u(\hat{\bf x}) d\hat{\bf x} \]" src="form_2249.png"/>
</p>
<p> we see that we can compute the coefficient <img class="formulaInl" alt="$\hat U_{\bf k}$" src="form_2223.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat U_{\bf k} = \sum_{i=0}^{\textrm{\tiny dofs per cell}} \left[\int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat \varphi_i(\hat{\bf x}) d\hat{\bf x} \right] u_i, \]" src="form_2250.png"/>
</p>
<p> where <img class="formulaInl" alt="$u_i$" src="form_2251.png"/> is the value of the <img class="formulaInl" alt="$i$" src="form_90.png"/>th degree of freedom on this cell. In other words, we can write it as a matrix-vector product </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat U_{\bf k} = {\cal F}_{{\bf k},j} u_j, \]" src="form_2252.png"/>
</p>
<p> with the matrix </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\cal F}_{{\bf k},j} = \int_{\hat K} e^{i {\bf k}\cdot \hat{\bf x}} \hat \varphi_j(\hat{\bf x}) d\hat{\bf x}. \]" src="form_2253.png"/>
</p>
<p> This matrix is easily computed for a given number of shape functions <img class="formulaInl" alt="$\varphi_j$" src="form_532.png"/> and Fourier modes <img class="formulaInl" alt="$N$" src="form_104.png"/>. Consequently, finding the coefficients <img class="formulaInl" alt="$\hat U_{\bf k}$" src="form_2223.png"/> is a rather trivial job. To simplify our life even further, we will use <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> class which does exactly this.</p>
<p>The next task is that we have to estimate how fast these coefficients decay with <img class="formulaInl" alt="$|{\bf k}|$" src="form_2237.png"/>. The problem is that, of course, we have only finitely many of these coefficients in the first place. In other words, the best we can do is to fit a function <img class="formulaInl" alt="$\alpha |{\bf k}|^{-\mu}$" src="form_2254.png"/> to our data points <img class="formulaInl" alt="$\hat U_{\bf k}$" src="form_2223.png"/>, for example by determining <img class="formulaInl" alt="$\alpha,\mu$" src="form_2255.png"/> via a least-squares procedure: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \min_{\alpha,\mu} \frac 12 \sum_{{\bf k}, |{\bf k}|\le N} \left( |\hat U_{\bf k}| - \alpha |{\bf k}|^{-\mu}\right)^2 \]" src="form_2256.png"/>
</p>
<p> However, the problem with this is that it leads to a nonlinear problem, a fact that we would like to avoid. On the other hand, we can transform the problem into a simpler one if we try to fit the logarithm of our coefficients to the logarithm of <img class="formulaInl" alt="$\alpha |{\bf k}|^{-\mu}$" src="form_2254.png"/>, like this: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \min_{\alpha,\mu} Q(\alpha,\mu) = \frac 12 \sum_{{\bf k}, |{\bf k}|\le N} \left( \ln |\hat U_{\bf k}| - \ln (\alpha |{\bf k}|^{-\mu})\right)^2. \]" src="form_2257.png"/>
</p>
<p> Using the usual facts about logarithms, we see that this yields the problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \min_{\beta,\mu} Q(\beta,\mu) = \frac 12 \sum_{{\bf k}, |{\bf k}|\le N} \left( \ln |\hat U_{\bf k}| - \beta + \mu \ln |{\bf k}|\right)^2, \]" src="form_2258.png"/>
</p>
<p> where <img class="formulaInl" alt="$\beta=\ln \alpha$" src="form_2259.png"/>. This is now a problem for which the optimality conditions <img class="formulaInl" alt="$\frac{\partial Q}{\partial\beta}=0, \frac{\partial Q}{\partial\mu}=0$" src="form_2260.png"/>, are linear in <img class="formulaInl" alt="$\beta,\mu$" src="form_2261.png"/>. We can write these conditions as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\begin{array}{cc} \sum_{{\bf k}, |{\bf k}|\le N} 1 &amp; \sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}| \\ \sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}| &amp; \sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2 \end{array}\right) \left(\begin{array}{c} \beta \\ -\mu \end{array}\right) = \left(\begin{array}{c} \sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \\ \sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \end{array}\right) \]" src="form_2262.png"/>
</p>
<p> This linear system is readily inverted to yield </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \beta = \frac 1{\left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) -\left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right)^2} \left[ \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}|\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \right) \right] \]" src="form_2263.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mu = \frac 1{\left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) -\left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right)^2} \left[ \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}|\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \right) \right]. \]" src="form_2264.png"/>
</p>
<p>This is nothing else but linear regression fit and to do that we will use <a class="el" href="namespaceFESeries.html#afa42058db3555536415fae91822d27e3">FESeries::linear_regression()</a>. While we are not particularly interested in the actual value of <img class="formulaInl" alt="$\beta$" src="form_414.png"/>, the formula above gives us a mean to calculate the value of the exponent <img class="formulaInl" alt="$\mu$" src="form_1643.png"/> that we can then use to determine that <img class="formulaInl" alt="$\hat u(\hat{\bf x})$" src="form_2217.png"/> is in <img class="formulaInl" alt="$H^s(\hat K)$" src="form_2228.png"/> with <img class="formulaInl" alt="$s=\mu-\frac d2$" src="form_2265.png"/>.</p>
<p><a class="anchor" id="Compensatingforanisotropy"></a></p><h4>Compensating for anisotropy</h4>
<p>In the formulas above, we have derived the Fourier coefficients <img class="formulaInl" alt="$\hat U_{\vec k}$" src="form_2266.png"/>. Because <img class="formulaInl" alt="${\bf k}$" src="form_2267.png"/> is a vector, we will get a number of Fourier coefficients <img class="formulaInl" alt="$\hat U_{{\bf k}}$" src="form_2268.png"/> for the same absolute value <img class="formulaInl" alt="$|{\bf k}|$" src="form_2237.png"/>, corresponding to the Fourier transform in different directions. If we now consider a function like <img class="formulaInl" alt="$|x|y^2$" src="form_2269.png"/> then we will find lots of large Fourier coefficients in <img class="formulaInl" alt="$x$" src="form_9.png"/>-direction because the function is non-smooth in this direction, but fast-decaying Fourier coefficients in <img class="formulaInl" alt="$y$" src="form_10.png"/>-direction because the function is smooth there. The question that arises is this: if we simply fit our polynomial decay <img class="formulaInl" alt="$\alpha |{\bf k}|^\mu$" src="form_2270.png"/> to <em>all</em> Fourier coefficients, we will fit it to a smoothness <em>averaged in all spatial directions</em>. Is this what we want? Or would it be better to only consider the largest coefficient <img class="formulaInl" alt="$\hat U_{{\bf k}}$" src="form_2268.png"/> for all <img class="formulaInl" alt="${\bf k}$" src="form_2267.png"/> with the same magnitude, essentially trying to determine the smoothness of the solution in that spatial direction in which the solution appears to be roughest?</p>
<p>One can probably argue for either case. The issue would be of more interest if deal.II had the ability to use anisotropic finite elements, i.e. ones that use different polynomial degrees in different spatial directions, as they would be able to exploit the directionally variable smoothness much better. Alas, this capability does not exist at the time of writing this tutorial program.</p>
<p>Either way, because we only have isotopic finite element classes, we adopt the viewpoint that we should tailor the polynomial degree to the lowest amount of regularity, in order to keep numerical efforts low. Consequently, instead of using the formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mu = \frac 1{\left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} (\ln |{\bf k}|)^2\right) -\left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right)^2} \left[ \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |{\bf k}|\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}|\right) - \left(\sum_{{\bf k}, |{\bf k}|\le N} 1\right) \left(\sum_{{\bf k}, |{\bf k}|\le N} \ln |\hat U_{{\bf k}}| \ln |{\bf k}| \right) \right]. \]" src="form_2264.png"/>
</p>
<p> to calculate <img class="formulaInl" alt="$\mu$" src="form_1643.png"/> as shown above, we have to slightly modify all sums: instead of summing over all Fourier modes, we only sum over those for which the Fourier coefficient is the largest one among all <img class="formulaInl" alt="$\hat U_{{\bf k}}$" src="form_2268.png"/> with the same magnitude <img class="formulaInl" alt="$|{\bf k}|$" src="form_2237.png"/>, i.e. all sums above have to replaced by the following sums: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{{\bf k}, |{\bf k}|\le N} \longrightarrow \sum_{\begin{matrix}{{\bf k}, |{\bf k}|\le N} \\ {|\hat U_{{\bf k}}| \ge |\hat U_{{\bf k}'}| \ \textrm{for all}\ {\bf k}'\ \textrm{with}\ |{\bf k}'|=|{\bf k}|}\end{matrix}} \]" src="form_2271.png"/>
</p>
<p> This is the form we will implement in the program.</p>
<p><a class="anchor" id="Questionsaboutcellsizes"></a></p><h4>Questions about cell sizes</h4>
<p>One may ask whether it is a problem that we only compute the Fourier transform on the <em>reference cell</em> (rather than the real cell) of the solution. After all, we stretch the solution by a factor <img class="formulaInl" alt="$\frac 1h$" src="form_2272.png"/> during the transformation, thereby shifting the Fourier frequencies by a factor of <img class="formulaInl" alt="$h$" src="form_720.png"/>. This is of particular concern since we may have neighboring cells with mesh sizes <img class="formulaInl" alt="$h$" src="form_720.png"/> that differ by a factor of 2 if one of them is more refined than the other. The concern is also motivated by the fact that, as we will see in the results section below, the estimated smoothness of the solution should be a more or less continuous function, but exhibits jumps at locations where the mesh size jumps. It therefore seems natural to ask whether we have to compensate for the transformation.</p>
<p>The short answer is "no". In the process outlined above, we attempt to find coefficients <img class="formulaInl" alt="$\beta,\mu$" src="form_2261.png"/> that minimize the sum of squares of the terms </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ln |\hat U_{{\bf k}}| - \beta + \mu \ln |{\bf k}|. \]" src="form_2273.png"/>
</p>
<p> To compensate for the transformation means not attempting to fit a decay <img class="formulaInl" alt="$|{\bf k}|^\mu$" src="form_2274.png"/> with respect to the Fourier frequencies <img class="formulaInl" alt="${\bf k}$" src="form_2267.png"/> <em>on the unit cell</em>, but to fit the coefficients <img class="formulaInl" alt="$\hat U_{{\bf k}}$" src="form_2268.png"/> computed on the reference cell <em>to the Fourier frequencies on the real cell <img class="formulaInl" alt="$|\vec k|h$" src="form_2275.png"/></em>, where <img class="formulaInl" alt="$h$" src="form_720.png"/> is the norm of the transformation operator (i.e. something like the diameter of the cell). In other words, we would have to minimize the sum of squares of the terms </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ln |\hat U_{{\bf k}}| - \beta + \mu \ln (|{\bf k}|h). \]" src="form_2276.png"/>
</p>
<p> instead. However, using fundamental properties of the logarithm, this is simply equivalent to minimizing </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \ln |\hat U_{{\bf k}}| - (\beta - \mu \ln h) + \mu \ln (|{\bf k}|). \]" src="form_2277.png"/>
</p>
<p> In other words, this and the original least squares problem will produce the same best-fit exponent <img class="formulaInl" alt="$\mu$" src="form_1643.png"/>, though the offset will in one case be <img class="formulaInl" alt="$\beta$" src="form_414.png"/> and in the other <img class="formulaInl" alt="$\beta-\mu \ln h$" src="form_2278.png"/>. However, since we are not interested in the offset at all but only in the exponent, it doesn't matter whether we scale Fourier frequencies in order to account for mesh size effects or not, the estimated smoothness exponent will be the same in either case.</p>
<p><a class="anchor" id="Complicationswithlinearsystemsforhpdiscretizations"></a></p><h3>Complications with linear systems for hp discretizations</h3>
<p><a class="anchor" id="Creatingthesparsitypattern"></a></p><h4>Creating the sparsity pattern</h4>
<p>One of the problems with <img class="formulaInl" alt="$hp$" src="form_49.png"/> methods is that the high polynomial degree of shape functions together with the large number of constrained degrees of freedom leads to matrices with large numbers of nonzero entries in some rows. At the same time, because there are areas where we use low polynomial degree and consequently matrix rows with relatively few nonzero entries. Consequently, allocating the sparsity pattern for these matrices is a challenge.</p>
<p>Most programs built on deal.II use the <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> function to allocate the sparsity pattern of a matrix, and later add a few more entries necessary to handle constrained degrees of freedom using <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense</a>. The sparsity pattern is then compressed using <a class="el" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">SparsityPattern::compress</a>. This method is explained in <a class="el" href="step_6.html">step-6</a> and used in most tutorial programs. In order to work, it needs an initial upper estimate for the maximal number of nonzero entries per row, something that can be had from the <a class="el" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">DoFHandler::max_couplings_between_dofs</a> function. This is necessary due to the data structure used in the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class.</p>
<p>Unfortunately, <a class="el" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">DoFHandler::max_couplings_between_dofs</a> is unable to produce an efficient upper estimate in 3d and for higher order elements. If used in these situations, it therefore leads the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class to allocate much too much memory, almost all of which will be released again when we call <a class="el" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">SparsityPattern::compress</a>. This deficiency, caused by the fact that <a class="el" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">DoFHandler::max_couplings_between_dofs</a> must produce a single number for the maximal number of elements per row even though most rows will be significantly shorter, can be so severe that the initial memory allocation for the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> exceeds the actual need by a factor of 10 or larger, and can lead to a program running out of memory when in fact there would be plenty of memory for all computations.</p>
<p>A solution to the problem has already been discussed in <a class="el" href="step_11.html">step-11</a> and <a class="el" href="step_18.html">step-18</a>. It used an intermediate object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. This class uses a different memory storage scheme that is optimized to <em>creating</em> a sparsity pattern when maximal numbers of entries per row are not accurately available, but is unsuitable for use as the sparsity pattern actually underlying a sparse matrix. After building the intermediate object, it is therefore copied into a true <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object, something that can be done very efficient and without having to over-allocate memory. Typical code doing this is shown in the documentation of the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> class. This solution is slower than directly building a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object, but only uses as much memory as is really necessary.</p>
<p><a class="anchor" id="Eliminatingconstraineddegreesoffreedom"></a></p><h4>Eliminating constrained degrees of freedom</h4>
<p>A second problem particular to <img class="formulaInl" alt="$hp$" src="form_49.png"/> methods arises because we have so many constrained degrees of freedom: typically up to about one third of all degrees of freedom (in 3d) are constrained because they either belong to cells with hanging nodes or because they are on cells adjacent to cells with a higher or lower polynomial degree. This is, in fact, not much more than the fraction of constrained degrees of freedom in non- <img class="formulaInl" alt="$hp$" src="form_49.png"/> mode, but the difference is that each constrained hanging node is constrained not only against the two adjacent degrees of freedom, but is constrained against many more degrees of freedom.</p>
<p>It turns out that the strategy presented first in <a class="el" href="step_6.html">step-6</a> to eliminate the constraints while computing the element matrices and vectors with <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global</a> is the most efficient approach also for this case. The alternative strategy to first build the matrix without constraints and then "condensing" away constrained degrees of freedom is considerably more expensive. It turns out that building the sparsity pattern by this inefficient algorithm requires at least <img class="formulaInl" alt="${\cal O}(N \log N)$" src="form_1893.png"/> in the number of unknowns, whereas an ideal finite element program would of course only have algorithms that are linear in the number of unknowns. Timing the sparsity pattern creation as well as the matrix assembly shows that the algorithm presented in <a class="el" href="step_6.html">step-6</a> (and used in the code below) is indeed faster.</p>
<p>In our program, we will also treat the boundary conditions as (possibly inhomogeneous) constraints and eliminate the matrix rows and columns to those as well. All we have to do for this is to call the function that interpolates the Dirichlet boundary conditions already in the setup phase in order to tell the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object about them, and then do the transfer from local to global data on matrix and vector simultaneously. This is exactly what we've shown in <a class="el" href="step_6.html">step-6</a>.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>The test case we will solve with this program is a re-take of the one we already look at in <a class="el" href="step_14.html">step-14</a>: we solve the Laplace equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\Delta u = f \]" src="form_2279.png"/>
</p>
<p> in 2d, with <img class="formulaInl" alt="$f=(x+1)(y+1)$" src="form_2280.png"/>, and with zero Dirichlet boundary values for <img class="formulaInl" alt="$u$" src="form_256.png"/>. We do so on the domain <img class="formulaInl" alt="$[-1,1]^2\backslash[-\frac 12,\frac 12]^2$" src="form_2281.png"/>, i.e. a square with a square hole in the middle.</p>
<p>The difference to <a class="el" href="step_14.html">step-14</a> is of course that we use <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite elements for the solution. The testcase is of interest because it has re-entrant corners in the corners of the hole, at which the solution has singularities. We therefore expect that the solution will be smooth in the interior of the domain, and rough in the vicinity of the singularities. The hope is that our refinement and smoothness indicators will be able to see this behavior and refine the mesh close to the singularities, while the polynomial degree is increased away from it. As we will see in the results section, this is indeed the case. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first few files have already been covered in previous examples and will thus not be further commented on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div></div><!-- fragment --><p>These are the new files we need. The first and second provide <em>hp</em> versions of the <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classFEValues.html">FEValues</a> classes as described in the introduction of this program. The last one provides Fourier transformation class on the unit cell.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_series.h&gt;</span></div></div><!-- fragment --><p>The last set of include files are standard C++ headers. We need support for complex numbers when we compute the Fourier transform.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;complex&gt;</span></div></div><!-- fragment --><p>Finally, this is as in previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step27</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Themainclass"></a> </p><h3>The main class</h3>
<p>The main class of this program looks very much like the one already used in the first few tutorial programs, for example the one in <a class="el" href="step_6.html">step-6</a>. The main difference is that we have merged the refine_grid and output_results functions into one since we will also want to output some of the quantities used in deciding how to refine the mesh (in particular the estimated smoothness of the solution). There is also a function that computes this estimated smoothness, as discussed in the introduction.</p>
<p>As far as member variables are concerned, we use the same structure as already used in <a class="el" href="step_6.html">step-6</a>, but instead of a regular <a class="el" href="classDoFHandler.html">DoFHandler</a> we use an object of type <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, and we need collections instead of individual finite element, quadrature, and face quadrature objects. We will fill these collections in the constructor of the class. The last variable, <code>max_degree</code>, indicates the maximal polynomial degree of shape functions used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceProblem ();</div><div class="line">  ~LaplaceProblem ();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> create_coarse_grid ();</div><div class="line">  <span class="keywordtype">void</span> estimate_smoothness (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;smoothness_indicators);</div><div class="line">  <span class="keywordtype">void</span> postprocess (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line">  std::pair&lt;bool,unsigned int&gt; predicate(<span class="keyword">const</span> <a class="code" href="classTableIndices.html">TableIndices&lt;dim&gt;</a> &amp;indices);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1DoFHandler.html">hp::DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line">  <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a>    fe_collection;</div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a>     quadrature_collection;</div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim-1&gt;   face_quadrature_collection;</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a> fourier_q_collection;</div><div class="line">  std::shared_ptr&lt;FESeries::Fourier&lt;dim&gt; &gt; fourier;</div><div class="line">  std::vector&lt;double&gt; ln_k;</div><div class="line">  <a class="code" href="classTable.html">Table&lt;dim,std::complex&lt;double&gt;</a> &gt; fourier_coefficients;</div><div class="line"></div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_degree;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Next, let us define the right hand side function for this problem. It is <img class="formulaInl" alt="$x+1$" src="form_2282.png"/> in 1d, <img class="formulaInl" alt="$(x+1)(y+1)$" src="form_2283.png"/> in 2d, and so on.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; () {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  / *component* /)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> product = 1;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    product *= (p[d]+1);</div><div class="line">  <span class="keywordflow">return</span> product;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Implementationofthemainclass"></a> </p><h3>Implementation of the main class</h3>
<p><a class="anchor" id="LaplaceProblemLaplaceProblem"></a> </p><h4>LaplaceProblem::LaplaceProblem</h4>
<p>The constructor of this class is fairly straightforward. It associates the <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> object with the triangulation, and then sets the maximal polynomial degree to 7 (in 1d and 2d) or 5 (in 3d and higher). We do so because using higher order polynomial degrees becomes prohibitively expensive, especially in higher space dimensions.</p>
<p>Following this, we fill the collections of finite element, and cell and face quadrature objects. We start with quadratic elements, and each quadrature formula is chosen so that it is appropriate for the matching finite element in the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> object.</p>
<p>Finally, we initialize <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> object which will be used to calculate coefficient in Fourier series as described in the introduction. In addition to the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>, we need to provide quadrature rules <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> for integration on the reference cell.</p>
<p>In order to resize fourier_coefficients <a class="el" href="classTable.html">Table</a>, we use the following auxiliary function</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim,<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keywordtype">void</span> resize(<a class="code" href="classTable.html">Table&lt;dim,T&gt;</a> &amp;coeff, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N)</div><div class="line">{</div><div class="line">  <a class="code" href="classTableIndices.html">TableIndices&lt;dim&gt;</a> size;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>++)</div><div class="line">    size[d] = N;</div><div class="line">  coeff.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a>(size);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem ()</div><div class="line">  :</div><div class="line">  dof_handler (triangulation),</div><div class="line">  max_degree (dim &lt;= 2 ? 7 : 5)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree=2; degree&lt;=max_degree; ++degree)</div><div class="line">    {</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(degree));</div><div class="line">      quadrature_collection.push_back (<a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree+1));</div><div class="line">      face_quadrature_collection.push_back (<a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(degree+1));</div><div class="line">    }</div></div><!-- fragment --><p>As described in the introduction, we define the Fourier vectors <img class="formulaInl" alt="${\bf k}$" src="form_2267.png"/> for which we want to compute Fourier coefficients of the solution on each cell as follows. In 2d, we will need coefficients corresponding to vectors <img class="formulaInl" alt="${\bf k}=(2 \pi i, 2\pi j)^T$" src="form_2284.png"/> for which <img class="formulaInl" alt="$\sqrt{i^2+j^2}\le N$" src="form_2285.png"/>, with <img class="formulaInl" alt="$i,j$" src="form_2286.png"/> integers and <img class="formulaInl" alt="$N$" src="form_104.png"/> being the maximal polynomial degree we use for the finite elements in this program. The <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> class' constructor first parameter <img class="formulaInl" alt="$N$" src="form_104.png"/> defines the number of coefficients in 1D with the total number of coefficients being <img class="formulaInl" alt="$N^{dim}$" src="form_2287.png"/>. Although we will not use coefficients corresponding to <img class="formulaInl" alt="$\sqrt{i^2+j^2}&gt; N$" src="form_2288.png"/> and <img class="formulaInl" alt="$i+j==0$" src="form_2289.png"/>, the overhead of their calculation is minimal. The transformation matrices for each <a class="el" href="classFiniteElement.html">FiniteElement</a> will be calculated only once the first time they are required in the course of hp-adaptive refinement. Because we work on the unit cell, we can do all this work without a mapping from reference to real cell and consequently can precalculate these matrices. The calculation of expansion coefficients for a particular set of local degrees of freedom on a given cell then follows as a simple matrix-vector product. The 3d case is handled analogously.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = max_degree;</div></div><!-- fragment --><p>We will need to assemble the matrices that do the Fourier transforms for each of the finite elements we deal with, i.e. the matrices <img class="formulaInl" alt="${\cal F}_{{\bf k},j}$" src="form_2290.png"/> defined in the introduction. We have to do that for each of the finite elements in use. To that end we need a quadrature rule. In this example we use the same quadrature formula for each finite element, namely that is obtained by iterating a 2-point Gauss formula as many times as the maximal exponent we use for the term <img class="formulaInl" alt="$e^{i{\bf k}\cdot{\bf x}}$" src="form_2291.png"/>:</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>            base_quadrature (2);</div><div class="line"><a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a>       quadrature (base_quadrature, N);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#ae4ebc4545cd7d9f0fa7ff5c1c6fae51f">size</a>(); i++)</div><div class="line">  fourier_q_collection.push_back(quadrature);</div></div><!-- fragment --><p>Now we are ready to set-up the <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> object</p>
<div class="fragment"><div class="line">fourier = std::make_shared&lt;FESeries::Fourier&lt;dim&gt; &gt;(N,</div><div class="line">                                                    fe_collection,</div><div class="line">                                                    fourier_q_collection);</div></div><!-- fragment --><p>We need to resize the matrix of fourier coefficients according to the number of modes N.</p>
<div class="fragment"><div class="line">  resize(fourier_coefficients,N);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemLaplaceProblem"></a> </p><h4>LaplaceProblem::~LaplaceProblem</h4>
<p>The destructor is unchanged from what we already did in <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::~LaplaceProblem ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>This function is again a verbatim copy of what we already did in <a class="el" href="step_6.html">step-6</a>. Despite function calls with exactly the same names and arguments, the algorithms used internally are different in some aspect since the dof_handler variable here is an hp object.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe_collection);</div><div class="line"></div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ();</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                           constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                            constraints);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                              dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4>LaplaceProblem::assemble_system</h4>
<p>This is the function that assembles the global matrix and right hand side vector from the local contributions of each cell. Its main working is as has been described in many of the tutorial programs before. The significant deviations are the ones necessary for <em>hp</em> finite element methods. In particular, that we need to use a collection of <a class="el" href="classFEValues.html">FEValues</a> object (implemented through the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> class), and that we have to eliminate constrained degrees of freedom already when copying local contributions into global objects. Both of these are explained in detail in the introduction of this program.</p>
<p>One other slight complication is the fact that because we use different polynomial degrees on different cells, the matrices and vectors holding local contributions do not have the same size on all cells. At the beginning of the loop over all cells, we therefore each time have to resize them to the correct size (given by <code>dofs_per_cell</code>). Because these classes are implement in such a way that reducing the size of a matrix or vector does not release the currently allocated memory (unless the new size is zero), the process of resizing at the beginning of the loop will only require re-allocation of memory during the first few iterations. Once we have found in a cell with the maximal finite element degree, no more re-allocations will happen because all subsequent <code>reinit</code> calls will only set the size to something that fits the currently allocated memory. This is important since allocating memory is expensive, and doing so every time we visit a new cell would take significant compute time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values (fe_collection,</div><div class="line">                                  quadrature_collection,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> RightHandSide&lt;dim&gt; rhs_function;</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aa57fdeca62a0708d77768a3bb2aeb826">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs;</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell;</div><div class="line"></div><div class="line">      cell_matrix.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (dofs_per_cell, dofs_per_cell);</div><div class="line">      cell_matrix = 0;</div><div class="line"></div><div class="line">      cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dofs_per_cell);</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      hp_fe_values.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a4bc26790261f1f9f4cc7e8e69e3d7920">get_present_fe_values</a> ();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt;  rhs_values (fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">      rhs_function.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               rhs_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0;</div><div class="line">           q_point&lt;fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line">           ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              cell_matrix(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                            rhs_values[q_point] *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">          }</div><div class="line"></div><div class="line">      local_dof_indices.resize (dofs_per_cell);</div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a> (cell_matrix, cell_rhs,</div><div class="line">                                              local_dof_indices,</div><div class="line">                                              system_matrix, system_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>The function solving the linear system is entirely unchanged from previous examples. We simply try to reduce the initial residual (which equals the <img class="formulaInl" alt="$l_2$" src="form_111.png"/> norm of the right hand side) by a certain factor:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (system_rhs.size(),</div><div class="line">                                          1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8*system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  cg.solve (system_matrix, solution, system_rhs,</div><div class="line">            preconditioner);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblempostprocess"></a> </p><h4>LaplaceProblem::postprocess</h4>
<p>After solving the linear system, we will want to postprocess the solution. Here, all we do is to estimate the error, estimate the local smoothness of the solution as described in the introduction, then write graphical output, and finally refine the mesh in both <img class="formulaInl" alt="$h$" src="form_720.png"/> and <img class="formulaInl" alt="$p$" src="form_202.png"/> according to the indicators computed before. We do all this in the same function because we want the estimated error and smoothness indicators not only for refinement, but also include them in the graphical output.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::postprocess (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div></div><!-- fragment --><p>Let us start with computing estimated error and smoothness indicators, which each are one number for each active cell of our triangulation. For the error indicator, we use the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class as always. Estimating the smoothness is done in the respective function of this class; that function is discussed further down below:</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                    face_quadrature_collection,</div><div class="line">                                    <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                    solution,</div><div class="line">                                    estimated_error_per_cell);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> smoothness_indicators (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">estimate_smoothness (smoothness_indicators);</div></div><!-- fragment --><p>Next we want to generate graphical output. In addition to the two estimated quantities derived above, we would also like to output the polynomial degree of the finite elements used on each of the elements on the mesh.</p>
<p>The way to do that requires that we loop over all cells and poll the active finite element index of them using <code>cell-&gt;active_fe_index()</code>. We then use the result of this operation and query the finite element collection for the finite element with that index, and finally determine the polynomial degree of that element. The result we put into a vector with one element per cell. The <a class="el" href="classDataOut.html">DataOut</a> class requires this to be a vector of <code>float</code> or <code>double</code>, even though our values are all integers, so that it what we use:</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> fe_degrees (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      fe_degrees(cell-&gt;active_cell_index())</div><div class="line">        = fe_collection[cell-&gt;active_fe_index()].degree;</div><div class="line">  }</div></div><!-- fragment --><p>With now all data vectors available &ndash; solution, estimated errors and smoothness indicators, and finite element degrees &ndash;, we create a <a class="el" href="classDataOut.html">DataOut</a> object for graphical output and attach all data. Note that the <a class="el" href="classDataOut.html">DataOut</a> class has a second template argument (which defaults to <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;, which is why we have never seen it in previous tutorial programs) that indicates the type of DoF handler to be used. Here, we have to use the <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> class:</p>
<div class="fragment"><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim,hp::DoFHandler&lt;dim&gt;</a> &gt; data_out;</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (estimated_error_per_cell, <span class="stringliteral">&quot;error&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (smoothness_indicators, <span class="stringliteral">&quot;smoothness&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (fe_degrees, <span class="stringliteral">&quot;fe_degree&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div></div><!-- fragment --><p>The final step in generating output is to determine a file name, open the file, and write the data into it (here, we use VTK format):</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 2) +</div><div class="line">                               <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">  std::ofstream output (filename.c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output);</div><div class="line">}</div></div><!-- fragment --><p>After this, we would like to actually refine the mesh, in both <img class="formulaInl" alt="$h$" src="form_720.png"/> and <img class="formulaInl" alt="$p$" src="form_202.png"/>. The way we are going to do this is as follows: first, we use the estimated error to flag those cells for refinement that have the largest error. This is what we have always done:</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                   estimated_error_per_cell,</div><div class="line">                                                   0.3, 0.03);</div></div><!-- fragment --><p>Next we would like to figure out which of the cells that have been flagged for refinement should actually have <img class="formulaInl" alt="$p$" src="form_202.png"/> increased instead of <img class="formulaInl" alt="$h$" src="form_720.png"/> decreased. The strategy we choose here is that we look at the smoothness indicators of those cells that are flagged for refinement, and increase <img class="formulaInl" alt="$p$" src="form_202.png"/> for those with a smoothness larger than a certain threshold. For this, we first have to determine the maximal and minimal values of the smoothness indicators of all flagged cells, which we do using a loop over all cells and comparing current minimal and maximal values. (We start with the minimal and maximal values of <em>all</em> cells, a range within which the minimal and maximal values on cells flagged for refinement must surely lie.) Absent any better strategies, we will then set the threshold above which will increase <img class="formulaInl" alt="$p$" src="form_202.png"/> instead of reducing <img class="formulaInl" alt="$h$" src="form_720.png"/> as the mean value between minimal and maximal smoothness indicators on cells flagged for refinement:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> max_smoothness = *std::min_element (smoothness_indicators.begin(),</div><div class="line">                                          smoothness_indicators.end()),</div><div class="line">                       min_smoothness = *std::max_element (smoothness_indicators.begin(),</div><div class="line">                                                           smoothness_indicators.end());</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;refine_flag_set())</div><div class="line">      {</div><div class="line">        max_smoothness = std::max (max_smoothness,</div><div class="line">                                   smoothness_indicators(cell-&gt;active_cell_index()));</div><div class="line">        min_smoothness = std::min (min_smoothness,</div><div class="line">                                   smoothness_indicators(cell-&gt;active_cell_index()));</div><div class="line">      }</div><div class="line">}</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> threshold_smoothness = (max_smoothness + min_smoothness) / 2;</div></div><!-- fragment --><p>With this, we can go back, loop over all cells again, and for those cells for which (i) the refinement flag is set, (ii) the smoothness indicator is larger than the threshold, and (iii) we still have a finite element with a polynomial degree higher than the current one in the finite element collection, we then increase the polynomial degree and in return remove the flag indicating that the cell should undergo bisection. For all other cells, the refinement flags remain untouched:</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;refine_flag_set()</div><div class="line">        &amp;&amp;</div><div class="line">        (smoothness_indicators(cell-&gt;active_cell_index()) &gt; threshold_smoothness)</div><div class="line">        &amp;&amp;</div><div class="line">        (cell-&gt;active_fe_index()+1 &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#ae4ebc4545cd7d9f0fa7ff5c1c6fae51f">size</a>()))</div><div class="line">      {</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line">        cell-&gt;set_active_fe_index (cell-&gt;active_fe_index() + 1);</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p>At the end of this procedure, we then refine the mesh. During this process, children of cells undergoing bisection inherit their mother cell's finite element index:</p>
<div class="fragment"><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemcreate_coarse_grid"></a> </p><h4>LaplaceProblem::create_coarse_grid</h4>
<p>The following function is used when creating the initial grid. It is a specialization for the 2d case, i.e. a corresponding function needs to be implemented if the program is run in anything other then 2d. The function is actually stolen from <a class="el" href="step_14.html">step-14</a> and generates the same mesh used already there, i.e. the square domain with the square hole in the middle. The meaning of the different parts of this function are explained in the documentation of <a class="el" href="step_14.html">step-14</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;2&gt;::create_coarse_grid ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> vertices_1[]</div><div class="line">    = {  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   -1.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, -1.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (0.,    -1.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, -1.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    -1.),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   -1./2.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, -1./2.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (0.,    -1./2.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, -1./2.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    -1./2.),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, 0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, 0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    0.),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   1./2.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, 1./2.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (0.,    1./2.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, 1./2.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    1./2.),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   1.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, 1.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (0.,    1.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, 1.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    1.)</div><div class="line">      };</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">  n_vertices = <span class="keyword">sizeof</span>(vertices_1) / <span class="keyword">sizeof</span>(vertices_1[0]);</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; vertices (&amp;vertices_1[0],</div><div class="line">                                           &amp;vertices_1[n_vertices]);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> cell_vertices[][<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::vertices_per_cell</a>]</div><div class="line">  = {{0, 1, 5, 6},</div><div class="line">    {1, 2, 6, 7},</div><div class="line">    {2, 3, 7, 8},</div><div class="line">    {3, 4, 8, 9},</div><div class="line">    {5, 6, 10, 11},</div><div class="line">    {8, 9, 12, 13},</div><div class="line">    {10, 11, 14, 15},</div><div class="line">    {12, 13, 17, 18},</div><div class="line">    {14, 15, 19, 20},</div><div class="line">    {15, 16, 20, 21},</div><div class="line">    {16, 17, 21, 22},</div><div class="line">    {17, 18, 22, 23}</div><div class="line">  };</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">  n_cells = <span class="keyword">sizeof</span>(cell_vertices) / <span class="keyword">sizeof</span>(cell_vertices[0]);</div><div class="line"></div><div class="line">  std::vector&lt;CellData&lt;dim&gt; &gt; cells (n_cells, <a class="code" href="structCellData.html">CellData&lt;dim&gt;</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_cells; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;</div><div class="line">           j&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell;</div><div class="line">           ++j)</div><div class="line">        cells[i].vertices[j] = cell_vertices[i][j];</div><div class="line">      cells[i].material_id = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab926104144af9f9f5ca8c0798308c68c">create_triangulation</a> (vertices,</div><div class="line">                                      cells,</div><div class="line">                                      <a class="code" href="structSubCellData.html">SubCellData</a>());</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>This function implements the logic of the program, as did the respective function in most of the previous programs already, see for example <a class="el" href="step_6.html">step-6</a>.</p>
<p>Basically, it contains the adaptive loop: in the first iteration create a coarse grid, and then set up the linear system, assemble it, solve, and postprocess the solution including mesh refinement. Then start over again. In the meantime, also output some information for those staring at the screen trying to figure out what the program does:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        create_coarse_grid ();</div><div class="line"></div><div class="line">      setup_system ();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">                &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;   Number of constraints       : &quot;</span></div><div class="line">                &lt;&lt; constraints.<a class="code" href="classConstraintMatrix.html#a319c347182a3494ee5b3fa6a1bf695ef">n_constraints</a>()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_system ();</div><div class="line">      solve ();</div><div class="line">      postprocess (cycle);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemestimate_smoothness"></a> </p><h4>LaplaceProblem::estimate_smoothness</h4>
<p>As described in the introduction, we will need to take the maximum absolute value of fourier coefficients which correspond to <img class="formulaInl" alt="$k$" src="form_44.png"/>-vector <img class="formulaInl" alt="$|{\bf k}|= const$" src="form_2292.png"/>. To filter the coefficients <a class="el" href="classTable.html">Table</a> we will use the <a class="el" href="namespaceFESeries.html#ae6f7cb5757382930fa06b48f236f447d">FESeries::process_coefficients()</a> which requires a predicate to be specified. The predicate should operate on <a class="el" href="classTableIndices.html">TableIndices</a> and return a pair of <code>bool</code> and <code>unsigned int</code>. The latter is the value of the map from TableIndicies to unsigned int. It is used to define subsets of coefficients from which we search for the one with highest absolute value, i.e. <img class="formulaInl" alt="$l^\infty$" src="form_2293.png"/>-norm. The <code>bool</code> parameter defines which indices should be used in processing. In the current case we are interested in coefficients which correspond to <img class="formulaInl" alt="$0 &lt; i*i+j*j &lt; N*N$" src="form_2294.png"/> and <img class="formulaInl" alt="$0 &lt; i*i+j*j+k*k &lt; N*N$" src="form_2295.png"/> in 2D and 3D, respectively.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;bool,unsigned int&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::</div><div class="line">predicate(<span class="keyword">const</span> <a class="code" href="classTableIndices.html">TableIndices&lt;dim&gt;</a> &amp;ind)</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt;dim; i++)</div><div class="line">    v += ind[i]*ind[i];</div><div class="line">  <span class="keywordflow">if</span> (v&gt;0 &amp;&amp; v &lt; max_degree*max_degree)</div><div class="line">    <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>,v);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> std::make_pair(<span class="keyword">false</span>,v);</div><div class="line">}</div></div><!-- fragment --><p>This last function of significance implements the algorithm to estimate the smoothness exponent using the algorithms explained in detail in the introduction. We will therefore only comment on those points that are of implementational importance.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LaplaceProblem&lt;dim&gt;::</div><div class="line">estimate_smoothness (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;smoothness_indicators)</div><div class="line">{</div></div><!-- fragment --><p>Since most of the hard work is done for us in <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> and we set up the object of this class in the constructor, what we are left to do here is apply this class to calculate coefficients and then perform linear regression to fit their decay slope.</p>
<p>First thing to do is to loop over all cells and do our work there, i.e. to locally do the Fourier transform and estimate the decay coefficient. We will use the following array as a scratch array in the loop to store local DoF values:</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>                     local_dof_values;</div></div><!-- fragment --><p>Then here is the loop:</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div></div><!-- fragment --><p>Inside the loop, we first need to get the values of the local degrees of freedom (which we put into the <code>local_dof_values</code> array after setting it to the right size) and then need to compute the Fourier transform by multiplying this vector with the matrix <img class="formulaInl" alt="${\cal F}$" src="form_2296.png"/> corresponding to this finite element. This is done by calling <a class="el" href="classFESeries_1_1Fourier.html#ab00848b6c873c0e58e33e84c04a4d84b">FESeries::Fourier::calculate()</a>, that has to be provided with the <code>local_dof_values</code>, <code>cell-&gt;active_fe_index()</code> and a <a class="el" href="classTable.html">Table</a> to store coefficients.</p>
<div class="fragment"><div class="line">local_dof_values.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell);</div><div class="line">cell-&gt;get_dof_values (solution, local_dof_values);</div><div class="line"></div><div class="line">fourier-&gt;calculate(local_dof_values,</div><div class="line">                   cell-&gt;active_fe_index(),</div><div class="line">                   fourier_coefficients);</div></div><!-- fragment --><p>The next thing, as explained in the introduction, is that we wanted to only fit our exponential decay of Fourier coefficients to the largest coefficients for each possible value of <img class="formulaInl" alt="$|{\bf k}|$" src="form_2237.png"/>. To this end, we use <a class="el" href="namespaceFESeries.html#ae6f7cb5757382930fa06b48f236f447d">FESeries::process_coefficients()</a> to rework coefficients into the desired format. We'll only take those Fourier coefficients with the largest magnitude for a given value of <img class="formulaInl" alt="$|{\bf k}|$" src="form_2237.png"/> and thereby need to use <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>:</p>
<div class="fragment"><div class="line">std::pair&lt;std::vector&lt;unsigned int&gt;, std::vector&lt;double&gt; &gt; res =</div><div class="line">  FESeries::process_coefficients&lt;dim&gt;(fourier_coefficients,</div><div class="line">                                      std::bind(&amp;LaplaceProblem&lt;dim&gt;::predicate,</div><div class="line">                                                <span class="keyword">this</span>,</div><div class="line">                                                std::placeholders::_1),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (res.first.size() == res.second.size(),</div><div class="line">        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>The first vector in the <code>std::pair</code> will store values of the predicate, that is <img class="formulaInl" alt="$i*i+j*j= const$" src="form_2297.png"/> or <img class="formulaInl" alt="$i*i+j*j+k*k = const$" src="form_2298.png"/> in 2D or 3D respectively. This vector will be the same for all the cells so we can calculate logarithms of the corresponding Fourier vectors <img class="formulaInl" alt="$|{\bf k}|$" src="form_2237.png"/> only once in the whole hp-refinement cycle:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (ln_k.size() == 0)</div><div class="line">  {</div><div class="line">    ln_k.resize(res.first.size(),0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; ln_k.size(); f++)</div><div class="line">      ln_k[f] = std::log (2.0*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*std::sqrt(1.*res.first[f]));</div><div class="line">  }</div></div><!-- fragment --><p>We have to calculate the logarithms of absolute values of coefficients and use it in linear regression fit to obtain <img class="formulaInl" alt="$\mu$" src="form_1643.png"/>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; res.second.size(); f++)</div><div class="line">  res.second[f] = std::log(res.second[f]);</div><div class="line"></div><div class="line">std::pair&lt;double,double&gt; fit = <a class="code" href="namespaceFESeries.html#afa42058db3555536415fae91822d27e3">FESeries::linear_regression</a>(ln_k,res.second);</div></div><!-- fragment --><p>The final step is to compute the Sobolev index <img class="formulaInl" alt="$s=\mu-\frac d2$" src="form_2265.png"/> and store it in the vector of estimated values for each cell:</p>
<div class="fragment"><div class="line">        smoothness_indicators(cell-&gt;active_cell_index()) = -fit.first - 1.*dim/2;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>The main function is again verbatim what we had before: wrap creating and running an object of the main class into a <code>try</code> block and catch whatever exceptions are thrown, thereby producing meaningful output if anything should go wrong:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step27;</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem;</div><div class="line">      laplace_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>In this section, we discuss a few results produced from running the current tutorial program. More results, in particular the extension to 3d calculations and determining how much compute time the individual components of the program take, are given in the <a class="el" href="DEALGlossary.html#hp_paper">hp_paper</a> .</p>
<p>When run, this is what the program produces:</p>
<div class="fragment"><div class="line">examples/step-27&gt; make <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a></div><div class="line">============================ Running step-27</div><div class="line">Cycle 0:</div><div class="line">   Number of active cells:       768</div><div class="line">   Number of degrees of freedom: 3264</div><div class="line">   Number of constraints       : 384</div><div class="line">Cycle 1:</div><div class="line">   Number of active cells:       966</div><div class="line">   Number of degrees of freedom: 5245</div><div class="line">   Number of constraints       : 936</div><div class="line">Cycle 2:</div><div class="line">   Number of active cells:       1143</div><div class="line">   Number of degrees of freedom: 8441</div><div class="line">   Number of constraints       : 1929</div><div class="line">Cycle 3:</div><div class="line">   Number of active cells:       1356</div><div class="line">   Number of degrees of freedom: 12349</div><div class="line">   Number of constraints       : 3046</div><div class="line">Cycle 4:</div><div class="line">   Number of active cells:       1644</div><div class="line">   Number of degrees of freedom: 18178</div><div class="line">   Number of constraints       : 4713</div><div class="line">Cycle 5:</div><div class="line">   Number of active cells:       1728</div><div class="line">   Number of degrees of freedom: 22591</div><div class="line">   Number of constraints       : 6095</div></div><!-- fragment --><p>The first thing we learn from this is that the number of constrained degrees of freedom is on the order of 20-25% of the total number of degrees of freedom, at least on the later grids when we have elements of relatively high order (in 3d, the fraction of constrained degrees of freedom can be up to 30%). This is, in fact, on the same order of magnitude as for non- <img class="formulaInl" alt="$hp$" src="form_49.png"/> discretizations. For example, in the last step of the <a class="el" href="step_6.html">step-6</a> program, we have 18401 degrees of freedom, 4104 of which are constrained. The difference is that in the latter program, each constrained hanging node is constrained against only the two adjacent degrees of freedom, whereas in the <img class="formulaInl" alt="$hp$" src="form_49.png"/> case, constrained nodes are constrained against many more degrees of freedom. Note also that the current program also includes nodes subject to Dirichlet boundary conditions in the list of constraints. In cycle 0, all the constraints are actually because of boundary conditions.</p>
<p>Of maybe more interest is to look at the graphical output. First, here is the solution of the problem:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.solution.png"/>
</div>
<p>Secondly, let us look at the sequence of meshes generated:</p>
<table width="60%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.mesh-0.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.mesh-1.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.mesh-2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.mesh-3.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.mesh-4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.mesh-5.png"/>
</div>
  </td></tr>
</table>
<p>It is clearly visible how the mesh is refined near the corner singularities, as one would expect it. More interestingly, we should be curious to see the distribution of finite element polynomial degrees to these mesh cells:</p>
<table width="60%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-0.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-1.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-2.png"/>
</div>
 <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-3.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.fe_degree-5.png"/>
</div>
  </td></tr>
</table>
<p>While this is certainly not a perfect arrangement, it does make some sense: we use low order elements close to boundaries and corners where regularity is low. On the other hand, higher order elements are used where (i) the error was at one point fairly large, i.e. mainly in the general area around the corner singularities and in the top right corner where the solution is large, and (ii) where the solution is smooth, i.e. far away from the boundary.</p>
<p>This arrangement of polynomial degrees of course follows from our smoothness estimator. Here is the estimated smoothness of the solution, with blue colors indicating least smoothness and red indicating the smoothest areas:</p>
<table width="60%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-0.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-1.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-2.png"/>
</div>
 <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-3.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-27.smoothness-5.png"/>
</div>
  </td></tr>
</table>
<p>The first conclusion one can draw from these images is that apparently the estimated smoothness is a fairly stable quantity under mesh refinement: what we get on the coarsest mesh is pretty close to what we get on the finest mesh. It is also obvious that the smoothness estimates are independent of the actual size of the solution (see the picture of the solution above), as it should be. A point of larger concern, however, is that one realizes on closer inspection that the estimator we have overestimates the smoothness of the solution on cells with hanging nodes. This in turn leads to higher polynomial degrees in these areas, skewing the allocation of finite elements onto cells.</p>
<p>We have no good explanation for this effect at the moment. One theory is that the numerical solution on cells with hanging nodes is, of course, constrained and therefore not entirely free to explore the function space to get close to the exact solution. This lack of degrees of freedom may manifest itself by yielding numerical solutions on these cells with suppressed oscillation, meaning a higher degree of smoothness. The estimator picks this signal up and the estimated smoothness overestimates the actual value. However, a definite answer to what is going on currently eludes the authors of this program.</p>
<p>The bigger question is, of course, how to avoid this problem. Possibilities include estimating the smoothness not on single cells, but cell assemblies or patches surrounding each cell. It may also be possible to find simple correction factors for each cell depending on the number of constrained degrees of freedom it has. In either case, there are ample opportunities for further research on finding good <img class="formulaInl" alt="$hp$" src="form_49.png"/> refinement criteria. On the other hand, the main point of the current program was to demonstrate using the <img class="formulaInl" alt="$hp$" src="form_49.png"/> technology in deal.II, which is unaffected by our use of a possible sub-optimal refinement criterion. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, Texas A&amp;M University, 2006, 2007;</span></div><div class="line"><span class="comment"> *          Denis Davydov, University of Erlangen-Nuremberg, 2016.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_series.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;complex&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step27</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem ();</div><div class="line">    ~LaplaceProblem ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> create_coarse_grid ();</div><div class="line">    <span class="keywordtype">void</span> estimate_smoothness (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;smoothness_indicators);</div><div class="line">    <span class="keywordtype">void</span> postprocess (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line">    std::pair&lt;bool,unsigned int&gt; predicate(<span class="keyword">const</span> <a class="code" href="classTableIndices.html">TableIndices&lt;dim&gt;</a> &amp;indices);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1DoFHandler.html">hp::DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line">    <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a>    fe_collection;</div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a>     quadrature_collection;</div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim-1&gt;   face_quadrature_collection;</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a> fourier_q_collection;</div><div class="line">    std::shared_ptr&lt;FESeries::Fourier&lt;dim&gt; &gt; fourier;</div><div class="line">    std::vector&lt;double&gt; ln_k;</div><div class="line">    <a class="code" href="classTable.html">Table&lt;dim,std::complex&lt;double&gt;</a> &gt; fourier_coefficients;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_degree;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; () {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span> product = 1;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      product *= (p[d]+1);</div><div class="line">    <span class="keywordflow">return</span> product;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim,<span class="keyword">typename</span> T&gt;</div><div class="line">  <span class="keywordtype">void</span> resize(<a class="code" href="classTable.html">Table&lt;dim,T&gt;</a> &amp;coeff, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTableIndices.html">TableIndices&lt;dim&gt;</a> size;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>++)</div><div class="line">      size[d] = N;</div><div class="line">    coeff.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a>(size);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem ()</div><div class="line">    :</div><div class="line">    dof_handler (triangulation),</div><div class="line">    max_degree (dim &lt;= 2 ? 7 : 5)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree=2; degree&lt;=max_degree; ++degree)</div><div class="line">      {</div><div class="line">        fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(degree));</div><div class="line">        quadrature_collection.push_back (<a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree+1));</div><div class="line">        face_quadrature_collection.push_back (<a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(degree+1));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = max_degree;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>            base_quadrature (2);</div><div class="line">    <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a>       quadrature (base_quadrature, N);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#ae4ebc4545cd7d9f0fa7ff5c1c6fae51f">size</a>(); i++)</div><div class="line">      fourier_q_collection.push_back(quadrature);</div><div class="line"></div><div class="line">    fourier = std::make_shared&lt;FESeries::Fourier&lt;dim&gt; &gt;(N,</div><div class="line">                                                        fe_collection,</div><div class="line">                                                        fourier_q_collection);</div><div class="line"></div><div class="line">    resize(fourier_coefficients,N);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::~LaplaceProblem ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe_collection);</div><div class="line"></div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a> ();</div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                             constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              0,</div><div class="line">                                              <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                              constraints);</div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values (fe_collection,</div><div class="line">                                    quadrature_collection,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt; rhs_function;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs;</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell;</div><div class="line"></div><div class="line">        cell_matrix.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (dofs_per_cell, dofs_per_cell);</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dofs_per_cell);</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        hp_fe_values.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a4bc26790261f1f9f4cc7e8e69e3d7920">get_present_fe_values</a> ();</div><div class="line"></div><div class="line">        std::vector&lt;double&gt;  rhs_values (fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line">        rhs_function.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                 rhs_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0;</div><div class="line">             q_point&lt;fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line">             ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                cell_matrix(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                              rhs_values[q_point] *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">            }</div><div class="line"></div><div class="line">        local_dof_indices.resize (dofs_per_cell);</div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a> (cell_matrix, cell_rhs,</div><div class="line">                                                local_dof_indices,</div><div class="line">                                                system_matrix, system_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (system_rhs.size(),</div><div class="line">                                            1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8*system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    cg.solve (system_matrix, solution, system_rhs,</div><div class="line">              preconditioner);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::postprocess (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                        face_quadrature_collection,</div><div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                        solution,</div><div class="line">                                        estimated_error_per_cell);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> smoothness_indicators (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    estimate_smoothness (smoothness_indicators);</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> fe_degrees (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">        cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">        endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">        <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">          fe_degrees(cell-&gt;active_cell_index())</div><div class="line">            = fe_collection[cell-&gt;active_fe_index()].degree;</div><div class="line">      }</div><div class="line"></div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim,hp::DoFHandler&lt;dim&gt;</a> &gt; data_out;</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (estimated_error_per_cell, <span class="stringliteral">&quot;error&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (smoothness_indicators, <span class="stringliteral">&quot;smoothness&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (fe_degrees, <span class="stringliteral">&quot;fe_degree&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                   <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 2) +</div><div class="line">                                   <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">      std::ofstream output (filename.c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                       estimated_error_per_cell,</div><div class="line">                                                       0.3, 0.03);</div><div class="line"></div><div class="line">      <span class="keywordtype">float</span> max_smoothness = *std::min_element (smoothness_indicators.<a class="code" href="classVector.html#af34b888fe493ef2ed188179de69ad7ed">begin</a>(),</div><div class="line">                                                smoothness_indicators.<a class="code" href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">end</a>()),</div><div class="line">                             min_smoothness = *std::max_element (smoothness_indicators.<a class="code" href="classVector.html#af34b888fe493ef2ed188179de69ad7ed">begin</a>(),</div><div class="line">                                                                 smoothness_indicators.<a class="code" href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">end</a>());</div><div class="line">      {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">        cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">        endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">        <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;refine_flag_set())</div><div class="line">            {</div><div class="line">              max_smoothness = std::max (max_smoothness,</div><div class="line">                                         smoothness_indicators(cell-&gt;active_cell_index()));</div><div class="line">              min_smoothness = std::min (min_smoothness,</div><div class="line">                                         smoothness_indicators(cell-&gt;active_cell_index()));</div><div class="line">            }</div><div class="line">      }</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">float</span> threshold_smoothness = (max_smoothness + min_smoothness) / 2;</div><div class="line"></div><div class="line">      {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">        cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">        endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">        <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;refine_flag_set()</div><div class="line">              &amp;&amp;</div><div class="line">              (smoothness_indicators(cell-&gt;active_cell_index()) &gt; threshold_smoothness)</div><div class="line">              &amp;&amp;</div><div class="line">              (cell-&gt;active_fe_index()+1 &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#ae4ebc4545cd7d9f0fa7ff5c1c6fae51f">size</a>()))</div><div class="line">            {</div><div class="line">              cell-&gt;clear_refine_flag();</div><div class="line">              cell-&gt;set_active_fe_index (cell-&gt;active_fe_index() + 1);</div><div class="line">            }</div><div class="line">      }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;2&gt;::create_coarse_grid ()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> vertices_1[]</div><div class="line">      = {  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   -1.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, -1.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (0.,    -1.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, -1.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    -1.),</div><div class="line"></div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   -1./2.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, -1./2.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (0.,    -1./2.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, -1./2.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    -1./2.),</div><div class="line"></div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   0.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, 0.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, 0.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    0.),</div><div class="line"></div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   1./2.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, 1./2.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (0.,    1./2.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, 1./2.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    1./2.),</div><div class="line"></div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.,   1.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1./2, 1.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (0.,    1.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1./2, 1.),</div><div class="line">           <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (+1,    1.)</div><div class="line">        };</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    n_vertices = <span class="keyword">sizeof</span>(vertices_1) / <span class="keyword">sizeof</span>(vertices_1[0]);</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; vertices (&amp;vertices_1[0],</div><div class="line">                                             &amp;vertices_1[n_vertices]);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> cell_vertices[][<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::vertices_per_cell</a>]</div><div class="line">    = {{0, 1, 5, 6},</div><div class="line">      {1, 2, 6, 7},</div><div class="line">      {2, 3, 7, 8},</div><div class="line">      {3, 4, 8, 9},</div><div class="line">      {5, 6, 10, 11},</div><div class="line">      {8, 9, 12, 13},</div><div class="line">      {10, 11, 14, 15},</div><div class="line">      {12, 13, 17, 18},</div><div class="line">      {14, 15, 19, 20},</div><div class="line">      {15, 16, 20, 21},</div><div class="line">      {16, 17, 21, 22},</div><div class="line">      {17, 18, 22, 23}</div><div class="line">    };</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    n_cells = <span class="keyword">sizeof</span>(cell_vertices) / <span class="keyword">sizeof</span>(cell_vertices[0]);</div><div class="line"></div><div class="line">    std::vector&lt;CellData&lt;dim&gt; &gt; cells (n_cells, <a class="code" href="structCellData.html">CellData&lt;dim&gt;</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_cells; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;</div><div class="line">             j&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell;</div><div class="line">             ++j)</div><div class="line">          cells[i].vertices[j] = cell_vertices[i][j];</div><div class="line">        cells[i].material_id = 0;</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab926104144af9f9f5ca8c0798308c68c">create_triangulation</a> (vertices,</div><div class="line">                                        cells,</div><div class="line">                                        <a class="code" href="structSubCellData.html">SubCellData</a>());</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          create_coarse_grid ();</div><div class="line"></div><div class="line">        setup_system ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">                  &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;   Number of constraints       : &quot;</span></div><div class="line">                  &lt;&lt; constraints.<a class="code" href="classConstraintMatrix.html#a319c347182a3494ee5b3fa6a1bf695ef">n_constraints</a>()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line">        solve ();</div><div class="line">        postprocess (cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;bool,unsigned int&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::</div><div class="line">  predicate(<span class="keyword">const</span> <a class="code" href="classTableIndices.html">TableIndices&lt;dim&gt;</a> &amp;ind)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt;dim; i++)</div><div class="line">      v += ind[i]*ind[i];</div><div class="line">    <span class="keywordflow">if</span> (v&gt;0 &amp;&amp; v &lt; max_degree*max_degree)</div><div class="line">      <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>,v);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> std::make_pair(<span class="keyword">false</span>,v);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  LaplaceProblem&lt;dim&gt;::</div><div class="line">  estimate_smoothness (<a class="code" href="classVector.html">Vector&lt;float&gt;</a> &amp;smoothness_indicators)</div><div class="line">  {</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                     local_dof_values;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        local_dof_values.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell);</div><div class="line">        cell-&gt;get_dof_values (solution, local_dof_values);</div><div class="line"></div><div class="line">        fourier-&gt;calculate(local_dof_values,</div><div class="line">                           cell-&gt;active_fe_index(),</div><div class="line">                           fourier_coefficients);</div><div class="line"></div><div class="line">        std::pair&lt;std::vector&lt;unsigned int&gt;, std::vector&lt;double&gt; &gt; res =</div><div class="line">          FESeries::process_coefficients&lt;dim&gt;(fourier_coefficients,</div><div class="line">                                              std::bind(&amp;LaplaceProblem&lt;dim&gt;::predicate,</div><div class="line">                                                        <span class="keyword">this</span>,</div><div class="line">                                                        std::placeholders::_1),</div><div class="line">                                              <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (res.first.size() == res.second.size(),</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (ln_k.size() == 0)</div><div class="line">          {</div><div class="line">            ln_k.resize(res.first.size(),0);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; ln_k.size(); f++)</div><div class="line">              ln_k[f] = std::log (2.0*<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*std::sqrt(1.*res.first[f]));</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; res.second.size(); f++)</div><div class="line">          res.second[f] = std::log(res.second[f]);</div><div class="line"></div><div class="line">        std::pair&lt;double,double&gt; fit = <a class="code" href="namespaceFESeries.html#afa42058db3555536415fae91822d27e3">FESeries::linear_regression</a>(ln_k,res.second);</div><div class="line"></div><div class="line">        smoothness_indicators(cell-&gt;active_cell_index()) = -fit.first - 1.*dim/2;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step27;</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem;</div><div class="line">      laplace_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
