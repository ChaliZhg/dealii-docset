<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TableBase&lt; N, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTableBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TableBase&lt; N, T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a> &raquo; <a class="el" href="group__data.html">Data storage primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="table_8h_source.html">deal.II/base/table.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TableBase&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTableBase__inherit__graph.svg" width="1704" height="3406"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae48115d9548347da59452bc28c90196e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTableBase.html#ae48115d9548347da59452bc28c90196e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ae48115d9548347da59452bc28c90196e">size_type</a></td></tr>
<tr class="separator:ae48115d9548347da59452bc28c90196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5de7b6d0c074080cc556d54b658c4060"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a5de7b6d0c074080cc556d54b658c4060">TableBase</a> ()</td></tr>
<tr class="separator:a5de7b6d0c074080cc556d54b658c4060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15af459bf3b300499ded46de0b2eec0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af15af459bf3b300499ded46de0b2eec0">TableBase</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;sizes)</td></tr>
<tr class="separator:af15af459bf3b300499ded46de0b2eec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b08c4ce198f3c4a697813a56db00a18"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a8b08c4ce198f3c4a697813a56db00a18"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#a8b08c4ce198f3c4a697813a56db00a18">TableBase</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;sizes, InputIterator entries, const bool C_style_indexing=true)</td></tr>
<tr class="separator:a8b08c4ce198f3c4a697813a56db00a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9996bc992edcbcc2d349554c6097249"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ab9996bc992edcbcc2d349554c6097249">TableBase</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;src)</td></tr>
<tr class="separator:ab9996bc992edcbcc2d349554c6097249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736feb31b90fcba77fd410ffe70b2622"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a736feb31b90fcba77fd410ffe70b2622"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#a736feb31b90fcba77fd410ffe70b2622">TableBase</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T2 &gt; &amp;src)</td></tr>
<tr class="separator:a736feb31b90fcba77fd410ffe70b2622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb93411b2c00d60f180af40bb46ac21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2bb93411b2c00d60f180af40bb46ac21">TableBase</a> (<a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&amp;src)</td></tr>
<tr class="separator:a2bb93411b2c00d60f180af40bb46ac21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb183eb68137a04ccc2d8d184c56070"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aadb183eb68137a04ccc2d8d184c56070">~TableBase</a> ()</td></tr>
<tr class="separator:aadb183eb68137a04ccc2d8d184c56070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480007c3101f430b0995e2920cef638e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a480007c3101f430b0995e2920cef638e">operator=</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;src)</td></tr>
<tr class="separator:a480007c3101f430b0995e2920cef638e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6ed7d830863e51cf1919c8444ccb44"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a3f6ed7d830863e51cf1919c8444ccb44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#a3f6ed7d830863e51cf1919c8444ccb44">operator=</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T2 &gt; &amp;src)</td></tr>
<tr class="separator:a3f6ed7d830863e51cf1919c8444ccb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab844b3353c91cb541a92c60a8289d92a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ab844b3353c91cb541a92c60a8289d92a">operator=</a> (<a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&amp;src)</td></tr>
<tr class="separator:ab844b3353c91cb541a92c60a8289d92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa998401367252589f5a4bdd7d8087380"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aa998401367252589f5a4bdd7d8087380">operator==</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;T2) const</td></tr>
<tr class="separator:aa998401367252589f5a4bdd7d8087380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e75a7ccd3359dccbddc0934bc1bf27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af0e75a7ccd3359dccbddc0934bc1bf27">reset_values</a> ()</td></tr>
<tr class="separator:af0e75a7ccd3359dccbddc0934bc1bf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302ef67031a523602fd39911b968d6ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;new_size, const bool omit_default_initialization=false)</td></tr>
<tr class="separator:a302ef67031a523602fd39911b968d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44facfc20335e07a1a096f3b54b014c7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a44facfc20335e07a1a096f3b54b014c7">size</a> (const unsigned int i) const</td></tr>
<tr class="separator:a44facfc20335e07a1a096f3b54b014c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba8a3da6e403297e8d2b231e9d6c35f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aaba8a3da6e403297e8d2b231e9d6c35f">size</a> () const</td></tr>
<tr class="separator:aaba8a3da6e403297e8d2b231e9d6c35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67161f19c760e98588bdecc560285d2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#ae48115d9548347da59452bc28c90196e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a67161f19c760e98588bdecc560285d2d">n_elements</a> () const</td></tr>
<tr class="separator:a67161f19c760e98588bdecc560285d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7b890ac4bbcba1b6524b45af1cbfd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#abb7b890ac4bbcba1b6524b45af1cbfd9">empty</a> () const</td></tr>
<tr class="separator:abb7b890ac4bbcba1b6524b45af1cbfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54a19dddbed32640b977b4d7948b434"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ad54a19dddbed32640b977b4d7948b434"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#ad54a19dddbed32640b977b4d7948b434">fill</a> (InputIterator entries, const bool C_style_indexing=true)</td></tr>
<tr class="separator:ad54a19dddbed32640b977b4d7948b434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0d148a657080f22dc7c4f213c5a8ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2a0d148a657080f22dc7c4f213c5a8ee">fill</a> (const T &amp;value)</td></tr>
<tr class="separator:a2a0d148a657080f22dc7c4f213c5a8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b90cda631253866e0f2fa02d714e6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2b90cda631253866e0f2fa02d714e6b0">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices)</td></tr>
<tr class="separator:a2b90cda631253866e0f2fa02d714e6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2966017e02f461809ff90eb8f4c86ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2966017e02f461809ff90eb8f4c86ed3">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:a2966017e02f461809ff90eb8f4c86ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140815b9435c997be48f439634afc4f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a140815b9435c997be48f439634afc4f5">swap</a> (<a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:a140815b9435c997be48f439634afc4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c63db9ae49e0e3b099f0244801016f2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2c63db9ae49e0e3b099f0244801016f2">memory_consumption</a> () const</td></tr>
<tr class="separator:a2c63db9ae49e0e3b099f0244801016f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee01f8890040d7b480fc0c72e19f6711"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:aee01f8890040d7b480fc0c72e19f6711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#aee01f8890040d7b480fc0c72e19f6711">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:aee01f8890040d7b480fc0c72e19f6711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab8546237d4c76440bfaed5e1818cdd90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#ae48115d9548347da59452bc28c90196e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ab8546237d4c76440bfaed5e1818cdd90">position</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:ab8546237d4c76440bfaed5e1818cdd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4474b545894de5a80f3fdacb9ead38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ad4474b545894de5a80f3fdacb9ead38c">el</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices)</td></tr>
<tr class="separator:ad4474b545894de5a80f3fdacb9ead38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9979fda00a9293c3fa6a6df97639e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a40a9979fda00a9293c3fa6a6df97639e">el</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:a40a9979fda00a9293c3fa6a6df97639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a50beea2748a06b3abb8d65d5fe7aa8aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a50beea2748a06b3abb8d65d5fe7aa8aa">values</a></td></tr>
<tr class="separator:a50beea2748a06b3abb8d65d5fe7aa8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33df922c5081e1b69e73027cacdaa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af33df922c5081e1b69e73027cacdaa95">table_size</a></td></tr>
<tr class="separator:af33df922c5081e1b69e73027cacdaa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2b417c0141e8f8a1800830f237577112"><td class="memTemplParams" colspan="2">template&lt;int , typename &gt; </td></tr>
<tr class="memitem:a2b417c0141e8f8a1800830f237577112"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2b417c0141e8f8a1800830f237577112">TableBase</a></td></tr>
<tr class="separator:a2b417c0141e8f8a1800830f237577112"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int N, typename T&gt;<br />
class TableBase&lt; N, T &gt;</h3>

<p>General class holding an array of objects of templated type in multiple dimensions. If the template parameter indicating the number of dimensions is one, then this is more or less a vector, if it is two then it is a matrix, and so on.</p>
<p>Previously, this data type was emulated in this library by constructs like <code>std::vector&lt;std::vector&lt;T&gt;&gt;</code>, or even higher nested constructs. However, this has the disadvantage that it is hard to initialize, and most importantly that it is very inefficient if all rows have the same size (which is the usual case), since then the memory for each row is allocated independently, both wasting time and memory. This can be made more efficient by allocating only one chunk of memory for the entire object.</p>
<p>Therefore, this data type was invented. Its implementation is rather straightforward, with two exceptions. The first thing to think about is how to pass the size in each of the coordinate directions to the object; this is done using the <a class="el" href="classTableIndices.html">TableIndices</a> class. Second, how to access the individual elements. The basic problem here is that we would like to make the number of arguments to be passed to the constructor as well as the access functions dependent on the template parameter <code>N</code> indicating the number of dimensions. Of course, this is not possible.</p>
<p>The way out of the first problem (and partly the second one as well) is to have a common base class <a class="el" href="classTableBase.html">TableBase</a> and a derived class for each value of <code>N</code>. This derived class has a constructor with the correct number of arguments, namely <code>N</code>. These then transform their arguments into the data type the base class (this class in fact) uses in the constructor as well as in element access through operator() functions.</p>
<p>The second problem is that we would like to allow access through a sequence of <code>operator[]</code> calls. This mostly because, as said, this class is a replacement for previous use of nested <code>std::vector</code> objects, where we had to use the <code>operator[]</code> access function recursively until we were at the innermost object. Emulating this behavior without losing the ability to do index checks, and in particular without losing performance is possible but nontrivial, and done in the TableBaseAccessors namespace.</p>
<h3>Comparison with the <a class="el" href="classTensor.html">Tensor</a> class</h3>
<p>In some way, this class is similar to the <a class="el" href="classTensor.html">Tensor</a> class, in that it templatizes on the number of dimensions. However, there are two major differences. The first is that the <a class="el" href="classTensor.html">Tensor</a> class stores only numeric values (as <code>double</code>s), while the <a class="el" href="classTable.html">Table</a> class stores arbitrary objects. The second is that the <a class="el" href="classTensor.html">Tensor</a> class has fixed dimensions, also given as a template argument, while this class can handle arbitrary dimensions, which may also be different between different indices.</p>
<p>This has two consequences. First, since the size is not known at compile time, it has to do explicit memory allocating. Second, the layout of individual elements is not known at compile time, so access is slower than for the <a class="el" href="classTensor.html">Tensor</a> class where the number of elements are their location is known at compile time and the compiler can optimize with this knowledge (for example when unrolling loops). On the other hand, this class is of course more flexible, for example when you want a two-dimensional table with the number of rows equal to the number of degrees of freedom on a cell, and the number of columns equal to the number of quadrature points. Both numbers may only be known at run-time, so a flexible table is needed here. Furthermore, you may want to store, say, the gradients of shape functions, so the data type is not a single scalar value, but a tensor itself.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2002. </dd></dl>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00032">32</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae48115d9548347da59452bc28c90196e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48115d9548347da59452bc28c90196e">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTableBase.html#ae48115d9548347da59452bc28c90196e">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html#ae48115d9548347da59452bc28c90196e">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer type used to count the number of elements in this container. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00411">411</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5de7b6d0c074080cc556d54b658c4060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de7b6d0c074080cc556d54b658c4060">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Set all dimensions to zero. </p>

</div>
</div>
<a id="af15af459bf3b300499ded46de0b2eec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15af459bf3b300499ded46de0b2eec0">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Initialize the array with the given dimensions in each index component. </p>

</div>
</div>
<a id="a8b08c4ce198f3c4a697813a56db00a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b08c4ce198f3c4a697813a56db00a18">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>C_style_indexing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Initialize the array with the given dimensions in each index component, and then initialize the elements of the table using the second and third argument by calling fill(entries,C_style_indexing). </p>

</div>
</div>
<a id="ab9996bc992edcbcc2d349554c6097249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9996bc992edcbcc2d349554c6097249">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Performs a deep copy. </p>

</div>
</div>
<a id="a736feb31b90fcba77fd410ffe70b2622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736feb31b90fcba77fd410ffe70b2622">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Performs a deep copy from a table object storing some other data type. </p>

</div>
</div>
<a id="a2bb93411b2c00d60f180af40bb46ac21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb93411b2c00d60f180af40bb46ac21">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor. Transfers the contents of another <a class="el" href="classTable.html">Table</a>. </p>

</div>
</div>
<a id="aadb183eb68137a04ccc2d8d184c56070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb183eb68137a04ccc2d8d184c56070">&#9670;&nbsp;</a></span>~TableBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::~<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Free allocated memory. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a480007c3101f430b0995e2920cef638e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480007c3101f430b0995e2920cef638e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt;N,T&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator. Copy all elements of <code>src</code> into the matrix. The size is adjusted if needed.</p>
<p>We can't use the other, templatized version since if we don't declare this one, the compiler will happily generate a predefined copy operator which is not what we want. </p>

</div>
</div>
<a id="a3f6ed7d830863e51cf1919c8444ccb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6ed7d830863e51cf1919c8444ccb44">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt;N,T&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator. Copy all elements of <code>src</code> into the array. The size is adjusted if needed.</p>
<p>This function requires that the type <code>T2</code> is convertible to <code>T</code>. </p>

</div>
</div>
<a id="ab844b3353c91cb541a92c60a8289d92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab844b3353c91cb541a92c60a8289d92a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt;N,T&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move assignment operator. Transfer all elements of <code>src</code> into the table. </p>

</div>
</div>
<a id="aa998401367252589f5a4bdd7d8087380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa998401367252589f5a4bdd7d8087380">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>T2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality of two tables. </p>

</div>
</div>
<a id="af0e75a7ccd3359dccbddc0934bc1bf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e75a7ccd3359dccbddc0934bc1bf27">&#9670;&nbsp;</a></span>reset_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::reset_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all entries to their default value (i.e. copy them over with default constructed objects). Do not change the size of the table, though. </p>

</div>
</div>
<a id="a302ef67031a523602fd39911b968d6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302ef67031a523602fd39911b968d6ab">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>omit_default_initialization</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the dimensions of this object to the sizes given in the argument, and newly allocate the required memory. If <code>omit_default_initialization</code> is set to <code>false</code>, all elements of the table are set to a default constructed object for the element type. Otherwise the memory is left in an uninitialized or otherwise undefined state. </p>

</div>
</div>
<a id="a44facfc20335e07a1a096f3b54b014c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44facfc20335e07a1a096f3b54b014c7">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::size </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the table in direction <code>i</code>. </p>

</div>
</div>
<a id="aaba8a3da6e403297e8d2b231e9d6c35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba8a3da6e403297e8d2b231e9d6c35f">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt;N&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the sizes of this object in each direction. </p>

</div>
</div>
<a id="a67161f19c760e98588bdecc560285d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67161f19c760e98588bdecc560285d2d">&#9670;&nbsp;</a></span>n_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#ae48115d9548347da59452bc28c90196e">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::n_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of elements stored in this object, which is the product of the extensions in each dimension. </p>

</div>
</div>
<a id="abb7b890ac4bbcba1b6524b45af1cbfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7b890ac4bbcba1b6524b45af1cbfd9">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty, i.e. one of the directions is zero. This is equivalent to <code><a class="el" href="classTableBase.html#a67161f19c760e98588bdecc560285d2d">n_elements()</a>==0</code>. </p>

</div>
</div>
<a id="ad54a19dddbed32640b977b4d7948b434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54a19dddbed32640b977b4d7948b434">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>C_style_indexing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill this table (which is assumed to already have the correct size) from a source given by dereferencing the given forward iterator (which could, for example, be a pointer to the first element of an array, or an inserting std::istream_iterator). The second argument denotes whether the elements pointed to are arranged in a way that corresponds to the last index running fastest or slowest. The default is to use C-style indexing where the last index runs fastest (as opposed to Fortran-style where the first index runs fastest when traversing multidimensional arrays. For example, if you try to fill an object of type <a class="el" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a>, then calling this function with the default value for the second argument will result in the equivalent of doing </p><div class="fragment"><div class="line"><a class="code" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a> t;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;t.sizes()[0]; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;t.sizes()[1]; ++j)</div><div class="line">    t[i][j] = *entries++;</div></div><!-- fragment --><p> On the other hand, if the second argument to this function is false, then this would result in code of the following form: </p><div class="fragment"><div class="line"><a class="code" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a> t;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;t.sizes()[1]; ++j)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;t.sizes()[0]; ++i)</div><div class="line">    t[i][j] = *entries++;</div></div><!-- fragment --><p> Note the switched order in which we fill the table elements by traversing the given set of iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>An iterator to a set of elements from which to initialize this table. It is assumed that iterator can be incremented and dereferenced a sufficient number of times to fill this table. </td></tr>
    <tr><td class="paramname">C_style_indexing</td><td>If true, run over elements of the table with the last index changing fastest as we dereference subsequent elements of the input range. If false, change the first index fastest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a0d148a657080f22dc7c4f213c5a8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0d148a657080f22dc7c4f213c5a8ee">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill all table entries with the same value. </p>

</div>
</div>
<a id="a2b90cda631253866e0f2fa02d714e6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b90cda631253866e0f2fa02d714e6b0">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::reference <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read-write reference to the indicated element. </p>

</div>
</div>
<a id="a2966017e02f461809ff90eb8f4c86ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2966017e02f461809ff90eb8f4c86ed3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::const_reference <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the indicated element as a read-only reference.</p>
<p>We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don't know here whether copying is expensive or not. </p>

</div>
</div>
<a id="a140815b9435c997be48f439634afc4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140815b9435c997be48f439634afc4f5">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of this table and the other table <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="a2c63db9ae49e0e3b099f0244801016f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c63db9ae49e0e3b099f0244801016f2">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="aee01f8890040d7b480fc0c72e19f6711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee01f8890040d7b480fc0c72e19f6711">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write or read the data of this object to or from a stream for the purpose of serialization. </p>

</div>
</div>
<a id="ab8546237d4c76440bfaed5e1818cdd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8546237d4c76440bfaed5e1818cdd90">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#ae48115d9548347da59452bc28c90196e">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the position of the indicated element within the array of elements stored one after the other. This function does no index checking. </p>

</div>
</div>
<a id="ad4474b545894de5a80f3fdacb9ead38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4474b545894de5a80f3fdacb9ead38c">&#9670;&nbsp;</a></span>el() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::reference <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-write reference to the indicated element.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked. </p>

</div>
</div>
<a id="a40a9979fda00a9293c3fa6a6df97639e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a9979fda00a9293c3fa6a6df97639e">&#9670;&nbsp;</a></span>el() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::const_reference <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the indicated element as a read-only reference.</p>
<p>This function does no bounds checking and is only to be used internally and in functions already checked.</p>
<p>We return the requested value as a constant reference rather than by value since this object may hold data types that may be large, and we don't know here whether copying is expensive or not. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2b417c0141e8f8a1800830f237577112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b417c0141e8f8a1800830f237577112">&#9670;&nbsp;</a></span>TableBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;int , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTableBase.html">TableBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make all other table classes friends. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00656">656</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a50beea2748a06b3abb8d65d5fe7aa8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50beea2748a06b3abb8d65d5fe7aa8aa">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Component-array. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00646">646</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="af33df922c5081e1b69e73027cacdaa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33df922c5081e1b69e73027cacdaa95">&#9670;&nbsp;</a></span>table_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableIndices.html">TableIndices</a>&lt;N&gt; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::table_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Size in each direction of the table. </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00651">651</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deal.II/base/<a class="el" href="table_8h_source.html">table.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
