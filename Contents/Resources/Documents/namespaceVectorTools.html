<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: VectorTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">VectorTools Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a69967cb7a148a7169963126249213db1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> { <br />
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a485d4198c1f422388b80cadb98af1f27">mean</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a8a97c0127bcfceec1fefbd0ad5839357">L1_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6">Lp_norm</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">H1_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1ab711e0a460000489addc7aa59878d2">Hdiv_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">H1_norm</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa24d2a903e0841b2d6794e3329a69930">W1p_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a619be0eb2626ecbb804b545b1618d6c3">W1p_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418">W1infty_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a694dcdb8213d64925e9be0fa90cc7619">W1infty_norm</a>
<br />
 }</td></tr>
<tr class="separator:a69967cb7a148a7169963126249213db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3553109639cec9bba5dc0216ff55a1d9"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3553109639cec9bba5dc0216ff55a1d9">ExcNonInterpolatingFE</a> ()</td></tr>
<tr class="separator:ga3553109639cec9bba5dc0216ff55a1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f7ffc57c76da1384a852920f756c1e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">ExcPointNotAvailableHere</a> ()</td></tr>
<tr class="separator:ga98f7ffc57c76da1384a852920f756c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interpolation and projection</div></td></tr>
<tr class="memitem:a05db6c8cebf924b417dd92f525efe3db"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:a05db6c8cebf924b417dd92f525efe3db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">interpolate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a05db6c8cebf924b417dd92f525efe3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d267850685f04deb2943076b3640b4f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:a0d267850685f04deb2943076b3640b4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a0d267850685f04deb2943076b3640b4f">interpolate</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a0d267850685f04deb2943076b3640b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5e3af70a47cedfaf361cf5c621e94e3d">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_2, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;transfer, const InVector &amp;data_1, OutVector &amp;data_2)</td></tr>
<tr class="separator:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdac18dce278e671f45bdcbf501b6e7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:a2bdac18dce278e671f45bdcbf501b6e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a2bdac18dce278e671f45bdcbf501b6e7">interpolate_based_on_material_id</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof_handler, const std::map&lt; <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; *&gt; &amp;function_map, VectorType &amp;dst, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a2bdac18dce278e671f45bdcbf501b6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68148d58c8dfd0916eceab9d89d74d5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:af68148d58c8dfd0916eceab9d89d74d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af68148d58c8dfd0916eceab9d89d74d5">interpolate_to_different_mesh</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof1, const VectorType &amp;u1, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof2, VectorType &amp;u2)</td></tr>
<tr class="separator:af68148d58c8dfd0916eceab9d89d74d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46030ef9207208150a5f001f67ef5b23"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:a46030ef9207208150a5f001f67ef5b23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a46030ef9207208150a5f001f67ef5b23">interpolate_to_different_mesh</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof1, const VectorType &amp;u1, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, VectorType &amp;u2)</td></tr>
<tr class="separator:a46030ef9207208150a5f001f67ef5b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a29ac462b74c27c3134d7e1bf0319e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:ab8a29ac462b74c27c3134d7e1bf0319e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ab8a29ac462b74c27c3134d7e1bf0319e">interpolate_to_different_mesh</a> (const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; DoFHandlerType&lt; dim, spacedim &gt; &gt; &amp;intergridmap, const VectorType &amp;u1, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, VectorType &amp;u2)</td></tr>
<tr class="separator:ab8a29ac462b74c27c3134d7e1bf0319e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68694d99266fa35e252f424f35d9f95"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ac68694d99266fa35e252f424f35d9f95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">project</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const bool enforce_zero_boundary=false, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q_boundary=(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim-1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt;(0)), const bool project_to_boundary_first=false)</td></tr>
<tr class="separator:ac68694d99266fa35e252f424f35d9f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af893f88b931ab9fd6c7b347a442f3dd7"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:af893f88b931ab9fd6c7b347a442f3dd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af893f88b931ab9fd6c7b347a442f3dd7">project</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const bool enforce_zero_boundary=false, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q_boundary=(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim-1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt;(0)), const bool project_to_boundary_first=false)</td></tr>
<tr class="separator:af893f88b931ab9fd6c7b347a442f3dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a3f3a72fd88c3bc57335f31522ef7d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a16a3f3a72fd88c3bc57335f31522ef7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a16a3f3a72fd88c3bc57335f31522ef7d">project</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const bool enforce_zero_boundary=false, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q_boundary=<a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt;(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim-1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt;(0)), const bool project_to_boundary_first=false)</td></tr>
<tr class="separator:a16a3f3a72fd88c3bc57335f31522ef7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49d18bbcf18d57f26951788bed35f46"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ae49d18bbcf18d57f26951788bed35f46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae49d18bbcf18d57f26951788bed35f46">project</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const bool enforce_zero_boundary=false, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q_boundary=<a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt;(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim-1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt;(0)), const bool project_to_boundary_first=false)</td></tr>
<tr class="separator:ae49d18bbcf18d57f26951788bed35f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5bfe48daf109acd2c18602bc8d672d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a9d5bfe48daf109acd2c18602bc8d672d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a9d5bfe48daf109acd2c18602bc8d672d">project</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const std::function&lt; typename VectorType::value_type(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned int)&gt; func, VectorType &amp;vec_result)</td></tr>
<tr class="separator:a9d5bfe48daf109acd2c18602bc8d672d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b92d2e03276e612cd3501d76a6be04"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType &gt; </td></tr>
<tr class="memitem:af2b92d2e03276e612cd3501d76a6be04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af2b92d2e03276e612cd3501d76a6be04">project</a> (std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type &gt; &gt; data, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const unsigned int n_q_points_1d, const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned int, const unsigned int)&gt; func, VectorType &amp;vec_result)</td></tr>
<tr class="separator:af2b92d2e03276e612cd3501d76a6be04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb0e0a26b2a4905d5bea205ec5c8cac"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType &gt; </td></tr>
<tr class="memitem:adeb0e0a26b2a4905d5bea205ec5c8cac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#adeb0e0a26b2a4905d5bea205ec5c8cac">project</a> (std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type &gt; &gt; data, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned int, const unsigned int)&gt; func, VectorType &amp;vec_result)</td></tr>
<tr class="separator:adeb0e0a26b2a4905d5bea205ec5c8cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187aeb575be07bc47cb3dea1a47aaf88"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:a187aeb575be07bc47cb3dea1a47aaf88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a187aeb575be07bc47cb3dea1a47aaf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56ea144baa6f3dd1ba7227c6e52084d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ac56ea144baa6f3dd1ba7227c6e52084d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac56ea144baa6f3dd1ba7227c6e52084d">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ac56ea144baa6f3dd1ba7227c6e52084d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceb3bb802af905dfc85593f1460c9c3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:a7ceb3bb802af905dfc85593f1460c9c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a7ceb3bb802af905dfc85593f1460c9c3">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a7ceb3bb802af905dfc85593f1460c9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30384b65027c0ca8ac49ebe19e4b84c5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:a30384b65027c0ca8ac49ebe19e4b84c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a30384b65027c0ca8ac49ebe19e4b84c5">interpolate_boundary_values</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a30384b65027c0ca8ac49ebe19e4b84c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b0779aa1a73b1f2a6cd189c9c4ba82"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:a42b0779aa1a73b1f2a6cd189c9c4ba82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a42b0779aa1a73b1f2a6cd189c9c4ba82">interpolate_boundary_values</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a42b0779aa1a73b1f2a6cd189c9c4ba82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3954be8b172fbcd05a94aba0cd6f40"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:gace3954be8b172fbcd05a94aba0cd6f40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gace3954be8b172fbcd05a94aba0cd6f40">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gace3954be8b172fbcd05a94aba0cd6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ef59a87a974d1e8cde1a579d4f327a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:gaf8ef59a87a974d1e8cde1a579d4f327a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf8ef59a87a974d1e8cde1a579d4f327a">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaf8ef59a87a974d1e8cde1a579d4f327a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2376b9a282a2b62be5c55ab62a11a132"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:ga2376b9a282a2b62be5c55ab62a11a132"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga2376b9a282a2b62be5c55ab62a11a132">interpolate_boundary_values</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga2376b9a282a2b62be5c55ab62a11a132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa78c814d6a60e060c0668add0f135e84"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:gaa78c814d6a60e060c0668add0f135e84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa78c814d6a60e060c0668add0f135e84">interpolate_boundary_values</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaa78c814d6a60e060c0668add0f135e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f69dee9fb8ad9f00bc39800573df130"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a5f69dee9fb8ad9f00bc39800573df130"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned int &gt; component_mapping=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:a5f69dee9fb8ad9f00bc39800573df130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae431e9f87e913996e0582f4927faa870"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ae431e9f87e913996e0582f4927faa870"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae431e9f87e913996e0582f4927faa870">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned int &gt; component_mapping=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:ae431e9f87e913996e0582f4927faa870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e267ca9a87ad2da060b25bed9177b6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aa5e267ca9a87ad2da060b25bed9177b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aa5e267ca9a87ad2da060b25bed9177b6">project_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned int &gt; component_mapping=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:aa5e267ca9a87ad2da060b25bed9177b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad120b560efff013cd2cc9aaafc179f00"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ad120b560efff013cd2cc9aaafc179f00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ad120b560efff013cd2cc9aaafc179f00">project_boundary_values</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned int &gt; component_mapping=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:ad120b560efff013cd2cc9aaafc179f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4201210dcce9a263f773209ac1775c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga5b4201210dcce9a263f773209ac1775c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5b4201210dcce9a263f773209ac1775c">project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, std::vector&lt; unsigned int &gt; component_mapping=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:ga5b4201210dcce9a263f773209ac1775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c57b25aa60c906ab463dbe5ca49ec82"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga2c57b25aa60c906ab463dbe5ca49ec82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga2c57b25aa60c906ab463dbe5ca49ec82">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, std::vector&lt; unsigned int &gt; component_mapping=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:ga2c57b25aa60c906ab463dbe5ca49ec82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c6685360c01c9c46eeb7575e8ef68ac"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga1c6685360c01c9c46eeb7575e8ef68ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1c6685360c01c9c46eeb7575e8ef68ac">project_boundary_values_curl_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga1c6685360c01c9c46eeb7575e8ef68ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5ab15402b144e80122ee983f76a4cd4"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gac5ab15402b144e80122ee983f76a4cd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gac5ab15402b144e80122ee983f76a4cd4">project_boundary_values_curl_conforming</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gac5ab15402b144e80122ee983f76a4cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fca3672ae63b249402460a6ed4538b4"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga6fca3672ae63b249402460a6ed4538b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga6fca3672ae63b249402460a6ed4538b4">project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga6fca3672ae63b249402460a6ed4538b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76f7bb9461f7a8be8da482d8198673f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaa76f7bb9461f7a8be8da482d8198673f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa76f7bb9461f7a8be8da482d8198673f">project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gaa76f7bb9461f7a8be8da482d8198673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86427a4e8b3a7e580dabb4e473005288"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga86427a4e8b3a7e580dabb4e473005288"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga86427a4e8b3a7e580dabb4e473005288">project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga86427a4e8b3a7e580dabb4e473005288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64db6ce0b7b31453e1ddac86ae4d04c9"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga64db6ce0b7b31453e1ddac86ae4d04c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga64db6ce0b7b31453e1ddac86ae4d04c9">project_boundary_values_div_conforming</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:ga64db6ce0b7b31453e1ddac86ae4d04c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b13c2da1b235c86cdbce2270525db99"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:ga5b13c2da1b235c86cdbce2270525db99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5b13c2da1b235c86cdbce2270525db99">compute_nonzero_normal_flux_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga5b13c2da1b235c86cdbce2270525db99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8d8c017ac654e24e71ad3fd7e76310"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:ga0e8d8c017ac654e24e71ad3fd7e76310"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">compute_no_normal_flux_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga0e8d8c017ac654e24e71ad3fd7e76310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a2c92faece22a1a7c8631a75d4a2f0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:ga83a2c92faece22a1a7c8631a75d4a2f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga83a2c92faece22a1a7c8631a75d4a2f0">compute_nonzero_tangential_flux_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga83a2c92faece22a1a7c8631a75d4a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga113d79605138e344578261503ed342d1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:ga113d79605138e344578261503ed342d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga113d79605138e344578261503ed342d1">compute_normal_flux_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga113d79605138e344578261503ed342d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assembling of right hand sides</div></td></tr>
<tr class="memitem:ad18037ddbd9cc65a77ffca01ddc347f5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:ad18037ddbd9cc65a77ffca01ddc347f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">create_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, VectorType &amp;rhs_vector, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:ad18037ddbd9cc65a77ffca01ddc347f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dbe0981c41a4fc2d25ed62e93c4e71"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a63dbe0981c41a4fc2d25ed62e93c4e71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a63dbe0981c41a4fc2d25ed62e93c4e71">create_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, VectorType &amp;rhs_vector, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a63dbe0981c41a4fc2d25ed62e93c4e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9578f9860a5b4ee2e70c0f5b673dd6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a2f9578f9860a5b4ee2e70c0f5b673dd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a2f9578f9860a5b4ee2e70c0f5b673dd6">create_right_hand_side</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, VectorType &amp;rhs_vector, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a2f9578f9860a5b4ee2e70c0f5b673dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5268e6802c5bfdabfd8d86b90f3eea65"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a5268e6802c5bfdabfd8d86b90f3eea65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5268e6802c5bfdabfd8d86b90f3eea65">create_right_hand_side</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, VectorType &amp;rhs_vector, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>())</td></tr>
<tr class="separator:a5268e6802c5bfdabfd8d86b90f3eea65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03b858b1a3b59003a76f6224e67efc7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad03b858b1a3b59003a76f6224e67efc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ad03b858b1a3b59003a76f6224e67efc7">create_point_source_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ad03b858b1a3b59003a76f6224e67efc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f0f9d09de84d3188cc1ae5f319c817"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af6f0f9d09de84d3188cc1ae5f319c817"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af6f0f9d09de84d3188cc1ae5f319c817">create_point_source_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:af6f0f9d09de84d3188cc1ae5f319c817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2395a12fd1fe62075f21f8c337761e8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac2395a12fd1fe62075f21f8c337761e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac2395a12fd1fe62075f21f8c337761e8">create_point_source_vector</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ac2395a12fd1fe62075f21f8c337761e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bc869d4f9170d17eb5bcd17516e83e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a43bc869d4f9170d17eb5bcd17516e83e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a43bc869d4f9170d17eb5bcd17516e83e">create_point_source_vector</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a43bc869d4f9170d17eb5bcd17516e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35661423471794eb9249ef906fcf96b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af35661423471794eb9249ef906fcf96b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af35661423471794eb9249ef906fcf96b">create_point_source_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:af35661423471794eb9249ef906fcf96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1f98ab183c1e9c67f4b47e893e6491"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aac1f98ab183c1e9c67f4b47e893e6491"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aac1f98ab183c1e9c67f4b47e893e6491">create_point_source_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:aac1f98ab183c1e9c67f4b47e893e6491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac155dbfa71563a89d8243c987168f8f6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac155dbfa71563a89d8243c987168f8f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac155dbfa71563a89d8243c987168f8f6">create_point_source_vector</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ac155dbfa71563a89d8243c987168f8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3868c79e0d7b2443ab114c55ba3bc19"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa3868c79e0d7b2443ab114c55ba3bc19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aa3868c79e0d7b2443ab114c55ba3bc19">create_point_source_vector</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:aa3868c79e0d7b2443ab114c55ba3bc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeb976be4183ae259c4390f14e9eca0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:afdeb976be4183ae259c4390f14e9eca0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afdeb976be4183ae259c4390f14e9eca0">create_boundary_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, VectorType &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:afdeb976be4183ae259c4390f14e9eca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9f34783151e13ce3a96d98f12b5ea8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a1a9f34783151e13ce3a96d98f12b5ea8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a1a9f34783151e13ce3a96d98f12b5ea8">create_boundary_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, VectorType &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a1a9f34783151e13ce3a96d98f12b5ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952645e12826224569681c2588ce6b22"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a952645e12826224569681c2588ce6b22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a952645e12826224569681c2588ce6b22">create_boundary_right_hand_side</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, VectorType &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a952645e12826224569681c2588ce6b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e258c26ff400da25863402c55b4cf9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a94e258c26ff400da25863402c55b4cf9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a94e258c26ff400da25863402c55b4cf9">create_boundary_right_hand_side</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, VectorType &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a94e258c26ff400da25863402c55b4cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Evaluation of functions and errors</div></td></tr>
<tr class="memitem:ac092dccd5ef1349dc207353450b58af1"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:ac092dccd5ef1349dc207353450b58af1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">integrate_difference</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; *weight=nullptr, const double exponent=2.)</td></tr>
<tr class="separator:ac092dccd5ef1349dc207353450b58af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e51ee41416d7469e78e364ec5eb3a1"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a12e51ee41416d7469e78e364ec5eb3a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a12e51ee41416d7469e78e364ec5eb3a1">integrate_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; *weight=nullptr, const double exponent=2.)</td></tr>
<tr class="separator:a12e51ee41416d7469e78e364ec5eb3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6675199255e4feb936ea9259947f3efa"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a6675199255e4feb936ea9259947f3efa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6675199255e4feb936ea9259947f3efa">integrate_difference</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; *weight=nullptr, const double exponent=2.)</td></tr>
<tr class="separator:a6675199255e4feb936ea9259947f3efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b5afc0b5a14602c9520808644b4e6c"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a82b5afc0b5a14602c9520808644b4e6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a82b5afc0b5a14602c9520808644b4e6c">integrate_difference</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; *weight=nullptr, const double exponent=2.)</td></tr>
<tr class="separator:a82b5afc0b5a14602c9520808644b4e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eb62d70953182dcc2b15c4e14dd533"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InVector &gt; </td></tr>
<tr class="memitem:a21eb62d70953182dcc2b15c4e14dd533"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const InVector &amp;cellwise_error, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const double exponent=2.)</td></tr>
<tr class="separator:a21eb62d70953182dcc2b15c4e14dd533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd0aa23f85da51e853e72b84b52068"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:afdcd0aa23f85da51e853e72b84b52068"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afdcd0aa23f85da51e853e72b84b52068">point_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;exact_solution, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;difference, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:afdcd0aa23f85da51e853e72b84b52068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47397b99e31a4100240e32e1bd2a1598"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a47397b99e31a4100240e32e1bd2a1598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a47397b99e31a4100240e32e1bd2a1598">point_difference</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;exact_solution, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;difference, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a47397b99e31a4100240e32e1bd2a1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee3adabb3fb97ac5d8996cd712b20e1"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:aaee3adabb3fb97ac5d8996cd712b20e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aaee3adabb3fb97ac5d8996cd712b20e1">point_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:aaee3adabb3fb97ac5d8996cd712b20e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744426c6dd5decc8ff18930aa25944a3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a744426c6dd5decc8ff18930aa25944a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a744426c6dd5decc8ff18930aa25944a3">point_value</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:a744426c6dd5decc8ff18930aa25944a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7662a955259d8485fbbc55605f0f6d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a6e7662a955259d8485fbbc55605f0f6d"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6e7662a955259d8485fbbc55605f0f6d">point_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a6e7662a955259d8485fbbc55605f0f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7d07d9105c966a280e490b2d57ce57"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a6a7d07d9105c966a280e490b2d57ce57"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6a7d07d9105c966a280e490b2d57ce57">point_value</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a6a7d07d9105c966a280e490b2d57ce57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ad93945eb2fe7f8be697a915c5f1c9"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a92ad93945eb2fe7f8be697a915c5f1c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a92ad93945eb2fe7f8be697a915c5f1c9">point_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:a92ad93945eb2fe7f8be697a915c5f1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf8a147cab73204cc30fdce2c58c6aa"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a7cf8a147cab73204cc30fdce2c58c6aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a7cf8a147cab73204cc30fdce2c58c6aa">point_value</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:a7cf8a147cab73204cc30fdce2c58c6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45b121bb9be2aa0458fc307933d0ac1"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ac45b121bb9be2aa0458fc307933d0ac1"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac45b121bb9be2aa0458fc307933d0ac1">point_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:ac45b121bb9be2aa0458fc307933d0ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc78e05b3e675bd4af2479aceeff686"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a3bc78e05b3e675bd4af2479aceeff686"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a3bc78e05b3e675bd4af2479aceeff686">point_value</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a3bc78e05b3e675bd4af2479aceeff686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34a6b6d598304e1a1b9ea12a84e52e3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ae34a6b6d598304e1a1b9ea12a84e52e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae34a6b6d598304e1a1b9ea12a84e52e3">point_gradient</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; &gt; &amp;value)</td></tr>
<tr class="separator:ae34a6b6d598304e1a1b9ea12a84e52e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e8d135c6fff789afca2f0545f6c144"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:af3e8d135c6fff789afca2f0545f6c144"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af3e8d135c6fff789afca2f0545f6c144">point_gradient</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; &gt; &amp;value)</td></tr>
<tr class="separator:af3e8d135c6fff789afca2f0545f6c144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb416862422a96caa40e303346f1dc94"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:abb416862422a96caa40e303346f1dc94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#abb416862422a96caa40e303346f1dc94">point_gradient</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:abb416862422a96caa40e303346f1dc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb8479328fea5e669d2748537d7ec84"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a3cb8479328fea5e669d2748537d7ec84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a3cb8479328fea5e669d2748537d7ec84">point_gradient</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a3cb8479328fea5e669d2748537d7ec84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177c9606907551c3bbce3c15089a78ee"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a177c9606907551c3bbce3c15089a78ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a177c9606907551c3bbce3c15089a78ee">point_gradient</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; &gt; &amp;value)</td></tr>
<tr class="separator:a177c9606907551c3bbce3c15089a78ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adf233a48591915036d6942578049ab"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a6adf233a48591915036d6942578049ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6adf233a48591915036d6942578049ab">point_gradient</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; &gt; &amp;value)</td></tr>
<tr class="separator:a6adf233a48591915036d6942578049ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9ef7436827a08481b6b0e2adcd7ad1"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a7e9ef7436827a08481b6b0e2adcd7ad1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a7e9ef7436827a08481b6b0e2adcd7ad1">point_gradient</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a7e9ef7436827a08481b6b0e2adcd7ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214c6be883f81fce7507b4dedf612ccc"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a214c6be883f81fce7507b4dedf612ccc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a214c6be883f81fce7507b4dedf612ccc">point_gradient</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const VectorType &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point)</td></tr>
<tr class="separator:a214c6be883f81fce7507b4dedf612ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a93f967a00dd4a9c65479c5323d4d5054"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a93f967a00dd4a9c65479c5323d4d5054"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a93f967a00dd4a9c65479c5323d4d5054">subtract_mean_value</a> (VectorType &amp;v, const std::vector&lt; bool &gt; &amp;p_select=std::vector&lt; bool &gt;())</td></tr>
<tr class="separator:a93f967a00dd4a9c65479c5323d4d5054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad086eb08b8424fd7c853e389a3978a9a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ad086eb08b8424fd7c853e389a3978a9a"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">compute_mean_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const VectorType &amp;v, const unsigned int component)</td></tr>
<tr class="separator:ad086eb08b8424fd7c853e389a3978a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4db7abc1e8c2ac5e814fe802a8a73a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:aed4db7abc1e8c2ac5e814fe802a8a73a"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aed4db7abc1e8c2ac5e814fe802a8a73a">compute_mean_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const VectorType &amp;v, const unsigned int component)</td></tr>
<tr class="separator:aed4db7abc1e8c2ac5e814fe802a8a73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0159943370879331189b956c3b86ec84"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename VectorType &gt; </td></tr>
<tr class="memitem:a0159943370879331189b956c3b86ec84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a0159943370879331189b956c3b86ec84">get_position_vector</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dh, VectorType &amp;vector, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a0159943370879331189b956c3b86ec84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provide a namespace which offers some operations on vectors. Among these are assembling of standard vectors, integration of the difference of a finite element solution and a continuous function, interpolations and projections of continuous functions to the finite element space and other operations.</p>
<dl class="section note"><dt>Note</dt><dd>There exist two versions of almost all functions, one that takes an explicit <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> argument and one that does not. The second one generally calls the first with an implicit <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> argument (i.e., with an argument of kind <a class="el" href="classMappingQGeneric.html">MappingQGeneric(1)</a>). If your intend your code to use a different mapping than a (bi-/tri-)linear one, then you need to call the functions <b>with</b> mapping argument should be used.</dd></dl>
<h3>Description of operations</h3>
<p>This collection of methods offers the following operations: </p><ul>
<li>
<p class="startli">Interpolation: assign each degree of freedom in the vector to be the value of the function given as argument. This is identical to saying that the resulting finite element function (which is isomorphic to the output vector) has exact function values in all support points of trial functions. The support point of a trial function is the point where its value equals one, e.g. for linear trial functions the support points are four corners of an element. This function therefore relies on the assumption that a finite element is used for which the degrees of freedom are function values (Lagrange elements) rather than gradients, normal derivatives, second derivatives, etc (Hermite elements, quintic Argyris element, etc.).</p>
<p>It seems inevitable that some values of the vector to be created are set twice or even more than that. The reason is that we have to loop over all cells and get the function values for each of the trial functions located thereon. This applies also to the functions located on faces and corners which we thus visit more than once. While setting the value in the vector is not an expensive operation, the evaluation of the given function may be, taking into account that a virtual function has to be called.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Projection: compute the <em>L</em><sup>2</sup>-projection of the given function onto the finite element space, i.e. if <em>f</em> is the function to be projected, compute <em>f<sub>h</sub></em> in <em>V<sub>h</sub></em> such that (<em>f<sub>h</sub></em>,<em>v<sub>h</sub></em>)=(<em>f</em>,<em>v<sub>h</sub></em>) for all discrete test functions <em>v<sub>h</sub></em>. This is done through the solution of the linear system of equations <em> M v = f</em> where <em>M</em> is the mass matrix <img class="formulaInl" alt="$m_{ij} = \int_\Omega \phi_i(x) \phi_j(x) dx$" src="form_1188.png"/> and <img class="formulaInl" alt="$f_i = \int_\Omega f(x) \phi_i(x) dx$" src="form_1194.png"/>. The solution vector <img class="formulaInl" alt="$v$" src="form_987.png"/> then is the nodal representation of the projection <em>f<sub>h</sub></em>. The <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">project()</a> functions are used in the <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_23.html">step-23</a> tutorial programs.</p>
<p>In order to get proper results, it be may necessary to treat boundary conditions right. Below are listed some cases where this may be needed. If needed, this is done by <em>L</em><sup>2</sup>-projection of the trace of the given function onto the finite element space restricted to the boundary of the domain, then taking this information and using it to eliminate the boundary nodes from the mass matrix of the whole domain, using the <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> function. The projection of the trace of the function to the boundary is done with the <a class="el" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">VectorTools::project_boundary_values()</a> (see below) function, which is called with a map of boundary functions std::map&lt;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const Function&lt;spacedim,number&gt;*&gt; in which all boundary indicators from zero to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>-1 (<a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is used for other purposes, see the <a class="el" href="classTriangulation.html">Triangulation</a> class documentation) point to the function to be projected. The projection to the boundary takes place using a second quadrature formula on the boundary given to the <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">project()</a> function. The first quadrature formula is used to compute the right hand side and for numerical quadrature of the mass matrix.</p>
<p>The projection of the boundary values first, then eliminating them from the global system of equations is not needed usually. It may be necessary if you want to enforce special restrictions on the boundary values of the projected function, for example in time dependent problems: you may want to project the initial values but need consistency with the boundary values for later times. Since the latter are projected onto the boundary in each time step, it is necessary that we also project the boundary values of the initial values, before projecting them to the whole domain.</p>
<p>Obviously, the results of the two schemes for projection are different. Usually, when projecting to the boundary first, the <em>L</em><sup>2</sup>-norm of the difference between original function and projection over the whole domain will be larger (factors of five have been observed) while the <em>L</em><sup>2</sup>-norm of the error integrated over the boundary should of course be less. The reverse should also hold if no projection to the boundary is performed.</p>
<p>The selection whether the projection to the boundary first is needed is done with the <code>project_to_boundary_first</code> flag passed to the function. If <code>false</code> is given, the additional quadrature formula for faces is ignored.</p>
<p>You should be aware of the fact that if no projection to the boundary is requested, a function with zero boundary values may not have zero boundary values after projection. There is a flag for this especially important case, which tells the function to enforce zero boundary values on the respective boundary parts. Since enforced zero boundary values could also have been reached through projection, but are more economically obtain using other methods, the <code>project_to_boundary_first</code> flag is ignored if the <code>enforce_zero_boundary</code> flag is set.</p>
<p>The solution of the linear system is presently done using a simple CG method without preconditioning and without multigrid. This is clearly not too efficient, but sufficient in many cases and simple to implement. This detail may change in the future.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Creation of right hand side vectors: The <a class="el" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">create_right_hand_side()</a> function computes the vector <img class="formulaInl" alt="$f_i = \int_\Omega f(x) \phi_i(x) dx$" src="form_1194.png"/>. This is the same as what the <code>MatrixCreator::create_*</code> functions which take a right hand side do, but without assembling a matrix.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Creation of right hand side vectors for point sources: The <a class="el" href="namespaceVectorTools.html#ad03b858b1a3b59003a76f6224e67efc7">create_point_source_vector()</a> function computes the vector <img class="formulaInl" alt="$f_i = \int_\Omega \delta(x-x_0) \phi_i(x) dx$" src="form_1195.png"/>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Creation of boundary right hand side vectors: The <a class="el" href="namespaceVectorTools.html#afdeb976be4183ae259c4390f14e9eca0">create_boundary_right_hand_side()</a> function computes the vector <img class="formulaInl" alt="$f_i = \int_{\partial\Omega} g(x) \phi_i(x) dx$" src="form_1196.png"/>. This is the right hand side contribution of boundary forces when having inhomogeneous Neumann boundary values in Laplace's equation or other second order operators. This function also takes an optional argument denoting over which parts of the boundary the integration shall extend. If the default argument is used, it is applied to all boundaries.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Interpolation of boundary values: The <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> function takes a list of boundary nodes and their values. You can get such a list by interpolation of a boundary function using the <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">interpolate_boundary_values()</a> function. To use it, you have to specify a list of pairs of boundary indicators (of type <code><a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a></code>; see the section in the documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class for more details) and the according functions denoting the Dirichlet boundary values of the nodes on boundary faces with this boundary indicator.</p>
<p>Usually, all other boundary conditions, such as inhomogeneous Neumann values or mixed boundary conditions are handled in the weak formulation. No attempt is made to include these into the process of matrix and vector assembly therefore.</p>
<p>Within this function, boundary values are interpolated, i.e. a node is given the point value of the boundary function. In some cases, it may be necessary to use the L2-projection of the boundary function or any other method. For this purpose we refer to the <a class="el" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">project_boundary_values()</a> function below.</p>
<p>You should be aware that the boundary function may be evaluated at nodes on the interior of faces. These, however, need not be on the true boundary, but rather are on the approximation of the boundary represented by the mapping of the unit cell to the real cell. Since this mapping will in most cases not be the exact one at the face, the boundary function is evaluated at points which are not on the boundary and you should make sure that the returned values are reasonable in some sense anyway.</p>
<p>In 1d the situation is a bit different since there faces (i.e. vertices) have no boundary indicator. It is assumed that if the boundary indicator zero is given in the list of boundary functions, the left boundary point is to be interpolated while the right boundary point is associated with the boundary index 1 in the map. The respective boundary functions are then evaluated at the place of the respective boundary point.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Projection of boundary values: The <a class="el" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">project_boundary_values()</a> function acts similar to the <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">interpolate_boundary_values()</a> function, apart from the fact that it does not get the nodal values of boundary nodes by interpolation but rather through the <em>L</em><sup>2</sup>-projection of the trace of the function to the boundary.</p>
<p>The projection takes place on all boundary parts with boundary indicators listed in the map (std::map&lt;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const Function&lt;spacedim,number&gt;*&gt;) of boundary functions. These boundary parts may or may not be continuous. For these boundary parts, the mass matrix is assembled using the MatrixTools::create_boundary_mass_matrix() function, as well as the appropriate right hand side. Then the resulting system of equations is solved using a simple CG method (without preconditioning), which is in most cases sufficient for the present purpose.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Computing errors: The function <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">integrate_difference()</a> performs the calculation of the error between a given (continuous) reference function and the finite element solution in different norms. The integration is performed using a given quadrature formula and assumes that the given finite element objects equals that used for the computation of the solution.</p>
<p>The result is stored in a vector (named <code>difference</code>), where each entry equals the given norm of the difference on a cell. The order of entries is the same as a <code>cell_iterator</code> takes when started with <code>begin_active</code> and promoted with the <code>++</code> operator.</p>
<p>This data, one number per active cell, can be used to generate graphical output by directly passing it to the <a class="el" href="classDataOut.html">DataOut</a> class through the <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut::add_data_vector</a> function. Alternatively, the global error can be computed using <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error()</a>. Finally, the output per cell from <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference()</a> can be interpolated to the nodal points of a finite element field using the <a class="el" href="namespaceDoFTools.html#a28e7d1e393e638ff46e5cba79db28324">DoFTools::distribute_cell_to_dof_vector</a> function.</p>
<p>Presently, there is the possibility to compute the following values from the difference, on each cell: <code>mean</code>, <code>L1_norm</code>, <code>L2_norm</code>, <code>Linfty_norm</code>, <code>H1_seminorm</code> and <code>H1_norm</code>, see <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a>. For the mean difference value, the reference function minus the numerical solution is computed, not the other way round.</p>
<p>The infinity norm of the difference on a given cell returns the maximum absolute value of the difference at the quadrature points given by the quadrature formula parameter. This will in some cases not be too good an approximation, since for example the Gauss quadrature formulae do not evaluate the difference at the end or corner points of the cells. You may want to choose a quadrature formula with more quadrature points or one with another distribution of the quadrature points in this case. You should also take into account the superconvergence properties of finite elements in some points: for example in 1D, the standard finite element method is a collocation method and should return the exact value at nodal points. Therefore, the trapezoidal rule should always return a vanishing L-infinity error. Conversely, in 2D the maximum L-infinity error should be located at the vertices or at the center of the cell, which would make it plausible to use the Simpson quadrature rule. On the other hand, there may be superconvergence at Gauss integration points. These examples are not intended as a rule of thumb, rather they are thought to illustrate that the use of the wrong quadrature formula may show a significantly wrong result and care should be taken to chose the right formula.</p>
<p>The <em>H</em><sup>1</sup> seminorm is the <em>L</em><sup>2</sup> norm of the gradient of the difference. The square of the full <em>H</em><sup>1</sup> norm is the sum of the square of seminorm and the square of the <em>L</em><sup>2</sup> norm.</p>
<p>To get the global <em>L<sup>1</sup></em> error, you have to sum up the entries in <code>difference</code>, e.g. using <a class="el" href="classVector.html#aeaa8fc05dd5a8a8f9560a5de096ebb4e">Vector::l1_norm()</a> function. For the global <em>L</em><sup>2</sup> difference, you have to sum up the squares of the entries and take the root of the sum, e.g. using <a class="el" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">Vector::l2_norm()</a>. These two operations represent the <em>l</em><sub>1</sub> and <em>l</em><sub>2</sub> norms of the vectors, but you need not take the absolute value of each entry, since the cellwise norms are already positive.</p>
<p>To get the global mean difference, simply sum up the elements as above. To get the <img class="formulaInl" alt="$L_\infty$" src="form_1197.png"/> norm, take the maximum of the vector elements, e.g. using the <a class="el" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">Vector::linfty_norm()</a> function.</p>
<p>For the global <em>H</em><sup>1</sup> norm and seminorm, the same rule applies as for the <em>L</em><sup>2</sup> norm: compute the <em>l</em><sub>2</sub> norm of the cell error vector.</p>
<p class="endli">Note that, in the codimension one case, if you ask for a norm that requires the computation of a gradient, then the provided function is automatically projected along the curve, and the difference is only computed on the tangential part of the gradient, since no information is available on the normal component of the gradient anyway. </p>
</li>
</ul>
<p>All functions use the finite element given to the <a class="el" href="classDoFHandler.html">DoFHandler</a> object the last time that the degrees of freedom were distributed over the triangulation. Also, if access to an object describing the exact form of the boundary is needed, the pointer stored within the triangulation object is accessed.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for some vector types, in particular <code><a class="el" href="classVector.html">Vector</a>&lt;float&gt;, <a class="el" href="classVector.html">Vector</a>&lt;double&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;float&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;double&gt;</code>; others can be generated in application code (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Ralf Hartmann, Guido Kanschat, 1998, 1999, 2000, 2001 </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a69967cb7a148a7169963126249213db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69967cb7a148a7169963126249213db1">&#9670;&nbsp;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Denote which norm/integral is to be computed by the <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">integrate_difference()</a> function on each cell and <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error()</a> for the whole domain. Let <img class="formulaInl" alt="$f:\Omega \rightarrow \mathbb{R}^c$" src="form_1198.png"/> be a finite element function with <img class="formulaInl" alt="$c$" src="form_257.png"/> components where component <img class="formulaInl" alt="$c$" src="form_257.png"/> is denoted by <img class="formulaInl" alt="$f_c$" src="form_1199.png"/> and <img class="formulaInl" alt="$\hat{f}$" src="form_1200.png"/> be the reference function (the <code>fe_function</code> and <code>exact_solution</code> arguments to <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">integrate_difference()</a>). Let <img class="formulaInl" alt="$e_c = \hat{f}_c - f_c$" src="form_1201.png"/> be the difference or error between the two. Further, let <img class="formulaInl" alt="$w:\Omega \rightarrow \mathbb{R}^c$" src="form_1202.png"/> be the <code>weight</code> function of <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">integrate_difference()</a>, which is assumed to be equal to one if not supplied. Finally, let <img class="formulaInl" alt="$p$" src="form_202.png"/> be the <code>exponent</code> argument (for <img class="formulaInl" alt="$L_p$" src="form_1203.png"/>-norms).</p>
<p>In the following,we denote by <img class="formulaInl" alt="$E_K$" src="form_1204.png"/> the local error computed by <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">integrate_difference()</a> on cell <img class="formulaInl" alt="$K$" src="form_57.png"/>, whereas <img class="formulaInl" alt="$E$" src="form_1205.png"/> is the global error computed by <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error()</a>. Note that integrals are approximated by quadrature in the usual way: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_A f(x) dx \approx \sum_q f(x_q) \omega_q. \]" src="form_1206.png"/>
</p>
<p> Similarly for suprema over a cell <img class="formulaInl" alt="$T$" src="form_1207.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sup_{x\in T} |f(x)| dx \approx \max_q |f(x_q)|. \]" src="form_1208.png"/>
</p>
 <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a485d4198c1f422388b80cadb98af1f27"></a>mean&#160;</td><td class="fielddoc"><p>The function or difference of functions is integrated on each cell <img class="formulaInl" alt="$K$" src="form_57.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \int_K \sum_c (\hat{f}_c - f_c) \, w_c = \int_K \sum_c e_c \, w_c \]" src="form_1265.png"/>
</p>
<p> and summed up to get </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sum_K E_K = \int_\Omega \sum_c (\hat{f}_c - f_c) \, w_c \]" src="form_1266.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \int_\Omega (\hat{f} - f) = \int_\Omega e. \]" src="form_1268.png"/>
</p>
<p>Note: This differs from what is typically known as the mean of a function by a factor of <img class="formulaInl" alt="$\frac{1}{|\Omega|}$" src="form_1269.png"/>. To compute the mean you can also use <a class="el" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">compute_mean_value()</a>. Finally, pay attention to the sign: if <img class="formulaInl" alt="$\hat{f}=0$" src="form_1270.png"/>, this will compute the negative of the mean of <img class="formulaInl" alt="$f$" src="form_417.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a8a97c0127bcfceec1fefbd0ad5839357"></a>L1_norm&#160;</td><td class="fielddoc"><p>The absolute value of the function is integrated: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \int_K \sum_c |e_c| \, w_c \]" src="form_1271.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sum_K E_K = \int_\Omega \sum_c |e_c| w_c, \]" src="form_1272.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \| e \|_{L^1}. \]" src="form_1273.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e"></a>L2_norm&#160;</td><td class="fielddoc"><p>The square of the function is integrated and the the square root of the result is computed on each cell: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \sqrt{ \int_K \sum_c e_c^2 \, w_c } \]" src="form_1274.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \sum_c e_c^2 \, w_c } \]" src="form_1275.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sqrt{ \int_\Omega e^2 } = \| e \|_{L^2} \]" src="form_1276.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6"></a>Lp_norm&#160;</td><td class="fielddoc"><p>The absolute value to the <img class="formulaInl" alt="$p$" src="form_202.png"/>-th power is integrated and the <img class="formulaInl" alt="$p$" src="form_202.png"/>-th root is computed on each cell. The exponent <img class="formulaInl" alt="$p$" src="form_202.png"/> is the <code>exponent</code> argument of <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">integrate_difference()</a> and <a class="el" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">compute_mean_value()</a>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \left( \int_K \sum_c |e_c|^p \, w_c \right)^{1/p} \]" src="form_1277.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \left( \sum_K E_K^p \right)^{1/p} \]" src="form_1278.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \| e \|_{L^p}. \]" src="form_1279.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4"></a>Linfty_norm&#160;</td><td class="fielddoc"><p>The maximum absolute value of the function: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \sup_K \max_c |e_c| \, w_c \]" src="form_1280.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \max_K E_K = \sup_\Omega \max_c |e_c| \, w_c \]" src="form_1281.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sup_\Omega \|e\|_\infty = \| e \|_{L^\infty}. \]" src="form_1282.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f"></a>H1_seminorm&#160;</td><td class="fielddoc"><p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a> of the gradient: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \sqrt{ \int_K \sum_c (\nabla e_c)^2 \, w_c } \]" src="form_1283.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \sum_c (\nabla e_c)^2 \, w_c } \]" src="form_1284.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \| \nabla e \|_{L^2}. \]" src="form_1285.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a1ab711e0a460000489addc7aa59878d2"></a>Hdiv_seminorm&#160;</td><td class="fielddoc"><p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a> of the divergence of a vector field. The function <img class="formulaInl" alt="$f$" src="form_417.png"/> is expected to have <img class="formulaInl" alt="$c \geq \text{dim}$" src="form_1286.png"/> components and the first <code>dim</code> will be used to compute the divergence: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \sqrt{ \int_K \left( \sum_c \frac{\partial e_c}{\partial x_c} \, \sqrt{w_c} \right)^2 } \]" src="form_1287.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \left( \sum_c \frac{\partial e_c}{\partial x_c} \, \sqrt{w_c} \right)^2 } \]" src="form_1288.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \| \nabla \cdot e \|_{L^2}. \]" src="form_1289.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c"></a>H1_norm&#160;</td><td class="fielddoc"><p>The square of this norm is the square of the <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a> plus the square of the <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">H1_seminorm</a>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \sqrt{ \int_K \sum_c (e_c^2 + (\nabla e_c)^2) \, w_c } \]" src="form_1290.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \sum_c (e_c^2 + (\nabla e_c)^2) \, w_c } \]" src="form_1291.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \left( \| e \|_{L^2}^2 + \| \nabla e \|_{L^2}^2 \right)^{1/2}. \]" src="form_1292.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1aa24d2a903e0841b2d6794e3329a69930"></a>W1p_seminorm&#160;</td><td class="fielddoc"><p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6">Lp_norm</a> of the gradient: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \left( \int_K \sum_c |\nabla e_c|^p \, w_c \right)^{1/p} \]" src="form_1293.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \left( \sum_K E_K^p \right)^{1/p} = \left( \int_\Omega \sum_c |\nabla e_c|^p \, w_c \right)^{1/p} \]" src="form_1294.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \| \nabla e \|_{L^p}. \]" src="form_1295.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a619be0eb2626ecbb804b545b1618d6c3"></a>W1p_norm&#160;</td><td class="fielddoc"><p>The same as the <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">H1_norm</a> but using <em>L<sup>p</sup></em>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \left( \int_K \sum_c (|e_c|^p + |\nabla e_c|^p) \, w_c \right)^{1/p} \]" src="form_1296.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \left( \sum_K E_K^p \right)^{1/p} = \left( \int_\Omega \sum_c (|e_c|^p + |\nabla e_c|^p) \, w_c \right)^{1/p} \]" src="form_1297.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \left( \| e \|_{L^p}^p + \| \nabla e \|_{L^p}^p \right)^{1/p}. \]" src="form_1298.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418"></a>W1infty_seminorm&#160;</td><td class="fielddoc"><p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a> of the gradient: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \sup_K \max_c |\nabla e_c| \, w_c \]" src="form_1299.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \max_K E_K = \sup_\Omega \max_c |\nabla e_c| \, w_c \]" src="form_1300.png"/>
</p>
<p> or, for <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \| \nabla e \|_{L^\infty}. \]" src="form_1301.png"/>
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a694dcdb8213d64925e9be0fa90cc7619"></a>W1infty_norm&#160;</td><td class="fielddoc"><p>The sum of <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a> and <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418">W1infty_seminorm</a>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_K = \sup_K \max_c |e_c| \, w_c + \sup_K \max_c |\nabla e_c| \, w_c. \]" src="form_1302.png"/>
</p>
<p> The global norm is not implemented in <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error()</a>, because it is impossible to compute the sum of the global norms from the values <img class="formulaInl" alt="$E_K$" src="form_1204.png"/>. As a work-around, you can compute the global <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a> and <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418">W1infty_seminorm</a> separately and then add them to get (with <img class="formulaInl" alt="$w \equiv 1$" src="form_1267.png"/>): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \| e \|_{L^\infty} + \| \nabla e \|_{L^\infty}. \]" src="form_1303.png"/>
</p>
 </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vector__tools_8h_source.html#l00347">347</a> of file <a class="el" href="vector__tools_8h_source.html">vector_tools.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a05db6c8cebf924b417dd92f525efe3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05db6c8cebf924b417dd92f525efe3db">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation of <code>function</code> at the support points to the finite element space described by the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a> object with which the given <a class="el" href="classDoFHandler.html">DoFHandler</a> argument is initialized. It is assumed that the number of components of <code>function</code> matches that of the finite element used by <code>dof</code>.</p>
<p>Note that you may have to call <code>hanging_nodes.distribute(vec)</code> with the hanging nodes from space <code>dof</code> afterwards, to make the result continuous again.</p>
<p>The template argument <code>DoFHandlerType</code> may either be of type <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>.</p>
<p>See the general documentation of this namespace for further information.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000046">Todo:</a></b></dt><dd>The <code>mapping</code> argument should be replaced by a <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a> in case of a <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. </dd></dl>

</div>
</div>
<a id="a0d267850685f04deb2943076b3640b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d267850685f04deb2943076b3640b4f">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <code><a class="el" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">interpolate()</a></code> function above with <code>mapping=MappingQGeneric1&lt;dim&gt;@()</code>. </p>

</div>
</div>
<a id="a5e3af70a47cedfaf361cf5c621e94e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3af70a47cedfaf361cf5c621e94e3d">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>data_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>data_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolate different finite element spaces. The interpolation of vector <code>data_1</code> is executed from the FE space represented by <code>dof_1</code> to the vector <code>data_2</code> on FE space <code>dof_2</code>. The interpolation on each cell is represented by the matrix <code>transfer</code>. Curved boundaries are neglected so far.</p>
<p>Note that you may have to call <code>hanging_nodes.distribute(data_2)</code> with the hanging nodes from space <code>dof_2</code> afterwards, to make the result continuous again.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for some vector types (see the general documentation of the namespace), but only the same vector for InVector and OutVector. Other combinations must be instantiated by hand. </dd></dl>

</div>
</div>
<a id="a2bdac18dce278e671f45bdcbf501b6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdac18dce278e671f45bdcbf501b6e7">&#9670;&nbsp;</a></span>interpolate_based_on_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_based_on_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a kind of generalization or modification of the very first <a class="el" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">interpolate()</a> function in the series. It interpolations a set of functions onto the finite element space given by the <a class="el" href="classDoFHandler.html">DoFHandler</a> argument where the determination which function to use is made based on the material id (see <a class="el" href="DEALGlossary.html#GlossMaterialId">GlossMaterialId</a>) of each cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>- The mapping to use to determine the location of support points at which the functions are to be evaluated. </td></tr>
    <tr><td class="paramname">dof_handler</td><td>- <a class="el" href="classDoFHandler.html">DoFHandler</a> initialized with <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a> objects, </td></tr>
    <tr><td class="paramname">function_map</td><td>- std::map reflecting the correspondence between material ids and functions, </td></tr>
    <tr><td class="paramname">dst</td><td>- global FE vector at the support points, </td></tr>
    <tr><td class="paramname">component_mask</td><td>- mask of components that shall be interpolated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If a material id of some group of cells is missed in <code>function_map</code>, then <code>dst</code> will not be updated in the respective degrees of freedom of the output vector For example, if <code>dst</code> was successfully initialized to capture the degrees of freedom of the <code>dof_handler</code> of the problem with all zeros in it, then those zeros which correspond to the missed material ids will still remain in <code>dst</code> even after calling this function.</dd>
<dd>
Degrees of freedom located on faces between cells of different material ids will get their value by that cell which was called last in the respective loop over cells implemented in this function. Since this process is kind of arbitrary, you cannot control it. However, if you want to have control over the order in which cells are visited, let us take a look at the following example: Let <code>u</code> be a variable of interest which is approximated by some CG finite element. Let <code>0</code>, <code>1</code> and <code>2</code> be material ids of cells on the triangulation. Let 0: 0.0, 1: 1.0, 2: 2.0 be the whole <code>function_map</code> that you want to pass to this function, where <code>key</code> is a material id and <code>value</code> is a value of <code>u</code>. By using the whole <code>function_map</code> you do not really know which values will be assigned to the face DoFs. On the other hand, if you split the whole <code>function_map</code> into three smaller independent objects 0: 0.0 and 1: 1.0 and 2: 2.0 and make three distinct calls of this function passing each of these objects separately (the order depends on what you want to get between cells), then each subsequent call will rewrite the intercell <code>dofs</code> of the previous one.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Valentin Zingan, 2013 </dd></dl>

</div>
</div>
<a id="af68148d58c8dfd0916eceab9d89d74d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68148d58c8dfd0916eceab9d89d74d5">&#9670;&nbsp;</a></span>interpolate_to_different_mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of a <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>, where <code>dof1</code> and <code>dof2</code> represent different triangulations with a common coarse grid.</p>
<p>dof1 and dof2 need to have the same finite element discretization.</p>
<p>Note that for continuous elements on grids with hanging nodes (i.e. locally refined grids) this function does not give the expected output. Indeed, the resulting output vector does not necessarily respect continuity requirements at hanging nodes, due to local cellwise interpolation.</p>
<p>For this case (continuous elements on grids with hanging nodes), please use the interpolate_to_different_mesh function with an additional <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> argument, see below, or make the field conforming yourself by calling the <code>ConstraintsMatrix::distribute</code> function of your hanging node constraints object.</p>
<dl class="section note"><dt>Note</dt><dd>: This function works with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, but only if the parallel partitioning is the same for both meshes (see the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a1bcfd814692ed67b8c57e84b042158ad">parallel::distributed::Triangulation&lt;dim&gt;::no_automatic_repartitioning</a> flag). </dd></dl>

</div>
</div>
<a id="a46030ef9207208150a5f001f67ef5b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46030ef9207208150a5f001f67ef5b23">&#9670;&nbsp;</a></span>interpolate_to_different_mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the interpolation of a <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>, where <code>dof1</code> and <code>dof2</code> represent different triangulations with a common coarse grid.</p>
<p>dof1 and dof2 need to have the same finite element discretization.</p>
<p><code>constraints</code> is a hanging node constraints object corresponding to <code>dof2</code>. This object is particularly important when interpolating onto continuous elements on grids with hanging nodes (locally refined grids): Without it - due to cellwise interpolation - the resulting output vector does not necessarily respect continuity requirements at hanging nodes. </p>

</div>
</div>
<a id="ab8a29ac462b74c27c3134d7e1bf0319e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a29ac462b74c27c3134d7e1bf0319e">&#9670;&nbsp;</a></span>interpolate_to_different_mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType , template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; DoFHandlerType&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>intergridmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same function as above, but takes an <a class="el" href="classInterGridMap.html">InterGridMap</a> object directly as a parameter. Useful for interpolating several vectors at the same time.</p>
<p><code>intergridmap</code> has to be initialized via <a class="el" href="classInterGridMap.html#a9e9ed6c30b05d6ff93587e5306122bc2">InterGridMap::make_mapping</a> pointing from a source <a class="el" href="classDoFHandler.html">DoFHandler</a> to a destination <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

</div>
</div>
<a id="ac68694d99266fa35e252f424f35d9f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68694d99266fa35e252f424f35d9f95">&#9670;&nbsp;</a></span>project() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code>(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim-1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim-1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the projection of <code>function</code> to the finite element space.</p>
<p>By default, projection to the boundary and enforcement of zero boundary values are disabled. The ordering of arguments to this function is such that you need not give a second quadrature formula if you don't want to project to the boundary first, but that you must if you want to do so.</p>
<p>A <a class="el" href="classMatrixFree.html">MatrixFree</a> implementation is used if the following conditions are met:</p><ul>
<li><code>enforce_zero_boundary</code> is false,</li>
<li><code>project_to_boundary_first</code> is false,</li>
<li>the <a class="el" href="classFiniteElement.html">FiniteElement</a> is supported by the <a class="el" href="classMatrixFree.html">MatrixFree</a> class,</li>
<li>the <a class="el" href="classFiniteElement.html">FiniteElement</a> has less than five components</li>
<li>the degree of the <a class="el" href="classFiniteElement.html">FiniteElement</a> is less than nine.</li>
<li>dim==spacedim</li>
</ul>
<p>In this case, this function performs numerical quadrature using the given quadrature formula for integration of the provided function while a <a class="el" href="classQGauss.html">QGauss</a>(fe_degree+2) object is used for the mass operator. You should therefore make sure that the given quadrature formula is sufficient for creating the right-hand side.</p>
<p>Otherwise, only serial Triangulations are supported and the mass matrix is assembled exactly using MatrixTools::create_mass_matrix and the same quadrature rule as for the right-hand side. You should therefore make sure that the given quadrature formula is also sufficient for creating the mass matrix.</p>
<p>See the general documentation of this namespace for further information.</p>
<p>In 1d, the default value of the boundary quadrature formula is an invalid object since integration on the boundary doesn't happen in 1d.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> the describes the finite element space to project into and that corresponds to <code>vec</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints</td><td>Constraints to be used when assembling the mass matrix, typically needed when you have hanging nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>The quadrature formula to be used for assembling the mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>The function to project into the finite element space. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>The output vector where the projected function will be stored in. This vector is required to be already initialized and must not have ghost elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enforce_zero_boundary</td><td>If true, <code>vec</code> will have zero boundary conditions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q_boundary</td><td><a class="el" href="classQuadrature.html">Quadrature</a> rule to be used if <code>project_to_boundary_first</code> is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">project_to_boundary_first</td><td>If true, perform a projection on the boundary before projecting the interior of the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af893f88b931ab9fd6c7b347a442f3dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af893f88b931ab9fd6c7b347a442f3dd7">&#9670;&nbsp;</a></span>project() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code>(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim-1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim-1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">project()</a> function above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a16a3f3a72fd88c3bc57335f31522ef7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a3f3a72fd88c3bc57335f31522ef7d">&#9670;&nbsp;</a></span>project() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code><a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;&#160;dim-1&#160;&gt;(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim-1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim-1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for arguments of type <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, hp::QuadratureCollection, <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a> </p>

</div>
</div>
<a id="ae49d18bbcf18d57f26951788bed35f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49d18bbcf18d57f26951788bed35f46">&#9670;&nbsp;</a></span>project() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code><a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;&#160;dim-1&#160;&gt;(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim-1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim-1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">project()</a> function above, with a collection of <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> mapping objects, i.e., with <a class="el" href="structhp_1_1StaticMappingQ1.html#a3951f29e14b906691298a07c932fe809">hp::StaticMappingQ1::mapping_collection</a>. </p>

</div>
</div>
<a id="a9d5bfe48daf109acd2c18602bc8d672d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5bfe48daf109acd2c18602bc8d672d">&#9670;&nbsp;</a></span>project() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; typename VectorType::value_type(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned int)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above for projection of scalar-valued quadrature data. The user provided function should return a value at the quadrature point based on the cell iterator and quadrature number and of course should be consistent with the provided <code>quadrature</code> object, which will be used to assemble the right-hand-side.</p>
<p>This function can be used with lambdas: </p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a></div><div class="line">(mapping,</div><div class="line"> dof_handler,</div><div class="line"> constraints,</div><div class="line"> quadrature_formula,</div><div class="line"> [=] (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp; cell, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q) -&gt; <span class="keywordtype">double</span></div><div class="line"> { <span class="keywordflow">return</span> qp_data.get_data(cell)[q]-&gt;density; },</div><div class="line"> field);</div></div><!-- fragment --><p> where <code>qp_data</code> is a <a class="el" href="classCellDataStorage.html">CellDataStorage</a> object, which stores quadrature point data. </p>

</div>
</div>
<a id="af2b92d2e03276e612cd3501d76a6be04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b92d2e03276e612cd3501d76a6be04">&#9670;&nbsp;</a></span>project() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type &gt; &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_q_points_1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned int, const unsigned int)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above for projection of scalar-valued <a class="el" href="classMatrixFree.html">MatrixFree</a> quadrature data. The user provided function <code>func</code> should return a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> value at the quadrature point based on the cell number and quadrature number and should be consistent with the <code>n_q_points_1d</code>.</p>
<p>This function can be used with lambdas: </p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a></div><div class="line">(matrix_free_data,</div><div class="line"> constraints,</div><div class="line"> 3,</div><div class="line"> [=] (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q) -&gt; <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a></div><div class="line"> { <span class="keywordflow">return</span> qp_data(cell,q); },</div><div class="line"> field);</div></div><!-- fragment --><p> where <code>qp_data</code> is a an object of type <a class="el" href="classTable.html">Table</a>&lt;2, VectorizedArray&lt;double&gt; &gt;, which stores quadrature point data. </p>

</div>
</div>
<a id="adeb0e0a26b2a4905d5bea205ec5c8cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb0e0a26b2a4905d5bea205ec5c8cac">&#9670;&nbsp;</a></span>project() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type &gt; &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned int, const unsigned int)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for <code>n_q_points_1d = matrix_free.get_dof_handler().get_fe().degree+1</code>. </p>

</div>
</div>
<a id="a187aeb575be07bc47cb3dea1a47aaf88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187aeb575be07bc47cb3dea1a47aaf88">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute Dirichlet boundary conditions. This function makes up a map of degrees of freedom subject to Dirichlet boundary conditions and the corresponding values to be assigned to them, by interpolation around the boundary. For each degree of freedom at the boundary, if its index already exists in <code>boundary_values</code> then its boundary value will be overwritten, otherwise a new entry with proper index and boundary value for this degree of freedom will be inserted into <code>boundary_values</code>.</p>
<p>The parameter <code>function_map</code> provides a list of boundary indicators to be handled by this function and corresponding boundary value functions. The keys of this map correspond to the number <code>boundary_id</code> of the face. <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is an illegal value for this key since it is reserved for interior faces.</p>
<p>The flags in the last parameter, <code>component_mask</code> denote which components of the finite element space shall be interpolated. If it is left as specified by the default value (i.e. an empty array), all components are interpolated. If it is different from the default value, it is assumed that the number of entries equals the number of components in the boundary functions and the finite element, and those components in the given boundary function will be used for which the respective flag was set in the component mask. See also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>. As an example, assume that you are solving the Stokes equations in 2d, with variables <img class="formulaInl" alt="$(u,v,p)$" src="form_1141.png"/> and that you only want to interpolate boundary values for the velocity, then the component mask should correspond to <code>(true,true,false)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Whether a component mask has been specified or not, the number of components of the functions in <code>function_map</code> must match that of the finite element used by <code>dof</code>. In other words, for the example above, you need to provide a <a class="el" href="classFunction.html">Function</a> object that has 3 components (the two velocities and the pressure), even though you are only interested in the first two of them. <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">interpolate_boundary_values()</a> will then call this function to obtain a vector of 3 values at each interpolation point but only take the first two and discard the third. In other words, you are free to return whatever you like in the third component of the vector returned by <a class="el" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">Function::vector_value</a>, but the <a class="el" href="classFunction.html">Function</a> object must state that it has 3 components.</dd></dl>
<p>If the finite element used has shape functions that are non-zero in more than one component (in deal.II speak: they are non-primitive), then these components can presently not be used for interpolating boundary values. Thus, the elements in the component mask corresponding to the components of these non-primitive shape functions must be <code>false</code>.</p>
<p>See the general documentation of this namespace for more information. </p>

</div>
</div>
<a id="ac56ea144baa6f3dd1ba7227c6e52084d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56ea144baa6f3dd1ba7227c6e52084d">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but take a mapping collection to go with the <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> object. </p>

</div>
</div>
<a id="a7ceb3bb802af905dfc85593f1460c9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceb3bb802af905dfc85593f1460c9c3">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but taking only one pair of boundary indicator and corresponding boundary function. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a30384b65027c0ca8ac49ebe19e4b84c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30384b65027c0ca8ac49ebe19e4b84c5">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the other <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a42b0779aa1a73b1f2a6cd189c9c4ba82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b0779aa1a73b1f2a6cd189c9c4ba82">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the other <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object. </p>

</div>
</div>
<a id="a5f69dee9fb8ad9f00bc39800573df130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f69dee9fb8ad9f00bc39800573df130">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project a function or a set of functions to the boundary of the domain. In other words, compute the solution of the following problem: Find <img class="formulaInl" alt="$u_h \in V_h$" src="form_76.png"/> (where <img class="formulaInl" alt="$V_h$" src="form_79.png"/> is the finite element space represented by the <a class="el" href="classDoFHandler.html">DoFHandler</a> argument of this function) so that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \int_{\Gamma} \varphi_i u_h = \sum_{k \in {\cal K}} \int_{\Gamma_k} \varphi_i f_k, \qquad \forall \varphi_i \in V_h \end{align*}" src="form_1209.png"/>
</p>
<p> where <img class="formulaInl" alt="$\Gamma = \bigcup_{k \in {\cal K}} \Gamma_k$" src="form_1210.png"/>, <img class="formulaInl" alt="$\Gamma_k \subset \partial\Omega$" src="form_1211.png"/>, <img class="formulaInl" alt="$\cal K$" src="form_1212.png"/> is the set of indices and <img class="formulaInl" alt="$f_k$" src="form_1213.png"/> the corresponding boundary functions represented in the function map argument <code>boundary_values</code> to this function, and the integrals are evaluated by quadrature. This problem has a non-unique solution in the interior, but it is well defined for the degrees of freedom on the part of the boundary, <img class="formulaInl" alt="$\Gamma$" src="form_1193.png"/>, for which we do the integration. The values of <img class="formulaInl" alt="$u_h|_\Gamma$" src="form_1214.png"/>, i.e., the nodal values of the degrees of freedom of this function along the boundary, are then what is computed by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping that will be used in the transformations necessary to integrate along the boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> that describes the finite element space and the numbering of degrees of freedom. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_functions</td><td>A map from boundary indicators to pointers to functions that describe the desired values on those parts of the boundary marked with this boundary indicator (see <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Boundary indicator</a>). The projection happens on only those parts of the boundary whose indicators are represented in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The face quadrature used in the integration necessary to compute the mass matrix and right hand side of the projection. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boundary_values</td><td>The result of this function. It is a map containing all indices of degrees of freedom at the boundary (as covered by the boundary parts in <code>boundary_functions</code>) and the computed dof value for this degree of freedom. For each degree of freedom at the boundary, if its index already exists in <code>boundary_values</code> then its boundary value will be overwritten, otherwise a new entry with proper index and boundary value for this degree of freedom will be inserted into <code>boundary_values</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mapping</td><td>It is sometimes convenient to project a vector-valued function onto only parts of a finite element space (for example, to project a function with <code>dim</code> components onto the velocity components of a <code>dim+1</code> component <a class="el" href="classDoFHandler.html">DoFHandler</a> for a Stokes problem). To allow for this, this argument allows components to be remapped. If the vector is not empty, it has to have one entry for each vector component of the finite element used in <code>dof</code>. This entry is the component number in <code>boundary_functions</code> that should be used for this component in <code>dof</code>. By default, no remapping is applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae431e9f87e913996e0582f4927faa870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae431e9f87e913996e0582f4927faa870">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">project_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. </p>

</div>
</div>
<a id="aa5e267ca9a87ad2da060b25bed9177b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e267ca9a87ad2da060b25bed9177b6">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for objects of type <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> </p>

</div>
</div>
<a id="ad120b560efff013cd2cc9aaafc179f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad120b560efff013cd2cc9aaafc179f00">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">project_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. </p>

</div>
</div>
<a id="ad18037ddbd9cc65a77ffca01ddc347f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18037ddbd9cc65a77ffca01ddc347f5">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector. Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this namespace for further information. </p>

</div>
</div>
<a id="a63dbe0981c41a4fc2d25ed62e93c4e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dbe0981c41a4fc2d25ed62e93c4e71">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">create_right_hand_side()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a2f9578f9860a5b4ee2e70c0f5b673dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9578f9860a5b4ee2e70c0f5b673dd6">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. </p>

</div>
</div>
<a id="a5268e6802c5bfdabfd8d86b90f3eea65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5268e6802c5bfdabfd8d86b90f3eea65">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. </p>

</div>
</div>
<a id="ad03b858b1a3b59003a76f6224e67efc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03b858b1a3b59003a76f6224e67efc7">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector for a point source at point <code>p</code>. In other words, it creates a vector <img class="formulaInl" alt="$F$" src="form_249.png"/> so that <img class="formulaInl" alt="$F_i = \int_\Omega \delta(x-p) \phi_i(x) dx$" src="form_1252.png"/>. Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this namespace for further information. </p>

</div>
</div>
<a id="af6f0f9d09de84d3188cc1ae5f319c817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f0f9d09de84d3188cc1ae5f319c817">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ad03b858b1a3b59003a76f6224e67efc7">create_point_source_vector()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="ac2395a12fd1fe62075f21f8c337761e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2395a12fd1fe62075f21f8c337761e8">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. </p>

</div>
</div>
<a id="a43bc869d4f9170d17eb5bcd17516e83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bc869d4f9170d17eb5bcd17516e83e">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. The function uses the default Q1 mapping object. Note that if your <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> uses any active fe index other than zero, then you need to call the function above that provides a mapping object for each active fe index. </p>

</div>
</div>
<a id="af35661423471794eb9249ef906fcf96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35661423471794eb9249ef906fcf96b">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector for a point source at point <code>p</code>. This variation of the function is meant for vector-valued problems with exactly dim components (it will also work for problems with more than dim components, and in this case simply consider only the first dim components of the shape functions). It computes a right hand side that corresponds to a forcing function that is equal to a delta function times a given direction. In other words, it creates a vector <img class="formulaInl" alt="$F$" src="form_249.png"/> so that <img class="formulaInl" alt="$F_i = \int_\Omega [\mathbf d \delta(x-p)] \cdot \phi_i(x) dx$" src="form_1253.png"/>. Note here that <img class="formulaInl" alt="$\phi_i$" src="form_525.png"/> is a vector-valued function. <img class="formulaInl" alt="$\mathbf d$" src="form_1254.png"/> is the given direction of the source term <img class="formulaInl" alt="$\mathbf d \delta(x-p)$" src="form_1255.png"/> and corresponds to the <code>direction</code> argument to be passed to this function.</p>
<p>Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this namespace for further information. </p>

</div>
</div>
<a id="aac1f98ab183c1e9c67f4b47e893e6491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1f98ab183c1e9c67f4b47e893e6491">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ad03b858b1a3b59003a76f6224e67efc7">create_point_source_vector()</a> function for vector-valued finite elements, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="ac155dbfa71563a89d8243c987168f8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac155dbfa71563a89d8243c987168f8f6">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. </p>

</div>
</div>
<a id="aa3868c79e0d7b2443ab114c55ba3bc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3868c79e0d7b2443ab114c55ba3bc19">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp objects. The function uses the default Q1 mapping object. Note that if your <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> uses any active fe index other than zero, then you need to call the function above that provides a mapping object for each active fe index. </p>

</div>
</div>
<a id="afdeb976be4183ae259c4390f14e9eca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdeb976be4183ae259c4390f14e9eca0">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector from boundary forces. Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this namespace for further information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a1a9f34783151e13ce3a96d98f12b5ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9f34783151e13ce3a96d98f12b5ea8">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#afdeb976be4183ae259c4390f14e9eca0">create_boundary_right_hand_side()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a952645e12826224569681c2588ce6b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952645e12826224569681c2588ce6b22">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the set of functions above, but for hp objects.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a94e258c26ff400da25863402c55b4cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e258c26ff400da25863402c55b4cf9">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#afdeb976be4183ae259c4390f14e9eca0">create_boundary_right_hand_side()</a> function, see above, with a single Q1 mapping as collection. This function therefore will only work if the only active fe index in use is zero.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ac092dccd5ef1349dc207353450b58af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac092dccd5ef1349dc207353450b58af1">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cellwise error of the finite element solution. Integrate the difference between a reference function which is given as a continuous function object, and a finite element function. The result of this function is the vector <code>difference</code> that contains one value per active cell <img class="formulaInl" alt="$K$" src="form_57.png"/> of the triangulation. Each of the values of this vector <img class="formulaInl" alt="$d$" src="form_301.png"/> equals </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} d_K = \| u-u_h \|_X \end{align*}" src="form_1256.png"/>
</p>
<p> where <img class="formulaInl" alt="$X$" src="form_711.png"/> denotes the norm chosen and <img class="formulaInl" alt="$u$" src="form_256.png"/> represents the exact solution.</p>
<p>It is assumed that the number of components of the function <code>exact_solution</code> matches that of the finite element used by <code>dof</code>.</p>
<p>To compute a global error norm of a finite element solution, use <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error()</a> with the output vector computed with this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping that is used when integrating the difference <img class="formulaInl" alt="$u-u_h$" src="form_1257.png"/>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> object that describes the finite element space in which the solution vector lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector with nodal values representing the numerical approximation <img class="formulaInl" alt="$u_h$" src="form_722.png"/>. This vector needs to correspond to the finite element space represented by <code>dof</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exact_solution</td><td>The exact solution that is used to compute the error. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">difference</td><td>The vector of values <img class="formulaInl" alt="$d_K$" src="form_1258.png"/> computed as above. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quadrature formula used to approximate the integral shown above. Note that some quadrature formulas are more useful than other in integrating <img class="formulaInl" alt="$u-u_h$" src="form_1257.png"/>. For example, it is known that the <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> approximation <img class="formulaInl" alt="$u_h$" src="form_722.png"/> to the exact solution <img class="formulaInl" alt="$u$" src="form_256.png"/> of a Laplace equation is particularly accurate (in fact, superconvergent, i.e. accurate to higher order) at the 4 Gauss points of a cell in 2d (or 8 points in 3d) that correspond to a <a class="el" href="classQGauss.html">QGauss(2)</a> object. Consequently, because a <a class="el" href="classQGauss.html">QGauss(2)</a> formula only evaluates the two solutions at these particular points, choosing this quadrature formula may indicate an error far smaller than it actually is. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">norm</td><td>The norm <img class="formulaInl" alt="$X$" src="form_711.png"/> shown above that should be computed. If the norm is NormType::Hdiv_seminorm, then the finite element on which this function is called needs to have at least dim vector components, and the divergence will be computed on the first div components. This works, for example, on the finite elements used for the mixed Laplace (<a class="el" href="step_20.html">step-20</a>) and the Stokes equations (<a class="el" href="step_22.html">step-22</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>The additional argument <code>weight</code> allows to evaluate weighted norms. The weight function may be scalar, establishing a spatially variable weight in the domain for all components equally. This may be used, for instance, to only integrate over parts of the domain. The weight function may also be vector-valued, with as many components as the finite element: Then, different components get different weights. A typical application is when the error with respect to only one or a subset of the solution variables is to be computed, in which case the other components would have weight values equal to zero. The <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> class is particularly useful for this purpose as it provides such a "mask" weight. The weight function is expected to be positive, but negative values are not filtered. The default value of this function, a null pointer, is interpreted as "no weighting function", i.e., weight=1 in the whole domain for all vector components uniformly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exponent</td><td>This value denotes the <img class="formulaInl" alt="$p$" src="form_202.png"/> used in computing <img class="formulaInl" alt="$L^p$" src="form_1259.png"/>-norms and <img class="formulaInl" alt="$W^{1,p}$" src="form_1260.png"/>-norms. The value is ignored if a <code>norm</code> other than NormType::Lp_norm, NormType::W1p_norm, or NormType::W1p_seminorm is chosen.</td></tr>
  </table>
  </dd>
</dl>
<p>See the general documentation of this namespace for more information.</p>
<dl class="section note"><dt>Note</dt><dd>If the integration here happens over the cells of a parallel::distribute::Triangulation object, then this function computes the vector elements <img class="formulaInl" alt="$d_K$" src="form_1258.png"/> for an output vector with as many cells as there are active cells of the triangulation object of the current processor. However, not all active cells are in fact locally owned: some may be ghost or artificial cells (see <a class="el" href="DEALGlossary.html#GlossGhostCell">here</a> and <a class="el" href="DEALGlossary.html#GlossArtificialCell">here</a>). The vector computed will, in the case of a distributed triangulation, contain zeros for cells that are not locally owned. As a consequence, in order to compute the <em>global</em> <img class="formulaInl" alt="$L_2$" src="form_608.png"/> error (for example), the errors from different processors need to be combined, see <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error()</a>.</dd></dl>
<p>Instantiations for this template are provided for some vector types (see the general documentation of the namespace), but only for InVectors as in the documentation of the namespace, OutVector only <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> and Vector&lt;float&gt;. </p>

</div>
</div>
<a id="a12e51ee41416d7469e78e364ec5eb3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e51ee41416d7469e78e364ec5eb3a1">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">integrate_difference()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a6675199255e4feb936ea9259947f3efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6675199255e4feb936ea9259947f3efa">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp. </p>

</div>
</div>
<a id="a82b5afc0b5a14602c9520808644b4e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b5afc0b5a14602c9520808644b4e6c">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, double &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">integrate_difference()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a21eb62d70953182dcc2b15c4e14dd533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21eb62d70953182dcc2b15c4e14dd533">&#9670;&nbsp;</a></span>compute_global_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double VectorTools::compute_global_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>cellwise_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a <a class="el" href="classVector.html">Vector</a> <code>cellwise_error</code> of errors on each cell with <code>tria.n_active_cells()</code> entries and return the global error as given by <code>norm</code>.</p>
<p>The <code>cellwise_error</code> vector is typically an output produced by <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference()</a> and you normally want to supply the same value for <code>norm</code> as you used in <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference()</a>.</p>
<p>If the given <a class="el" href="classTriangulation.html">Triangulation</a> is a <a class="el" href="classparallel_1_1Triangulation.html">parallel::Triangulation</a>, entries in <code>cellwise_error</code> that do not correspond to locally owned cells are assumed to be 0.0 and a parallel reduction using MPI is done to compute the global error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> with active cells corresponding with the entries in <code>cellwise_error</code>. </td></tr>
    <tr><td class="paramname">cellwise_error</td><td><a class="el" href="classVector.html">Vector</a> of errors on each active cell. </td></tr>
    <tr><td class="paramname">norm</td><td>The type of norm to compute. </td></tr>
    <tr><td class="paramname">exponent</td><td>The exponent <img class="formulaInl" alt="$p$" src="form_202.png"/> to use for <img class="formulaInl" alt="$L^p$" src="form_1259.png"/>-norms and <img class="formulaInl" alt="$W^{1,p}$" src="form_1260.png"/>-norms. The value is ignored if a <code>norm</code> other than NormType::Lp_norm, NormType::W1p_norm, or NormType::W1p_seminorm is chosen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Instantiated for type <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> and Vector&lt;float&gt;. </dd></dl>

</div>
</div>
<a id="afdcd0aa23f85da51e853e72b84b52068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcd0aa23f85da51e853e72b84b52068">&#9670;&nbsp;</a></span>point_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classPoint.html">Point</a> error evaluation. Find the first cell containing the given point and compute the difference of a (possibly vector-valued) finite element function and a continuous function (with as many vector components as the finite element) at this point.</p>
<p>This is a wrapper function using a Q1-mapping for cell boundaries to call the other <a class="el" href="namespaceVectorTools.html#afdcd0aa23f85da51e853e72b84b52068">point_difference()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown. </dd></dl>

</div>
</div>
<a id="a47397b99e31a4100240e32e1bd2a1598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47397b99e31a4100240e32e1bd2a1598">&#9670;&nbsp;</a></span>point_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classPoint.html">Point</a> error evaluation. Find the first cell containing the given point and compute the difference of a (possibly vector-valued) finite element function and a continuous function (with as many vector components as the finite element) at this point.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping to evaluate the difference.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown. </dd></dl>

</div>
</div>
<a id="aaee3adabb3fb97ac5d8996cd712b20e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee3adabb3fb97ac5d8996cd712b20e1">&#9670;&nbsp;</a></span>point_value() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the (vector) value of this function through the last argument.</p>
<p>This is a wrapper function using a Q1-mapping for cell boundaries to call the other <a class="el" href="namespaceVectorTools.html#afdcd0aa23f85da51e853e72b84b52068">point_difference()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a744426c6dd5decc8ff18930aa25944a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744426c6dd5decc8ff18930aa25944a3">&#9670;&nbsp;</a></span>point_value() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a6e7662a955259d8485fbbc55605f0f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7662a955259d8485fbbc55605f0f6d">&#9670;&nbsp;</a></span>point_value() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the value of this function.</p>
<p>Compared with the other function of the same name, this is a wrapper function using a Q1-mapping for cells.</p>
<p>This function is used in the "Possibilities for extensions" part of the results section of <a class="el" href="step_3.html">step-3</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a6a7d07d9105c966a280e490b2d57ce57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7d07d9105c966a280e490b2d57ce57">&#9670;&nbsp;</a></span>point_value() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a92ad93945eb2fe7f8be697a915c5f1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ad93945eb2fe7f8be697a915c5f1c9">&#9670;&nbsp;</a></span>point_value() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the (vector) value of this function through the last argument.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping to evaluate the difference.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a7cf8a147cab73204cc30fdce2c58c6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf8a147cab73204cc30fdce2c58c6aa">&#9670;&nbsp;</a></span>point_value() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="ac45b121bb9be2aa0458fc307933d0ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45b121bb9be2aa0458fc307933d0ac1">&#9670;&nbsp;</a></span>point_value() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the value of this function.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping to evaluate the difference.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a3bc78e05b3e675bd4af2479aceeff686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc78e05b3e675bd4af2479aceeff686">&#9670;&nbsp;</a></span>point_value() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="ae34a6b6d598304e1a1b9ea12a84e52e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34a6b6d598304e1a1b9ea12a84e52e3">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the (vector) gradient of this function through the last argument.</p>
<p>This is a wrapper function using a Q1-mapping for cell boundaries to call the other <a class="el" href="namespaceVectorTools.html#ae34a6b6d598304e1a1b9ea12a84e52e3">point_gradient()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="af3e8d135c6fff789afca2f0545f6c144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e8d135c6fff789afca2f0545f6c144">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="abb416862422a96caa40e303346f1dc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb416862422a96caa40e303346f1dc94">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim, typename VectorType::value_type&gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the gradient of this function.</p>
<p>Compared with the other function of the same name, this is a wrapper function using a Q1-mapping for cells.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a3cb8479328fea5e669d2748537d7ec84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb8479328fea5e669d2748537d7ec84">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim, typename VectorType::value_type&gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a177c9606907551c3bbce3c15089a78ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177c9606907551c3bbce3c15089a78ee">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the gradients of this function through the last argument.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping for evaluation.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a6adf233a48591915036d6942578049ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adf233a48591915036d6942578049ab">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a7e9ef7436827a08481b6b0e2adcd7ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9ef7436827a08481b6b0e2adcd7ad1">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim, typename VectorType::value_type&gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the gradient of this function.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping for evaluation.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a214c6be883f81fce7507b4dedf612ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214c6be883f81fce7507b4dedf612ccc">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim, typename VectorType::value_type&gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type <a class="el" href="group__Exceptions.html#ga98f7ffc57c76da1384a852920f756c1e">VectorTools::ExcPointNotAvailableHere</a> is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a93f967a00dd4a9c65479c5323d4d5054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f967a00dd4a9c65479c5323d4d5054">&#9670;&nbsp;</a></span>subtract_mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::subtract_mean_value </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_select</em> = <code>std::vector&lt;&#160;bool&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean value operations Subtract the (algebraic) mean value from a vector.</p>
<p>This function is most frequently used as a mean-value filter for Stokes: The pressure in Stokes' equations with only Dirichlet boundaries for the velocities is only determined up to a constant. This function allows to subtract the mean value of the pressure. It is usually called in a preconditioner and generates updates with mean value zero. The mean value is computed as the mean value of the degrees of freedom values as given by the input vector; they are not weighted by the area of cells, i.e. the mean is computed as <img class="formulaInl" alt="$\sum_i v_i$" src="form_1261.png"/>, rather than as <img class="formulaInl" alt="$\int_\Omega v(x) = \int_\Omega \sum_i v_i \phi_i(x)$" src="form_1262.png"/>. The latter can be obtained from the VectorTools::compute_mean_function, however.</p>
<p>Apart from the vector <code>v</code> to operate on, this function takes a boolean mask <code>p_select</code> that has a true entry for every element of the vector for which the mean value shall be computed and later subtracted. The argument is used to denote which components of the solution vector correspond to the pressure, and avoid touching all other components of the vector, such as the velocity components. (Note, however, that the mask is not a <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> operating on the vector components of the finite element the solution vector <code>v</code> may be associated with; rather, it is a mask on the entire vector, without reference to what the vector elements mean.)</p>
<p>The boolean mask <code>p_select</code> has an empty vector as default value, which will be interpreted as selecting all vector elements, hence, subtracting the algebraic mean value on the whole vector. This allows to call this function without a boolean mask if the whole vector should be processed.</p>
<dl class="section note"><dt>Note</dt><dd>In the context of using this function to filter out the kernel of an operator (such as the null space of the Stokes operator that consists of the constant pressures), this function only makes sense for finite elements for which the null space indeed consists of the vector <img class="formulaInl" alt="$(1,1,\ldots,1)^T$" src="form_1263.png"/>. This is the case for example for the usual Lagrange elements where the sum of all shape functions equals the function that is constant one. However, it is not true for some other functions: for example, for the <a class="el" href="classFE__DGP.html">FE_DGP</a> element (another valid choice for the pressure in Stokes discretizations), the first shape function on each cell is constant while further elements are <img class="formulaInl" alt="$L_2$" src="form_608.png"/> orthogonal to it (on the reference cell); consequently, the sum of all shape functions is not equal to one, and the vector that is associated with the constant mode is not equal to <img class="formulaInl" alt="$(1,1,\ldots,1)^T$" src="form_1263.png"/>. For such elements, a different procedure has to be used when subtracting the mean value.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is only implemented for <a class="el" href="classVector.html">Vector</a> and <a class="el" href="classBlockVector.html">BlockVector</a>. It is not implemented for any of the distributed vector classes. </dd></dl>

</div>
</div>
<a id="ad086eb08b8424fd7c853e389a3978a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad086eb08b8424fd7c853e389a3978a9a">&#9670;&nbsp;</a></span>compute_mean_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::compute_mean_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the mean value of one component of the solution.</p>
<p>This function integrates the chosen component over the whole domain and returns the result, i.e. it computes <img class="formulaInl" alt="$\frac{1}{|\Omega|}\int_\Omega [u_h(x)]_c \; dx$" src="form_1264.png"/> where <img class="formulaInl" alt="$c$" src="form_257.png"/> is the vector component and <img class="formulaInl" alt="$u_h$" src="form_722.png"/> is the function representation of the nodal vector given as fourth argument. The integral is evaluated numerically using the quadrature formula given as third argument.</p>
<p>This function is used in the "Possibilities for extensions" part of the results section of <a class="el" href="step_3.html">step-3</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The function is most often used when solving a problem whose solution is only defined up to a constant, for example a pure Neumann problem or the pressure in a Stokes or Navier-Stokes problem. In both cases, subtracting the mean value as computed by the current function, from the nodal vector does not generally yield the desired result of a finite element function with mean value zero. In fact, it only works for Lagrangian elements. For all other elements, you will need to compute the mean value and subtract it right inside the evaluation routine. </dd></dl>

</div>
</div>
<a id="aed4db7abc1e8c2ac5e814fe802a8a73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4db7abc1e8c2ac5e814fe802a8a73a">&#9670;&nbsp;</a></span>compute_mean_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::compute_mean_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the other <a class="el" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">compute_mean_value()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a0159943370879331189b956c3b86ec84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0159943370879331189b956c3b86ec84">&#9670;&nbsp;</a></span>get_position_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::get_position_vector </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Geometrical interpolation Given a <a class="el" href="classDoFHandler.html">DoFHandler</a> containing at least a spacedim vector field, this function interpolates the <a class="el" href="classTriangulation.html">Triangulation</a> at the support points of a <a class="el" href="classFE__Q.html">FE_Q()</a> finite element of the same degree as the degree of the required components.</p>
<p>Curved manifold are respected, and the resulting VectorType will be geometrically consistent. The resulting map is guaranteed to be interpolatory at the support points of a <a class="el" href="classFE__Q.html">FE_Q()</a> finite element of the same degree as the degree of the required components.</p>
<p>If the underlying finite element is an <a class="el" href="classFE__Q.html">FE_Q(1)</a>^spacedim, then the resulting <code>VectorType</code> is a finite element field representation of the vertices of the <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>The optional <a class="el" href="classComponentMask.html">ComponentMask</a> argument can be used to specify what components of the <a class="el" href="classFiniteElement.html">FiniteElement</a> to use to describe the geometry. If no mask is specified at construction time, then a default one is used, i.e., the first spacedim components of the <a class="el" href="classFiniteElement.html">FiniteElement</a> are assumed to represent the geometry of the problem.</p>
<p>This function is only implemented for FiniteElements where the specified components are primitive.</p>
<dl class="section author"><dt>Author</dt><dd>Luca Heltai, 2015 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
