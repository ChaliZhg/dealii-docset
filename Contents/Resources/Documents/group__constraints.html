<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Constraints on degrees of freedom</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Constraints on degrees of freedom<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Constraints on degrees of freedom:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__constraints.svg" width="459" height="50"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Sparsity pattern generation</h2></td></tr>
<tr class="memitem:ga38d88a1a559e9fc65d60f3e168921ba5"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga38d88a1a559e9fc65d60f3e168921ba5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (const DoFHandlerType &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>(), const bool keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:ga38d88a1a559e9fc65d60f3e168921ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ec1ee2ac7c86b16700022b704b69c8"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga33ec1ee2ac7c86b16700022b704b69c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga33ec1ee2ac7c86b16700022b704b69c8">DoFTools::make_sparsity_pattern</a> (const DoFHandlerType &amp;dof_handler, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;coupling, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints=<a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>(), const bool keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:ga33ec1ee2ac7c86b16700022b704b69c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff02f744dd1e598c12dce9b9db76d115"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:gaff02f744dd1e598c12dce9b9db76d115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> (const DoFHandlerType &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:gaff02f744dd1e598c12dce9b9db76d115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd002a45af5a826d13b707df9196e1d1"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:gafd002a45af5a826d13b707df9196e1d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gafd002a45af5a826d13b707df9196e1d1">DoFTools::make_flux_sparsity_pattern</a> (const DoFHandlerType &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const bool keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gafd002a45af5a826d13b707df9196e1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4509f3b692f2e92b6a254421a47c398f"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga4509f3b692f2e92b6a254421a47c398f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga4509f3b692f2e92b6a254421a47c398f">DoFTools::make_flux_sparsity_pattern</a> (const DoFHandlerType &amp;dof, SparsityPatternType &amp;sparsity, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;cell_integrals_mask, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;face_integrals_mask, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:ga4509f3b692f2e92b6a254421a47c398f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0325952967bc36bb8314eb10922c0516"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga0325952967bc36bb8314eb10922c0516"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga0325952967bc36bb8314eb10922c0516">DoFTools::make_sparsity_pattern</a> (const DoFHandlerType &amp;dof_row, const DoFHandlerType &amp;dof_col, SparsityPatternType &amp;sparsity)</td></tr>
<tr class="separator:ga0325952967bc36bb8314eb10922c0516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e6fde9a62ec980a910fb83d29c7221"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga13e6fde9a62ec980a910fb83d29c7221"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga13e6fde9a62ec980a910fb83d29c7221">DoFTools::make_flux_sparsity_pattern</a> (const DoFHandlerType &amp;dof, SparsityPatternType &amp;sparsity, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const bool keep_constrained_dofs, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;couplings, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;face_couplings, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id)</td></tr>
<tr class="separator:ga13e6fde9a62ec980a910fb83d29c7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26118f9936a251b465a6391fe40ec9d4"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga26118f9936a251b465a6391fe40ec9d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga26118f9936a251b465a6391fe40ec9d4">DoFTools::make_boundary_sparsity_pattern</a> (const DoFHandlerType &amp;dof, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga26118f9936a251b465a6391fe40ec9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga092ce6ed09ae5ec3c6d758d46d79320a"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:ga092ce6ed09ae5ec3c6d758d46d79320a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga092ce6ed09ae5ec3c6d758d46d79320a">DoFTools::make_boundary_sparsity_pattern</a> (const DoFHandlerType &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; DoFHandlerType::space_dimension, number &gt; *&gt; &amp;boundary_ids, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, SparsityPatternType &amp;sparsity)</td></tr>
<tr class="separator:ga092ce6ed09ae5ec3c6d758d46d79320a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Hanging nodes and other constraints</h2></td></tr>
<tr class="memitem:ga3eaa31a679484e80c193e74e8a967dc8"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ga3eaa31a679484e80c193e74e8a967dc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (const DoFHandlerType &amp;dof_handler, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints)</td></tr>
<tr class="separator:ga3eaa31a679484e80c193e74e8a967dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf101e71f1ed2458bbbfd94e6bf96594"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gacf101e71f1ed2458bbbfd94e6bf96594"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gacf101e71f1ed2458bbbfd94e6bf96594">DoFTools::compute_intergrid_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned int coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned int fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt; &amp;coarse_to_fine_grid_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints)</td></tr>
<tr class="separator:gacf101e71f1ed2458bbbfd94e6bf96594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga024b972c7426a7cae7c7d4a1037f6723"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga024b972c7426a7cae7c7d4a1037f6723"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga024b972c7426a7cae7c7d4a1037f6723">DoFTools::compute_intergrid_transfer_representation</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned int coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned int fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt; &amp;coarse_to_fine_grid_map, std::vector&lt; std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, float &gt; &gt; &amp;transfer_representation)</td></tr>
<tr class="separator:ga024b972c7426a7cae7c7d4a1037f6723"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Miscellaneous</h2></td></tr>
<tr class="memitem:gaa2268fcc4cc5295e084a87f423989273"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:gaa2268fcc4cc5295e084a87f423989273"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa2268fcc4cc5295e084a87f423989273">DoFTools::make_zero_boundary_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_id, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaa2268fcc4cc5295e084a87f423989273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a486449ec11cef8346f04f16ee9db7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:gac8a486449ec11cef8346f04f16ee9db7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gac8a486449ec11cef8346f04f16ee9db7">DoFTools::make_zero_boundary_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gac8a486449ec11cef8346f04f16ee9db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Indirectly applying constraints to LinearOperator</h2></td></tr>
<tr class="memitem:gab4b8d59b61a2d51242f62a8efb0b027f"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain &gt; </td></tr>
<tr class="memitem:gab4b8d59b61a2d51242f62a8efb0b027f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gab4b8d59b61a2d51242f62a8efb0b027f">distribute_constraints_linear_operator</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; &amp;exemplar)</td></tr>
<tr class="separator:gab4b8d59b61a2d51242f62a8efb0b027f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c3344899778735f7d68db5875ec2cb1"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain &gt; </td></tr>
<tr class="memitem:ga3c3344899778735f7d68db5875ec2cb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3c3344899778735f7d68db5875ec2cb1">project_to_constrained_linear_operator</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga3c3344899778735f7d68db5875ec2cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c2f70370213d436cb9fade9d813478"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain &gt; </td></tr>
<tr class="memitem:ga59c2f70370213d436cb9fade9d813478"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga59c2f70370213d436cb9fade9d813478">constrained_linear_operator</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; &amp;linop)</td></tr>
<tr class="separator:ga59c2f70370213d436cb9fade9d813478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84aae431c14515ad113f480541a22b96"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain &gt; </td></tr>
<tr class="memitem:ga84aae431c14515ad113f480541a22b96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga84aae431c14515ad113f480541a22b96">constrained_right_hand_side</a> (const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint_matrix, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; &amp;linop, const Range &amp;right_hand_side)</td></tr>
<tr class="separator:ga84aae431c14515ad113f480541a22b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interpolation and projection</h2></td></tr>
<tr class="memitem:gace3954be8b172fbcd05a94aba0cd6f40"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:gace3954be8b172fbcd05a94aba0cd6f40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gace3954be8b172fbcd05a94aba0cd6f40">VectorTools::interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gace3954be8b172fbcd05a94aba0cd6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ef59a87a974d1e8cde1a579d4f327a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:gaf8ef59a87a974d1e8cde1a579d4f327a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf8ef59a87a974d1e8cde1a579d4f327a">VectorTools::interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaf8ef59a87a974d1e8cde1a579d4f327a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2376b9a282a2b62be5c55ab62a11a132"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:ga2376b9a282a2b62be5c55ab62a11a132"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga2376b9a282a2b62be5c55ab62a11a132">VectorTools::interpolate_boundary_values</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga2376b9a282a2b62be5c55ab62a11a132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa78c814d6a60e060c0668add0f135e84"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </td></tr>
<tr class="memitem:gaa78c814d6a60e060c0668add0f135e84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa78c814d6a60e060c0668add0f135e84">VectorTools::interpolate_boundary_values</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaa78c814d6a60e060c0668add0f135e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4201210dcce9a263f773209ac1775c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga5b4201210dcce9a263f773209ac1775c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5b4201210dcce9a263f773209ac1775c">VectorTools::project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, std::vector&lt; unsigned int &gt; component_mapping=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:ga5b4201210dcce9a263f773209ac1775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c57b25aa60c906ab463dbe5ca49ec82"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga2c57b25aa60c906ab463dbe5ca49ec82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga2c57b25aa60c906ab463dbe5ca49ec82">VectorTools::project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;q, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, std::vector&lt; unsigned int &gt; component_mapping=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:ga2c57b25aa60c906ab463dbe5ca49ec82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c6685360c01c9c46eeb7575e8ef68ac"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga1c6685360c01c9c46eeb7575e8ef68ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1c6685360c01c9c46eeb7575e8ef68ac">VectorTools::project_boundary_values_curl_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga1c6685360c01c9c46eeb7575e8ef68ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5ab15402b144e80122ee983f76a4cd4"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gac5ab15402b144e80122ee983f76a4cd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gac5ab15402b144e80122ee983f76a4cd4">VectorTools::project_boundary_values_curl_conforming</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gac5ab15402b144e80122ee983f76a4cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fca3672ae63b249402460a6ed4538b4"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga6fca3672ae63b249402460a6ed4538b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga6fca3672ae63b249402460a6ed4538b4">VectorTools::project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga6fca3672ae63b249402460a6ed4538b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76f7bb9461f7a8be8da482d8198673f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaa76f7bb9461f7a8be8da482d8198673f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa76f7bb9461f7a8be8da482d8198673f">VectorTools::project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gaa76f7bb9461f7a8be8da482d8198673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86427a4e8b3a7e580dabb4e473005288"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga86427a4e8b3a7e580dabb4e473005288"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga86427a4e8b3a7e580dabb4e473005288">VectorTools::project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga86427a4e8b3a7e580dabb4e473005288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64db6ce0b7b31453e1ddac86ae4d04c9"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga64db6ce0b7b31453e1ddac86ae4d04c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga64db6ce0b7b31453e1ddac86ae4d04c9">VectorTools::project_boundary_values_div_conforming</a> (const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const unsigned int first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> boundary_component, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:ga64db6ce0b7b31453e1ddac86ae4d04c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b13c2da1b235c86cdbce2270525db99"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:ga5b13c2da1b235c86cdbce2270525db99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5b13c2da1b235c86cdbce2270525db99">VectorTools::compute_nonzero_normal_flux_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga5b13c2da1b235c86cdbce2270525db99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8d8c017ac654e24e71ad3fd7e76310"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:ga0e8d8c017ac654e24e71ad3fd7e76310"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">VectorTools::compute_no_normal_flux_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga0e8d8c017ac654e24e71ad3fd7e76310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a2c92faece22a1a7c8631a75d4a2f0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:ga83a2c92faece22a1a7c8631a75d4a2f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga83a2c92faece22a1a7c8631a75d4a2f0">VectorTools::compute_nonzero_tangential_flux_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;function_map, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga83a2c92faece22a1a7c8631a75d4a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga113d79605138e344578261503ed342d1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </td></tr>
<tr class="memitem:ga113d79605138e344578261503ed342d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga113d79605138e344578261503ed342d1">VectorTools::compute_normal_flux_constraints</a> (const DoFHandlerType&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::mapping)</td></tr>
<tr class="separator:ga113d79605138e344578261503ed342d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module deals with constraints on degrees of freedom. The central class to deal with constraints is the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class.</p>
<p>Constraints typically come from several sources, for example:</p><ul>
<li>If you have Dirichlet-type boundary conditions, <img class="formulaInl" alt="$u|_{\partial\Omega}=g$" src="form_2.png"/>, one usually enforces them by requiring that degrees of freedom on the boundary have particular values, for example <img class="formulaInl" alt="$x_{12}=42$" src="form_3.png"/> if the boundary condition <img class="formulaInl" alt="$g(\mathbf x)$" src="form_4.png"/> requires that the finite element solution <img class="formulaInl" alt="$u(\mathbf x)$" src="form_5.png"/> at the location of degree of freedom 12 has the value 42. Such constraints are generated by those versions of the <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> function that take a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> argument (though there are also other ways of dealing with Dirichlet conditions, using <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>, see for example <a class="el" href="step_3.html">step-3</a> and <a class="el" href="step_4.html">step-4</a>).</li>
<li>If you have boundary conditions that set a certain part of the solution's value, for example no normal flux, <img class="formulaInl" alt="$\mathbf n \cdot \mathbf u=0$" src="form_6.png"/> (as happens in flow problems and is handled by the <a class="el" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">VectorTools::compute_no_normal_flux_constraints</a> function) or prescribed tangential components, <img class="formulaInl" alt="$\mathbf{n}\times\mathbf{u}= \mathbf{n}\times\mathbf{f}$" src="form_7.png"/> (as happens in electromagnetic problems and is handled by the <a class="el" href="group__constraints.html#ga1c6685360c01c9c46eeb7575e8ef68ac">VectorTools::project_boundary_values_curl_conforming</a> function). For the former case, imagine for example that we are at at vertex where the normal vector has the form <img class="formulaInl" alt="$\frac 1{\sqrt{14}} (1,2,3)^T$" src="form_8.png"/> and that the <img class="formulaInl" alt="$x$" src="form_9.png"/>-, <img class="formulaInl" alt="$y$" src="form_10.png"/>- and <img class="formulaInl" alt="$z$" src="form_11.png"/>-components of the flow field at this vertex are associated with degrees of freedom 12, 28, and 40. Then the no-normal-flux condition means that we need to have the condition <img class="formulaInl" alt="$\frac 1{\sqrt{14}} (x_{12}+2x_{28}+3x_{40})=0$" src="form_12.png"/>. The prescribed tangential component leads to similar constraints though there is often something on the right hand side.</li>
<li>If you have hanging node constraints, for example in a mesh like this: <div class="image">
<img src="hanging_nodes.png" alt="hanging_nodes.png"/>
</div>
 Let's assume the bottom right one of the two red degrees of freedom is <img class="formulaInl" alt="$x_{12}$" src="form_13.png"/> and that the two yellow neighbors on its left and right are <img class="formulaInl" alt="$x_{28}$" src="form_14.png"/> and <img class="formulaInl" alt="$x_{40}$" src="form_15.png"/>. Then, requiring that the finite element function be continuous is equivalent to requiring that <img class="formulaInl" alt="$x_{12}= \frac 12 (x_{28}+x_{40})$" src="form_16.png"/>. A similar situation occurs in the context of hp adaptive finite element methods. For example, when using Q1 and Q2 elements (i.e. using <a class="el" href="classFE__Q.html">FE_Q(1)</a> and <a class="el" href="classFE__Q.html">FE_Q(2)</a>) on the two marked cells of the mesh <div class="image">
<img src="hp-refinement-simple.png" alt="hp-refinement-simple.png"/>
</div>
 there are three constraints: first <img class="formulaInl" alt="$x_2=\frac 12 x_0 + \frac 12 x_1$" src="form_17.png"/>, then <img class="formulaInl" alt="$x_4=\frac 14 x_0 + \frac 34 x_1$" src="form_18.png"/>, and finally the identity <img class="formulaInl" alt="$x_3=x_1$" src="form_19.png"/>. Similar constraints occur as hanging nodes even if all cells used the same finite elements. In all of these cases, you would use the <a class="el" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> function to compute such constraints.</li>
<li>Other linear constraints, for example when you try to impose a certain average value for a problem that would otherwise not have a unique solution. An example of this is given in the <a class="el" href="step_11.html">step-11</a> tutorial program.</li>
</ul>
<p>In all of these examples, constraints on degrees of freedom are linear and possibly inhomogeneous. In other words, the always have the form <img class="formulaInl" alt="$x_{i_1} = \sum_{j=2}^M a_{i_j} x_{i_j} + b_i$" src="form_20.png"/>. The deal.II class that deals with storing and using these constraints is <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. The naming stems from the fact that the class originally only stored the (sparse) matrix <img class="formulaInl" alt="$a_{i_j}$" src="form_21.png"/>. The class name component "matrix" no longer makes much sense today since the class has learned to also deal with inhomogeneities <img class="formulaInl" alt="$b_i$" src="form_22.png"/>.</p>
<h3>Eliminating constraints</h3>
<p>When building the global system matrix and the right hand sides, one can build them without taking care of the constraints, i.e. by simply looping over cells and adding the local contributions to the global matrix and right hand side objects. In order to do actual calculations, you have to 'condense' the linear system: eliminate constrained degrees of freedom and distribute the appropriate values to the unconstrained dofs. This changes the sparsity pattern of the sparse matrices used in finite element calculations and is thus a quite expensive operation. The general scheme of things is then that you build your system, you eliminate (condense) away constrained nodes using the <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a> functions, then you solve the remaining system, and finally you compute the values of constrained nodes from the values of the unconstrained ones using the <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> function. Note that the <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a> function is applied to matrix and right hand side of the linear system, while the <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> function is applied to the solution vector. This is the method used in the first few tutorial programs, see for example <a class="el" href="step_6.html">step-6</a>.</p>
<p>This scheme of first building a linear system and then eliminating constrained degrees of freedom is inefficient, and a bottleneck if there are many constraints and matrices are full, i.e. especially for 3d and/or higher order or hp finite elements. Furthermore, it is impossible to implement for parallel computations where a process may not have access to elements of the matrix. We therefore offer a second way of building linear systems, using the <a class="el" href="classConstraintMatrix.html#ac42f9aba996e2528dc152497eac08dd8">ConstraintMatrix::add_entries_local_to_global()</a> and <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global()</a> functions discussed below. The resulting linear systems are equivalent to those one gets after calling the <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a> functions.</p>
<dl class="section note"><dt>Note</dt><dd>Both ways of applying constraints set the value of the matrix diagonals to constrained entries to a <em>positive</em> entry of the same magnitude as the other entries in the matrix. As a consequence, you need to set up your problem such that the weak form describing the main matrix contribution is not <em>negative definite</em>. Otherwise, iterative solvers such as CG will break down or be considerably slower as GMRES.</dd>
<dd>
While these two ways are <em>equivalent</em>, i.e., the solution of linear systems computed via either approach is the same, the linear systems themselves do not necessarily have the same matrix and right hand side vector entries. Specifically, the matrix diagonal and right hand side entries corresponding to constrained degrees of freedom may be different as a result of the way in which we compute them; they are, however, always chosen in such a way that the solution to the linear system is the same.</dd></dl>
<h4>Condensing matrices and sparsity patterns</h4>
<p>As mentioned above, the first way of using constraints is to build linear systems without regards to constraints and then "condensing" them away. Condensation of a matrix is done in four steps:</p><ul>
<li>first one builds the sparsity pattern (e.g. using <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern()</a>);</li>
<li>then the sparsity pattern of the condensed matrix is made out of the original sparsity pattern and the constraints;</li>
<li>third, the global matrix is assembled;</li>
<li>and fourth, the matrix is finally condensed.</li>
</ul>
<p>In the condensation process, we are not actually changing the number of rows or columns of the sparsity pattern, matrix, and vectors. Instead, the condense functions add nonzero entries to the sparsity pattern of the matrix (with constrained nodes in it) where the condensation process of the matrix will create additional nonzero elements. In the condensation process itself, rows and columns subject to constraints are distributed to the rows and columns of unconstrained nodes. The constrained degrees of freedom remain in place. In order not to disturb the solution process, these rows and columns are filled with zeros and an appropriate positive value on the main diagonal (we choose an average of the magnitudes of the other diagonal elements, so as to make sure that the new diagonal entry has the same order of magnitude as the other entries; this preserves the scaling properties of the matrix). The corresponding value in the right hand sides is set to zero. This way, the constrained node will always get the value zero upon solution of the equation system and will not couple to other nodes any more.</p>
<p>Keeping the entries in the matrix has the advantage over creating a new and smaller matrix, that only one matrix and sparsity pattern is needed thus less memory is required. Additionally, the condensation process is less expensive, since not all but only constrained values in the matrix have to be copied. On the other hand, the solution process will take a bit longer, since matrix vector multiplications will incur multiplications with zeroes in the lines subject to constraints. Additionally, the vector size is larger, resulting in more memory consumption for those iterative solution methods using a larger number of auxiliary vectors (e.g. methods using explicit orthogonalization procedures). Nevertheless, this process is more efficient due to its lower memory consumption and is discussed in the first few programs of the <a class="el" href="Tutorial.html">Tutorial programs</a> , for example in <a class="el" href="step_6.html">step-6</a>.</p>
<p>The condensation functions exist for different argument types: <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classSparseMatrix.html">SparseMatrix</a> and <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>. Note that there are no versions for arguments of type <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix()</a> or any of the other PETSc or Trilinos matrix wrapper classes. This is due to the fact that it is relatively hard to get a representation of the sparsity structure of PETSc matrices, and to modify them efficiently; this holds in particular, if the matrix is actually distributed across a cluster of computers. If you want to use PETSc/Trilinos matrices, you can either copy an already condensed deal.II matrix, or assemble the PETSc/Trilinos matrix in the already condensed form, see the discussion below.</p>
<h5>Condensing vectors</h5>
<p>Condensing vectors works exactly as described above for matrices. Note that condensation is an idempotent operation, i.e. doing it more than once on a vector or matrix yields the same result as doing it only once: once an object has been condensed, further condensation operations don't change it any more.</p>
<p>In contrast to the matrix condensation functions, the vector condensation functions exist in variants for PETSc and Trilinos vectors. However, using them is typically expensive, and should be avoided. You should use the same techniques as mentioned above to avoid their use.</p>
<h4>Avoiding explicit condensation</h4>
<p>Sometimes, one wants to avoid explicit condensation of a linear system after it has been built at all. There are two main reasons for wanting to do so:</p>
<ul>
<li>
<p class="startli">Condensation is an expensive operation, in particular if there are many constraints and/or if the matrix has many nonzero entries. Both is typically the case for 3d, or high polynomial degree computations, as well as for hp finite element methods, see for example the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a>. This is the case discussed in the hp tutorial program, <a class="el" href="step_27.html">step-27</a>, as well as in <a class="el" href="step_22.html">step-22</a> and <a class="el" href="step_31.html">step-31</a>.</p>
<p class="endli"></p>
</li>
<li>
There may not be a <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a> function for the matrix you use (this is, for example, the case for the PETSc and Trilinos wrapper classes where we have no access to the underlying representation of the matrix, and therefore cannot efficiently implement the <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a> operation). This is the case discussed in <a class="el" href="step_17.html">step-17</a>, <a class="el" href="step_18.html">step-18</a>, <a class="el" href="step_31.html">step-31</a>, and <a class="el" href="step_32.html">step-32</a>. </li>
</ul>
<p>In this case, one possibility is to distribute local entries to the final destinations right at the moment of transferring them into the global matrices and vectors, and similarly build a sparsity pattern in the condensed form at the time it is set up originally.</p>
<p>The <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class offers support for these operations as well. For example, the <a class="el" href="classConstraintMatrix.html#ac42f9aba996e2528dc152497eac08dd8">ConstraintMatrix::add_entries_local_to_global()</a> function adds nonzero entries to a sparsity pattern object. It not only adds a given entry, but also all entries that we will have to write to if the current entry corresponds to a constrained degree of freedom that will later be eliminated. Similarly, one can use the <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global()</a> functions to directly distribute entries in vectors and matrices when copying local contributions into a global matrix or vector. These calls make a subsequent call to <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a> unnecessary. For examples of their use see the tutorial programs referenced above.</p>
<p>Note that, despite their name which describes what the function really does, the <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global()</a> functions has to be applied to matrices and right hand side vectors, whereas the <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> function discussed below is applied to the solution vector after solving the linear system.</p>
<h3>Distributing constraints</h3>
<p>After solving the condensed system of equations, the solution vector has to be "distributed": the modification to the original linear system that results from calling <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense</a> leads to a linear system that solves correctly for all degrees of freedom that are unconstrained but leaves the values of constrained degrees of freedom undefined. To get the correct values also for these degrees of freedom, you need to "distribute" the unconstrained values also to their constrained colleagues. This is done by the <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> function. The operation of distribution undoes the condensation process in some sense, but it should be noted that it is not the inverse operation. Basically, distribution sets the values of the constrained nodes to the value that is computed from the constraint given the values of the unconstrained nodes plus possible inhomogeneities.</p>
<h3>Treatment of inhomogeneous constraints</h3>
<p>In case some constraint lines have inhomogeneities (which is typically the case if the constraint comes from implementation of inhomogeneous boundary conditions), the situation is a bit more complicated than if the only constraints were due to hanging nodes alone. This is because the elimination of the non-diagonal values in the matrix generate contributions in the eliminated rows in the vector. This means that inhomogeneities can only be handled with functions that act simultaneously on a matrix and a vector. This means that all inhomogeneities are ignored in case the respective condense function is called without any matrix (or if the matrix has already been condensed before).</p>
<p>The use of <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> for implementing Dirichlet boundary conditions is discussed in the <a class="el" href="step_22.html">step-22</a> tutorial program. A further example that applies the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> is <a class="el" href="step_41.html">step-41</a>. The situation here is little more complicated, because there we have some constraints which are not at the boundary. There are two ways to apply inhomogeneous constraints after creating the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>:</p>
<p>First approach:</p><ul>
<li>Apply the <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global()</a> function to the system matrix and the right-hand-side with the parameter use_inhomogeneities_for_rhs = false (i.e., the default)</li>
<li>Set the solution to zero in the inhomogeneous constrained components using the <a class="el" href="classConstraintMatrix.html#a5a4f1186dc10d707b933b6ff24f7cad8">ConstraintMatrix::set_zero()</a> function (or start with a solution vector equal to zero)</li>
<li>solve() the linear system</li>
<li>Apply <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> to the solution</li>
</ul>
<p>Second approach:</p><ul>
<li>Use the <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global()</a> function with the parameter use_inhomogeneities_for_rhs = true and apply it to the system matrix and the right-hand-side</li>
<li>Set the concerning components of the solution to the inhomogeneous constrained values (for example using <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a>)</li>
<li>solve() the linear system</li>
<li>Depending on the solver now you have to apply the <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> function to the solution, because the solver could change the constrained values in the solution. For a Krylov based solver this should not be strictly necessary, but it is still possible that there is a difference between the inhomogeneous value and the solution value in the order of machine precision, and you may want to call <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> anyway if you have additional constraints such as from hanging nodes.</li>
</ul>
<p>Of course, both approaches lead to the same final answer but in different ways. Using the first approach (i.e., when using use_inhomogeneities_for_rhs = false in <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global()</a>), the linear system we build has zero entries in the right hand side in all those places where a degree of freedom is constrained, and some positive value on the matrix diagonal of these lines. Consequently, the solution vector of the linear system will have a zero value for inhomogeneously constrained degrees of freedom and we need to call <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> to give these degrees of freedom their correct nonzero values.</p>
<p>On the other hand, in the second approach, the matrix diagonal element and corresponding right hand side entry for inhomogeneously constrained degrees of freedom are so that the solution of the linear system already has the correct value (e.g., if the constraint is that <img class="formulaInl" alt="$x_{13}=42$" src="form_23.png"/> then row <img class="formulaInl" alt="$13$" src="form_24.png"/> if the matrix is empty with the exception of the diagonal entry, and <img class="formulaInl" alt="$b_{13}/A_{13,13}=42$" src="form_25.png"/> so that the solution of <img class="formulaInl" alt="$Ax=b$" src="form_26.png"/> must satisfy <img class="formulaInl" alt="$x_{13}=42$" src="form_23.png"/> as desired). As a consequence, we do not need to call <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> after solving to fix up inhomogeneously constrained components of the solution, though there is also no harm in doing so.</p>
<p>There remains the question of which of the approaches to take and why we need to set to zero the values of the solution vector in the first approach. The answer to both questions has to do with how iterative solvers solve the linear system. To this end, consider that we typically stop iterations when the residual has dropped below a certain fraction of the norm of the right hand side, or, alternatively, a certain fraction of the norm of the initial residual. Now consider this:</p>
<ul>
<li>In the first approach, the right hand side entries for constrained degrees of freedom are zero, i.e., the norm of the right hand side really only consists of those parts that we care about. On the other hand, if we start with a solution vector that is not zero in constrained entries, then the initial residual is very large because the value that is currently in the solution vector does not match the solution of the linear system (which is zero in these components). Thus, if we stop iterations once we have reduced the initial residual by a certain factor, we may reach the threshold after a single iteration because constrained degrees of freedom are resolved by iterative solvers in just one iteration. If the initial residual was dominated by these degrees of freedom, then we see a steep reduction in the first step although we did not really make much progress on the remainder of the linear system in this just one iteration. We can avoid this problem by either stopping iterations once the norm of the residual reaches a certain fraction of the <em>norm of the right hand side</em>, or we can set the solution components to zero (thus reducing the initial residual) and iterating until we hit a certain fraction of the <em>norm of the initial residual</em>.</li>
<li>In the second approach, we get the same problem if the starting vector in the iteration is zero, since then the residual may be dominated by constrained degrees of freedom having values that do not match the values we want for them at the solution. We can again circumvent this problem by setting the corresponding elements of the solution vector to their correct values, by calling <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> <em>before</em> solving the linear system (and then, as necessary, a second time after solving).</li>
</ul>
<p>In addition to these considerations, consider the case where we have inhomogeneous constraints of the kind <img class="formulaInl" alt="$x_{3}=\tfrac 12 x_1 + \tfrac 12$" src="form_27.png"/>, e.g., from a hanging node constraint of the form <img class="formulaInl" alt="$x_{3}=\tfrac 12 (x_1 + x_2)$" src="form_28.png"/> where <img class="formulaInl" alt="$x_2$" src="form_29.png"/> is itself constrained by boundary values to <img class="formulaInl" alt="$x_2=1$" src="form_30.png"/>. In this case, the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> can of course not figure out what the final value of <img class="formulaInl" alt="$x_3$" src="form_31.png"/> should be and, consequently, can not set the solution vector's third component correctly. Thus, the second approach will not work and you should take the first.</p>
<h3>Dealing with conflicting constraints</h3>
<p>There are situations where degrees of freedom are constrained in more than one way, and sometimes in conflicting ways. Consider, for example the following situation: </p><div class="image">
<img src="conflicting_constraints.png" alt="conflicting_constraints.png"/>
</div>
<p>Here, degree of freedom <img class="formulaInl" alt="$x_0$" src="form_32.png"/> marked in blue is a hanging node. If we used trilinear finite elements, i.e. <a class="el" href="classFE__Q.html">FE_Q(1)</a>, then it would carry the constraint <img class="formulaInl" alt="$x_0=\frac 12 (x_{1}+x_{2})$" src="form_33.png"/>. On the other hand, it is at the boundary, and if we have imposed boundary conditions <img class="formulaInl" alt="$u|_{\partial\Omega}=g$" src="form_2.png"/> then we will have the constraint <img class="formulaInl" alt="$x_0=g_0$" src="form_34.png"/> where <img class="formulaInl" alt="$g_0$" src="form_35.png"/> is the value of the boundary function <img class="formulaInl" alt="$g(\mathbf x)$" src="form_4.png"/> at the location of this degree of freedom.</p>
<p>So, which one will win? Or maybe: which one <em>should</em> win? There is no good answer to this question:</p><ul>
<li>If the hanging node constraint is the one that is ultimately enforced, then the resulting solution does not satisfy boundary conditions any more for general boundary functions <img class="formulaInl" alt="$g$" src="form_36.png"/>.</li>
<li>If it had been done the other way around, the solution would not satisfy hanging node constraints at this point and consequently would not satisfy the regularity properties of the element chosen (e.g. would not be continuous despite using a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> element).</li>
<li>The situation becomes completely hopeless if you consider curved boundaries since then the edge midpoint (i.e. the hanging node) does in general not lie on the mother edge. Consequently, the solution will not be <img class="formulaInl" alt="$H^1$" src="form_38.png"/> conforming anyway, regardless of the priority of the two competing constraints. If the hanging node constraint wins, then the solution will be neither conforming, nor have the right boundary values. In other words, it is not entirely clear what the "correct" solution would be. In most cases, it will not matter much: in either case, the error introduced either by the non-conformity or the incorrect boundary values will be at worst at the same order as the discretization's overall error.</li>
</ul>
<p>That said, what should you do if you know what you want is this:</p><ul>
<li>If you want the hanging node constraints to win, then first build these through the <a class="el" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints()</a> function. Then interpolate the boundary values using <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values()</a> into the same <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object. If the latter function encounters a boundary node that already is constrained, it will simply ignore the boundary values at this node and leave the constraint untouched.</li>
<li>If you want the boundary value constraint to win, build the hanging node constraints as above and use these to assemble the matrix using the <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global()</a> function (or, alternatively, assemble the matrix and then use <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a> on it). In a second step, use the <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values()</a> function that returns a std::map and use it as input for <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> to set boundary nodes to their correct value.</li>
</ul>
<p>Either behavior can also be achieved by building two separate <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> objects and calling <a class="el" href="classConstraintMatrix.html#aa471ba15f320b700280ab5e5ac59d88b">ConstraintMatrix::merge</a> function with a particular second argument.</p>
<h3>Applying constraints indirectly with a <a class="el" href="classLinearOperator.html">LinearOperator</a></h3>
<p>Sometimes it is either not desirable, or not possible to directly condense, or eliminate constraints from a system of linear equations. In particular if there is no underlying matrix object that could be condensed (or taken care of constraints during assembly). This is usually the case if the system is described by a <a class="el" href="classLinearOperator.html">LinearOperator</a>.</p>
<p>In this case we can solve the modified system </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (C^T A C + Id_c) \tilde x = C^T (b - A\,k) \]" src="form_39.png"/>
</p>
<p> instead [1] (M. S. Shephard. Linear multipoint constraints applied via transformation as part of a direct stiffness assembly process. <em>International Journal for Numerical Methods in Engineering</em> 20(11):2107-2112, 1985).</p>
<p>Here, <img class="formulaInl" alt="$A$" src="form_40.png"/> is a given (unconstrained) system matrix for which we only assume that we can apply it to a vector but can not necessarily access individual matrix entries. <img class="formulaInl" alt="$b$" src="form_41.png"/> is the corresponding right hand side of a system of linear equations <img class="formulaInl" alt="$A\,x=b$" src="form_42.png"/>. The matrix <img class="formulaInl" alt="$C$" src="form_43.png"/> describes the homogeneous part of the linear constraints stored in a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> and the vector <img class="formulaInl" alt="$k$" src="form_44.png"/> is the vector of corresponding inhomogeneities. More precisely, the <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> operation applied on a vector <img class="formulaInl" alt="$x$" src="form_9.png"/> is the operation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x \leftarrow C\,x+k. \]" src="form_45.png"/>
</p>
<p> And finally, <img class="formulaInl" alt="$Id_c$" src="form_46.png"/> denotes the identity on the subspace of constrained degrees of freedom.</p>
<p>The corresponding solution of <img class="formulaInl" alt="$A\,x=b$" src="form_42.png"/> that obeys these constraints is then recovered by distributing constraints: <img class="formulaInl" alt="$x=C\tilde x+k$" src="form_47.png"/>.</p>
<p>The whole system can be set up and solved with the following snippet of code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constrained_linear_operator.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// system_matrix     - unconstrained and assembled system matrix</span></div><div class="line"><span class="comment">// right_hand_side   - unconstrained and assembled right hand side</span></div><div class="line"><span class="comment">// constraint_matrix - a ConstraintMatrix object</span></div><div class="line"><span class="comment">// solver            - an appropriate, iterative solver</span></div><div class="line"><span class="comment">// preconditioner    - a preconditioner</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_a = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(system_matrix);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_amod = <a class="code" href="group__constraints.html#ga59c2f70370213d436cb9fade9d813478">constrained_linear_operator</a>(constraint_matrix, op_a);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> rhs_mod = <a class="code" href="group__constraints.html#ga84aae431c14515ad113f480541a22b96">constrained_right_hand_side</a>(constraint_matrix,</div><div class="line">                                                     op_a,</div><div class="line">                                                     right_hand_side);</div><div class="line"></div><div class="line">solver.solve(op_amod, solution, rhs_mod, preconditioner);</div><div class="line">constraint_matrix.distribute(solution);</div></div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a id="ga38d88a1a559e9fc65d60f3e168921ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38d88a1a559e9fc65d60f3e168921ba5">&#9670;&nbsp;</a></span>make_sparsity_pattern() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute which entries of a matrix built on the given <code>dof_handler</code> may possibly be nonzero, and create a sparsity pattern object that represents these nonzero locations.</p>
<p>This function computes the possible positions of non-zero entries in the global system matrix by <em>simulating</em> which entries one would write to during the actual assembly of a matrix. For this, the function assumes that each finite element basis function is non-zero on a cell only if its degree of freedom is associated with the interior, a face, an edge or a vertex of this cell. As a result, a matrix entry <img class="formulaInl" alt="$A_{ij}$" src="form_530.png"/> that is computed from two basis functions <img class="formulaInl" alt="$\varphi_i$" src="form_531.png"/> and <img class="formulaInl" alt="$\varphi_j$" src="form_532.png"/> with (global) indices <img class="formulaInl" alt="$i$" src="form_90.png"/> and <img class="formulaInl" alt="$j$" src="form_513.png"/> (for example, using a bilinear form <img class="formulaInl" alt="$A_{ij}=a(\varphi_i,\varphi_j)$" src="form_533.png"/>) can be non-zero only if these shape functions correspond to degrees of freedom that are defined on at least one common cell. Therefore, this function just loops over all cells, figures out the global indices of all degrees of freedom, and presumes that all matrix entries that couple any of these indices will result in a nonzero matrix entry. These will then be added to the sparsity pattern. As this process of generating the sparsity pattern does not take into account the equation to be solved later on, the resulting sparsity pattern is symmetric.</p>
<p>This algorithm makes no distinction between shape functions on each cell, i.e., it simply couples all degrees of freedom on a cell with all other degrees of freedom on a cell. This is often the case, and always a safe assumption. However, if you know something about the structure of your operator and that it does not couple certain shape functions with certain test functions, then you can get a sparser sparsity pattern by calling a variant of the current function described below that allows to specify which vector components couple with which other vector components.</p>
<p>The method described above lives on the assumption that coupling between degrees of freedom only happens if shape functions overlap on at least one cell. This is the case with most usual finite element formulations involving conforming elements. However, for formulations such as the Discontinuous Galerkin finite element method, the bilinear form contains terms on interfaces between cells that couple shape functions that live on one cell with shape functions that live on a neighboring cell. The current function would not see these couplings, and would consequently not allocate entries in the sparsity pattern. You would then get into trouble during matrix assembly because you try to write into matrix entries for which no space has been allocated in the sparsity pattern. This can be avoided by calling the <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern()</a> function instead, which takes into account coupling between degrees of freedom on neighboring cells.</p>
<p>There are other situations where bilinear forms contain non-local terms, for example in treating integral equations. These require different methods for building the sparsity patterns that depend on the exact formulation of the problem. You will have to do this yourself then.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> object that describes which degrees of freedom live on which cells.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sparsity_pattern</td><td>The sparsity pattern to be filled with entries.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints</td><td>The process for generating entries described above is purely local to each cell. Consequently, the sparsity pattern does not provide for matrix entries that will only be written into during the elimination of hanging nodes or other constraints. They have to be taken care of by a subsequent call to <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a>. Alternatively, the constraints on degrees of freedom can already be taken into account at the time of creating the sparsity pattern. For this, pass the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object as the third argument to the current function. No call to <a class="el" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">ConstraintMatrix::condense()</a> is then necessary. This process is explained in <a class="el" href="step_6.html">step-6</a>, <a class="el" href="step_27.html">step-27</a>, and other tutorial programs.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_constrained_dofs</td><td>In case the constraints are already taken care of in this function by passing in a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object, it is possible to abandon some off-diagonal entries in the sparsity pattern if these entries will also not be written into during the actual assembly of the matrix this sparsity pattern later serves. Specifically, when using an assembly method that uses <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global()</a>, no entries will ever be written into those matrix rows or columns that correspond to constrained degrees of freedom. In such cases, you can set the argument <code>keep_constrained_dofs</code> to <code>false</code> to avoid allocating these entries in the sparsity pattern.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomain_id</td><td>If specified, the sparsity pattern is built only on cells that have a subdomain_id equal to the given argument. This is useful in parallel contexts where the matrix and sparsity pattern (for example a <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a>) may be distributed and not every MPI process needs to build the entire sparsity pattern; in that case, it is sufficient if every process only builds that part of the sparsity pattern that corresponds to the subdomain_id for which it is responsible. This feature is used in <a class="el" href="step_32.html">step-32</a>. (This argument is not usually needed for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> because the current function only loops over locally owned cells anyway; thus, this argument typically only makes sense if you want to use the subdomain_id for anything other than indicating which processor owns a cell, for example which geometric component of the domain a cell belongs to.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The actual type of the sparsity pattern may be <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>, <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a>, or any other class that satisfies similar requirements. It is assumed that the size of the sparsity pattern matches the number of degrees of freedom and that enough unused nonzero entries are left to fill the sparsity pattern if the sparsity pattern is of "static" kind (see <a class="el" href="group__Sparsity.html">Sparsity patterns</a> for more information on what this means). The nonzero entries generated by this function are added to possible previous content of the object, i.e., previously added entries are not removed.</dd>
<dd>
If the sparsity pattern is represented by an object of type <a class="el" href="classSparsityPattern.html">SparsityPattern</a> (as opposed to, for example, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>), you need to remember using <a class="el" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">SparsityPattern::compress()</a> after generating the pattern. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00055">55</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga33ec1ee2ac7c86b16700022b704b69c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33ec1ee2ac7c86b16700022b704b69c8">&#9670;&nbsp;</a></span>make_sparsity_pattern() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coupling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute which entries of a matrix built on the given <code>dof_handler</code> may possibly be nonzero, and create a sparsity pattern object that represents these nonzero locations.</p>
<p>This function is a simple variation on the previous <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">make_sparsity_pattern()</a> function (see there for a description of all of the common arguments), but it provides functionality for vector finite elements that allows to be more specific about which variables couple in which equation.</p>
<p>For example, if you wanted to solve the Stokes equations,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -\Delta \mathbf u + \nabla p &amp;= 0,\\ \text{div}\ u &amp;= 0 \end{align*}" src="form_534.png"/>
</p>
<p>in two space dimensions, using stable Q2/Q1 mixed elements (using the <a class="el" href="classFESystem.html">FESystem</a> class), then you don't want all degrees of freedom to couple in each equation. More specifically, in the first equation, only <img class="formulaInl" alt="$u_x$" src="form_535.png"/> and <img class="formulaInl" alt="$p$" src="form_202.png"/> appear; in the second equation, only <img class="formulaInl" alt="$u_y$" src="form_536.png"/> and <img class="formulaInl" alt="$p$" src="form_202.png"/> appear; and in the third equation, only <img class="formulaInl" alt="$u_x$" src="form_535.png"/> and <img class="formulaInl" alt="$u_y$" src="form_536.png"/> appear. (Note that this discussion only talks about vector components of the solution variable and the different equation, and has nothing to do with degrees of freedom, or in fact with any kind of discretization.) We can describe this by the following pattern of "couplings":</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{ccc} 1 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 0 \end{array} \right] \]" src="form_537.png"/>
</p>
<p>where "1" indicates that two variables (i.e., vector components of the <a class="el" href="classFESystem.html">FESystem</a>) couple in the respective equation, and a "0" means no coupling. These zeros imply that upon discretization via a standard finite element formulation, we will not write entries into the matrix that, for example, couple pressure test functions with pressure shape functions (and similar for the other zeros above). It is then a waste to allocate memory for these entries in the matrix and the sparsity pattern, and you can avoid this by creating a mask such as the one above that describes this to the (current) function that computes the sparsity pattern. As stated above, the mask shown above refers to components of the composed <a class="el" href="classFESystem.html">FESystem</a>, rather than to degrees of freedom or shape functions.</p>
<p>This function is designed to accept a coupling pattern, like the one shown above, through the <code>couplings</code> parameter, which contains values of type <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a>. It builds the matrix structure just like the previous function, but does not create matrix elements if not specified by the coupling pattern. If the couplings are symmetric, then so will be the resulting sparsity pattern.</p>
<p>There is a complication if some or all of the shape functions of the finite element in use are non-zero in more than one component (in deal.II speak: they are <a class="el" href="DEALGlossary.html#GlossPrimitive">non-primitive finite elements</a>). In this case, the coupling element corresponding to the first non-zero component is taken and additional ones for this component are ignored. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00114">114</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="gaff02f744dd1e598c12dce9b9db76d115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff02f744dd1e598c12dce9b9db76d115">&#9670;&nbsp;</a></span>make_flux_sparsity_pattern() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute which entries of a matrix built on the given <code>dof_handler</code> may possibly be nonzero, and create a sparsity pattern object that represents these nonzero locations. This function is a variation of the <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">make_sparsity_pattern()</a> functions above in that it assumes that the bilinear form you want to use to generate the matrix also contains terms that integrate over the <em>faces</em> between cells (i.e., it contains "fluxes" between cells, explaining the name of the function).</p>
<p>This function is useful for Discontinuous Galerkin methods where the standard <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">make_sparsity_pattern()</a> function would only create nonzero entries for all degrees of freedom on one cell coupling to all other degrees of freedom on the same cell; however, in DG methods, all or some degrees of freedom on each cell also couple to the degrees of freedom on other cells connected to the current one by a common face. The current function also creates the nonzero entries in the matrix resulting from these additional couplings. In other words, this function computes a strict super-set of nonzero entries compared to the work done by <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">make_sparsity_pattern()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> object that describes which degrees of freedom live on which cells.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sparsity_pattern</td><td>The sparsity pattern to be filled with entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The actual type of the sparsity pattern may be <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>, <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a>, or any other class that satisfies similar requirements. It is assumed that the size of the sparsity pattern matches the number of degrees of freedom and that enough unused nonzero entries are left to fill the sparsity pattern if the sparsity pattern is of "static" kind (see <a class="el" href="group__Sparsity.html">Sparsity patterns</a> for more information on what this means). The nonzero entries generated by this function are added to possible previous content of the object, i.e., previously added entries are not removed.</dd>
<dd>
If the sparsity pattern is represented by an object of type <a class="el" href="classSparsityPattern.html">SparsityPattern</a> (as opposed to, for example, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>), you need to remember using <a class="el" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">SparsityPattern::compress()</a> after generating the pattern. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00615">615</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="gafd002a45af5a826d13b707df9196e1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd002a45af5a826d13b707df9196e1d1">&#9670;&nbsp;</a></span>make_flux_sparsity_pattern() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does essentially the same as the other <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">make_flux_sparsity_pattern()</a> function but allows the specification of a number of additional arguments. These carry the same meaning as discussed in the first <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">make_sparsity_pattern()</a> function above. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00461">461</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga4509f3b692f2e92b6a254421a47c398f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4509f3b692f2e92b6a254421a47c398f">&#9670;&nbsp;</a></span>make_flux_sparsity_pattern() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_integrals_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_integrals_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does essentially the same as the other <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">make_flux_sparsity_pattern()</a> function but allows the specification of coupling matrices that state which components of the solution variable couple in each of the equations you are discretizing. This works in complete analogy as discussed in the second <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">make_sparsity_pattern()</a> function above.</p>
<p>In fact, this function takes two such masks, one describing which variables couple with each other in the cell integrals that make up your bilinear form, and which variables couple with each other in the face integrals. If you passed masks consisting of only 1s to both of these, then you would get the same sparsity pattern as if you had called the first of the <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">make_sparsity_pattern()</a> functions above. By setting some of the entries of these masks to zeros, you can get a sparser sparsity pattern. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l01200">1200</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga3eaa31a679484e80c193e74e8a967dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eaa31a679484e80c193e74e8a967dc8">&#9670;&nbsp;</a></span>make_hanging_node_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_hanging_node_constraints </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the constraints resulting from the presence of hanging nodes. Hanging nodes are best explained using a small picture:</p>
<div class="image">
<img src="hanging_nodes.png" alt="hanging_nodes.png"/>
</div>
<p>In order to make a finite element function globally continuous, we have to make sure that the dark red nodes have values that are compatible with the adjacent yellow nodes, so that the function has no jump when coming from the small cells to the large one at the top right. We therefore have to add conditions that constrain those "hanging nodes".</p>
<p>The object into which these are inserted is later used to condense the global system matrix and right hand side, and to extend the solution vectors from the true degrees of freedom also to the constraint nodes. This function is explained in detail in the <a class="el" href="step_6.html">step-6</a> tutorial program and is used in almost all following programs as well.</p>
<p>This function does not clear the constraint matrix object before use, in order to allow adding constraints from different sources to the same object. You therefore need to make sure it contains only constraints you still want; otherwise call the <a class="el" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">ConstraintMatrix::clear()</a> function. Likewise, this function does not close the object since you may want to enter other constraints later on yourself.</p>
<p>In the hp-case, i.e. when the argument is of type <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, we consider constraints due to different finite elements used on two sides of a face between cells as hanging nodes as well. In other words, for hp finite elements, this function computes all constraints due to differing mesh sizes (h) or polynomial degrees (p) between adjacent cells.</p>
<p>The template argument (and by consequence the type of the first argument to this function) can be either <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l01730">1730</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="gaa2268fcc4cc5295e084a87f423989273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2268fcc4cc5295e084a87f423989273">&#9670;&nbsp;</a></span>make_zero_boundary_constraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_zero_boundary_constraints </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>zero_boundary_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a constraint matrix for the constraints that result from zero boundary values on the given boundary indicator.</p>
<p>This function constrains all degrees of freedom on the given part of the boundary.</p>
<p>A variant of this function with different arguments is used in <a class="el" href="step_36.html">step-36</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> to work on. </td></tr>
    <tr><td class="paramname">boundary_id</td><td>The indicator of that part of the boundary for which constraints should be computed. If this number equals <a class="el" href="namespacenumbers.html#a1745778880e38cde9ef045471f4757fd">numbers::invalid_boundary_id</a> then all boundaries of the domain will be treated. </td></tr>
    <tr><td class="paramname">zero_boundary_constraints</td><td>The constraint object into which the constraints will be written. The new constraints due to zero boundary values will simply be added, preserving any other constraints previously present. However, this will only work if the previous content of that object consists of constraints on degrees of freedom that are not located on the boundary treated here. If there are previously existing constraints for degrees of freedom located on the boundary, then this would constitute a conflict. See the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module for handling the case where there are conflicting constraints on individual degrees of freedom. </td></tr>
    <tr><td class="paramname">component_mask</td><td>An optional component mask that restricts the functionality of this function to a subset of an <a class="el" href="classFESystem.html">FESystem</a>. For non- <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a> shape functions, any degree of freedom is affected that belongs to a shape function where at least one of its nonzero components is affected by the component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). If this argument is omitted, all components of the finite element with degrees of freedom at the boundary will be considered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l03244">3244</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="gac8a486449ec11cef8346f04f16ee9db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8a486449ec11cef8346f04f16ee9db7">&#9670;&nbsp;</a></span>make_zero_boundary_constraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_zero_boundary_constraints </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>zero_boundary_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the same as the previous function, except do it for all parts of the boundary, not just those with a particular boundary indicator. This function is then equivalent to calling the previous one with <a class="el" href="namespacenumbers.html#a1745778880e38cde9ef045471f4757fd">numbers::invalid_boundary_id</a> as second argument.</p>
<p>This function is used in <a class="el" href="step_36.html">step-36</a>, for example. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l03330">3330</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="gace3954be8b172fbcd05a94aba0cd6f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace3954be8b172fbcd05a94aba0cd6f40">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to Dirichlet boundary conditions into a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraints</code>. This function identifies the degrees of freedom subject to Dirichlet boundary conditions, adds them to the list of constrained DoFs in <code>constraints</code> and sets the respective inhomogeneity to the value interpolated around the boundary. If this routine encounters a DoF that already is constrained (for instance by a hanging node constraint, see below, or any other type of constraint, e.g. from periodic boundary conditions), the old setting of the constraint (dofs the entry is constrained to, inhomogeneities) is kept and nothing happens.</p>
<dl class="section note"><dt>Note</dt><dd>When combining adaptively refined meshes with hanging node constraints and boundary conditions like from the current function within one <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object, the hanging node constraints should always be set first, and then the boundary conditions since boundary conditions are not set in the second operation on degrees of freedom that are already constrained. This makes sure that the discretization remains conforming as is needed. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a>.</dd></dl>
<p>The parameter <code>boundary_component</code> corresponds to the number <code>boundary_id</code> of the face.</p>
<p>The flags in the last parameter, <code>component_mask</code> denote which components of the finite element space shall be interpolated. If it is left as specified by the default value (i.e. an empty array), all components are interpolated. If it is different from the default value, it is assumed that the number of entries equals the number of components in the boundary functions and the finite element, and those components in the given boundary function will be used for which the respective flag was set in the component mask. See also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>. As an example, assume that you are solving the Stokes equations in 2d, with variables <img class="formulaInl" alt="$(u,v,p)$" src="form_1141.png"/> and that you only want to interpolate boundary values for the pressure, then the component mask should correspond to <code>(true,true,false)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Whether a component mask has been specified or not, the number of components of the functions in <code>function_map</code> must match that of the finite element used by <code>dof</code>. In other words, for the example above, you need to provide a <a class="el" href="classFunction.html">Function</a> object that has 3 components (the two velocities and the pressure), even though you are only interested in the first two of them. <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">interpolate_boundary_values()</a> will then call this function to obtain a vector of 3 values at each interpolation point but only take the first two and discard the third. In other words, you are free to return whatever you like in the third component of the vector returned by <a class="el" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">Function::vector_value</a>, but the <a class="el" href="classFunction.html">Function</a> object must state that it has 3 components.</dd></dl>
<p>If the finite element used has shape functions that are non-zero in more than one component (in deal.II speak: they are non-primitive), then these components can presently not be used for interpolating boundary values. Thus, the elements in the component mask corresponding to the components of these non-primitive shape functions must be <code>false</code>.</p>
<p>See the general documentation of this namespace for more information. </p>

</div>
</div>
<a id="gaf8ef59a87a974d1e8cde1a579d4f327a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ef59a87a974d1e8cde1a579d4f327a">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but taking only one pair of boundary indicator and corresponding boundary function. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ga2376b9a282a2b62be5c55ab62a11a132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2376b9a282a2b62be5c55ab62a11a132">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the other <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="gaa78c814d6a60e060c0668add0f135e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa78c814d6a60e060c0668add0f135e84">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the other <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object. </p>

</div>
</div>
<a id="ga5b4201210dcce9a263f773209ac1775c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b4201210dcce9a263f773209ac1775c">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project a function to the boundary of the domain, using the given quadrature formula for the faces. This function identifies the degrees of freedom subject to Dirichlet boundary conditions, adds them to the list of constrained DoFs in <code>constraints</code> and sets the respective inhomogeneity to the value resulting from the projection operation. If this routine encounters a DoF that already is constrained (for instance by a hanging node constraint, see below, or any other type of constraint, e.g. from periodic boundary conditions), the old setting of the constraint (dofs the entry is constrained to, inhomogeneities) is kept and nothing happens.</p>
<dl class="section note"><dt>Note</dt><dd>When combining adaptively refined meshes with hanging node constraints and boundary conditions like from the current function within one <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object, the hanging node constraints should always be set first, and then the boundary conditions since boundary conditions are not set in the second operation on degrees of freedom that are already constrained. This makes sure that the discretization remains conforming as is needed. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a>.</dd></dl>
<p>If <code>component_mapping</code> is empty, it is assumed that the number of components of <code>boundary_function</code> matches that of the finite element used by <code>dof</code>.</p>
<p>In 1d, projection equals interpolation. Therefore, interpolate_boundary_values is called.</p>
<ul>
<li><code>component_mapping:</code> if the components in <code>boundary_functions</code> and <code>dof</code> do not coincide, this vector allows them to be remapped. If the vector is not empty, it has to have one entry for each component in <code>dof</code>. This entry is the component number in <code>boundary_functions</code> that should be used for this component in <code>dof</code>. By default, no remapping is applied. </li>
</ul>

</div>
</div>
<a id="ga2c57b25aa60c906ab463dbe5ca49ec82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c57b25aa60c906ab463dbe5ca49ec82">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>std::vector&lt;&#160;unsigned&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">project_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. </p>

</div>
</div>
<a id="ga1c6685360c01c9c46eeb7575e8ef68ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c6685360c01c9c46eeb7575e8ef68ac">&#9670;&nbsp;</a></span>project_boundary_values_curl_conforming() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_curl_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute constraints that correspond to boundary conditions of the form <img class="formulaInl" alt="$\vec{n}\times\vec{u}=\vec{n}\times\vec{f}$" src="form_1215.png"/>, i.e. the tangential components of <img class="formulaInl" alt="$u$" src="form_256.png"/> and <img class="formulaInl" alt="$f$" src="form_417.png"/> shall coincide.</p>
<p>If the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraints</code> contained values or other constraints before, the new ones are added or the old ones overwritten, if a node of the boundary part to be used was already in the list of constraints. This is handled by using inhomogeneous constraints. Please note that when combining adaptive meshes and this kind of constraints, the Dirichlet conditions should be set first, and then completed by hanging node constraints, in order to make sure that the discretization remains consistent. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a>.</p>
<p>This function is explicitly written to use with the <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> elements. Thus it throws an exception, if it is called with other finite elements.</p>
<p>The second argument of this function denotes the first vector component in the finite element that corresponds to the vector function that you want to constrain. For example, if we want to solve Maxwell's equations in 3d and the finite element has components <img class="formulaInl" alt="$(E_x,E_y,E_z,B_x,B_y,B_z)$" src="form_1216.png"/> and we want the boundary conditions <img class="formulaInl" alt="$\vec{n}\times\vec{B}=\vec{n}\times\vec{f}$" src="form_1217.png"/>, then <code>first_vector_component</code> would be 3. Vectors are implicitly assumed to have exactly <code>dim</code> components that are ordered in the same way as we usually order the coordinate directions, i.e. <img class="formulaInl" alt="$x$" src="form_9.png"/>-, <img class="formulaInl" alt="$y$" src="form_10.png"/>-, and finally <img class="formulaInl" alt="$z$" src="form_11.png"/>-component.</p>
<p>The parameter <code>boundary_component</code> corresponds to the number <code>boundary_id</code> of the face. <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is an illegal value, since it is reserved for interior faces.</p>
<p>The last argument is denoted to compute the normal vector <img class="formulaInl" alt="$\vec{n}$" src="form_1218.png"/> at the boundary points.</p>
<h4>Computing constraints</h4>
<p>To compute the constraints we use projection-based interpolation as proposed in Solin, Segeth and Dolezel (Higher order finite elements, Chapman&amp;Hall, 2004) on every face located at the boundary.</p>
<p>First one projects <img class="formulaInl" alt="$\vec{f}$" src="form_1219.png"/> on the lowest-order edge shape functions. Then the remaining part <img class="formulaInl" alt="$(I-P_0)\vec{f}$" src="form_1220.png"/> of the function is projected on the remaining higher-order edge shape functions. In the last step we project <img class="formulaInl" alt="$(I-P_0-P_e)\vec{f}$" src="form_1221.png"/> on the bubble shape functions defined on the face.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="gac5ab15402b144e80122ee983f76a4cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5ab15402b144e80122ee983f76a4cd4">&#9670;&nbsp;</a></span>project_boundary_values_curl_conforming() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_curl_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_collection</em> = <code><a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping_collection</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for the hp-namespace.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ga6fca3672ae63b249402460a6ed4538b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fca3672ae63b249402460a6ed4538b4">&#9670;&nbsp;</a></span>project_boundary_values_curl_conforming_l2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_curl_conforming_l2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is an updated version of the project_boundary_values_curl_conforming function. The intention is to fix a problem when using the previous function in conjunction with non- rectangular geometries (i.e. elements with non-rectangular faces). The L2-projection method used has been taken from the paper "Electromagnetic scattering simulation using an H (curl) conforming hp finite element method in three dimensions" by PD Ledger, K Morgan and O Hassan ( Int. J. Num. Meth. Fluids, Volume 53, Issue 8, pages 1267–1296).</p>
<p>This function will compute constraints that correspond to Dirichlet boundary conditions of the form <img class="formulaInl" alt="$\vec{n}\times\vec{E}=\vec{n}\times\vec{F}$" src="form_1222.png"/> i.e. the tangential components of <img class="formulaInl" alt="$\vec{E}$" src="form_1223.png"/> and <img class="formulaInl" alt="$f$" src="form_417.png"/> shall coincide.</p>
<h4>Computing constraints</h4>
<p>To compute the constraints we use a projection method based upon the paper mentioned above. In 2D this is done in a single stage for the edge- based shape functions, regardless of the order of the finite element. In 3D this is done in two stages, edges first and then faces.</p>
<p>For each cell, each edge, <img class="formulaInl" alt="$e$" src="form_1224.png"/>, is projected by solving the linear system <img class="formulaInl" alt="$Ax=b$" src="form_26.png"/> where <img class="formulaInl" alt="$x$" src="form_9.png"/> is the vector of contraints on degrees of freedom on the edge and</p>
<p><img class="formulaInl" alt="$A_{ij} = \int_{e} (\vec{s}_{i}\cdot\vec{t})(\vec{s}_{j}\cdot\vec{t}) dS$" src="form_1225.png"/></p>
<p><img class="formulaInl" alt="$b_{i} = \int_{e} (\vec{s}_{i}\cdot\vec{t})(\vec{F}\cdot\vec{t}) dS$" src="form_1226.png"/></p>
<p>with <img class="formulaInl" alt="$\vec{s}_{i}$" src="form_1227.png"/> the <img class="formulaInl" alt="$i^{th}$" src="form_1228.png"/> shape function and <img class="formulaInl" alt="$\vec{t}$" src="form_1229.png"/> the tangent vector.</p>
<p>Once all edge constraints, <img class="formulaInl" alt="$x$" src="form_9.png"/>, have been computed, we may compute the face constraints in a similar fashion, taking into account the residuals from the edges.</p>
<p>For each face on the cell, <img class="formulaInl" alt="$f$" src="form_417.png"/>, we solve the linear system <img class="formulaInl" alt="$By=c$" src="form_1230.png"/> where <img class="formulaInl" alt="$y$" src="form_10.png"/> is the vector of constraints on degrees of freedom on the face and</p>
<p><img class="formulaInl" alt="$B_{ij} = \int_{f} (\vec{n} \times \vec{s}_{i}) \cdot (\vec{n} \times \vec{s}_{j}) dS$" src="form_1231.png"/></p>
<p><img class="formulaInl" alt="$c_{i} = \int_{f} (\vec{n} \times \vec{r}) \cdot (\vec{n} \times \vec{s}_i) dS$" src="form_1232.png"/></p>
<p>and <img class="formulaInl" alt="$\vec{r} = \vec{F} - \sum_{e \in f} \sum{i \in e} x_{i}\vec{s}_i$" src="form_1233.png"/>, the edge residual.</p>
<p>The resulting constraints are then given in the solutions <img class="formulaInl" alt="$x$" src="form_9.png"/> and <img class="formulaInl" alt="$y$" src="form_10.png"/>.</p>
<p>If the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraints</code> contained values or other constraints before, the new ones are added or the old ones overwritten, if a node of the boundary part to be used was already in the list of constraints. This is handled by using inhomogeneous constraints. Please note that when combining adaptive meshes and this kind of constraints, the Dirichlet conditions should be set first, and then completed by hanging node constraints, in order to make sure that the discretization remains consistent. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a>.</p>
<h4>Arguments to this function</h4>
<p>This function is explicitly for use with <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> elements, or with <a class="el" href="classFESystem.html">FESystem</a> elements which contain <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> elements. It will throw an exception if called with any other finite element. The user must ensure that <a class="el" href="classFESystem.html">FESystem</a> elements are correctly setup when using this function as this check not possible in this case.</p>
<p>The second argument of this function denotes the first vector component of the finite element which corresponds to the vector function that you wish to constrain. For example, if we are solving Maxwell's equations in 3D and have components <img class="formulaInl" alt="$(E_x,E_y,E_z,B_x,B_y,B_z)$" src="form_1216.png"/> and we want the boundary conditions <img class="formulaInl" alt="$\vec{n}\times\vec{B}=\vec{n}\times\vec{f}$" src="form_1217.png"/>, then <code>first_vector_component</code> would be 3. The <code>boundary_function</code> must return 6 components in this example, with the first 3 corresponding to <img class="formulaInl" alt="$\vec{E}$" src="form_1223.png"/> and the second 3 corresponding to <img class="formulaInl" alt="$\vec{B}$" src="form_1234.png"/>. Vectors are implicitly assumed to have exactly <code>dim</code> components that are ordered in the same way as we usually order the coordinate directions, i.e. <img class="formulaInl" alt="$x$" src="form_9.png"/>-, <img class="formulaInl" alt="$y$" src="form_10.png"/>-, and finally <img class="formulaInl" alt="$z$" src="form_11.png"/>-component.</p>
<p>The parameter <code>boundary_component</code> corresponds to the number <code>boundary_id</code> of the face. <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is an illegal value, since it is reserved for interior faces.</p>
<p>The last argument is denoted to compute the normal vector <img class="formulaInl" alt="$\vec{n}$" src="form_1218.png"/> at the boundary points.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="gaa76f7bb9461f7a8be8da482d8198673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa76f7bb9461f7a8be8da482d8198673f">&#9670;&nbsp;</a></span>project_boundary_values_curl_conforming_l2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_curl_conforming_l2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_collection</em> = <code><a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping_collection</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hp-namespace version of project_boundary_values_curl_conforming_l2 (above). </p>

</div>
</div>
<a id="ga86427a4e8b3a7e580dabb4e473005288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86427a4e8b3a7e580dabb4e473005288">&#9670;&nbsp;</a></span>project_boundary_values_div_conforming() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_div_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute constraints that correspond to boundary conditions of the form <img class="formulaInl" alt="$\vec{n}^T\vec{u}=\vec{n}^T\vec{f}$" src="form_1235.png"/>, i.e. the normal components of the solution <img class="formulaInl" alt="$u$" src="form_256.png"/> and a given <img class="formulaInl" alt="$f$" src="form_417.png"/> shall coincide. The function <img class="formulaInl" alt="$f$" src="form_417.png"/> is given by <code>boundary_function</code> and the resulting constraints are added to <code>constraints</code> for faces with boundary indicator <code>boundary_component</code>.</p>
<p>This function is explicitly written to use with the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> elements. Thus it throws an exception, if it is called with other finite elements.</p>
<p>If the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraints</code> contained values or other constraints before, the new ones are added or the old ones overwritten, if a node of the boundary part to be used was already in the list of constraints. This is handled by using inhomogeneous constraints. Please note that when combining adaptive meshes and this kind of constraints, the Dirichlet conditions should be set first, and then completed by hanging node constraints, in order to make sure that the discretization remains consistent. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a>.</p>
<p>The argument <code>first_vector_component</code> denotes the first vector component in the finite element that corresponds to the vector function <img class="formulaInl" alt="$\vec{u}$" src="form_1236.png"/> that you want to constrain. Vectors are implicitly assumed to have exactly <code>dim</code> components that are ordered in the same way as we usually order the coordinate directions, i.e., <img class="formulaInl" alt="$x$" src="form_9.png"/>-, <img class="formulaInl" alt="$y$" src="form_10.png"/>-, and finally <img class="formulaInl" alt="$z$" src="form_11.png"/>-component.</p>
<p>The parameter <code>boundary_component</code> corresponds to the <code>boundary_id</code> of the faces where the boundary conditions are applied. <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is an illegal value, since it is reserved for interior faces. The <code>mapping</code> is used to compute the normal vector <img class="formulaInl" alt="$\vec{n}$" src="form_1218.png"/> at the boundary points.</p>
<h4>Computing constraints</h4>
<p>To compute the constraints we use interpolation operator proposed in Brezzi, Fortin (Mixed and Hybrid (Finite Element Methods, Springer, 1991) on every face located at the boundary.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ga64db6ce0b7b31453e1ddac86ae4d04c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64db6ce0b7b31453e1ddac86ae4d04c9">&#9670;&nbsp;</a></span>project_boundary_values_div_conforming() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_div_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_collection</em> = <code><a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping_collection</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for the hp-namespace.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ga5b13c2da1b235c86cdbce2270525db99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b13c2da1b235c86cdbce2270525db99">&#9670;&nbsp;</a></span>compute_nonzero_normal_flux_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_nonzero_normal_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes the constraints that correspond to boundary conditions of the form <img class="formulaInl" alt="$\vec u \cdot \vec n=\vec u_\Gamma \cdot \vec n$" src="form_1237.png"/>, i.e., normal flux constraints where <img class="formulaInl" alt="$\vec u$" src="form_1238.png"/> is a vector-valued solution variable and <img class="formulaInl" alt="$\vec u_\Gamma$" src="form_1239.png"/> is a prescribed vector field whose normal component we want to be equal to the normal component of the solution. These conditions have exactly the form handled by the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class, in that they relate a <em>linear combination</em> of boundary degrees of freedom to a corresponding value (the inhomogeneity of the constraint). Consequently, the current function creates a list of constraints that are written into a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. This object may already have some content, for example from hanging node constraints, that remains untouched. These constraints have to be applied to the linear system like any other such constraints, i.e., you have to condense the linear system with the constraints before solving, and you have to distribute the solution vector afterwards.</p>
<p>This function treats a more general case than <a class="el" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">VectorTools::compute_no_normal_flux_constraints()</a> (which can only handle the case where <img class="formulaInl" alt="$\vec u_\Gamma \cdot \vec n = 0$" src="form_1240.png"/>, and is used in <a class="el" href="step_31.html">step-31</a> and <a class="el" href="step_32.html">step-32</a>). However, because everything that would apply to that function also applies as a special case to the current function, the following discussion is relevant to both.</p>
<dl class="section note"><dt>Note</dt><dd>This function doesn't make much sense in 1d, so it throws an exception if <code>dim</code> equals one.</dd></dl>
<h4>Arguments to this function</h4>
<p>The second argument of this function denotes the first vector component in the finite element that corresponds to the vector function that you want to constrain. For example, if we were solving a Stokes equation in 2d and the finite element had components <img class="formulaInl" alt="$(u,v,p)$" src="form_1141.png"/>, then <code>first_vector_component</code> needs to be zero if you intend to constraint the vector <img class="formulaInl" alt="$(u,v)^T \cdot \vec n = \vec u_\Gamma \cdot \vec n$" src="form_1241.png"/>. On the other hand, if we solved the Maxwell equations in 3d and the finite element has components <img class="formulaInl" alt="$(E_x,E_y,E_z,B_x,B_y,B_z)$" src="form_1216.png"/> and we want the boundary condition <img class="formulaInl" alt="$\vec B\cdot \vec n=\vec B_\Gamma\cdot \vec n$" src="form_1242.png"/>, then <code>first_vector_component</code> would be 3. Vectors are implicitly assumed to have exactly <code>dim</code> components that are ordered in the same way as we usually order the coordinate directions, i.e. <img class="formulaInl" alt="$x$" src="form_9.png"/>-, <img class="formulaInl" alt="$y$" src="form_10.png"/>-, and finally <img class="formulaInl" alt="$z$" src="form_11.png"/>-component. The function assumes, but can't check, that the vector components in the range <code>[first_vector_component,first_vector_component+dim)</code> come from the same base finite element. For example, in the Stokes example above, it would not make sense to use a <code><a class="el" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(2), 1, <a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim)</code> (note that the first velocity vector component is a <img class="formulaInl" alt="$Q_2$" src="form_575.png"/> element, whereas all the other ones are <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> elements) as there would be points on the boundary where the <img class="formulaInl" alt="$x$" src="form_9.png"/>-velocity is defined but no corresponding <img class="formulaInl" alt="$y$" src="form_10.png"/>- or <img class="formulaInl" alt="$z$" src="form_11.png"/>-velocities.</p>
<p>The third argument denotes the set of boundary indicators on which the boundary condition is to be enforced. Note that, as explained below, this is one of the few functions where it makes a difference where we call the function multiple times with only one boundary indicator, or whether we call the function once with the whole set of boundary indicators at once.</p>
<p>Argument four (<code>function_map</code>) describes the boundary function <img class="formulaInl" alt="$\vec u_\Gamma$" src="form_1239.png"/> for each boundary id. The function <code>function_map[id]</code> is used on boundary with id <code>id</code> taken from the set <code>boundary_ids</code>. Each function in <code>function_map</code> is expected to have <code>dim</code> components, which are used independent of <code>first_vector_component</code>.</p>
<p>The mapping argument is used to compute the boundary points at which the function needs to request the normal vector <img class="formulaInl" alt="$\vec n$" src="form_1243.png"/> from the boundary description.</p>
<dl class="section note"><dt>Note</dt><dd>When combining adaptively refined meshes with hanging node constraints and boundary conditions like from the current function within one <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object, the hanging node constraints should always be set first, and then the boundary conditions since boundary conditions are not set in the second operation on degrees of freedom that are already constrained. This makes sure that the discretization remains conforming as is needed. See the discussion on conflicting constraints in the module on <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a>.</dd></dl>
<h4>Computing constraints in 2d</h4>
<p>Computing these constraints requires some smarts. The main question revolves around the question what the normal vector is. Consider the following situation:</p>
<div class="image">
<img src="no_normal_flux_1.png" alt="no_normal_flux_1.png"/>
</div>
 <p>Here, we have two cells that use a bilinear mapping (i.e., <a class="el" href="classMappingQGeneric.html">MappingQGeneric(1)</a>). Consequently, for each of the cells, the normal vector is perpendicular to the straight edge. If the two edges at the top and right are meant to approximate a curved boundary (as indicated by the dashed line), then neither of the two computed normal vectors are equal to the exact normal vector (though they approximate it as the mesh is refined further). What is worse, if we constrain <img class="formulaInl" alt="$\vec u \cdot \vec n= \vec u_\Gamma \cdot \vec n$" src="form_1244.png"/> at the common vertex with the normal vector from both cells, then we constrain the vector <img class="formulaInl" alt="$\vec u$" src="form_1238.png"/> with respect to two linearly independent vectors; consequently, the constraint would be <img class="formulaInl" alt="$\vec u=\vec u_\Gamma$" src="form_1245.png"/> at this point (i.e. <em>all</em> components of the vector), which is not what we wanted.</p>
<p>To deal with this situation, the algorithm works in the following way: at each point where we want to constrain <img class="formulaInl" alt="$\vec u$" src="form_1238.png"/>, we first collect all normal vectors that adjacent cells might compute at this point. We then do not constrain <img class="formulaInl" alt="$\vec u \cdot \vec n=\vec u_\Gamma \cdot \vec n$" src="form_1237.png"/> for <em>each</em> of these normal vectors but only for the <em>average</em> of the normal vectors. In the example above, we therefore record only a single constraint <img class="formulaInl" alt="$\vec u \cdot \vec {\bar n}=\vec u_\Gamma \cdot \vec {\bar n}$" src="form_1246.png"/>, where <img class="formulaInl" alt="$\vec {\bar n}$" src="form_1247.png"/> is the average of the two indicated normal vectors.</p>
<p>Unfortunately, this is not quite enough. Consider the situation here:</p>
<div class="image">
<img src="no_normal_flux_2.png" alt="no_normal_flux_2.png"/>
</div>
 <p>If again the top and right edges approximate a curved boundary, and the left boundary a separate boundary (for example straight) so that the exact boundary has indeed a corner at the top left vertex, then the above construction would not work: here, we indeed want the constraint that <img class="formulaInl" alt="$\vec u$" src="form_1238.png"/> at this point (because the normal velocities with respect to both the left normal as well as the top normal vector should be zero), not that the velocity in the direction of the average normal vector is zero.</p>
<p>Consequently, we use the following heuristic to determine whether all normal vectors computed at one point are to be averaged: if two normal vectors for the same point are computed on <em>different</em> cells, then they are to be averaged. This covers the first example above. If they are computed from the same cell, then the fact that they are different is considered indication that they come from different parts of the boundary that might be joined by a real corner, and must not be averaged.</p>
<p>There is one problem with this scheme. If, for example, the same domain we have considered above, is discretized with the following mesh, then we get into trouble:</p>
<div class="image">
<img src="no_normal_flux_3.png" alt="no_normal_flux_3.png"/>
</div>
 <p>Here, the algorithm assumes that the boundary does not have a corner at the point where faces <img class="formulaInl" alt="$F1$" src="form_1248.png"/> and <img class="formulaInl" alt="$F2$" src="form_1249.png"/> join because at that point there are two different normal vectors computed from different cells. If you intend for there to be a corner of the exact boundary at this point, the only way to deal with this is to assign the two parts of the boundary different boundary indicators and call this function twice, once for each boundary indicators; doing so will yield only one normal vector at this point per invocation (because we consider only one boundary part at a time), with the result that the normal vectors will not be averaged. This situation also needs to be taken into account when using this function around reentrant corners on Cartesian meshes. If normal-flux boundary conditions are to be enforced on non-Cartesian meshes around reentrant corners, one may even get cycles in the constraints as one will in general constrain different components from the two sides. In that case, set a no-slip constraint on the reentrant vertex first.</p>
<h4>Computing constraints in 3d</h4>
<p>The situation is more complicated in 3d. Consider the following case where we want to compute the constraints at the marked vertex:</p>
<div class="image">
<img src="no_normal_flux_4.png" alt="no_normal_flux_4.png"/>
</div>
 <p>Here, we get four different normal vectors, one from each of the four faces that meet at the vertex. Even though they may form a complete set of vectors, it is not our intent to constrain all components of the vector field at this point. Rather, we would like to still allow tangential flow, where the term "tangential" has to be suitably defined.</p>
<p>In a case like this, the algorithm proceeds as follows: for each cell that has computed two tangential vectors at this point, we compute the unconstrained direction as the outer product of the two tangential vectors (if necessary multiplied by minus one). We then average these tangential vectors. Finally, we compute constraints for the two directions perpendicular to this averaged tangential direction.</p>
<p>There are cases where one cell contributes two tangential directions and another one only one; for example, this would happen if both top and front faces of the left cell belong to the boundary selected whereas only the top face of the right cell belongs to it, maybe indicating the the entire front part of the domain is a smooth manifold whereas the top really forms two separate manifolds that meet in a ridge, and that normal-flux boundary conditions are only desired on the front manifold and the right one on top. In cases like these, it's difficult to define what should happen. The current implementation simply ignores the one contribution from the cell that only contributes one normal vector. In the example shown, this is acceptable because the normal vector for the front face of the left cell is the same as the normal vector provided by the front face of the right cell (the surface is planar) but it would be a problem if the front manifold would be curved. Regardless, it is unclear how one would proceed in this case and ignoring the single cell is likely the best one can do.</p>
<h4>Results</h4>
<p>Because it makes for good pictures, here are two images of vector fields on a circle and on a sphere to which the constraints computed by this function have been applied (for illustration purposes, we enforce zero normal flux, which can more easily be computed using <a class="el" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">VectorTools::compute_no_normal_flux_constraints()</a>, as this must lead to a <em>tangential</em> vector field):</p>
<div class="image">
<img src="no_normal_flux_5.png" alt="no_normal_flux_5.png"/>
</div>
 <div class="image">
<img src="no_normal_flux_6.png" alt="no_normal_flux_6.png"/>
</div>
 <p>The vectors fields are not physically reasonable but the tangentiality constraint is clearly enforced. The fact that the vector fields are zero at some points on the boundary is an artifact of the way it is created, it is not constrained to be zero at these points.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ga0e8d8c017ac654e24e71ad3fd7e76310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e8d8c017ac654e24e71ad3fd7e76310">&#9670;&nbsp;</a></span>compute_no_normal_flux_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_no_normal_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the <a class="el" href="group__constraints.html#ga5b13c2da1b235c86cdbce2270525db99">compute_nonzero_normal_flux_constraints()</a> function (see there for more information), but for the simpler case of homogeneous normal-flux constraints, i.e., for imposing the condition <img class="formulaInl" alt="$\vec u \cdot \vec n= 0$" src="form_1250.png"/>. This function is used in <a class="el" href="step_31.html">step-31</a> and <a class="el" href="step_32.html">step-32</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ga83a2c92faece22a1a7c8631a75d4a2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83a2c92faece22a1a7c8631a75d4a2f0">&#9670;&nbsp;</a></span>compute_nonzero_tangential_flux_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_nonzero_tangential_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structFunctionMap.html">FunctionMap</a>&lt; spacedim &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the constraints that correspond to boundary conditions of the form <img class="formulaInl" alt="$\vec u \times \vec n=\vec u_\Gamma \times \vec n$" src="form_1251.png"/>, i.e., tangential flow constraints where <img class="formulaInl" alt="$\vec u$" src="form_1238.png"/> is a vector-valued solution variable and <img class="formulaInl" alt="$\vec u_\Gamma$" src="form_1239.png"/> is prescribed vector field whose tangential component(s) we want to be equal to the tangential component(s) of the solution. This function constrains exactly those dim-1 vector-valued components that are left unconstrained by <a class="el" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">VectorTools::compute_no_normal_flux_constraints()</a>, and leaves the one component unconstrained that is constrained by that function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ga113d79605138e344578261503ed342d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga113d79605138e344578261503ed342d1">&#9670;&nbsp;</a></span>compute_normal_flux_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, template&lt; int, int &gt; class DoFHandlerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_normal_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for homogeneous tangential-flux constraints.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="gab4b8d59b61a2d51242f62a8efb0b027f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4b8d59b61a2d51242f62a8efb0b027f">&#9670;&nbsp;</a></span>distribute_constraints_linear_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; distribute_constraints_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraint_matrix</code> and an operator exemplar <code>exemplar</code> (this exemplar is usually a linear operator that describes the system matrix - it is only used to create domain and range vectors of appropriate sizes, its action <code>vmult</code> is never used). A <a class="el" href="classLinearOperator.html">LinearOperator</a> object associated with the "homogeneous action" of the underlying <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object is returned:</p>
<p>Applying the <a class="el" href="classLinearOperator.html">LinearOperator</a> object on a vector <code>u</code> results in a vector <code>v</code> that stores the result of calling <a class="el" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">ConstraintMatrix::distribute()</a> on <code>u</code> - with one important difference: inhomogeneities are not applied, but always treated as 0 instead.</p>
<p>The <a class="el" href="classLinearOperator.html">LinearOperator</a> object created by this function is primarily used internally in <a class="el" href="group__constraints.html#ga59c2f70370213d436cb9fade9d813478">constrained_linear_operator()</a> to build up a modified system of linear equations. How to solve a linear system of equations with this approach is explained in detail in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<dl class="section author"><dt>Author</dt><dd>Mauro Bardelloni, Matthias Maier, 2015</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently, this function may not work correctly for distributed data structures. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00064">64</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga3c3344899778735f7d68db5875ec2cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c3344899778735f7d68db5875ec2cb1">&#9670;&nbsp;</a></span>project_to_constrained_linear_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; project_to_constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> <code>constraint_matrix</code> and an operator exemplar <code>exemplar</code>, return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that is the projection to the subspace of constrained degrees of freedom, i.e. all entries of the result vector that correspond to unconstrained degrees of freedom are set to zero.</p>
<dl class="section author"><dt>Author</dt><dd>Mauro Bardelloni, Matthias Maier, 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00146">146</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga59c2f70370213d436cb9fade9d813478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59c2f70370213d436cb9fade9d813478">&#9670;&nbsp;</a></span>constrained_linear_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object <code>constraint_matrix</code> and a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>linop</code>, this function creates a <a class="el" href="classLinearOperator.html">LinearOperator</a> object consisting of the composition of three operations and a regularization: </p><div class="fragment"><div class="line">Ct * linop * C + Id_c;</div></div><!-- fragment --><p> with </p><div class="fragment"><div class="line">C = <a class="code" href="group__constraints.html#gab4b8d59b61a2d51242f62a8efb0b027f">distribute_constraints_linear_operator</a>(constraint_matrix, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(C);</div><div class="line">Id_c = <a class="code" href="group__constraints.html#ga3c3344899778735f7d68db5875ec2cb1">project_to_constrained_linear_operator</a>(constraint_matrix, linop);</div></div><!-- fragment --><p> and <code>Id_c</code> is the projection to the subspace consisting of all vector entries associated with constrained degrees of freedoms.</p>
<p>This <a class="el" href="classLinearOperator.html">LinearOperator</a> object is used together with <a class="el" href="group__constraints.html#ga84aae431c14515ad113f480541a22b96">constrained_right_hand_side()</a> to build up the following modified system of linear equations: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]" src="form_996.png"/>
</p>
<p> with a given (unconstrained) system matrix <img class="formulaInl" alt="$A$" src="form_40.png"/>, right hand side <img class="formulaInl" alt="$b$" src="form_41.png"/>, and linear constraints <img class="formulaInl" alt="$C$" src="form_43.png"/> with inhomogeneities <img class="formulaInl" alt="$k$" src="form_44.png"/>.</p>
<p>A detailed explanation of this approach is given in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<dl class="section author"><dt>Author</dt><dd>Mauro Bardelloni, Matthias Maier, 2015</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently, this function may not work correctly for distributed data structures. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00232">232</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga84aae431c14515ad113f480541a22b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84aae431c14515ad113f480541a22b96">&#9670;&nbsp;</a></span>constrained_right_hand_side()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; constrained_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object <code>constraint_matrix</code>, a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>linop</code> and a right-hand side <code>right_hand_side</code>, this function creates a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> that stores the following computation: </p><div class="fragment"><div class="line">Ct * (right_hand_side - linop * k)</div></div><!-- fragment --><p> with </p><div class="fragment"><div class="line">C = <a class="code" href="group__constraints.html#gab4b8d59b61a2d51242f62a8efb0b027f">distribute_constraints_linear_operator</a>(constraint_matrix, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(C);</div></div><!-- fragment --><p>This <a class="el" href="classLinearOperator.html">LinearOperator</a> object is used together with <a class="el" href="group__constraints.html#ga84aae431c14515ad113f480541a22b96">constrained_right_hand_side()</a> to build up the following modified system of linear equations: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]" src="form_996.png"/>
</p>
<p> with a given (unconstrained) system matrix <img class="formulaInl" alt="$A$" src="form_40.png"/>, right hand side <img class="formulaInl" alt="$b$" src="form_41.png"/>, and linear constraints <img class="formulaInl" alt="$C$" src="form_43.png"/> with inhomogeneities <img class="formulaInl" alt="$k$" src="form_44.png"/>.</p>
<p>A detailed explanation of this approach is given in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<dl class="section author"><dt>Author</dt><dd>Mauro Bardelloni, Matthias Maier, 2015</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently, this function may not work correctly for distributed data structures. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00280">280</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga0325952967bc36bb8314eb10922c0516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0325952967bc36bb8314eb10922c0516">&#9670;&nbsp;</a></span>make_sparsity_pattern() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a sparsity pattern that allows coupling degrees of freedom on two different but related meshes.</p>
<p>The idea is that if the two given <a class="el" href="classDoFHandler.html">DoFHandler</a> objects correspond to two different meshes (and potentially to different finite elements used on these cells), but that if the two triangulations they are based on are derived from the same coarse mesh through hierarchical refinement, then one may set up a problem where one would like to test shape functions from one mesh against the shape functions from another mesh. In particular, this means that shape functions from a cell on the first mesh are tested against those on the second cell that are located on the corresponding cell; this correspondence is something that the IntergridMap class can determine.</p>
<p>This function then constructs a sparsity pattern for which the degrees of freedom that represent the rows come from the first given <a class="el" href="classDoFHandler.html">DoFHandler</a>, whereas the ones that correspond to columns come from the second <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00200">200</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga13e6fde9a62ec980a910fb83d29c7221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13e6fde9a62ec980a910fb83d29c7221">&#9670;&nbsp;</a></span>make_flux_sparsity_pattern() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>couplings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_couplings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does essentially the same as the previous <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">make_flux_sparsity_pattern()</a> function but allows the application of a constraint matrix. This is useful in the case where some components of a finite element are continuous and some discontinuous, allowing constraints to be imposed on the continuous part while also building the flux terms needed for the discontinuous part. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l01216">1216</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga26118f9936a251b465a6391fe40ec9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26118f9936a251b465a6391fe40ec9d4">&#9670;&nbsp;</a></span>make_boundary_sparsity_pattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_boundary_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the sparsity pattern for boundary matrices. See the general documentation of this class for more information.</p>
<p>The function does essentially what the other <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">make_sparsity_pattern()</a> functions do, but assumes that the bilinear form that is used to build the matrix does not consist of domain integrals, but only of integrals over the boundary of the domain. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00304">304</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga092ce6ed09ae5ec3c6d758d46d79320a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga092ce6ed09ae5ec3c6d758d46d79320a">&#9670;&nbsp;</a></span>make_boundary_sparsity_pattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename SparsityPatternType , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_boundary_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; DoFHandlerType::space_dimension, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a variation of the previous <a class="el" href="group__constraints.html#ga26118f9936a251b465a6391fe40ec9d4">make_boundary_sparsity_pattern()</a> function in which we assume that the boundary integrals that will give rise to the matrix extends only over those parts of the boundary whose boundary indicators are listed in the <code>boundary_ids</code> argument to this function.</p>
<p>This function could have been written by passing a <code>set</code> of boundary_id numbers. However, most of the functions throughout deal.II dealing with boundary indicators take a mapping of boundary indicators and the corresponding boundary function, i.e., a std::map&lt;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, const Function&lt;spacedim,number&gt;*&gt; argument. Correspondingly, this function does the same, though the actual boundary function is ignored here. (Consequently, if you don't have any such boundary functions, just create a map with the boundary indicators you want and set the function pointers to null pointers). </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00373">373</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="gacf101e71f1ed2458bbbfd94e6bf96594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf101e71f1ed2458bbbfd94e6bf96594">&#9670;&nbsp;</a></span>compute_intergrid_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::compute_intergrid_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>coarse_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fine_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_to_fine_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used when different variables in a problem are discretized on different grids, where one grid is strictly coarser than the other. An example are optimization problems where the control variable is often discretized on a coarser mesh than the state variable.</p>
<p>The function's result can be stated as follows mathematically: Let <img class="formulaInl" alt="${\cal T}_0$" src="form_538.png"/> and <img class="formulaInl" alt="${\cal T}_1$" src="form_539.png"/> be two meshes where <img class="formulaInl" alt="${\cal T}_1$" src="form_539.png"/> results from <img class="formulaInl" alt="${\cal T}_0$" src="form_538.png"/> strictly by refining or leaving alone the cells of <img class="formulaInl" alt="${\cal T}_0$" src="form_538.png"/>. Using the same finite element on both, there are function spaces <img class="formulaInl" alt="${\cal V}_0$" src="form_540.png"/> and <img class="formulaInl" alt="${\cal V}_1$" src="form_541.png"/> associated with these meshes. Then every function <img class="formulaInl" alt="$v_0 \in {\cal V}_0$" src="form_542.png"/> can of course also be represented exactly in <img class="formulaInl" alt="${\cal V}_1$" src="form_541.png"/> since by construction <img class="formulaInl" alt="${\cal V}_0 \subset {\cal V}_1$" src="form_543.png"/>. However, not every function in <img class="formulaInl" alt="${\cal V}_1$" src="form_541.png"/> can be expressed as a linear combination of the shape functions of <img class="formulaInl" alt="${\cal V}_0$" src="form_540.png"/>. The functions that can be represented lie in a homogenous subspace of <img class="formulaInl" alt="${\cal V}_1$" src="form_541.png"/> (namely, <img class="formulaInl" alt="${\cal V}_0$" src="form_540.png"/>, of course) and this subspace can be represented by a linear constraint of the form <img class="formulaInl" alt="$CV=0$" src="form_544.png"/> where <img class="formulaInl" alt="$V$" src="form_204.png"/> is the vector of nodal values of functions <img class="formulaInl" alt="$v\in {\cal V}_1$" src="form_545.png"/>. In other words, every function <img class="formulaInl" alt="$v_h=\sum_j V_j \varphi_j^{(1)} \in {\cal V}_1$" src="form_546.png"/> that also satisfies <img class="formulaInl" alt="$v_h\in {\cal V}_0$" src="form_547.png"/> automatically satisfies <img class="formulaInl" alt="$CV=0$" src="form_544.png"/>. This function computes the matrix <img class="formulaInl" alt="$C$" src="form_43.png"/> in the form of a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object.</p>
<p>The construction of these constraints is done as follows: for each of the degrees of freedom (i.e. shape functions) on the coarse grid, we compute its representation on the fine grid, i.e. how the linear combination of shape functions on the fine grid looks like that resembles the shape function on the coarse grid. From this information, we can then compute the constraints which have to hold if a solution of a linear equation on the fine grid shall be representable on the coarse grid. The exact algorithm how these constraints can be computed is rather complicated and is best understood by reading the source code, which contains many comments.</p>
<p>The use of this function is as follows: it accepts as parameters two DoF Handlers, the first of which refers to the coarse grid and the second of which is the fine grid. On both, a finite element is represented by the DoF handler objects, which will usually have several vector components, which may belong to different base elements. The second and fourth parameter of this function therefore state which vector component on the coarse grid shall be used to restrict the stated component on the fine grid. The finite element used for the respective components on the two grids needs to be the same. An example may clarify this: consider an optimization problem with controls <img class="formulaInl" alt="$q$" src="form_171.png"/> discretized on a coarse mesh and a state variable <img class="formulaInl" alt="$u$" src="form_256.png"/> (and corresponding Lagrange multiplier <img class="formulaInl" alt="$\lambda$" src="form_548.png"/>) discretized on the fine mesh. These are discretized using piecewise constant discontinuous, continuous linear, and continuous linear elements, respectively. Only the parameter <img class="formulaInl" alt="$q$" src="form_171.png"/> is represented on the coarse grid, thus the <a class="el" href="classDoFHandler.html">DoFHandler</a> object on the coarse grid represents only one variable, discretized using piecewise constant discontinuous elements. Then, the parameter denoting the vector component on the coarse grid would be zero (the only possible choice, since the variable on the coarse grid is scalar). If the ordering of variables in the fine mesh <a class="el" href="classFESystem.html">FESystem</a> is <img class="formulaInl" alt="$u, q, \lambda$" src="form_549.png"/>, then the fourth argument of the function corresponding to the vector component would be one (corresponding to the variable <img class="formulaInl" alt="$q$" src="form_171.png"/>; zero would be <img class="formulaInl" alt="$u$" src="form_256.png"/>, two would be <img class="formulaInl" alt="$\lambda$" src="form_548.png"/>).</p>
<p>The function also requires an object of type IntergridMap representing how to get from the coarse mesh cells to the corresponding cells on the fine mesh. This could in principle be generated by the function itself from the two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, but since it is probably available anyway in programs that use different meshes, the function simply takes it as an argument.</p>
<p>The computed constraints are entered into a variable of type <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>; previous contents are not deleted. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l02985">2985</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="ga024b972c7426a7cae7c7d4a1037f6723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga024b972c7426a7cae7c7d4a1037f6723">&#9670;&nbsp;</a></span>compute_intergrid_transfer_representation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::compute_intergrid_transfer_representation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>coarse_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fine_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_to_fine_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer_representation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function generates a matrix such that when a vector of data with as many elements as there are degrees of freedom of this component on the coarse grid is multiplied to this matrix, we obtain a vector with as many elements as there are global degrees of freedom on the fine grid. All the elements of the other vector components of the finite element fields on the fine grid are not touched.</p>
<p><a class="el" href="classTriangulation.html">Triangulation</a> of the fine grid can be distributed. When called in parallel, each process has to have a copy of the coarse grid. In this case, function returns transfer representation for a set of locally owned cells.</p>
<p>The output of this function is a compressed format that can be used to construct corresponding sparse transfer matrix. </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l03156">3156</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
