<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-52 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-52 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemstatement">Problem statement</a>
        <li><a href="#RungeKuttamethods">Runge-Kutta methods</a>
      <ul>
        <li><a href="#ExplicitRungeKuttamethods">Explicit Runge-Kutta methods</a>
        <li><a href="#EmbeddedRungeKuttamethods">Embedded Runge-Kutta methods</a>
        <li><a href="#ImplicitRungeKuttamethods">Implicit Runge-Kutta methods</a>
      </ul>
        <li><a href="#Spatiallydiscreteformulation">Spatially discrete formulation</a>
        <li><a href="#Notesonthetestcase">Notes on the testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeDiffusioncodeclass">The <code>Diffusion</code> class</a>
      <ul>
        <li><a href="#codeDiffusionsetup_systemcode"><code>Diffusion::setup_system</code></a>
        <li><a href="#codeDiffusionassemble_systemcode"><code>Diffusion::assemble_system</code></a>
        <li><a href="#codeDiffusionget_sourcecode"><code>Diffusion::get_source</code></a>
        <li><a href="#codeDiffusionevaluate_diffusioncode"><code>Diffusion:evaluate_diffusion</code></a>
        <li><a href="#codeDiffusionid_minus_tau_J_inversecode"><code>Diffusion::id_minus_tau_J_inverse</code></a>
        <li><a href="#codeDiffusionoutput_resultscode"><code>Diffusion::output_results</code></a>
        <li><a href="#codeDiffusionexplicit_methodcode"><code>Diffusion::explicit_method</code></a>
        <li><a href="#codeDiffusionimplicit_methodcode"><code>Diffusion::implicit_method</code></a>
        <li><a href="#codeDiffusionembedded_explicit_methodcode"><code>Diffusion::embedded_explicit_method</code></a>
        <li><a href="#codeDiffusionruncode"><code>Diffusion::run</code></a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Bruno Turcksin and Damien Lebrun-Grandie.</em></p>
<dl class="section note"><dt>Note</dt><dd>In order to run this program, deal.II must be configured to use the UMFPACK sparse direct solver. Refer to the <a href="../../readme.html#umfpack">ReadMe</a> for instructions how to do this.</dd></dl>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introducion"></a></p><h1>Introducion</h1>
<p>This program shows how to use Runge-Kutta methods to solve a time-dependent problem. It solves a small variation of the heat equation discussed first in <a class="el" href="step_26.html">step-26</a> but, since the purpose of this program is only to demonstrate using more advanced ways to interface with deal.II's time stepping algorithms, only solves a simple problem on a uniformly refined mesh.</p>
<p><a class="anchor" id="Problemstatement"></a></p><h3>Problem statement</h3>
<p>In this example, we solve the one-group time-dependent diffusion approximation of the neutron transport equation (see <a class="el" href="step_28.html">step-28</a> for the time-independent multigroup diffusion). This is a model for how neutrons move around highly scattering media, and consequently it is a variant of the time-dependent diffusion equation &ndash; which is just a different name for the heat equation discussed in <a class="el" href="step_26.html">step-26</a>, plus some extra terms. We assume that the medium is not fissible and therefore, the neutron flux satisfies the following equation: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{1}{v}\frac{\partial \phi(x,t)}{\partial t} = \nabla \cdot D(x) \nabla \phi(x,t) - \Sigma_a(x) \phi(x,t) + S(x,t) \end{eqnarray*}" src="form_3953.png"/>
</p>
<p> augmented by appropriate boundary conditions. Here, <img class="formulaInl" alt="$v$" src="form_987.png"/> is the velocity of neutrons (for simplicity we assume it is equal to 1 which can be achieved by simply scaling the time variable), <img class="formulaInl" alt="$D$" src="form_1015.png"/> is the diffusion coefficient, <img class="formulaInl" alt="$\Sigma_a$" src="form_3954.png"/> is the absorption cross section, and <img class="formulaInl" alt="$S$" src="form_731.png"/> is a source. Because we are only interested in the time dependence, we assume that <img class="formulaInl" alt="$D$" src="form_1015.png"/> and <img class="formulaInl" alt="$\Sigma_a$" src="form_3954.png"/> are constant.</p>
<p>Since this program only intends to demonstrate how to use advanced time stepping algorithms, we will only look for the solutions of relatively simple problems. Specifically, we are looking for a solution on a square domain <img class="formulaInl" alt="$[0,b]\times[0,b]$" src="form_3955.png"/> of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \phi(x,t) = A\sin(\omega t)(bx-x^2). \end{eqnarray*}" src="form_3956.png"/>
</p>
<p> By using quadratic finite elements, we can represent this function exactly at any particular time, and all the error will be due to the time discretization. We do this because it is then easy to observe the order of convergence of the various time stepping schemes we will consider, without having to separate spatial and temporal errors.</p>
<p>We impose the following boundary conditions: homogeneous Dirichlet for <img class="formulaInl" alt="$x=0$" src="form_810.png"/> and <img class="formulaInl" alt="$x=b$" src="form_3957.png"/> and homogeneous Neumann conditions for <img class="formulaInl" alt="$y=0$" src="form_3958.png"/> and <img class="formulaInl" alt="$y=b$" src="form_3959.png"/>. We choose the source term so that the corresponding solution is in fact of the form stated above: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} S=A\left(\frac{1}{v}\omega \cos(\omega t)(bx -x^2) + \sin(\omega t) \left(\Sigma_a (bx-x^2)+2D\right) \right). \end{eqnarray*}" src="form_3960.png"/>
</p>
<p> Because the solution is a sine in time, we know that the exact solution satisfies <img class="formulaInl" alt="$\phi\left(x,\pi\right) = 0$" src="form_3961.png"/>. Therefore, the error at time <img class="formulaInl" alt="$t=\pi$" src="form_3962.png"/> is simply the norm of the numerical solution, i.e., <img class="formulaInl" alt="$\|e(\cdot,t=\pi)\|_{L_2} = \|\phi_h(\cdot,t=\pi)\|_{L_2}$" src="form_3963.png"/>, and is particularly easily evaluated. In the code, we evaluate the <img class="formulaInl" alt="$l_2$" src="form_111.png"/> norm of the vector of nodal values of <img class="formulaInl" alt="$\phi_h$" src="form_2992.png"/> instead of the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> norm of the associated spatial function, since the former is simpler to compute; however, on uniform meshes, the two are just related by a constant and we can consequently observe the temporal convergence order with either.</p>
<p><a class="anchor" id="RungeKuttamethods"></a></p><h3>Runge-Kutta methods</h3>
<p>The Runge-Kutta methods implemented in deal.II assume that the equation to be solved can be written as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{dy}{dt} = g(t,y). \end{eqnarray*}" src="form_3964.png"/>
</p>
<p> On the other hand, when using finite elements, discretized time derivatives always result in the presence of a mass matrix on the left hand side. This can easily be seen by considering that if the solution vector <img class="formulaInl" alt="$y(t)$" src="form_3965.png"/> in the equation above is in fact the vector of nodal coefficients <img class="formulaInl" alt="$U(t)$" src="form_3966.png"/> for a variable of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} u_h(x,t) = \sum_j U_j(t) \varphi_j(x) \end{eqnarray*}" src="form_3967.png"/>
</p>
<p> with spatial shape functions <img class="formulaInl" alt="$\varphi_j(x)$" src="form_3968.png"/>, then multiplying an equation of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{\partial u(x,t)}{\partial t} = q(t,u(x,t)) \end{eqnarray*}" src="form_3969.png"/>
</p>
<p> by test functions, integrating over <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>, substituting <img class="formulaInl" alt="$u\rightarrow u_h$" src="form_3970.png"/> and restricting the test functions to the <img class="formulaInl" alt="$\varphi_i(x)$" src="form_3971.png"/> from above, then this spatially discretized equation has the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M\frac{dU}{dt} = f(t,U), \end{eqnarray*}" src="form_3972.png"/>
</p>
<p> where <img class="formulaInl" alt="$M$" src="form_64.png"/> is the mass matrix and <img class="formulaInl" alt="$f(t,U)$" src="form_3973.png"/> is the spatially discretized version of <img class="formulaInl" alt="$q(t,u(x,t))$" src="form_3974.png"/> (where <img class="formulaInl" alt="$q$" src="form_171.png"/> is typically the place where spatial derivatives appear, but this is not of much concern for the moment given that we only consider time derivatives). In other words, this form fits the general scheme above if we write </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{dy}{dt} = g(t,y) = M^{-1}f(t,y). \end{eqnarray*}" src="form_3975.png"/>
</p>
<p>Runke-Kutta methods are time stepping schemes that approximate <img class="formulaInl" alt="$y(t_n)\approx y_{n}$" src="form_3976.png"/> through a particular one-step approach. They are typically written in the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} y_{n+1} = y_n + \sum_{i=1}^s b_i k_i \end{eqnarray*}" src="form_3977.png"/>
</p>
<p> where for the form of the right hand side above </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} k_i = h M^{-1} f\left(t_n+c_ih,y_n+\sum_{j=1}^sa_{ij}k_j\right). \end{eqnarray*}" src="form_3978.png"/>
</p>
<p> Here <img class="formulaInl" alt="$a_{ij}$" src="form_524.png"/>, <img class="formulaInl" alt="$b_i$" src="form_22.png"/>, and <img class="formulaInl" alt="$c_i$" src="form_3979.png"/> are known coefficients that identify which particular Runge-Kutta scheme you want to use, and <img class="formulaInl" alt="$h=t_{n+1}-t_n$" src="form_3980.png"/> is the time step used. Different time stepping methods of the Runge-Kutta class differ in the number of stages <img class="formulaInl" alt="$s$" src="form_308.png"/> and the values they use for the coefficients <img class="formulaInl" alt="$a_{ij}$" src="form_524.png"/>, <img class="formulaInl" alt="$b_i$" src="form_22.png"/>, and <img class="formulaInl" alt="$c_i$" src="form_3979.png"/> but are otherwise easy to implement since one can look up tabulated values for these coefficients. (These tables are often called Butcher tableaus.)</p>
<p>At the time of the writing of this tutorial, the methods implemented in deal.II can be divided in three categories: </p><ol>
<li>
Explicit Runge-Kutta; in order for a method to be explicit, it is necessary that in the formula above defining <img class="formulaInl" alt="$k_i$" src="form_3981.png"/>, <img class="formulaInl" alt="$k_i$" src="form_3981.png"/> does not appear on the right hand side. In other words, these methods have to satisfy <img class="formulaInl" alt="$a_{ii}=0, i=1,\ldots,s$" src="form_3982.png"/>. </li>
<li>
Embedded (or adaptive) Runge-Kutta; we will discuss their properties below. </li>
<li>
Implicit Runge-Kutta; this class of methods require the solution of a possibly nonlinear system the stages <img class="formulaInl" alt="$k_i$" src="form_3981.png"/> above, i.e., they have <img class="formulaInl" alt="$a_{ii}\neq 0$" src="form_3983.png"/> for at least one of the stages <img class="formulaInl" alt="$i=1,\ldots,s$" src="form_3984.png"/>. </li>
</ol>
<p>Many well known time stepping schemes that one does not typically associate with the names Runge or Kutta can in fact be written in a way so that they, too, can be expressed in these categories. They oftentimes represent the lowest-order members of these families.</p>
<p><a class="anchor" id="ExplicitRungeKuttamethods"></a></p><h4>Explicit Runge-Kutta methods</h4>
<p>These methods, only require a function to evaluate <img class="formulaInl" alt="$M^{-1}f(t,y)$" src="form_3985.png"/> but not (as implicit methods) to solve an equation that involves <img class="formulaInl" alt="$f(t,y)$" src="form_3986.png"/> for <img class="formulaInl" alt="$y$" src="form_10.png"/>. As all explicit time stepping methods, they become unstable when the time step chosen is too large.</p>
<p>Well known methods in this class include forward Euler, third order Runge-Kutta, and fourth order Runge-Kutta (often abbreviated as RK4).</p>
<p><a class="anchor" id="EmbeddedRungeKuttamethods"></a></p><h4>Embedded Runge-Kutta methods</h4>
<p>These methods use both a lower and a higher order method to estimate the error and decide if the time step needs to be shortened or can be increased. The term "embedded" refers to the fact that the lower-order method does not require additional evaluates of the function <img class="formulaInl" alt="$M^{-1}f(\cdot,\cdot)$" src="form_3987.png"/> but reuses data that has to be computed for the high order method anyway. It is, in other words, essentially free, and we get the error estimate as a side product of using the higher order method.</p>
<p>This class of methods include Heun-Euler, Bogacki-Shampine, Dormand-Prince (ode45 in Matlab and often abbreviated as RK45 to indicate that the lower and higher order methods used here are 4th and 5th order Runge-Kutta methods, respectively), Fehlberg, and Cash-Karp.</p>
<p>At the time of the writing, only embedded explicit methods have been implemented.</p>
<p><a class="anchor" id="ImplicitRungeKuttamethods"></a></p><h4>Implicit Runge-Kutta methods</h4>
<p>Implicit methods require the solution of (possibly nonlinear) systems of the form <img class="formulaInl" alt="$\alpha y = f(t,y)$" src="form_3988.png"/> for <img class="formulaInl" alt="$y$" src="form_10.png"/> in each (sub-)timestep. Internally, this is done using a Newton-type method and, consequently, they require that the user provide functions that can evaluate <img class="formulaInl" alt="$M^{-1}f(t,y)$" src="form_3985.png"/> and <img class="formulaInl" alt="$\left(I-\tau M^{-1} \frac{\partial f}{\partial y}\right)^{-1}$" src="form_3989.png"/> or equivalently <img class="formulaInl" alt="$\left(M - \tau \frac{\partial f}{\partial y}\right)^{-1} M$" src="form_3990.png"/>.</p>
<p>The particular form of this operator results from the fact that each Newton step requires the solution of an equation of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \left(M - \tau \frac{\partial f}{\partial y}\right) \Delta y = -M h(t,y) \end{align*}" src="form_3991.png"/>
</p>
<p> for some (given) <img class="formulaInl" alt="$h(t,y)$" src="form_3992.png"/>. Implicit methods are always stable, regardless of the time step size, but too large time steps of course affect the <em>accuracy</em> of the solution, even if the numerical solution remains stable and bounded.</p>
<p>Methods in this class include backward Euler, implicit midpoint, Crank-Nicolson, and the two stage SDIRK method (short for "singly diagonally
implicit Runge-Kutta", a term coined to indicate that the diagonal elements <img class="formulaInl" alt="$a_{ii}$" src="form_1120.png"/> defining the time stepping method are all equal; this property allows for the Newton matrix <img class="formulaInl" alt="$I-\tau M^{-1}\frac{\partial f}{\partial y}$" src="form_3993.png"/> to be re-used between stages because <img class="formulaInl" alt="$\tau$" src="form_1599.png"/> is the same every time).</p>
<p><a class="anchor" id="Spatiallydiscreteformulation"></a></p><h3>Spatially discrete formulation</h3>
<p>By expanding the solution of our model problem as always using shape functions <img class="formulaInl" alt="$\psi_j$" src="form_3994.png"/> and writing </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \phi_h(x,t) = \sum_j U_j(t) \psi_j(x), \end{eqnarray*}" src="form_3995.png"/>
</p>
<p> we immediately get the spatially discretized version of the diffusion equation as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M \frac{dU(t)}{dt} = -{\cal D} U(t) - {\cal A} U(t) + {\cal S}(t) \end{eqnarray*}" src="form_3996.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M_{ij} &amp;=&amp; (\psi_i,\psi_j), \\ {\cal D}_{ij} &amp;=&amp; (D\nabla\psi_i,\nabla\psi_j)_\Omega, \\ {\cal A}_{ij} &amp;=&amp; (\Sigma_a\psi_i,\psi_j)_\Omega, \\ {\cal S}_{i}(t) &amp;=&amp; (\psi_i,S(x,t))_\Omega. \end{eqnarray*}" src="form_3997.png"/>
</p>
<p> See also <a class="el" href="step_24.html">step-24</a> and <a class="el" href="step_26.html">step-26</a> to understand how we arrive here. Boundary terms are not necessary due to the chosen boundary conditions for the current problem. To use the Runge-Kutta methods, we recast this as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f(y) = -{\cal D}y - {\cal A}y + {\cal S}. \end{eqnarray*}" src="form_3998.png"/>
</p>
<p> In the code, we will need to be able to evaluate this function <img class="formulaInl" alt="$f(U)$" src="form_3999.png"/> along with its derivative, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{\partial f}{\partial y} = -{\cal D} - {\cal A}. \end{eqnarray*}" src="form_4000.png"/>
</p>
<p><a class="anchor" id="Notesonthetestcase"></a></p><h3>Notes on the testcase</h3>
<p>To simplify the problem, the domain is two dimensional and the mesh is uniformly refined (there is no need to adapt the mesh since we use quadratic finite elements and the exact solution is quadratic). Going from a two dimensional domain to a three dimensional domain is not very challenging. However if you intend to solve more complex problems where the mesh must be adapted (as is done, for example, in <a class="el" href="step_26.html">step-26</a>), then it is important to remember the following issues:</p>
<ol>
<li>
You will need to project the solution to the new mesh when the mesh is changed. Of course, the mesh used should be the same from the beginning to the end of each time step, a question that arises because Runge-Kutta methods use multiple evaluations of the equations within each time step. </li>
<li>
You will need to update the mass matrix and its inverse every time the mesh is changed. </li>
</ol>
<p>The techniques for these steps are readily available by looking at <a class="el" href="step_26.html">step-26</a>. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first task as usual is to include the functionality of these well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div></div><!-- fragment --><p>This is the only include file that is new: It includes all the Runge-Kutta methods.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/time_stepping.h&gt;</span></div></div><!-- fragment --><p>The next step is like in all previous tutorial programs: We put everything into a namespace of its own and then import the deal.II classes and functions into it.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step52</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeDiffusioncodeclass"></a> </p><h3>The <code>Diffusion</code> class</h3>
<p>The next piece is the declaration of the main class. Most of the functions in this class are not new and have been explained in previous tutorials. The only interesting functions are <code>evaluate_diffusion()</code> and <code>id_minus_tau_J_inverse()</code>. <code>evaluate_diffusion()</code> evaluates the diffusion equation, <img class="formulaInl" alt="$M^{-1}(f(t,y))$" src="form_4001.png"/>, at a given time and a given <img class="formulaInl" alt="$y$" src="form_10.png"/>. <code>id_minus_tau_J_inverse()</code> evaluates <img class="formulaInl" alt="$\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}$" src="form_4002.png"/> or equivalently <img class="formulaInl" alt="$\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M$" src="form_4003.png"/> at a given time, for a given <img class="formulaInl" alt="$\tau$" src="form_1599.png"/> and <img class="formulaInl" alt="$y$" src="form_10.png"/>. This function is needed when an implicit method is used.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Diffusion</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Diffusion();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_source (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> evaluate_diffusion (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> id_minus_tau_J_inverse (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> tau,</div><div class="line">                                         <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time_step,</div><div class="line">                       <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method) <span class="keyword">const</span>;</div></div><!-- fragment --><p>The next three functions are the drivers for the explicit methods, the implicit methods, and the embedded explicit methods respectively. The driver function for embedded explicit methods returns the number of steps executed given that it only takes the number of time steps passed as an argument as a hint, but internally computed the optimal time step itself.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> explicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> implicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_explicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span>                     initial_time,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span>                     final_time);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                 fe_degree;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>                       diffusion_coefficient;</div><div class="line">  <span class="keywordtype">double</span>                       absorption_cross_section;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>             triangulation;</div><div class="line"></div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>                      fe;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>                dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>             constraint_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>              sparsity_pattern;</div><div class="line"></div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>         system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>         mass_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>         mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>          inverse_mass_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>               solution;</div><div class="line">};</div></div><!-- fragment --><p>We choose quadratic finite elements and we initialize the parameters.</p>
<div class="fragment"><div class="line">Diffusion::Diffusion()</div><div class="line">  :</div><div class="line">  fe_degree(2),</div><div class="line">  diffusion_coefficient(1./30.),</div><div class="line">  absorption_cross_section(1.),</div><div class="line">  fe(fe_degree),</div><div class="line">  dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionsetup_systemcode"></a> </p><h4><code>Diffusion::setup_system</code></h4>
<p>Now, we create the constraint matrix and the sparsity pattern. Then, we initialize the matrices and the solution vector.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler,1,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;2&gt;</a>(),constraint_matrix);</div><div class="line">  constraint_matrix.close();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler,dsp,constraint_matrix);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(sparsity_pattern);</div><div class="line">  mass_minus_tau_Jacobian.reinit(sparsity_pattern);</div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionassemble_systemcode"></a> </p><h4><code>Diffusion::assemble_system</code></h4>
<p>In this function, we compute <img class="formulaInl" alt="$-\int D \nabla b_i \cdot \nabla b_j d\boldsymbol{r} - \int \Sigma_a b_i b_j d\boldsymbol{r}$" src="form_4004.png"/> and the mass matrix <img class="formulaInl" alt="$\int b_i b_j d\boldsymbol{r}$" src="form_4005.png"/>. The mass matrix is then inverted using a direct solver; the <code>inverse_mass_matrix</code> variable will then store the inverse of the mass matrix so that <img class="formulaInl" alt="$M^{-1}$" src="form_1703.png"/> can be applied to a vector using the <code>vmult()</code> function of that object. (Internally, UMFPACK does not really store the inverse of the matrix, but its LU factors; applying the inverse matrix is then equivalent to doing one forward and one backward solves with these two factors, which has the same complexity as applying an explicit inverse of the matrix).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::assemble_system ()</div><div class="line">{</div><div class="line">  system_matrix = 0.;</div><div class="line">  mass_matrix = 0.;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree+1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe, quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      cell_matrix = 0.;</div><div class="line">      cell_mass_matrix = 0.;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              cell_matrix(i,j) += ((-diffusion_coefficient *</div><div class="line">                                    fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                    fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point)</div><div class="line">                                    - absorption_cross_section *</div><div class="line">                                    fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                    fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point)) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              cell_mass_matrix(i,j) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point) *</div><div class="line">                                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">            }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraint_matrix.distribute_local_to_global(cell_matrix,local_dof_indices,system_matrix);</div><div class="line">      constraint_matrix.distribute_local_to_global(cell_mass_matrix,local_dof_indices,mass_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  inverse_mass_matrix.<a class="code" href="classDoFHandler.html#aeca4a4af5c4d7f7c68a4def9ae87bc7b">initialize</a>(mass_matrix);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionget_sourcecode"></a> </p><h4><code>Diffusion::get_source</code></h4>
<p>In this function, the source term of the equation for a given time and a given point is computed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> Diffusion::get_source (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                              <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> intensity = 10.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> frequency = <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>/10.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> b = 5.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x = point(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> intensity* (frequency*std::cos(frequency*time)*(b*x-x*x)</div><div class="line">                     +</div><div class="line">                     std::sin(frequency*time) * (absorption_cross_section*(b*x-x*x)</div><div class="line">                                                 +</div><div class="line">                                                 2.*diffusion_coefficient));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionevaluate_diffusioncode"></a> </p><h4><code>Diffusion:evaluate_diffusion</code></h4>
<p>Next, we evaluate the weak form of the diffusion equation at a given time <img class="formulaInl" alt="$t$" src="form_844.png"/> and for a given vector <img class="formulaInl" alt="$y$" src="form_10.png"/>. In other words, as outlined in the introduction, we evaluate <img class="formulaInl" alt="$M^{-1}(-{\cal D}y - {\cal A}y + {\cal S})$" src="form_4006.png"/>. For this, we have to apply the matrix <img class="formulaInl" alt="$-{\cal D} - {\cal A}$" src="form_4007.png"/> (previously computed and stored in the variable <code>system_matrix</code>) to <img class="formulaInl" alt="$y$" src="form_10.png"/> and then add the source term which we integrate as we usually do. (Integrating up the solution could be done using <a class="el" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">VectorTools::create_right_hand_side()</a> if you wanted to save a few lines of code, or wanted to take advantage of doing the integration in parallel.) The result is then multiplied by <img class="formulaInl" alt="$M^{-1}$" src="form_1703.png"/>.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::evaluate_diffusion (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                                              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  tmp = 0.;</div><div class="line">  system_matrix.vmult(tmp,y);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree+1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>  cell_source(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      cell_source = 0.;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> source = get_source(time,</div><div class="line">                                           fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point));</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            cell_source(i) += source *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraint_matrix.distribute_local_to_global(cell_source,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   tmp);</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> value(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  inverse_mass_matrix.vmult(value,tmp);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> value;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionid_minus_tau_J_inversecode"></a> </p><h4><code>Diffusion::id_minus_tau_J_inverse</code></h4>
<p>We compute <img class="formulaInl" alt="$\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M$" src="form_4003.png"/>. This is done in several steps:</p><ul>
<li>compute <img class="formulaInl" alt="$M-\tau \frac{\partial f}{\partial y}$" src="form_4008.png"/></li>
<li>invert the matrix to get <img class="formulaInl" alt="$\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1}$" src="form_4009.png"/></li>
<li>compute <img class="formulaInl" alt="$tmp=My$" src="form_4010.png"/></li>
<li>compute <img class="formulaInl" alt="$z=\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} tmp = \left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} My$" src="form_4011.png"/></li>
<li>return z.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::id_minus_tau_J_inverse (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                                                  <span class="keyword">const</span> <span class="keywordtype">double</span> tau,</div><div class="line">                                                  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)</div><div class="line">{</div><div class="line">  (void) time;</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">  mass_minus_tau_Jacobian.copy_from(mass_matrix);</div><div class="line">  mass_minus_tau_Jacobian.add(-tau, system_matrix);</div><div class="line"></div><div class="line">  inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(mass_minus_tau_Jacobian);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a2697cc4cb0be492f39f95ad8a816d7d4">vmult</a>(tmp, y);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> result(y);</div><div class="line">  inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(result,tmp);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionoutput_resultscode"></a> </p><h4><code>Diffusion::output_results</code></h4>
<p>The following function then outputs the solution in vtu files indexed by the number of the time step and the name of the time stepping method. Of course, the (exact) result should really be the same for all time stepping method, but the output here at least allows us to compare them.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time_step,</div><div class="line">                                <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::string method_name;</div><div class="line"></div><div class="line">  <span class="keywordflow">switch</span> (method)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::FORWARD_EULER:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;forward_euler&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::RK_THIRD_ORDER:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;rk3&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::RK_CLASSIC_FOURTH_ORDER:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;rk4&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::BACKWARD_EULER:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;backward_euler&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::IMPLICIT_MIDPOINT:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;implicit_midpoint&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::SDIRK_TWO_STAGES:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;sdirk&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::HEUN_EULER:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;heun_euler&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::BOGACKI_SHAMPINE:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;bocacki_shampine&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::DOPRI:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;dopri&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::FEHLBERG:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;fehlberg&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">case</span> TimeStepping::CASH_KARP:</div><div class="line">    {</div><div class="line">      method_name = <span class="stringliteral">&quot;cash_karp&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">    {</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + method_name + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (time_step, 3) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename.c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionexplicit_methodcode"></a> </p><h4><code>Diffusion::explicit_method</code></h4>
<p>This function is the driver for all the explicit methods. It calls <code>evolve_one_time_step</code> which performs one time step. For explicit methods, <code>evolve_one_time_step</code> needs to evaluate <img class="formulaInl" alt="$M^{-1}(f(t,y))$" src="form_4001.png"/>, i.e, it needs <code>evaluate_diffusion</code>. Because <code>evaluate_diffusion</code> is a member function, it needs to be bound to <code>this</code>. Finally, the solution is output every 10 time steps.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::explicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step = (final_time-initial_time)/static_cast&lt;double&gt; (n_time_steps);</div><div class="line">  <span class="keywordtype">double</span> time = initial_time;</div><div class="line">  solution = 0.;</div><div class="line"></div><div class="line">  <a class="code" href="classTimeStepping_1_1ExplicitRungeKutta.html">TimeStepping::ExplicitRungeKutta&lt;Vector&lt;double&gt;</a> &gt; explicit_runge_kutta(method);</div><div class="line">  output_results(0,method);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_time_steps; ++i)</div><div class="line">    {</div><div class="line">      time = explicit_runge_kutta.evolve_one_time_step(</div><div class="line">               std::bind(&amp;Diffusion::evaluate_diffusion,</div><div class="line">                         <span class="keyword">this</span>,</div><div class="line">                         std::placeholders::_1,</div><div class="line">                         std::placeholders::_2),</div><div class="line">               time,time_step,solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((i+1)%10==0)</div><div class="line">        output_results(i+1,method);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionimplicit_methodcode"></a> </p><h4><code>Diffusion::implicit_method</code></h4>
<p>This function is equivalent to <code>explicit_method</code> but for implicit methods. When using implicit methods, we need to evaluate <img class="formulaInl" alt="$M^{-1}(f(t,y))$" src="form_4001.png"/> and <img class="formulaInl" alt="$\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}$" src="form_4002.png"/> for which we use the two member functions previously introduced.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::implicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step = (final_time-initial_time)/static_cast&lt;double&gt; (n_time_steps);</div><div class="line">  <span class="keywordtype">double</span> time = initial_time;</div><div class="line">  solution = 0.;</div><div class="line"></div><div class="line">  <a class="code" href="classTimeStepping_1_1ImplicitRungeKutta.html">TimeStepping::ImplicitRungeKutta&lt;Vector&lt;double&gt;</a> &gt; implicit_runge_kutta(method);</div><div class="line">  output_results(0,method);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_time_steps; ++i)</div><div class="line">    {</div><div class="line">      time = implicit_runge_kutta.evolve_one_time_step(</div><div class="line">               std::bind(&amp;Diffusion::evaluate_diffusion,</div><div class="line">                         <span class="keyword">this</span>,</div><div class="line">                         std::placeholders::_1,</div><div class="line">                         std::placeholders::_2),</div><div class="line">               std::bind(&amp;Diffusion::id_minus_tau_J_inverse,</div><div class="line">                         <span class="keyword">this</span>,</div><div class="line">                         std::placeholders::_1,</div><div class="line">                         std::placeholders::_2,</div><div class="line">                         std::placeholders::_3),</div><div class="line">               time,time_step,solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((i+1)%10==0)</div><div class="line">        output_results(i+1,method);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionembedded_explicit_methodcode"></a> </p><h4><code>Diffusion::embedded_explicit_method</code></h4>
<p>This function is the driver for the embedded explicit methods. It requires more parameters:</p><ul>
<li>coarsen_param: factor multiplying the current time step when the error is below the threshold.</li>
<li>refine_param: factor multiplying the current time step when the error is above the threshold.</li>
<li>min_delta: smallest time step acceptable.</li>
<li>max_delta: largest time step acceptable.</li>
<li>refine_tol: threshold above which the time step is refined.</li>
<li>coarsen_tol: threshold below which the time step is coarsen. Embedded methods use a guessed time step. If the error using this time step is too large, the time step will be reduced. If the error is below the threshold, a larger time step will be tried for the next time step. <code>delta_t_guess</code> is the guessed time step produced by the embedded method.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Diffusion::embedded_explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                                                 <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                                                 <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> time_step = (final_time-initial_time)/static_cast&lt;double&gt; (n_time_steps);</div><div class="line">  <span class="keywordtype">double</span> time = initial_time;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_param = 1.2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> refine_param = 0.8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_delta = 1e-8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_delta = 10*time_step;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> refine_tol = 1e-1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_tol = 1e-5;</div><div class="line">  solution = 0.;</div><div class="line"></div><div class="line">  <a class="code" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html">TimeStepping::EmbeddedExplicitRungeKutta&lt;Vector&lt;double&gt;</a> &gt;</div><div class="line">  embedded_explicit_runge_kutta(method,</div><div class="line">                                coarsen_param,</div><div class="line">                                refine_param,</div><div class="line">                                min_delta,</div><div class="line">                                max_delta,</div><div class="line">                                refine_tol,</div><div class="line">                                coarsen_tol);</div><div class="line">  output_results (0, method);</div></div><!-- fragment --><p>Now for the time loop. The last time step is chosen such that the final time is exactly reached.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps=0;</div><div class="line">  <span class="keywordflow">while</span> (time&lt;final_time)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (time+time_step&gt;final_time)</div><div class="line">        time_step = final_time-time;</div><div class="line"></div><div class="line">      time = embedded_explicit_runge_kutta.evolve_one_time_step(</div><div class="line">               std::bind(&amp;Diffusion::evaluate_diffusion,<span class="keyword">this</span>,std::placeholders::_1,std::placeholders::_2),</div><div class="line">               time,time_step,solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((n_steps+1)%10==0)</div><div class="line">        output_results(n_steps+1,method);</div><div class="line"></div><div class="line">      time_step = embedded_explicit_runge_kutta.get_status().delta_t_guess;</div><div class="line">      ++n_steps;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> n_steps;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionruncode"></a> </p><h4><code>Diffusion::run</code></h4>
<p>The following is the main function of the program. At the top, we create the grid (a [0,5]x[0,5] square) and refine it four times to get a mesh that has 16 by 16 cells, for a total of 256. We then set the boundary indicator to 1 for those parts of the boundary where <img class="formulaInl" alt="$x=0$" src="form_810.png"/> and <img class="formulaInl" alt="$x=5$" src="form_4012.png"/>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::run ()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 5.);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;2&gt;::faces_per_cell; ++f)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;face(f)-&gt;center()[0]==0.) || (cell-&gt;face(f)-&gt;center()[0]==5.))</div><div class="line">            cell-&gt;face(f)-&gt;set_boundary_id(1);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            cell-&gt;face(f)-&gt;set_boundary_id(0);</div><div class="line">        }</div></div><!-- fragment --><p>Next, we set up the linear systems and fill them with content so that they can be used throughout the time stepping process:</p>
<div class="fragment"><div class="line">setup_system();</div><div class="line"></div><div class="line">assemble_system();</div></div><!-- fragment --><p>Finally, we solve the diffusion problem using several of the Runge-Kutta methods implemented in namespace <a class="el" href="namespaceTimeStepping.html">TimeStepping</a>, each time outputting the error at the end time. (As explained in the introduction, since the exact solution is zero at the final time, the error equals the numerical solution and can be computed by just taking the <img class="formulaInl" alt="$l_2$" src="form_111.png"/> norm of the solution vector.)</p>
<div class="fragment"><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       n_steps      = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time   = 10.;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    explicit_method (TimeStepping::FORWARD_EULER,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Forward Euler:            error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method (TimeStepping::RK_THIRD_ORDER,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Third order Runge-Kutta:  error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method (TimeStepping::RK_CLASSIC_FOURTH_ORDER,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Fourth order Runge-Kutta: error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    implicit_method (TimeStepping::BACKWARD_EULER,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Backward Euler:           error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method (TimeStepping::IMPLICIT_MIDPOINT,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit Midpoint:        error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method (TimeStepping::CRANK_NICOLSON,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Crank-Nicolson:           error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method (TimeStepping::SDIRK_TWO_STAGES,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;SDIRK:                    error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Embedded explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::HEUN_EULER,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Heun-Euler:               error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::BOGACKI_SHAMPINE,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Bogacki-Shampine:         error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::DOPRI,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Dopri:                    error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::FEHLBERG,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Fehlberg:                 error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::CASH_KARP,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cash-Karp:                error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>The following <code>main</code> function is similar to previous examples and need not be commented on.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step52::Diffusion diffusion;</div><div class="line">      diffusion.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The point of this program is less to show particular results, but instead to show how it is done. This we have already demonstrated simply by discussing the code above. Consequently, the output the program yields is relatively sparse and consists only of the console output and the solutions given in VTU format for visualization.</p>
<p>The console output contains both errors and, for some of the methods, the number of steps they performed: </p><div class="fragment"><div class="line">Explicit methods:</div><div class="line">Forward Euler:            error=1.00883</div><div class="line">Third order Runge-Kutta:  error=0.000227982</div><div class="line">Fourth order Runge-Kutta: error=1.90541e-06</div><div class="line"></div><div class="line">Implicit methods:</div><div class="line">Backward Euler:           error=1.03428</div><div class="line">Implicit Midpoint:        error=0.00862702</div><div class="line">Crank-Nicolson:           error=0.00862675</div><div class="line">SDIRK:                    error=0.0042349</div><div class="line"></div><div class="line">Embedded %<span class="keyword">explicit</span> methods:</div><div class="line">Heun-Euler:               error=0.0073012</div><div class="line">                steps performed=284</div><div class="line">Bogacki-Shampine:         error=0.000403281</div><div class="line">                steps performed=181</div><div class="line">Dopri:                    error=0.0165485</div><div class="line">                steps performed=119</div><div class="line">Fehlberg:                 error=0.00104926</div><div class="line">                steps performed=106</div><div class="line">Cash-Karp:                error=8.59366e-07</div><div class="line">                steps performed=107</div></div><!-- fragment --><p>As expected the higher order methods give (much) more accurate solutions. We also see that the (rather inaccurate) Heun-Euler method increased the number of time steps in order to satisfy the tolerance. On the other hand, the other embedded methods used a lot less time steps than what was prescribed. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2014 - 2015 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Damien Lebrun-Grandie, Bruno Turcksin, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/time_stepping.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step52</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>Diffusion</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Diffusion();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_source (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> evaluate_diffusion (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                                       <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> id_minus_tau_J_inverse (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">double</span> tau,</div><div class="line">                                           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time_step,</div><div class="line">                         <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> explicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> implicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_explicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">double</span>                     initial_time,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">double</span>                     final_time);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                 fe_degree;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>                       diffusion_coefficient;</div><div class="line">    <span class="keywordtype">double</span>                       absorption_cross_section;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>             triangulation;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>                      fe;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>                dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>             constraint_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>              sparsity_pattern;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>         system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>         mass_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>         mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>          inverse_mass_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>               solution;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Diffusion::Diffusion()</div><div class="line">    :</div><div class="line">    fe_degree(2),</div><div class="line">    diffusion_coefficient(1./30.),</div><div class="line">    absorption_cross_section(1.),</div><div class="line">    fe(fe_degree),</div><div class="line">    dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::setup_system ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler,1,<a class="code" href="classZeroFunction.html">ZeroFunction&lt;2&gt;</a>(),constraint_matrix);</div><div class="line">    constraint_matrix.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler,dsp,constraint_matrix);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(sparsity_pattern);</div><div class="line">    mass_minus_tau_Jacobian.reinit(sparsity_pattern);</div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::assemble_system ()</div><div class="line">  {</div><div class="line">    system_matrix = 0.;</div><div class="line">    mass_matrix = 0.;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree+1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe, quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        cell_matrix = 0.;</div><div class="line">        cell_mass_matrix = 0.;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                cell_matrix(i,j) += ((-diffusion_coefficient *</div><div class="line">                                      fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                      fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point)</div><div class="line">                                      - absorption_cross_section *</div><div class="line">                                      fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                      fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point)) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                cell_mass_matrix(i,j) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point) *</div><div class="line">                                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">              }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraint_matrix.distribute_local_to_global(cell_matrix,local_dof_indices,system_matrix);</div><div class="line">        constraint_matrix.distribute_local_to_global(cell_mass_matrix,local_dof_indices,mass_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    inverse_mass_matrix.<a class="code" href="classDoFHandler.html#aeca4a4af5c4d7f7c68a4def9ae87bc7b">initialize</a>(mass_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> Diffusion::get_source (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> intensity = 10.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> frequency = <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>/10.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> b = 5.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> intensity* (frequency*std::cos(frequency*time)*(b*x-x*x)</div><div class="line">                       +</div><div class="line">                       std::sin(frequency*time) * (absorption_cross_section*(b*x-x*x)</div><div class="line">                                                   +</div><div class="line">                                                   2.*diffusion_coefficient));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::evaluate_diffusion (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                                                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    tmp = 0.;</div><div class="line">    system_matrix.vmult(tmp,y);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree+1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>  cell_source(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        cell_source = 0.;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> source = get_source(time,</div><div class="line">                                             fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">              cell_source(i) += source *</div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraint_matrix.distribute_local_to_global(cell_source,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     tmp);</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> value(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    inverse_mass_matrix.vmult(value,tmp);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::id_minus_tau_J_inverse (<span class="keyword">const</span> <span class="keywordtype">double</span> time,</div><div class="line">                                                    <span class="keyword">const</span> <span class="keywordtype">double</span> tau,</div><div class="line">                                                    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)</div><div class="line">  {</div><div class="line">    (void) time;</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">    mass_minus_tau_Jacobian.copy_from(mass_matrix);</div><div class="line">    mass_minus_tau_Jacobian.add(-tau, system_matrix);</div><div class="line"></div><div class="line">    inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(mass_minus_tau_Jacobian);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a2697cc4cb0be492f39f95ad8a816d7d4">vmult</a>(tmp, y);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> result(y);</div><div class="line">    inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(result,tmp);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> time_step,</div><div class="line">                                  <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::string method_name;</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (method)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::FORWARD_EULER:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;forward_euler&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::RK_THIRD_ORDER:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;rk3&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::RK_CLASSIC_FOURTH_ORDER:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;rk4&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::BACKWARD_EULER:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;backward_euler&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::IMPLICIT_MIDPOINT:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;implicit_midpoint&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::SDIRK_TWO_STAGES:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;sdirk&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::HEUN_EULER:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;heun_euler&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::BOGACKI_SHAMPINE:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;bocacki_shampine&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::DOPRI:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;dopri&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::FEHLBERG:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;fehlberg&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">case</span> TimeStepping::CASH_KARP:</div><div class="line">      {</div><div class="line">        method_name = <span class="stringliteral">&quot;cash_karp&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">      {</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + method_name + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (time_step, 3) +</div><div class="line">                                 <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename.c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::explicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step = (final_time-initial_time)/static_cast&lt;double&gt; (n_time_steps);</div><div class="line">    <span class="keywordtype">double</span> time = initial_time;</div><div class="line">    solution = 0.;</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1ExplicitRungeKutta.html">TimeStepping::ExplicitRungeKutta&lt;Vector&lt;double&gt;</a> &gt; explicit_runge_kutta(method);</div><div class="line">    output_results(0,method);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_time_steps; ++i)</div><div class="line">      {</div><div class="line">        time = explicit_runge_kutta.evolve_one_time_step(</div><div class="line">                 std::bind(&amp;Diffusion::evaluate_diffusion,</div><div class="line">                           <span class="keyword">this</span>,</div><div class="line">                           std::placeholders::_1,</div><div class="line">                           std::placeholders::_2),</div><div class="line">                 time,time_step,solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((i+1)%10==0)</div><div class="line">          output_results(i+1,method);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::implicit_method (<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step = (final_time-initial_time)/static_cast&lt;double&gt; (n_time_steps);</div><div class="line">    <span class="keywordtype">double</span> time = initial_time;</div><div class="line">    solution = 0.;</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1ImplicitRungeKutta.html">TimeStepping::ImplicitRungeKutta&lt;Vector&lt;double&gt;</a> &gt; implicit_runge_kutta(method);</div><div class="line">    output_results(0,method);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_time_steps; ++i)</div><div class="line">      {</div><div class="line">        time = implicit_runge_kutta.evolve_one_time_step(</div><div class="line">                 std::bind(&amp;Diffusion::evaluate_diffusion,</div><div class="line">                           <span class="keyword">this</span>,</div><div class="line">                           std::placeholders::_1,</div><div class="line">                           std::placeholders::_2),</div><div class="line">                 std::bind(&amp;Diffusion::id_minus_tau_J_inverse,</div><div class="line">                           <span class="keyword">this</span>,</div><div class="line">                           std::placeholders::_1,</div><div class="line">                           std::placeholders::_2,</div><div class="line">                           std::placeholders::_3),</div><div class="line">                 time,time_step,solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((i+1)%10==0)</div><div class="line">          output_results(i+1,method);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Diffusion::embedded_explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">double</span> time_step = (final_time-initial_time)/static_cast&lt;double&gt; (n_time_steps);</div><div class="line">    <span class="keywordtype">double</span> time = initial_time;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_param = 1.2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refine_param = 0.8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_delta = 1e-8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_delta = 10*time_step;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refine_tol = 1e-1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_tol = 1e-5;</div><div class="line">    solution = 0.;</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html">TimeStepping::EmbeddedExplicitRungeKutta&lt;Vector&lt;double&gt;</a> &gt;</div><div class="line">    embedded_explicit_runge_kutta(method,</div><div class="line">                                  coarsen_param,</div><div class="line">                                  refine_param,</div><div class="line">                                  min_delta,</div><div class="line">                                  max_delta,</div><div class="line">                                  refine_tol,</div><div class="line">                                  coarsen_tol);</div><div class="line">    output_results (0, method);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps=0;</div><div class="line">    <span class="keywordflow">while</span> (time&lt;final_time)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (time+time_step&gt;final_time)</div><div class="line">          time_step = final_time-time;</div><div class="line"></div><div class="line">        time = embedded_explicit_runge_kutta.evolve_one_time_step(</div><div class="line">                 std::bind(&amp;Diffusion::evaluate_diffusion,<span class="keyword">this</span>,std::placeholders::_1,std::placeholders::_2),</div><div class="line">                 time,time_step,solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((n_steps+1)%10==0)</div><div class="line">          output_results(n_steps+1,method);</div><div class="line"></div><div class="line">        time_step = embedded_explicit_runge_kutta.get_status().delta_t_guess;</div><div class="line">        ++n_steps;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> n_steps;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::run ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 5.);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">    <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a></div><div class="line">    cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">    endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;2&gt;::faces_per_cell; ++f)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;face(f)-&gt;center()[0]==0.) || (cell-&gt;face(f)-&gt;center()[0]==5.))</div><div class="line">              cell-&gt;face(f)-&gt;set_boundary_id(1);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              cell-&gt;face(f)-&gt;set_boundary_id(0);</div><div class="line">          }</div><div class="line"></div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       n_steps      = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time   = 10.;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    explicit_method (TimeStepping::FORWARD_EULER,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Forward Euler:            error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method (TimeStepping::RK_THIRD_ORDER,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Third order Runge-Kutta:  error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method (TimeStepping::RK_CLASSIC_FOURTH_ORDER,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Fourth order Runge-Kutta: error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    implicit_method (TimeStepping::BACKWARD_EULER,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Backward Euler:           error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method (TimeStepping::IMPLICIT_MIDPOINT,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit Midpoint:        error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method (TimeStepping::CRANK_NICOLSON,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Crank-Nicolson:           error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method (TimeStepping::SDIRK_TWO_STAGES,</div><div class="line">                     n_time_steps,</div><div class="line">                     initial_time,</div><div class="line">                     final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;SDIRK:                    error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Embedded explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::HEUN_EULER,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Heun-Euler:               error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::BOGACKI_SHAMPINE,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Bogacki-Shampine:         error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::DOPRI,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Dopri:                    error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::FEHLBERG,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Fehlberg:                 error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method (TimeStepping::CASH_KARP,</div><div class="line">                                        n_time_steps,</div><div class="line">                                        initial_time,</div><div class="line">                                        final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cash-Karp:                error=&quot;</span> &lt;&lt; solution.l2_norm() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step52::Diffusion diffusion;</div><div class="line">      diffusion.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
