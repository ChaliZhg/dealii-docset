<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataPostprocessorInputs::CommonInputs&lt; spacedim &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDataPostprocessorInputs.html">DataPostprocessorInputs</a></li><li class="navelem"><a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html">CommonInputs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="structDataPostprocessorInputs_1_1CommonInputs-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataPostprocessorInputs::CommonInputs&lt; spacedim &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="data__postprocessor_8h_source.html">deal.II/numerics/data_postprocessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataPostprocessorInputs::CommonInputs&lt; spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structDataPostprocessorInputs_1_1CommonInputs__inherit__graph.svg" width="716" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a644b6a85f81a4d9b0ce1be180d99f74b"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a644b6a85f81a4d9b0ce1be180d99f74b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a644b6a85f81a4d9b0ce1be180d99f74b">set_cell</a> (const typename DoFHandlerType::cell_iterator &amp;<a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a2e18ccd556d1c5369785d6501fc4e88c">cell</a>)</td></tr>
<tr class="separator:a644b6a85f81a4d9b0ce1be180d99f74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00d5d79436ce5347e46d80575b97be8"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:af00d5d79436ce5347e46d80575b97be8"><td class="memTemplItemLeft" align="right" valign="top">DoFHandlerType::cell_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#af00d5d79436ce5347e46d80575b97be8">get_cell</a> () const</td></tr>
<tr class="separator:af00d5d79436ce5347e46d80575b97be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a55d5102e8dc63fe68922c9b05e3881b2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a55d5102e8dc63fe68922c9b05e3881b2">normals</a></td></tr>
<tr class="separator:a55d5102e8dc63fe68922c9b05e3881b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9941db2917f9b597d25fa6e60bb2d2ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a9941db2917f9b597d25fa6e60bb2d2ec">evaluation_points</a></td></tr>
<tr class="separator:a9941db2917f9b597d25fa6e60bb2d2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2e18ccd556d1c5369785d6501fc4e88c"><td class="memItemLeft" align="right" valign="top">boost::any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a2e18ccd556d1c5369785d6501fc4e88c">cell</a></td></tr>
<tr class="separator:a2e18ccd556d1c5369785d6501fc4e88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int spacedim&gt;<br />
struct DataPostprocessorInputs::CommonInputs&lt; spacedim &gt;</h3>

<p>A base class containing common elements for the <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">Scalar</a> and <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector</a> classes that are passed as arguments to <a class="el" href="classDataPostprocessor.html#acf197b51f7557e327888be579531750c">DataPostprocessor::evaluate_scalar_field()</a> and <a class="el" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">DataPostprocessor::evaluate_vector_field()</a>. This common base class provides access to the points at which the solution is being evaluated, and a few other fields, as described in the following.</p>
<h4>Normal vector access</h4>
<p>If appropriate, i.e., if the object that is currently being processed is a face of a cell and the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object is called from <a class="el" href="classDataOutFaces.html">DataOutFaces</a> or a similar class, then the current object also stores the normal vectors to the geometry on which output is generated, at these evaluation points.</p>
<p>On the other hand, if the solution is being evaluated on a cell, then the <code>normal_vectors</code> member variable does not contain anything useful.</p>
<h4>Cell access</h4>
<p><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> is typically called from classes such as <a class="el" href="classDataOut.html">DataOut</a> or <a class="el" href="classDataOutFaces.html">DataOutFaces</a> that evaluate solution fields on a cell-by-cell basis. As a consequence, classes derived from <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> (or <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> or <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>) sometimes need to use which cell is currently under investigation. Consequently, <a class="el" href="classDataOut.html">DataOut</a> and similar classes pass the cell they are currently working on to <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> via the classes in this namespace (and specifically the current base class).</p>
<p>However, the situation is not so simple. This is because the current class (and those derived from it) only knows the space dimension in which the output lives. But this can come from many sources. First, the cell may be a cell in a <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> object. Second, if we are in 3d, this may be because we are working on a DoFHandler&lt;3&gt;, or a DoFHandler&lt;2,3&gt; (i.e., either a 3d mesh, or a 2d meshes of a 2d surface embedded in 3d space). Finally, if one considers classes such as <a class="el" href="classDataOutRotation.html">DataOutRotation</a> or <a class="el" href="classDataOutStack.html">DataOutStack</a>, then <code>spacedim</code> being equal to 3 might mean that we are actually working on a DoFHandler&lt;2&gt; or hp::DoFHandler&lt;2&gt;.</p>
<p>In other words, just because we know the value of the <code>spacedim</code> template argument of the current class does not mean that the data type of the cell iterator that is currently being worked on is obvious.</p>
<p>To make the cell iterator accessible nevertheless, this class uses an object of type boost::any to store the cell iterator. You can think of this as being a void pointer that can point to anything. To use what is being used therefore requires the user to know the data type of the thing being pointed to.</p>
<p>To make this work, the <a class="el" href="classDataOut.html">DataOut</a> and related classes store in objects of the current type a representation of the cell. To get it back out, you would use the <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#af00d5d79436ce5347e46d80575b97be8">get_cell()</a> function that requires you to say, as a template parameter, the <a class="el" href="classDoFHandler.html">DoFHandler</a> type to which the cell that is currently being processed belongs. This is knowledge you typically have in an application: for example, if your application runs in <code>dim</code> space dimensions, uses a <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, and you are currently using the <a class="el" href="classDataOut.html">DataOut</a> class, then the cells that are worked on have data type <code><a class="el" href="classDataOut.html#a18090a6fd3e956f7710dc7a33b4cd756">DataOut&lt;dim&gt;::cell_iterator</a></code>. Consequently, in a postprocessor, you can call <code>inputs.get_cell&lt;<a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt;dim&gt; &gt; </code>. For technical reasons, however, C++ will typically require you to write this as <code>inputs.template get_cell&lt;<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt; &gt; </code> because the member function we call here requires that we explicitly provide the template argument.</p>
<p>Let us consider a complete example of a postprocessor that computes the fluid norm of the stress <img class="formulaInl" alt="$\|\sigma\| = \|\eta \nabla u\|$" src="form_1144.png"/> from the viscosity <img class="formulaInl" alt="$\eta$" src="form_1145.png"/> and the gradient of the fluid velocity, <img class="formulaInl" alt="$\nabla u$" src="form_1146.png"/>, assuming that the viscosity is something that depends on the cell's material id. This can be done using a class we derive from <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> where we overload the <a class="el" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">DataPostprocessor::evaluate_vector_field()</a> function that receives the values and gradients of the velocity (plus of other solution variables such as the pressure, but let's ignore those for the moment). Then we could use code such as this, assuming that we use a <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ComputeStress : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ... <span class="comment">// overload other necessary member variables</span></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    evaluate_vector_field (<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;input_data,</div><div class="line">                           std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;               &amp;computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">hp::DoFHandler&lt;dim&gt;::cell_iterator</a></div><div class="line">        current_cell = input_data.template get_cell&lt;hp::DoFHandler&lt;dim&gt; &gt;();</div><div class="line">      <span class="keyword">const</span> viscosity = look_up_viscosity (current_cell-&gt;material_id());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;input_data.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>.size(); ++q)</div><div class="line">        computed_quantities[q][0] = (viscosity * input_data.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>[q]).norm();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8h_source.html#l00145">145</a> of file <a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a644b6a85f81a4d9b0ce1be180d99f74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644b6a85f81a4d9b0ce1be180d99f74b">&#9670;&nbsp;</a></span>set_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html">DataPostprocessorInputs::CommonInputs</a>&lt; spacedim &gt;::set_cell </td>
          <td>(</td>
          <td class="paramtype">const typename DoFHandlerType::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the cell that is currently being used in evaluating the data for which the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object is being called.</p>
<p>This function is not usually called from user space, but is instead called by <a class="el" href="classDataOut.html">DataOut</a> and similar classes when creating the object that is then passed to <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>. </p>

</div>
</div>
<a id="af00d5d79436ce5347e46d80575b97be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00d5d79436ce5347e46d80575b97be8">&#9670;&nbsp;</a></span>get_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DoFHandlerType::cell_iterator <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html">DataPostprocessorInputs::CommonInputs</a>&lt; spacedim &gt;::get_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the cell on which we currently produce graphical output. See the documentation of the current class for an example on how to use this function. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a55d5102e8dc63fe68922c9b05e3881b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d5102e8dc63fe68922c9b05e3881b2">&#9670;&nbsp;</a></span>normals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; &gt; <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html">DataPostprocessorInputs::CommonInputs</a>&lt; spacedim &gt;::normals</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An array of vectors normal to the faces of cells, evaluated at the points at which we are generating graphical output. This array is only used by the <a class="el" href="classDataOutFaces.html">DataOutFaces</a> class, and is left empty by all other classes for which the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> framework can be used. In the case of <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, the array contains the outward normal vectors to the face, seen from the interior of the cell.</p>
<p>This array is only filled if a user-derived class overloads the <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">DataPostprocessor::get_needed_update_flags()</a>, and the function returns (possibly among other flags) UpdateFlags::update_normal_vectors. Alternatively, a class derived from <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> or <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a> may pass this flag to the constructor of <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> or <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8h_source.html#l00163">163</a> of file <a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>

</div>
</div>
<a id="a9941db2917f9b597d25fa6e60bb2d2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9941db2917f9b597d25fa6e60bb2d2ec">&#9670;&nbsp;</a></span>evaluation_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt; <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html">DataPostprocessorInputs::CommonInputs</a>&lt; spacedim &gt;::evaluation_points</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An array of coordinates corresponding to the locations at which we are generating graphical output on one cell.</p>
<p>This array is only filled if a user-derived class overloads the <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">DataPostprocessor::get_needed_update_flags()</a>, and the function returns (possibly among other flags) UpdateFlags::update_quadrature_points. Alternatively, a class derived from <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> or <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a> may pass this flag to the constructor of <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> or <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8h_source.html#l00177">177</a> of file <a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>

</div>
</div>
<a id="a2e18ccd556d1c5369785d6501fc4e88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e18ccd556d1c5369785d6501fc4e88c">&#9670;&nbsp;</a></span>cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::any <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html">DataPostprocessorInputs::CommonInputs</a>&lt; spacedim &gt;::cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The place where <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a644b6a85f81a4d9b0ce1be180d99f74b">set_cell()</a> stores the cell. Since the actual data type of the cell iterator can be many different things, the interface uses boost::any here. This makes assignment in <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a644b6a85f81a4d9b0ce1be180d99f74b">set_cell()</a> simple, but requires knowing the data type of the stored object in <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#af00d5d79436ce5347e46d80575b97be8">get_cell()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8h_source.html#l00208">208</a> of file <a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>deal.II/numerics/<a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
