<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-48 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-48 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemstatementanddiscretization"> Problem statement and discretization </a>
        <li><a href="#Implementationofconstraints">Implementation of constraints</a>
        <li><a href="#Parallelization"> Parallelization </a>
        <li><a href="#Thetestcase"> The test case </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#SineGordonOperation">SineGordonOperation</a>
      <ul>
        <li><a href="#SineGordonOperationSineGordonOperation">SineGordonOperation::SineGordonOperation</a>
        <li><a href="#SineGordonOperationlocal_apply">SineGordonOperation::local_apply</a>
        <li><a href="#SineGordonOperationapply">SineGordonOperation::apply</a>
      </ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#SineGordonProblemclass">SineGordonProblem class</a>
      <ul>
        <li><a href="#SineGordonProblemSineGordonProblem">SineGordonProblem::SineGordonProblem</a>
        <li><a href="#SineGordonProblemmake_grid_and_dofs">SineGordonProblem::make_grid_and_dofs</a>
        <li><a href="#SineGordonProblemoutput_results">SineGordonProblem::output_results</a>
        <li><a href="#SineGordonProblemrun">SineGordonProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Comparisonwithasparsematrix">Comparison with a sparse matrix</a>
        <li><a href="#Parallelrunin3D">Parallel run in 3D</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
</p>
<p><em> This program was contributed by Katharina Kormann and Martin Kronbichler.</em></p>
<p><em>The algorithm for the matrix-vector product is based on the article <a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">A generic interface for parallel cell-based finite element operator application</a> by Martin Kronbichler and Katharina Kormann, Computers and Fluids 63:135&ndash;147, 2012, and the paper &quot;Parallel finite element operator application: Graph partitioning and coloring&quot; by Katharina Kormann and Martin Kronbichler in: Proceedings of the 7th IEEE International Conference on e-Science, 2011. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program demonstrates how to use the cell-based implementation of finite element operators with the <a class="el" href="classMatrixFree.html">MatrixFree</a> class, first introduced in <a class="el" href="step_37.html">step-37</a>, to solve nonlinear partial differential equations. Moreover, we demonstrate how the <a class="el" href="classMatrixFree.html">MatrixFree</a> class handles constraints, an issue shortly mentioned in the results section of <a class="el" href="step_37.html">step-37</a>. Finally, we will use an explicit time-stepping method to solve the problem and introduce Gauss-Lobatto finite elements that are very convenient in this case since their mass matrix can be accurately approximated by a diagonal, and thus trivially invertible, matrix. The two ingredients to this property are firstly a distribution of the nodal points of Lagrange polynomials according to the point distribution of the Gauss-Lobatto quadrature rule. Secondly, the quadrature is done with the same Gauss-Lobatto quadrature rule. In this formula, the integrals <img class="formulaInl" alt="$\int_K \varphi_i \varphi_j dx\approx \sum_q \varphi_i \varphi_j \mathrm{det}(J) \big |_{x_q}$" src="form_3873.png"/> are approximated to zero whenever <img class="formulaInl" alt="$i\neq j$" src="form_509.png"/>, because on the points defining the Lagrange polynomials exactly one function <img class="formulaInl" alt="$\varphi_j$" src="form_532.png"/> is one and all others zero. Moreover, the Gauss-Lobatto distribution of nodes of Lagrange polynomials clusters the nodes towards the element boundaries. This results in a well-conditioned polynomial basis for high-order discretization methods. Indeed, the condition number of an <a class="el" href="classFE__Q.html">FE_Q</a> elements with equidistant nodes grows exponentially with the degree, which destroys any benefit for orders of about five and higher. For this reason, Gauss-Lobatto points are the default distribution for <a class="el" href="classFE__Q.html">FE_Q</a> (but at degrees one and two, those are equivalent to the equidistant points).</p>
<p><a class="anchor" id="Problemstatementanddiscretization"></a></p><h3>Problem statement and discretization </h3>
<p>As an example, we choose to solve the sine-Gordon soliton equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} u_{tt} &amp;=&amp; \Delta u -\sin(u) \quad\mbox{for}\quad (x,t) \in \Omega \times (t_0,t_f],\\ {\mathbf n} \cdot \nabla u &amp;=&amp; 0 \quad\mbox{for}\quad (x,t) \in \partial\Omega \times (t_0,t_f],\\ u(x,t_0) &amp;=&amp; u_0(x). \end{eqnarray*}" src="form_3874.png"/>
</p>
<p>that was already introduced in <a class="el" href="step_25.html">step-25</a>. As a simple explicit time integration method, we choose leap frog scheme using the second-order formulation of the equation. Then, the scheme reads in weak form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (v,u^{n+1}) = (v,2 u^n-u^{n-1} - (\Delta t)^2 \sin(u^n)) - (\nabla v, (\Delta t)^2 \nabla u^n), \end{eqnarray*}" src="form_3875.png"/>
</p>
<p> where <em> v</em> denotes a test function and the index <em>n</em> stands for the time step number.</p>
<p>For the spatial discretization, we choose <a class="el" href="classFE__Q.html">FE_Q</a> elements with basis functions defined to interpolate the support points of the Gauss-Lobatto quadrature rule. Moreover, when we compute the integrals over the basis functions to form the mass matrix and the operator on the right hand side of the equation above, we use the Gauss-Lobatto quadrature rule with the same support points as the node points of the finite element to evaluate the integrals. Since the finite element is Lagrangian, this will yield a diagonal mass matrix on the left hand side of the equation, making the solution of the linear system in each time step trivial.</p>
<p>Using this quadrature rule, for a <em>p</em>th order finite element, we use a <em>(2p-1)</em>th order accurate formula to evaluate the integrals. Since the product of two <em>p</em>th order basis functions when computing a mass matrix gives a function with polynomial degree <em>2p</em> in each direction, the integrals are not computed exactly. However, considering the fact that the interpolation order of finite elements of degree <em>p</em> is <em>p+1</em>, the overall convergence properties are not disturbed by the quadrature error, in particular not when we use high orders.</p>
<p>Apart from the fact that we avoid solving linear systems with this type of elements when using explicit time-stepping, they come with two other advantages. When we are using the sum-factorization approach to evaluate the finite element operator (cf. <a class="el" href="step_37.html">step-37</a>), we have to evaluate the function at the quadrature points. In the case of Gauss-Lobatto elements, where quadrature points and node points of the finite element coincide, this operation is trivial since the value of the function at the quadrature points is given by its one-dimensional coefficients. In this way, the complexity of a finite element operator evaluation is further reduced compared to equidistant elements.</p>
<p>The third advantage is the fact that these elements are better conditioned than equidistant Lagrange polynomials for increasing order so that we can use higher order elements for an accurate solution of the equation. Lagrange elements <a class="el" href="classFE__Q.html">FE_Q</a> with equidistant points should not be used for polynomial degrees four and higher.</p>
<p>To sum up the discussion, by using the right finite element and quadrature rule combination, we end up with a scheme where we in each time step need to compute the right hand side vector corresponding to the formulation above and then multiply it by the inverse of the diagonal mass matrix. In practice, of course, we extract the diagonal elements and invert them only once at the beginning of the program.</p>
<p><a class="anchor" id="Implementationofconstraints"></a></p><h3>Implementation of constraints</h3>
<p>The usual way to handle constraints in <code>deal.II</code> is to use the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class that builds a sparse matrix storing information about which degrees of freedom (DoF) are constrained and how they are constrained. This format uses an unnecessarily large amount of memory since there are not so many different types of constraints: for example, in the case of hanging nodes when using linear finite element on every cell, constraints most have the form <img class="formulaInl" alt="$x_k = \frac 12 x_i + \frac 12 x_j$" src="form_3876.png"/> where the coefficients <img class="formulaInl" alt="$\frac 12$" src="form_1656.png"/> are always the same and only <img class="formulaInl" alt="$i,j,k$" src="form_3877.png"/> are different. While storing this redundant information is not a problem in general because it is only needed once during matrix and right hand side assembly, it becomes a problem when we want to use the matrix-free approach since there this information has to be accessed every time we apply the operator. Thus, instead of a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>, we use a variable that we call <code>constraint_pool</code> that collects the weights of the different constraints. Then, we only have to store an identifier of each constraint in the mesh instead of all the weights. Moreover, we do not want to apply the constraints in a pre- and postprocessing step but want to take care of constraints as we evaluate the finite element operator. Therefore, we embed the constraint information into the variable <code>indices_local_to_global</code> that is used to extract the cell information from the global vector. If a DoF is constrained, the <code>indices_local_to_global</code> variable contains the global indices of the DoFs that it is constrained to. Then, we have another variable <code>constraint_indicator</code> at hand that holds, for each cell, the local indices of DoFs that are constrained as well as the identifier of the type of constraint. Actually, you will not see these data structures in the example program since the class <code><a class="el" href="classFEEvaluation.html">FEEvaluation</a></code> takes care of the constraints without user interaction.</p>
<p><a class="anchor" id="Parallelization"></a></p><h3>Parallelization </h3>
<p>The <a class="el" href="classMatrixFree.html">MatrixFree</a> class comes with the option to be parallelized on three levels: MPI parallelization on clusters of distributed nodes, thread parallelization scheduled by the Threading Building Blocks library, and finally with a vectorization by clustering of two (or more) cells into a SIMD data type for the operator application. As we have already discussed in <a class="el" href="step_37.html">step-37</a>, you will get best performance by using an instruction set specific to your system, e.g. with the cmake variable <code>-DCMAKE_CXX_FLAGS="-march=native"</code>. The MPI parallelization was already exploited in <a class="el" href="step_37.html">step-37</a>. Here, we additionally consider thread parallelization with TBB. This is fairly simple, as all we need to do is to tell the initialization of the <a class="el" href="classMatrixFree.html">MatrixFree</a> object about the fact that we want to use a thread parallel scheme through the variable MatrixFree::AdditionalData::thread_parallel_scheme. During setup, a dependency graph similar to the one described in the <a class="el" href="DEALGlossary.html#workstream_paper">workstream_paper</a> , which allows the code to schedule the work of the <code>local_apply</code> function on chunks of cell without several threads accessing the same vector indices. As opposed to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> loops, some additional clever tricks to avoid global synchronizations as described in <a href="https://dx.doi.org/10.1109/eScience.2011.53">Kormann and Kronbichler (2011)</a> are also applied.</p>
<p>Note that this program is designed to be run with a distributed triangulation (<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>), which requires deal.II to be configured with <a href="http://www.p4est.org/">p4est</a> as described in the <a href="../../readme.html">deal.II ReadMe</a> file. However, a non-distributed triangulation is also supported, in which case the computation will be run in serial.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case </h3>
<p>In our example, we choose the initial value to be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} u(x,t) = \prod_{i=1}^{d} -4 \arctan \left( \frac{m}{\sqrt{1-m^2}}\frac{\sin\left(\sqrt{1-m^2} t +c_2\right)}{\cosh(mx_i+c_1)}\right) \end{eqnarray*}" src="form_3878.png"/>
</p>
<p> and solve the equation over the time interval [-10,10]. The constants are chosen to be <img class="formulaInl" alt="$c_1=c_1=0$" src="form_3879.png"/> and <em> m=0.5</em>. As mentioned in <a class="el" href="step_25.html">step-25</a>, in one dimension <em>u</em> as a function of <em>t</em> is the exact solution of the sine-Gordon equation. For higher dimension, this is however not the case. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The necessary files from the deal.II library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div></div><!-- fragment --><p>This includes the data structures for the efficient implementation of matrix-free methods.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/la_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/matrix_free/matrix_free.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/matrix_free/fe_evaluation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step48</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>We start by defining two global variables to collect all parameters subject to changes at one place: One for the dimension and one for the finite element degree. The dimension is used in the main function as a template argument for the actual classes (like in all other deal.II programs), whereas the degree of the finite element is more crucial, as it is passed as a template argument to the implementation of the Sine-Gordon operator. Therefore, it needs to be a compile-time constant.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension = 2;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree = 4;</div></div><!-- fragment --><p><a class="anchor" id="SineGordonOperation"></a> </p><h3>SineGordonOperation</h3>
<p>The <code>SineGordonOperation</code> class implements the cell-based operation that is needed in each time step. This nonlinear operation can be implemented straight-forwardly based on the <code><a class="el" href="classMatrixFree.html">MatrixFree</a></code> class, in the same way as a linear operation would be treated by this implementation of the finite element operator application. We apply two template arguments to the class, one for the dimension and one for the degree of the finite element. This is a difference to other functions in deal.II where only the dimension is a template argument. This is necessary to provide the inner loops in <code><a class="el" href="classFEEvaluation.html">FEEvaluation</a></code> with information about loop lengths etc., which is essential for efficiency. On the other hand, it makes it more challenging to implement the degree as a run-time parameter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>SineGordonOperation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SineGordonOperation(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a> &amp;data_in,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span>                  time_step);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> apply (<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>                     &amp;dst,</div><div class="line">              <span class="keyword">const</span> std::vector&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>*&gt; &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a>         &amp;data;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a>         delta_t_sqr;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> inv_mass_matrix;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_apply (<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a>               &amp;data,</div><div class="line">                    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>      &amp;dst,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>*&gt; &amp;src,</div><div class="line">                    <span class="keyword">const</span> std::pair&lt;unsigned int,unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="SineGordonOperationSineGordonOperation"></a> </p><h4>SineGordonOperation::SineGordonOperation</h4>
<p>This is the constructor of the SineGordonOperation class. It receives a reference to the <a class="el" href="classMatrixFree.html">MatrixFree</a> holding the problem information and the time step size as input parameters. The initialization routine sets up the mass matrix. Since we use Gauss-Lobatto elements, the mass matrix is a diagonal matrix and can be stored as a vector. The computation of the mass matrix diagonal is simple to achieve with the data structures provided by <a class="el" href="classFEEvaluation.html">FEEvaluation</a>: Just loop over all (macro-) cells and integrate over the function that is constant one on all quadrature points by using the <code>integrate</code> function with <code>true</code> argument at the slot for values. Finally, we invert the diagonal entries since we have to multiply by the inverse mass matrix in each time step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">SineGordonOperation&lt;dim,fe_degree&gt;::</div><div class="line">SineGordonOperation(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a> &amp;data_in,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span>                  time_step)</div><div class="line">  :</div><div class="line">  data(data_in),</div><div class="line">  delta_t_sqr(<a class="code" href="classVectorizedArray.html#a74a5f244c26ff4ace917f8477779782c">make_vectorized_array</a>(time_step *time_step))</div><div class="line">{</div><div class="line">  <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> one = make_vectorized_array (1.);</div><div class="line"></div><div class="line">  data.initialize_dof_vector (inv_mass_matrix);</div><div class="line"></div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree&gt;</a>   fe_eval(data);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            n_q_points = fe_eval.n_q_points;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell=0; cell&lt;data.n_macro_cells(); ++cell)</div><div class="line">    {</div><div class="line">      fe_eval.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        fe_eval.submit_value(one,q);</div><div class="line">      fe_eval.integrate (<span class="keyword">true</span>,<span class="keyword">false</span>);</div><div class="line">      fe_eval.distribute_local_to_global (inv_mass_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  inv_mass_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;inv_mass_matrix.local_size(); ++k)</div><div class="line">    <span class="keywordflow">if</span> (inv_mass_matrix.local_element(k)&gt;1e-15)</div><div class="line">      inv_mass_matrix.local_element(k) = 1./inv_mass_matrix.local_element(k);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      inv_mass_matrix.local_element(k) = 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SineGordonOperationlocal_apply"></a> </p><h4>SineGordonOperation::local_apply</h4>
<p>This operator implements the core operation of the program, the integration over a range of cells for the nonlinear operator of the Sine-Gordon problem. The implementation is based on the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class as in <a class="el" href="step_37.html">step-37</a>. Due to the special structure in Gauss-Lobatto elements, certain operations become simpler, in particular the evaluation of shape function values on quadrature points which is simply the injection of the values of cell degrees of freedom. The <a class="el" href="classMatrixFree.html">MatrixFree</a> class detects possible structure of the finite element at quadrature points when initializing, which is then used by <a class="el" href="classFEEvaluation.html">FEEvaluation</a> for selecting the most appropriate numerical kernel.</p>
<p>The nonlinear function that we have to evaluate for the time stepping routine includes the value of the function at the present time <code>current</code> as well as the value at the previous time step <code>old</code>. Both values are passed to the operator in the collection of source vectors <code>src</code>, which is simply a <code>std::vector</code> of pointers to the actual solution vectors. This construct of collecting several source vectors into one is necessary as the cell loop in <code><a class="el" href="classMatrixFree.html">MatrixFree</a></code> takes exactly one source and one destination vector, even if we happen to use many vectors like the two in this case. Note that the cell loop accepts any valid class for input and output, which does not only include vectors but general data types. However, only in case it encounters a LinearAlgebra::distributed::Vector&lt;Number&gt; or a <code>std::vector</code> collecting these vectors, it calls functions that exchange data at the beginning and the end of the loop. In the loop over the cells, we first have to read in the values in the vectors related to the local values. Then, we evaluate the value and the gradient of the current solution vector and the values of the old vector at the quadrature points. Then, we combine the terms in the scheme in the loop over the quadrature points. Finally, we integrate the result against the test function and accumulate the result to the global solution vector <code>dst</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> SineGordonOperation&lt;dim, fe_degree&gt;::</div><div class="line">local_apply (<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim&gt;</a>                      &amp;data,</div><div class="line">             <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>      &amp;dst,</div><div class="line">             <span class="keyword">const</span> std::vector&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>*&gt; &amp;src,</div><div class="line">             <span class="keyword">const</span> std::pair&lt;unsigned int,unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (src.<a class="code" href="classTrilinosWrappers_1_1VectorBase.html#abf1421453bd5801e0a712ceceeac3cbc">size</a>(), 2);</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree&gt;</a> current (data), old (data);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell=cell_range.first; cell&lt;cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      current.reinit (cell);</div><div class="line">      old.reinit (cell);</div><div class="line"></div><div class="line">      current.read_dof_values (*src[0]);</div><div class="line">      old.read_dof_values     (*src[1]);</div><div class="line"></div><div class="line">      current.evaluate (<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">      old.evaluate (<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;current.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> current_value = current.get_value(q);</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> old_value     = old.get_value(q);</div><div class="line"></div><div class="line">          current.submit_value (2.*current_value - old_value -</div><div class="line">                                delta_t_sqr * std::sin(current_value),q);</div><div class="line">          current.submit_gradient (- delta_t_sqr *</div><div class="line">                                   current.get_gradient(q), q);</div><div class="line">        }</div><div class="line"></div><div class="line">      current.integrate (<span class="keyword">true</span>,<span class="keyword">true</span>);</div><div class="line">      current.distribute_local_to_global (dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SineGordonOperationapply"></a> </p><h4>SineGordonOperation::apply</h4>
<p>This function performs the time stepping routine based on the cell-local strategy. First the destination vector is set to zero, then the cell-loop is called, and finally the solution is multiplied by the inverse mass matrix. The structure of the cell loop is implemented in the cell finite element operator class. On each cell it applies the routine defined as the <code>local_apply()</code> method of the class <code>SineGordonOperation</code>, i.e., <code>this</code>. One could also provide a function with the same signature that is not part of a class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> SineGordonOperation&lt;dim, fe_degree&gt;::</div><div class="line">apply (<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>                     &amp;dst,</div><div class="line">       <span class="keyword">const</span> std::vector&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>*&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  dst = 0;</div><div class="line">  data.<a class="code" href="classMatrixFree.html#a523c939c0f87d8ad17d81bb3a2667b02">cell_loop</a> (&amp;SineGordonOperation&lt;dim,fe_degree&gt;::local_apply,</div><div class="line">                  <span class="keyword">this</span>, dst, src);</div><div class="line">  dst.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#afe20bd36869672666539d70f6c62c053">scale</a>(inv_mass_matrix);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>We define a time-dependent function that is used as initial value. Different solutions can be obtained by varying the starting time. This function has already been explained in <a class="el" href="step_25.html">step-25</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactSolution (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_components = 1,</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span> time = 0.) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(n_components, time) {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ExactSolution&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> / * component * /)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> t = this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> m = 0.5;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> c1 = 0.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> c2 = 0.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> factor = (m / std::sqrt(1.-m*m) *</div><div class="line">                         std::sin(std::sqrt(1.-m*m)*t+c2));</div><div class="line">  <span class="keywordtype">double</span> result = 1.;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">    result *= -4. * std::atan (factor / std::cosh(m*p[d]+c1));</div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SineGordonProblemclass"></a> </p><h3>SineGordonProblem class</h3>
<p>This is the main class that builds on the class in <a class="el" href="step_25.html">step-25</a>. However, we replaced the SparseMatrix&lt;double&gt; class by the <a class="el" href="classMatrixFree.html">MatrixFree</a> class to store the geometry data. Also, we use a distributed triangulation in this example.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SineGordonProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SineGordonProblem ();</div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_grid_and_dofs ();</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a> matrix_free_data;</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution, old_solution, old_old_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_global_refinements;</div><div class="line">    <span class="keywordtype">double</span> time, time_step;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> final_time;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> cfl_number;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_timestep_skip;</div><div class="line">  };</div></div><!-- fragment --><p><a class="anchor" id="SineGordonProblemSineGordonProblem"></a> </p><h4>SineGordonProblem::SineGordonProblem</h4>
<p>This is the constructor of the SineGordonProblem class. The time interval and time step size are defined here. Moreover, we use the degree of the finite element that we defined at the top of the program to initialize a <a class="el" href="classFE__Q.html">FE_Q</a> finite element based on Gauss-Lobatto support points. These points are convenient because in conjunction with a <a class="el" href="classQGaussLobatto.html">QGaussLobatto</a> quadrature rule of the same order they give a diagonal mass matrix without compromising accuracy too much (note that the integration is inexact, though), see also the discussion in the introduction. Note that <a class="el" href="classFE__Q.html">FE_Q</a> selects the Gauss-Lobatto nodal points by default due to their improved conditioning versus equidistant points. To make things more explicit, we choose to state the selection of the nodal points nonetheless.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SineGordonProblem&lt;dim&gt;::SineGordonProblem ()</div><div class="line">    :</div><div class="line">    pcout (<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">           <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD)==0),</div><div class="line">#ifdef DEAL_II_WITH_P4EST</div><div class="line">    triangulation (MPI_COMM_WORLD),</div><div class="line">#endif</div><div class="line">    fe (<a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;1&gt;(fe_degree+1)),</div><div class="line">    dof_handler (triangulation),</div><div class="line">    n_global_refinements (10-2*dim),</div><div class="line">    time (-10),</div><div class="line">    time_step(10.),</div><div class="line">    final_time (10),</div><div class="line">    cfl_number (.1/fe_degree),</div><div class="line">    output_timestep_skip (200)</div><div class="line">  {}</div></div><!-- fragment --><p><a class="anchor" id="SineGordonProblemmake_grid_and_dofs"></a> </p><h4>SineGordonProblem::make_grid_and_dofs</h4>
<p>As in <a class="el" href="step_25.html">step-25</a> this functions sets up a cube grid in <code>dim</code> dimensions of extent <img class="formulaInl" alt="$[-15,15]$" src="form_3880.png"/>. We refine the mesh more in the center of the domain since the solution is concentrated there. We first refine all cells whose center is within a radius of 11, and then refine once more for a radius 6. This simple ad hoc refinement could be done better by adapting the mesh to the solution using error estimators during the time stepping as done in other example programs, and using <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> to transfer the solution to the new mesh.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SineGordonProblem&lt;dim&gt;::make_grid_and_dofs ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -15, 15);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (n_global_refinements);</div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">      end_cell = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">      <span class="keywordflow">for</span> ( ; cell != end_cell; ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;center().norm() &lt; 11)</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">      cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">      end_cell = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">      <span class="keywordflow">for</span> ( ; cell != end_cell; ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;center().norm() &lt; 6)</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of global active cells: &quot;</span></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>()</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">          &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>We generate hanging node constraints for ensuring continuity of the solution. As in <a class="el" href="step_40.html">step-40</a>, we need to equip the constraint matrix with the <a class="el" href="classIndexSet.html">IndexSet</a> of locally relevant degrees of freedom to avoid it to consume too much memory for big problems. Next, the <code> <a class="el" href="classMatrixFree.html">MatrixFree</a> </code> for the problem is set up. Note that we specify the MPI communicator which we are going to use, and that we also want to use shared-memory parallelization (hence one would use multithreading for intra-node parallelism and not MPI; note that we here choose the standard option &mdash; if we wanted to disable shared memory parallelization, we would choose <code>none</code>). Finally, three solution vectors are initialized. <a class="el" href="classMatrixFree.html">MatrixFree</a> stores the layout that is to be used by distributed vectors, so we just ask it to initialize the vectors.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler,</div><div class="line">                                           locally_relevant_dofs);</div><div class="line">  constraints.clear();</div><div class="line">  constraints.reinit (locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler, constraints);</div><div class="line">  constraints.close();</div><div class="line"></div><div class="line">  <a class="code" href="classQGaussLobatto.html">QGaussLobatto&lt;1&gt;</a> quadrature (fe_degree+1);</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim&gt;::AdditionalData</a> additional_data;</div><div class="line">  additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a2c5d05b92a9c51568b7fd6c70938007a">tasks_parallel_scheme</a> =</div><div class="line">    <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim&gt;::AdditionalData::partition_partition</a>;</div><div class="line"></div><div class="line">  matrix_free_data.<a class="code" href="classMatrixFree.html#a8999754a8b1501b3d3797fac6e61ba81">reinit</a> (dof_handler, constraints,</div><div class="line">                           quadrature, additional_data);</div><div class="line"></div><div class="line">  matrix_free_data.initialize_dof_vector (solution);</div><div class="line">  old_solution.reinit (solution);</div><div class="line">  old_old_solution.reinit (solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SineGordonProblemoutput_results"></a> </p><h4>SineGordonProblem::output_results</h4>
<p>This function prints the norm of the solution and writes the solution vector to a file. The norm is standard (except for the fact that we need to accumulate the norms over all processors for the parallel grid), and the second is similar to what we did in <a class="el" href="step_40.html">step-40</a> or <a class="el" href="step_37.html">step-37</a>. Note that we can use the same vector for output as the one used during computations: The vectors in the matrix-free framework always provide full information on all locally owned cells (this is what is needed in the local evaluations, too), including ghost vector entries on these cells. This is the only data that is needed in the integrate_difference function as well as in <a class="el" href="classDataOut.html">DataOut</a>. The only action to take at this point is then to make sure that the vector updates its ghost values before we read from them. This is a feature present only in the <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> class. Distributed vectors with PETSc and Trilinos, on the other hand, need to be copied to special vectors including ghost values (see the relevant section in <a class="el" href="step_40.html">step-40</a>). If we also wanted to access all degrees of freedom on ghost cells (e.g. when computing error estimators that use the jump of solution over cell boundaries), we would need more information and create a vector initialized with locally relevant dofs just as in <a class="el" href="step_40.html">step-40</a>. Observe also that we need to distribute constraints for output - they are not filled during computations (rather, they are interpolated on the fly in the matrix-free method read_dof_values).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">SineGordonProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number)</div><div class="line">{</div><div class="line">  constraints.distribute (solution);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> norm_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  solution.<a class="code" href="classVector.html#ae50dd04b204d8ebf6be467c3ebe2234f">update_ghost_values</a>();</div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler,</div><div class="line">                                     solution,</div><div class="line">                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                     norm_per_cell,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe_degree+1),</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> solution_norm =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      norm_per_cell,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Time:&quot;</span></div><div class="line">        &lt;&lt; std::setw(8) &lt;&lt; std::setprecision(3) &lt;&lt; time</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;, solution norm: &quot;</span></div><div class="line">        &lt;&lt; std::setprecision(5) &lt;&lt; std::setw(7) &lt;&lt; solution_norm</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (timestep_number, 3);</div><div class="line"></div><div class="line">  std::ofstream output ((filename +</div><div class="line">                         <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (<a class="code" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a>::</div><div class="line">                                                         <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD),4) + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;std::string&gt; filenames;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">           i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a> (MPI_COMM_WORLD); ++i)</div><div class="line">        filenames.push_back (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (timestep_number, 3) +</div><div class="line">                             <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (i, 4) +</div><div class="line">                             <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"></div><div class="line">      std::ofstream master_output ((filename + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (master_output, filenames);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SineGordonProblemrun"></a> </p><h4>SineGordonProblem::run</h4>
<p>This function is called by the main function and calls the subroutines of the class.</p>
<p>The first step is to set up the grid and the cell operator. Then, the time step is computed from the CFL number given in the constructor and the finest mesh size. The finest mesh size is computed as the diameter of the last cell in the triangulation, which is the last cell on the finest level of the mesh. This is only possible for Cartesian meshes, otherwise, one needs to loop over all cells. Note that we need to query all the processors for their finest cell since the not all processors might hold a region where the mesh is at the finest level. Then, we readjust the time step a little to hit the final time exactly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">SineGordonProblem&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  make_grid_and_dofs();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> local_min_cell_diameter =</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a1a8e886767303b776351e42658e454c0">last</a>()-&gt;diameter()/std::sqrt(dim);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_min_cell_diameter</div><div class="line">    = -<a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(-local_min_cell_diameter, MPI_COMM_WORLD);</div><div class="line">  time_step = cfl_number * global_min_cell_diameter;</div><div class="line">  time_step = (final_time-time)/(<span class="keywordtype">int</span>((final_time-time)/time_step));</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Time step size: &quot;</span> &lt;&lt; time_step &lt;&lt; <span class="stringliteral">&quot;, finest cell: &quot;</span></div><div class="line">        &lt;&lt; global_min_cell_diameter &lt;&lt; std::endl &lt;&lt; std::endl;</div></div><!-- fragment --><p>Next the initial value is set. Since we have a two-step time stepping method, we also need a value of the solution at time-time_step. For accurate results, one would need to compute this from the time derivative of the solution at initial time, but here we ignore this difficulty and just set it to the initial value function at that artificial time.</p>
<p>We create an output of the initial value. Then we also need to collect the two starting solutions in a <code>std::vector</code> of pointers field and to set up an instance of the <code> SineGordonOperation class </code> based on the finite element degree specified at the top of this file.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a> (dof_handler,</div><div class="line">                          ExactSolution&lt;dim&gt; (1, time),</div><div class="line">                          solution);</div><div class="line"><a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a> (dof_handler,</div><div class="line">                          ExactSolution&lt;dim&gt; (1, time-time_step),</div><div class="line">                          old_solution);</div><div class="line">output_results (0);</div><div class="line"></div><div class="line">std::vector&lt;LinearAlgebra::distributed::Vector&lt;double&gt;*&gt; previous_solutions;</div><div class="line">previous_solutions.push_back(&amp;old_solution);</div><div class="line">previous_solutions.push_back(&amp;old_old_solution);</div><div class="line"></div><div class="line">SineGordonOperation&lt;dim,fe_degree&gt; sine_gordon_op (matrix_free_data,</div><div class="line">                                                   time_step);</div></div><!-- fragment --><p>Now loop over the time steps. In each iteration, we shift the solution vectors by one and call the <code> apply </code> function of the <code> SineGordonOperator </code>. Then, we write the solution to a file. We clock the wall times for the computational time needed as wall as the time needed to create the output and report the numbers when the time stepping is finished.</p>
<p>Note how this shift is implemented: We simply call the swap method on the two vectors which swaps only some pointers without the need to copy data around. Obviously, this is a more efficient way to update the vectors during time stepping. Let us see what happens in more detail: First, we exchange <code>old_solution</code> with <code>old_old_solution</code>, which means that <code>old_old_solution</code> gets <code>old_solution</code>, which is what we expect. Similarly, <code>old_solution</code> gets the content from <code>solution</code> in the next step. Afterward, <code>solution</code> holds <code>old_old_solution</code>, but that will be overwritten during this step.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number = 1;</div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">    <span class="keywordtype">double</span> wtime = 0;</div><div class="line">    <span class="keywordtype">double</span> output_time = 0;</div><div class="line">    <span class="keywordflow">for</span> (time+=time_step; time&lt;=final_time; time+=time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        timer.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line">        old_old_solution.swap (old_solution);</div><div class="line">        old_solution.swap (solution);</div><div class="line">        sine_gordon_op.apply (solution, previous_solutions);</div><div class="line">        wtime += timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line">        <span class="keywordflow">if</span> (timestep_number % output_timestep_skip == 0)</div><div class="line">          output_results(timestep_number / output_timestep_skip);</div><div class="line"></div><div class="line">        output_time += timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">      }</div><div class="line">    timer.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line">    output_results(timestep_number / output_timestep_skip + 1);</div><div class="line">    output_time += timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Performed &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; time steps.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Average wallclock time per time step: &quot;</span></div><div class="line">          &lt;&lt; wtime / timestep_number &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Spent &quot;</span> &lt;&lt; output_time &lt;&lt; <span class="stringliteral">&quot;s on output and &quot;</span></div><div class="line">          &lt;&lt; wtime &lt;&lt; <span class="stringliteral">&quot;s on computations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>As in <a class="el" href="step_40.html">step-40</a>, we initialize MPI at the start of the program. Since we will in general mix MPI parallelization with threads, we also set the third argument in MPI_InitFinalize that controls the number of threads to an invalid number, which means that the TBB library chooses the number of threads automatically, typically to the number of available cores in the system. As an alternative, you can also set this number manually if you want to set a specific number of threads (e.g. when MPI-only is required).</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>Step48;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization (argc, argv,</div><div class="line">                                                       <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SineGordonProblem&lt;dimension&gt; sg_problem;</div><div class="line">      sg_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Comparisonwithasparsematrix"></a></p><h3>Comparison with a sparse matrix</h3>
<p>In order to demonstrate the gain in using the <a class="el" href="classMatrixFree.html">MatrixFree</a> class instead of the standard <code>deal.II</code> assembly routines for evaluating the information from old time steps, we study a simple serial run of the code on a nonadaptive mesh. Since much time is spent on evaluating the sine function, we do not only show the numbers of the full sine-Gordon equation but also for the wave equation (the sine-term skipped from the sine-Gordon equation). We use both second and fourth order elements. The results are summarized in the following table.</p>
<table align="center" border="1">
<tr>
<th>&#160; </th><th colspan="3">wave equation </th><th colspan="2">sine-Gordon  </th></tr>
<tr>
<th>&#160; </th><th>MF </th><th>SpMV </th><th>dealii </th><th>MF </th><th>dealii  </th></tr>
<tr>
<td>2D, <img class="formulaInl" alt="$\mathcal{Q}_2$" src="form_3881.png"/> </td><td align="right">0.0106 </td><td align="right">0.00971 </td><td align="right">0.109 </td><td align="right">0.0243 </td><td align="right">0.124  </td></tr>
<tr>
<td>2D, <img class="formulaInl" alt="$\mathcal{Q}_4$" src="form_3882.png"/> </td><td align="right">0.0328 </td><td align="right">0.0706 </td><td align="right">0.528 </td><td align="right">0.0714 </td><td align="right">0.502  </td></tr>
<tr>
<td>3D, <img class="formulaInl" alt="$\mathcal{Q}_2$" src="form_3881.png"/> </td><td align="right">0.0151 </td><td align="right">0.0320 </td><td align="right">0.331 </td><td align="right">0.0376 </td><td align="right">0.364  </td></tr>
<tr>
<td>3D, <img class="formulaInl" alt="$\mathcal{Q}_4$" src="form_3882.png"/> </td><td align="right">0.0918 </td><td align="right">0.844 </td><td align="right">6.83 </td><td align="right">0.194 </td><td align="right">6.95  </td></tr>
</table>
<p>It is apparent that the matrix-free code outperforms the standard assembly routines in deal.II by far. In 3D and for fourth order elements, one operator application is also almost ten times as fast as a sparse matrix-vector product.</p>
<p><a class="anchor" id="Parallelrunin3D"></a></p><h3>Parallel run in 3D</h3>
<p>To demonstrate how the example scales for a parallel run and to demonstrate that hanging node constraints can be handled in an efficient way, we run the example in 3D with <img class="formulaInl" alt="$\mathcal{Q}_4$" src="form_3882.png"/> elements. First, we run it on a notebook with 2 cores (Sandy Bridge CPU) at 2.7 GHz. </p><div class="fragment"><div class="line">$ make debug-mode=off run</div><div class="line">   Number of global active cells: 17592</div><div class="line">   Number of degrees of freedom: 1193881</div><div class="line">   Time step size: 0.0117233, finest cell: 0.46875</div><div class="line"></div><div class="line">   Time:     -10, solution norm:  29.558</div><div class="line">   Time:   -7.66, solution norm:  129.13</div><div class="line">   Time:   -5.31, solution norm:  67.753</div><div class="line">   Time:   -2.97, solution norm:  79.245</div><div class="line">   Time:  -0.621, solution norm:  123.52</div><div class="line">   Time:    1.72, solution norm:  43.525</div><div class="line">   Time:    4.07, solution norm:  93.285</div><div class="line">   Time:    6.41, solution norm:  97.722</div><div class="line">   Time:    8.76, solution norm:  36.734</div><div class="line">   Time:      10, solution norm:  94.115</div><div class="line"></div><div class="line">   Performed 1706 time steps.</div><div class="line">   Average wallclock time per time step: 0.038261s</div><div class="line">   Spent 11.977s on output and 65.273s on computations.</div></div><!-- fragment --><p>It takes 0.04 seconds for one time step on a notebook with more than a million degrees of freedom (note that we would need many processors to reach such numbers when solving linear systems). If we run the same 3D code on a cluster with 2 nodes and each node runs 8 threads, we get the following times:</p>
<div class="fragment"><div class="line">$ mpirun --bynode -n 2 ./step-48</div><div class="line">...</div><div class="line">   Performed 1706 time steps.</div><div class="line">   Average wallclock time per time step: 0.0123188s</div><div class="line">   Spent 6.74378s on output and 21.0158s on computations.</div></div><!-- fragment --><p>We observe a considerable speedup over the notebook (16 cores versus 2 cores; nonetheless, one notebook core is considerably faster than one core of the cluster because of a newer processor architecture). If we run the same program on 4 nodes with 8 threads on each node, we get: </p><div class="fragment"><div class="line">$ mpirun --bynode -n 4 ./step-48</div><div class="line">...</div><div class="line">   Performed 1706 time steps.</div><div class="line">   Average wallclock time per time step: 0.00689865s</div><div class="line">   Spent 3.54145s on output and 11.7691s on computations.</div></div><!-- fragment --><p>By comparing the times for two nodes and four nodes, we observe the nice scaling behavior of the implementation. Of course, the code can also be run in MPI-mode only by disabling the multithreading flag in the code. If we use the same 32 cores as for the hybrid parallelization above, we observe the following run-time:</p>
<div class="fragment"><div class="line">$ mpirun -n 32 ./step-48</div><div class="line">...</div><div class="line">   Performed 1706 time steps.</div><div class="line">   Average wallclock time per time step: 0.0189041s</div><div class="line">   Spent 0.968967s on output and 32.2504s on computations.</div></div><!-- fragment --><p>We observe slower speed for computations, but faster output (which makes sense, as output is only parallelized by MPI and not threads), whereas the computations are faster if we use hybrid parallelism in the given case.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>There are several things in this program that could be improved to make it even more efficient (besides improved boundary conditions and physical stuff as discussed in <a class="el" href="step_25.html">step-25</a>):</p>
<ul>
<li>
<p class="startli"><b>Faster evaluation of sine terms:</b> As becomes obvious from the comparison of the plain wave equation and the sine-Gordon equation above, the evaluation of the sine terms dominates the total time for the finite element operator application. There are a few reasons for this: Firstly, the deal.II sine computation of a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> field is not vectorized (as opposed to the rest of the operator application). This could be cured by handing the sine computation to a library with vectorized sine computations like Intel's math kernel library (MKL). By using the function <code>vdSin</code> in MKL, the program uses half the computing time in 2D and 40 percent less time in 3D. On the other hand, the sine computation is structurally much more complicated than the simple arithmetic operations like additions and multiplications in the rest of the local operation.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Higher order time stepping:</b> While the implementation allows for arbitrary order in the spatial part (by adjusting the degree of the finite element), the time stepping scheme is a standard second-order leap-frog scheme. Since solutions in wave propagation problems are usually very smooth, the error is likely dominated by the time stepping part. Of course, this could be cured by using smaller time steps (at a fixed spatial resolution), but it would be more efficient to use higher order time stepping as well. While it would be straight-forward to do so for a first-order system (use some Runge&ndash;Kutta scheme of higher order, probably combined with adaptive time step selection like the <a href="http://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method">Dormand&ndash;Prince method</a>), it is more challenging for the second-order formulation. At least in the finite difference community, people usually use the PDE to find spatial correction terms that improve the temporal error.</p>
<p class="endli"></p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2011 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Katharina Kormann, Martin Kronbichler, Uppsala University, 2011-2012</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/la_parallel_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/matrix_free/matrix_free.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/matrix_free/fe_evaluation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step48</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension = 2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree = 4;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keyword">class </span>SineGordonOperation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SineGordonOperation(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a> &amp;data_in,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>                  time_step);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> apply (<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>                     &amp;dst,</div><div class="line">                <span class="keyword">const</span> std::vector&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>*&gt; &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a>         &amp;data;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a>         delta_t_sqr;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> inv_mass_matrix;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_apply (<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a>               &amp;data,</div><div class="line">                      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>      &amp;dst,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>*&gt; &amp;src,</div><div class="line">                      <span class="keyword">const</span> std::pair&lt;unsigned int,unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  SineGordonOperation&lt;dim,fe_degree&gt;::</div><div class="line">  SineGordonOperation(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a> &amp;data_in,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span>                  time_step)</div><div class="line">    :</div><div class="line">    data(data_in),</div><div class="line">    delta_t_sqr(make_vectorized_array(time_step *time_step))</div><div class="line">  {</div><div class="line">    <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> one = make_vectorized_array (1.);</div><div class="line"></div><div class="line">    data.<a class="code" href="classMatrixFree.html#a254dd56fdce3104116caf6099f003467">initialize_dof_vector</a> (inv_mass_matrix);</div><div class="line"></div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree&gt;</a>   fe_eval(data);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            n_q_points = fe_eval.n_q_points;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell=0; cell&lt;data.<a class="code" href="classMatrixFree.html#a9143bf7be90031800cf8fcffbb5b0aaf">n_macro_cells</a>(); ++cell)</div><div class="line">      {</div><div class="line">        fe_eval.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          fe_eval.submit_value(one,q);</div><div class="line">        fe_eval.integrate (<span class="keyword">true</span>,<span class="keyword">false</span>);</div><div class="line">        fe_eval.distribute_local_to_global (inv_mass_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    inv_mass_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;inv_mass_matrix.local_size(); ++k)</div><div class="line">      <span class="keywordflow">if</span> (inv_mass_matrix.local_element(k)&gt;1e-15)</div><div class="line">        inv_mass_matrix.local_element(k) = 1./inv_mass_matrix.local_element(k);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        inv_mass_matrix.local_element(k) = 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> SineGordonOperation&lt;dim, fe_degree&gt;::</div><div class="line">  local_apply (<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim&gt;</a>                      &amp;data,</div><div class="line">               <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>      &amp;dst,</div><div class="line">               <span class="keyword">const</span> std::vector&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>*&gt; &amp;src,</div><div class="line">               <span class="keyword">const</span> std::pair&lt;unsigned int,unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a> (src.<a class="code" href="classTrilinosWrappers_1_1VectorBase.html#abf1421453bd5801e0a712ceceeac3cbc">size</a>(), 2);</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree&gt;</a> current (data), old (data);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell=cell_range.first; cell&lt;cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        current.reinit (cell);</div><div class="line">        old.reinit (cell);</div><div class="line"></div><div class="line">        current.read_dof_values (*src[0]);</div><div class="line">        old.read_dof_values     (*src[1]);</div><div class="line"></div><div class="line">        current.evaluate (<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">        old.evaluate (<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;current.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> current_value = current.get_value(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> old_value     = old.get_value(q);</div><div class="line"></div><div class="line">            current.submit_value (2.*current_value - old_value -</div><div class="line">                                  delta_t_sqr * std::sin(current_value),q);</div><div class="line">            current.submit_gradient (- delta_t_sqr *</div><div class="line">                                     current.get_gradient(q), q);</div><div class="line">          }</div><div class="line"></div><div class="line">        current.integrate (<span class="keyword">true</span>,<span class="keyword">true</span>);</div><div class="line">        current.distribute_local_to_global (dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> SineGordonOperation&lt;dim, fe_degree&gt;::</div><div class="line">  apply (<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>                     &amp;dst,</div><div class="line">         <span class="keyword">const</span> std::vector&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a>*&gt; &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    dst = 0;</div><div class="line">    data.<a class="code" href="classMatrixFree.html#a523c939c0f87d8ad17d81bb3a2667b02">cell_loop</a> (&amp;SineGordonOperation&lt;dim,fe_degree&gt;::local_apply,</div><div class="line">                    <span class="keyword">this</span>, dst, src);</div><div class="line">    dst.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#afe20bd36869672666539d70f6c62c053">scale</a>(inv_mass_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExactSolution (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_components = 1,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> time = 0.) : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(n_components, time) {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> ExactSolution&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/* component */</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span> t = this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a> ();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> m = 0.5;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c1 = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c2 = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> factor = (m / std::sqrt(1.-m*m) *</div><div class="line">                           std::sin(std::sqrt(1.-m*m)*t+c2));</div><div class="line">    <span class="keywordtype">double</span> result = 1.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">      result *= -4. * std::atan (factor / std::cosh(m*p[d]+c1));</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SineGordonProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SineGordonProblem ();</div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_grid_and_dofs ();</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>             locally_relevant_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim,double&gt;</a> matrix_free_data;</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution, old_solution, old_old_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_global_refinements;</div><div class="line">    <span class="keywordtype">double</span> time, time_step;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> final_time;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> cfl_number;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_timestep_skip;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SineGordonProblem&lt;dim&gt;::SineGordonProblem ()</div><div class="line">    :</div><div class="line">    pcout (<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">           <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD)==0),</div><div class="line">#ifdef DEAL_II_WITH_P4EST</div><div class="line">    triangulation (MPI_COMM_WORLD),</div><div class="line">#endif</div><div class="line">    fe (<a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;1&gt;(fe_degree+1)),</div><div class="line">    dof_handler (triangulation),</div><div class="line">    n_global_refinements (10-2*dim),</div><div class="line">    time (-10),</div><div class="line">    time_step(10.),</div><div class="line">    final_time (10),</div><div class="line">    cfl_number (.1/fe_degree),</div><div class="line">    output_timestep_skip (200)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SineGordonProblem&lt;dim&gt;::make_grid_and_dofs ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -15, 15);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (n_global_refinements);</div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">      end_cell = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">      <span class="keywordflow">for</span> ( ; cell != end_cell; ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;center().norm() &lt; 11)</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">      cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">      end_cell = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">      <span class="keywordflow">for</span> ( ; cell != end_cell; ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;center().norm() &lt; 6)</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of global active cells: &quot;</span></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>()</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">          &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (dof_handler,</div><div class="line">                                             locally_relevant_dofs);</div><div class="line">    constraints.clear();</div><div class="line">    constraints.reinit (locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler, constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="classQGaussLobatto.html">QGaussLobatto&lt;1&gt;</a> quadrature (fe_degree+1);</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim&gt;::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a2c5d05b92a9c51568b7fd6c70938007a">tasks_parallel_scheme</a> =</div><div class="line">      <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim&gt;::AdditionalData::partition_partition</a>;</div><div class="line"></div><div class="line">    matrix_free_data.<a class="code" href="classMatrixFree.html#a8999754a8b1501b3d3797fac6e61ba81">reinit</a> (dof_handler, constraints,</div><div class="line">                             quadrature, additional_data);</div><div class="line"></div><div class="line">    matrix_free_data.initialize_dof_vector (solution);</div><div class="line">    old_solution.reinit (solution);</div><div class="line">    old_old_solution.reinit (solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  SineGordonProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number)</div><div class="line">  {</div><div class="line">    constraints.distribute (solution);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> norm_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    solution.<a class="code" href="classVector.html#ae50dd04b204d8ebf6be467c3ebe2234f">update_ghost_values</a>();</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler,</div><div class="line">                                       solution,</div><div class="line">                                       <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                       norm_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe_degree+1),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> solution_norm =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        norm_per_cell,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Time:&quot;</span></div><div class="line">          &lt;&lt; std::setw(8) &lt;&lt; std::setprecision(3) &lt;&lt; time</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;, solution norm: &quot;</span></div><div class="line">          &lt;&lt; std::setprecision(5) &lt;&lt; std::setw(7) &lt;&lt; solution_norm</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (timestep_number, 3);</div><div class="line"></div><div class="line">    std::ofstream output ((filename +</div><div class="line">                           <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (<a class="code" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a>::</div><div class="line">                                                           <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD),4) + <span class="stringliteral">&quot;.vtu&quot;</span>).c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">      {</div><div class="line">        std::vector&lt;std::string&gt; filenames;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;</div><div class="line">             i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a> (MPI_COMM_WORLD); ++i)</div><div class="line">          filenames.push_back (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (timestep_number, 3) +</div><div class="line">                               <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (i, 4) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line"></div><div class="line">        std::ofstream master_output ((filename + <span class="stringliteral">&quot;.pvtu&quot;</span>).c_str());</div><div class="line">        data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (master_output, filenames);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  SineGordonProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> local_min_cell_diameter =</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a1a8e886767303b776351e42658e454c0">last</a>()-&gt;diameter()/std::sqrt(dim);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_min_cell_diameter</div><div class="line">      = -<a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(-local_min_cell_diameter, MPI_COMM_WORLD);</div><div class="line">    time_step = cfl_number * global_min_cell_diameter;</div><div class="line">    time_step = (final_time-time)/(<span class="keywordtype">int</span>((final_time-time)/time_step));</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Time step size: &quot;</span> &lt;&lt; time_step &lt;&lt; <span class="stringliteral">&quot;, finest cell: &quot;</span></div><div class="line">          &lt;&lt; global_min_cell_diameter &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a> (dof_handler,</div><div class="line">                              ExactSolution&lt;dim&gt; (1, time),</div><div class="line">                              solution);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a05db6c8cebf924b417dd92f525efe3db">VectorTools::interpolate</a> (dof_handler,</div><div class="line">                              ExactSolution&lt;dim&gt; (1, time-time_step),</div><div class="line">                              old_solution);</div><div class="line">    output_results (0);</div><div class="line"></div><div class="line">    std::vector&lt;LinearAlgebra::distributed::Vector&lt;double&gt;*&gt; previous_solutions;</div><div class="line">    previous_solutions.push_back(&amp;old_solution);</div><div class="line">    previous_solutions.push_back(&amp;old_old_solution);</div><div class="line"></div><div class="line">    SineGordonOperation&lt;dim,fe_degree&gt; sine_gordon_op (matrix_free_data,</div><div class="line">                                                       time_step);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number = 1;</div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">    <span class="keywordtype">double</span> wtime = 0;</div><div class="line">    <span class="keywordtype">double</span> output_time = 0;</div><div class="line">    <span class="keywordflow">for</span> (time+=time_step; time&lt;=final_time; time+=time_step, ++timestep_number)</div><div class="line">      {</div><div class="line">        timer.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line">        old_old_solution.swap (old_solution);</div><div class="line">        old_solution.swap (solution);</div><div class="line">        sine_gordon_op.apply (solution, previous_solutions);</div><div class="line">        wtime += timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line">        <span class="keywordflow">if</span> (timestep_number % output_timestep_skip == 0)</div><div class="line">          output_results(timestep_number / output_timestep_skip);</div><div class="line"></div><div class="line">        output_time += timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">      }</div><div class="line">    timer.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line">    output_results(timestep_number / output_timestep_skip + 1);</div><div class="line">    output_time += timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Performed &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; time steps.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Average wallclock time per time step: &quot;</span></div><div class="line">          &lt;&lt; wtime / timestep_number &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Spent &quot;</span> &lt;&lt; output_time &lt;&lt; <span class="stringliteral">&quot;s on output and &quot;</span></div><div class="line">          &lt;&lt; wtime &lt;&lt; <span class="stringliteral">&quot;s on computations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>Step48;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization (argc, argv,</div><div class="line">                                                       <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      SineGordonProblem&lt;dimension&gt; sg_problem;</div><div class="line">      sg_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
