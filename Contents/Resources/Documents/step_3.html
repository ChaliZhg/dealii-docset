<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-3 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-3 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thebasicfunctioningoffiniteelements">The basic functioning of finite elements</a>
        <li><a href="#Abouttheimplementation">About the implementation</a>
        <li><a href="#Anoteontypes"> A note on types </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Manynewincludefiles">Many new include files</a>
        <li><a href="#ThecodeStep3codeclass">The <code>Step3</code> class</a>
      <ul>
        <li><a href="#Step3Step3">Step3::Step3</a>
        <li><a href="#Step3make_grid">Step3::make_grid</a>
        <li><a href="#Step3setup_system">Step3::setup_system</a>
        <li><a href="#Step3assemble_system">Step3::assemble_system</a>
        <li><a href="#Step3solve">Step3::solve</a>
        <li><a href="#Step3output_results">Step3::output_results</a>
        <li><a href="#Step3run">Step3::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.10.html">video lecture 10</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p><a class="anchor" id="Thebasicfunctioningoffiniteelements"></a></p><h3>The basic functioning of finite elements</h3>
<p>This is the first example where we actually use finite elements to compute something. We will solve a simple version of Poisson's equation with zero boundary values, but a nonzero right hand side: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -\Delta u &amp;= f \qquad\qquad &amp; \text{in}\ \Omega, \\ u &amp;= 0 \qquad\qquad &amp; \text{on}\ \partial\Omega. \end{align*}" src="form_2450.png"/>
</p>
<p> We will solve this equation on the unit square, <img class="formulaInl" alt="$\Omega=[0,1]^2$" src="form_1448.png"/>, for which you've already learned how to generate a mesh in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a>. In this program, we will also only consider the particular case <img class="formulaInl" alt="$f(\mathbf x)=1$" src="form_2451.png"/> and come back to how to implement the more general case in the next tutorial program, <a class="el" href="step_4.html">step-4</a>.</p>
<p>If you've learned about the basics of the finite element method, you will remember the steps we need to take to approximate the solution <img class="formulaInl" alt="$u$" src="form_256.png"/> by a finite dimensional approximation. Specifically, we first need to derive the weak form of the equation above, which we obtain by multiplying the equation by a test function <img class="formulaInl" alt="$\varphi$" src="form_94.png"/> <em>from the left</em> (we will come back to the reason for multiplying from the left and not from the right below) and integrating over the domain <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -\int_\Omega \varphi \Delta u = \int_\Omega \varphi f. \end{align*}" src="form_2452.png"/>
</p>
<p> This can be integrated by parts: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \int_\Omega \nabla\varphi \cdot \nabla u - \int_{\partial\Omega} \varphi \mathbf{n}\cdot \nabla u = \int_\Omega \varphi f. \end{align*}" src="form_2453.png"/>
</p>
<p> The test function <img class="formulaInl" alt="$\varphi$" src="form_94.png"/> has to satisfy the same kind of boundary conditions (in mathematical terms: it needs to come from the tangent space of the set in which we seek the solution), so on the boundary <img class="formulaInl" alt="$\varphi=0$" src="form_2454.png"/> and consequently the weak form we are looking for reads </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (\nabla\varphi, \nabla u) = (\varphi, f), \end{align*}" src="form_2455.png"/>
</p>
<p> where we have used the common notation <img class="formulaInl" alt="$(a,b)=\int_\Omega a\; b$" src="form_2456.png"/>. The problem then asks for a function <img class="formulaInl" alt="$u$" src="form_256.png"/> for which this statement is true for all test functions <img class="formulaInl" alt="$\varphi$" src="form_94.png"/> from the appropriate space (which here is the space <img class="formulaInl" alt="$H^1$" src="form_38.png"/>).</p>
<p>Of course we can't find such a function on a computer in the general case, and instead we seek an approximation <img class="formulaInl" alt="$u_h(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)$" src="form_2457.png"/>, where the <img class="formulaInl" alt="$U_j$" src="form_75.png"/> are unknown expansion coefficients we need to determine (the "degrees of freedom" of this problem), and <img class="formulaInl" alt="$\varphi_i(\mathbf x)$" src="form_2179.png"/> are the finite element shape functions we will use. To define these shape functions, we need the following:</p>
<ul>
<li>A mesh on which to define shape functions. You have already seen how to generate and manipulate the objects that describe meshes in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a>.</li>
<li>A finite element that describes the shape functions we want to use on the reference cell (which in deal.II is always the unit interval <img class="formulaInl" alt="$[0,1]$" src="form_364.png"/>, the unit square <img class="formulaInl" alt="$[0,1]^2$" src="form_431.png"/> or the unit cube <img class="formulaInl" alt="$[0,1]^3$" src="form_2458.png"/>, depending on which space dimension you work in. In <a class="el" href="step_2.html">step-2</a>, we had already used an object of type FE_Q&lt;2&gt;, which denotes the usual Lagrange elements that define shape functions by interpolation on support points. The simplest one is FE_Q&lt;2&gt;(1), which uses polynomial degree 1. In 2d, these are often referred to as <em>bilinear</em>, since they are linear in each of the two coordinates of the reference cell. (In 1d, they would be <em>linear</em> and in 3d <em>tri-linear</em>; however, in the deal.II documentation, we will frequently not make this distinction and simply always call these functions "linear".)</li>
<li>A <a class="el" href="classDoFHandler.html">DoFHandler</a> object that enumerates all the degrees of freedom on the mesh, taking the reference cell description the finite element object provides as the basis. You've also already seen how to do this in <a class="el" href="step_2.html">step-2</a>.</li>
<li>A mapping that tells how the shape functions on the real cell are obtained from the shape functions defined by the finite element class on the reference cell. By default, unless you explicitly say otherwise, deal.II will use a (bi-, tri-)linear mapping for this, so in most cases you don't have to worry about this step.</li>
</ul>
<p>Through these steps, we now have a set of functions <img class="formulaInl" alt="$\varphi_i$" src="form_531.png"/>, and we can define the weak form of the discrete problem: Find a function <img class="formulaInl" alt="$u_h$" src="form_722.png"/>, i.e. find the expansion coefficients <img class="formulaInl" alt="$U_i$" src="form_2459.png"/> mentioned above, so that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (\nabla\varphi_i, \nabla u_h) = (\varphi_i, f), \qquad\qquad i=0\ldots N-1. \end{align*}" src="form_2460.png"/>
</p>
<p> Note that we here follow the convention that everything is counted starting at zero, as common in C and C++. This equation can be rewritten as a linear system by inserting the representation <img class="formulaInl" alt="$u_h(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)$" src="form_2457.png"/>: Find a vector <img class="formulaInl" alt="$U$" src="form_203.png"/> so that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} A U = F, \end{align*}" src="form_2461.png"/>
</p>
<p> where the matrix <img class="formulaInl" alt="$A$" src="form_40.png"/> and the right hand side <img class="formulaInl" alt="$F$" src="form_249.png"/> are defined as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} A_{ij} &amp;= (\nabla\varphi_i, \nabla \varphi_j), \\ F_i &amp;= (\varphi_i, f). \end{align*}" src="form_2462.png"/>
</p>
<p> Before we move on with describing how these quantities can be computed, note that if we had multiplied the original equation from the <em>right</em> by a test function rather than from the left, then we would have obtained a linear system of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} U^T A = F \end{align*}" src="form_2463.png"/>
</p>
<p> with a row vector <img class="formulaInl" alt="$F$" src="form_249.png"/>. By transposing this system, this is of course equivalent to solving </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} A^T U = F \end{align*}" src="form_2464.png"/>
</p>
<p> which here is the same as above since <img class="formulaInl" alt="$A=A^T$" src="form_2465.png"/> but in general is not. To avoid any sort of confusion, experience has shown that simply getting into the habit of multiplying the equation from the left rather than from the right (as is often done in the mathematical literature) avoids a common class of errors as the matrix is automatically correct and does not need to be transposed when comparing theory and implementation. See <a class="el" href="step_9.html">step-9</a> for the first example in this tutorial where we have a non-symmetric bilinear form for which it makes a difference whether we multiply from the right or from the left.</p>
<p>Now we know what we need (namely objects that hold the matrix and vectors, as well as ways to compute <img class="formulaInl" alt="$A_{ij},F_i$" src="form_2466.png"/>), and we can look at what it takes to make that happen:</p>
<ul>
<li>The objects for <img class="formulaInl" alt="$A,U,F$" src="form_2467.png"/> are of type <a class="el" href="classSparseMatrix.html">SparseMatrix</a> and <a class="el" href="classVector.html">Vector</a>, and we will see in the program below what classes are used to solve linear systems.</li>
<li>We need a way to form the integrals. In the finite element method, this is most commonly done using quadrature, i.e. the integrals are replaced by a weighted sum over a set of points on each cell. That is, we first split the integral over <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> into integrals over all cells, <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} A_{ij} &amp;= (\nabla\varphi_i, \nabla \varphi_j) = \sum_{K \in {\mathbb T}} \int_K \nabla\varphi_i \cdot \nabla \varphi_j, \\ F_i &amp;= (\varphi_i, f) = \sum_{K \in {\mathbb T}} \int_K \varphi_i f, \end{align*}" src="form_2468.png"/>
</p>
 and then approximate each cell's contribution by quadrature: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} A^K_{ij} &amp;= \int_K \nabla\varphi_i \cdot \nabla \varphi_j \approx \sum_q \nabla\varphi_i(\mathbf x^K_q) \cdot \nabla \varphi_j(\mathbf x^K_q) w_q^K, \\ F^K_i &amp;= \int_K \varphi_i f \approx \sum_q \varphi_i(\mathbf x^K_q) f(\mathbf x^K_q) w^K_q, \end{align*}" src="form_2469.png"/>
</p>
 where <img class="formulaInl" alt="$\mathbf x^K_q$" src="form_2470.png"/> is the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point on cell <img class="formulaInl" alt="$K$" src="form_57.png"/>, and <img class="formulaInl" alt="$w^K_q$" src="form_2471.png"/> the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature weight. There are different parts to what is needed in doing this, and we will discuss them in turn next.</li>
<li>First, we need a way to describe the location <img class="formulaInl" alt="$\mathbf x_q^K$" src="form_2472.png"/> of quadrature points and their weights <img class="formulaInl" alt="$w^K_q$" src="form_2471.png"/>. They are usually mapped from the reference cell in the same way as shape functions, i.e., implicitly using the <a class="el" href="classMappingQ1.html">MappingQ1</a> class or, if you explicitly say so, through one of the other classes derived from <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a>. The locations and weights on the reference cell are described by objects derived from the <a class="el" href="classQuadrature.html">Quadrature</a> base class. Typically, one chooses a quadrature formula (i.e. a set of points and weights) so that the quadrature exactly equals the integral in the matrix; this can be achieved because all factors in the integral are polynomial, and is done by Gaussian quadrature formulas, implemented in the <a class="el" href="classQGauss.html">QGauss</a> class.</li>
<li>We then need something that can help us evaluate <img class="formulaInl" alt="$\varphi_i(\mathbf x^K_q)$" src="form_2473.png"/> on cell <img class="formulaInl" alt="$K$" src="form_57.png"/>. This is what the <a class="el" href="classFEValues.html">FEValues</a> class does: it takes a finite element objects to describe <img class="formulaInl" alt="$\varphi$" src="form_94.png"/> on the reference cell, a quadrature object to describe the quadrature points and weights, and a mapping object (or implicitly takes the <a class="el" href="classMappingQ1.html">MappingQ1</a> class) and provides values and derivatives of the shape functions on the real cell <img class="formulaInl" alt="$K$" src="form_57.png"/> as well as all sorts of other information needed for integration, at the quadrature points located on <img class="formulaInl" alt="$K$" src="form_57.png"/>.</li>
</ul>
<p><a class="el" href="classFEValues.html">FEValues</a> really is the central class in the assembly process. One way you can view it is as follows: The <a class="el" href="classFiniteElement.html">FiniteElement</a> and derived classes describe shape <em>functions</em>, i.e., infinite dimensional objects: functions have values at every point. We need this for theoretical reasons because we want to perform our analysis with integrals over functions. However, for a computer, this is a very difficult concept, since they can in general only deal with a finite amount of information, and so we replace integrals by sums over quadrature points that we obtain by mapping (the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> object) using points defined on a reference cell (the <a class="el" href="classQuadrature.html">Quadrature</a> object) onto points on the real cell. In essence, we reduce the problem to one where we only need a finite amount of information, namely shape function values and derivatives, quadrature weights, normal vectors, etc, exclusively at a finite set of points. The <a class="el" href="classFEValues.html">FEValues</a> class is the one that brings the three components together and provides this finite set of information on a particular cell <img class="formulaInl" alt="$K$" src="form_57.png"/>. You will see it in action when we assemble the linear system below.</p>
<p>It is noteworthy that all of this could also be achieved if you simply created these three objects yourself in an application program, and juggled the information yourself. However, this would neither be simpler (the <a class="el" href="classFEValues.html">FEValues</a> class provides exactly the kind of information you actually need) nor faster: the <a class="el" href="classFEValues.html">FEValues</a> class is highly optimized to only compute on each cell the particular information you need; if anything can be re-used from the previous cell, then it will do so, and there is a lot of code in that class to make sure things are cached wherever this is advantageous.</p>
<p>The final piece of this introduction is to mention that after a linear system is obtained, it is solved using an iterative solver and then postprocessed: we create an output file using the <a class="el" href="classDataOut.html">DataOut</a> class that can then be visualized using one of the common visualization programs.</p>
<dl class="section note"><dt>Note</dt><dd>The preceding overview of all the important steps of any finite element implementation has its counterpart in deal.II: The library can naturally be grouped into a number of "modules" that cover the basic concepts just outlined. You can access these modules through the tab at the top of this page. An overview of the most fundamental groups of concepts is also available on the <a href="index.html">front page of the deal.II manual</a>.</dd></dl>
<p><a class="anchor" id="Abouttheimplementation"></a></p><h3>About the implementation</h3>
<p>Although this is the simplest possible equation you can solve using the finite element method, this program shows the basic structure of most finite element programs and also serves as the template that almost all of the following programs will essentially follow. Specifically, the main class of this program looks like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Step3 ();</div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid ();</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>     triangulation;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>              fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>        dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line">};</div></div><!-- fragment --><p>This follows the object oriented programming mantra of <a href="http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)">data encapsulation</a>, i.e. we do our best to hide almost all internal details of this class in private members that are not accessible to the outside.</p>
<p>Let's start with the member variables: These follow the building blocks we have outlined above in the bullet points, namely we need a <a class="el" href="classTriangulation.html">Triangulation</a> and a <a class="el" href="classDoFHandler.html">DoFHandler</a> object, and a finite element object that describes the kinds of shape functions we want to use. The second group of objects relate to the linear algebra: the system matrix and right hand side as well as the solution vector, and an object that describes the sparsity pattern of the matrix. This is all this class needs (and the essentials that any solver for a stationary PDE requires) and that needs to survive throughout the entire program. In contrast to this, the <a class="el" href="classFEValues.html">FEValues</a> object we need for assembly is only required throughout assembly, and so we create it as a local object in the function that does that and destroy it again at its end.</p>
<p>Secondly, let's look at the member functions. These, as well, already form the common structure that almost all following tutorial programs will use: </p><ul>
<li>
<code>make_grid()</code>: This is what one could call a <em>preprocessing function</em>. As its name suggests, it sets up the object that stores the triangulation. In later examples, it could also deal with boundary conditions, geometries, etc. </li>
<li>
<code>setup_system()</code>: This then is the function in which all the other data structures are set up that are needed to solve the problem. In particular, it will initialize the <a class="el" href="classDoFHandler.html">DoFHandler</a> object and correctly size the various objects that have to do with the linear algebra. This function is often separated from the preprocessing function above because, in a time dependent program, it may be called at least every few time steps whenever the mesh is adaptively refined (something we will see how to do in <a class="el" href="step_6.html">step-6</a>). On the other hand, setting up the mesh itself in the preprocessing function above is done only once at the beginning of the program and is, therefore, separated into its own function. </li>
<li>
<code>assemble_system()</code>: This, then is where the contents of the matrix and right hand side are computed, as discussed at length in the introduction above. Since doing something with this linear system is conceptually very different from computing its entries, we separate it from the following function. </li>
<li>
<code>solve()</code>: This then is the function in which we compute the solution <img class="formulaInl" alt="$U$" src="form_203.png"/> of the linear system <img class="formulaInl" alt="$AU=F$" src="form_2474.png"/>. In the current program, this is a simple task since the matrix is so simple, but it will become a significant part of a program's size whenever the problem is not so trivial any more (see, for example, <a class="el" href="step_20.html">step-20</a>, <a class="el" href="step_22.html">step-22</a>, or <a class="el" href="step_31.html">step-31</a> once you've learned a bit more about the library). </li>
<li>
<code>output_results()</code>: Finally, when you have computed a solution, you probably want to do something with it. For example, you may want to output it in a format that can be visualized, or you may want to compute quantities you are interested in: say, heat fluxes in a heat exchanger, air friction coefficients of a wing, maximum bridge loads, or simple the value of the numerical solution at a point. This function is therefore the place for postprocessing your solution. </li>
</ul>
<p>All of this is held together by the single public function (other than the constructor), namely the <code>run()</code> function. It is the one that is called from the place where an object of this type is created, and it is the one that calls all the other functions in their proper order. Encapsulating this operation into the <code>run()</code> function, rather than calling all the other functions from <code>main()</code> makes sure that you can change how the separation of concerns within this class is implemented. For example, if one of the functions becomes too big, you can split it up into two, and the only places you have to be concerned about changing as a consequence are within this very same class, and not anywhere else.</p>
<p>As mentioned above, you will see this general structure &mdash; sometimes with variants in spelling of the functions' names, but in essentially this order of separation of functionality &mdash; again in many of the following tutorial programs.</p>
<p><a class="anchor" id="Anoteontypes"></a></p><h3>A note on types </h3>
<p>deal.II defines a number of integral types via <code>typedef</code>s in namespace types. In particular, in this program you will see <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> in a couple of places: an integer type that is used to denote the <em>global</em> index of a degree of freedom, i.e., the index of a particular degree of freedom within the <a class="el" href="classDoFHandler.html">DoFHandler</a> object that is defined on top of a triangulation (as opposed to the index of a particular degree of freedom within a particular cell). For the current program (as well as almost all of the tutorial programs), you will have a few thousand to maybe a few million unknowns globally (and, for <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> elements, you will have 4 <em>locally on each cell</em> in 2d and 8 in 3d). Consequently, a data type that allows to store sufficiently large numbers for global DoF indices is <code>unsigned int</code> given that it allows to store numbers between 0 and slightly more than 4 billion (on most systems, where integers are 32-bit). In fact, this is what <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> is.</p>
<p>So, why not just use <code>unsigned int</code> right away? deal.II used to do this until version 7.3. However, deal.II supports very large computations (via the framework discussed in <a class="el" href="step_40.html">step-40</a>) that may have more than 4 billion unknowns when spread across a few thousand processors. Consequently, there are situations where <code>unsigned int</code> is not sufficiently large and we need a 64-bit unsigned integral type. To make this possible, we introduced <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> which by default is defined as simply <code>unsigned int</code> whereas it is possible to define it as <code>unsigned long long int</code> if necessary, by passing a particular flag during configuration (see the ReadMe file).</p>
<p>This covers the technical aspect. But there is also a documentation purpose: everywhere in the library and codes that are built on it, if you see a place using the data type <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, you immediately know that the quantity that is being referenced is, in fact, a global dof index. No such meaning would be apparent if we had just used <code>unsigned int</code> (which may also be a local index, a boundary indicator, a material id, etc.). Immediately knowing what a variable refers to also helps avoid errors: it's quite clear that there must be a bug if you see an object of type <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> being assigned to variable of type <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>, even though they are both represented by unsigned integers and the compiler will, consequently, not complain.</p>
<p>In more practical terms what the presence of this type means is that during assembly, we create a <img class="formulaInl" alt="$4\times 4$" src="form_2475.png"/> matrix (in 2d, using a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> element) of the contributions of the cell we are currently sitting on, and then we need to add the elements of this matrix to the appropriate elements of the global (system) matrix. For this, we need to get at the global indices of the degrees of freedom that are local to the current cell, for which we will always use the following piece of the code: </p><div class="fragment"><div class="line">cell-&gt;get_dof_indices (local_dof_indices);</div></div><!-- fragment --><p> where <code>local_dof_indices</code> is declared as </p><div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div></div><!-- fragment --><p> The name of this variable might be a bit of a misnomer &ndash; it stands for "the global indices of those degrees of freedom locally defined on the current cell" &ndash; but variables that hold this information are universally named this way throughout the library.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> is not the only type defined in this namespace. Rather, there is a whole family, including <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>, <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>, and <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a>. All of these are <code>typedef</code>s for integer data types but, as explained above, they are used throughout the library so that (i) the intent of a variable becomes more easily discerned, and (ii) so that it becomes possible to change the actual type to a larger one if necessary without having to go through the entire library and figure out whether a particular use of <code>unsigned int</code> corresponds to, say, a material indicator.</dd></dl>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Manynewincludefiles"></a> </p><h3>Many new include files</h3>
<p>These include files are already known to you. They declare the classes which handle triangulations and enumeration of degrees of freedom:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div></div><!-- fragment --><p>And this is the file in which the functions are declared that create grids:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div></div><!-- fragment --><p>The next three files contain classes which are needed for loops over all cells and to get the information from the cell objects. The first two have been used before to get geometric information from cells; the last one is new and provides information about the degrees of freedom local to a cell:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div></div><!-- fragment --><p>In this file contains the description of the Lagrange interpolation finite element:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div></div><!-- fragment --><p>And this file is needed for the creation of sparsity patterns of sparse matrices, as shown in previous examples:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div></div><!-- fragment --><p>The next two file are needed for assembling the matrix using quadrature on each cell. The classes declared in them will be explained below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div></div><!-- fragment --><p>The following three include files we need for the treatment of boundary values:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div></div><!-- fragment --><p>We're now almost to the end. The second to last group of include files is for the linear algebra which we employ to solve the system of equations arising from the finite element discretization of the Laplace equation. We will use vectors and full matrices for assembling the system of equations locally on each cell, and transfer the results into a sparse matrix. We will then use a Conjugate Gradient solver to solve the problem, for which we need a preconditioner (in this program, we use the identity preconditioner which does nothing, but we need to include the file anyway):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div></div><!-- fragment --><p>Finally, this is for output to a file and to the console:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>...and this is to import the deal.II namespace into the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeStep3codeclass"></a> </p><h3>The <code>Step3</code> class</h3>
<p>Instead of the procedural programming of previous examples, we encapsulate everything into a class for this program. The class consists of functions which each perform certain aspects of a finite element program, a `main' function which controls what is done first and what is done next, and a list of member variables.</p>
<p>The public part of the class is rather short: it has a constructor and a function `run' that is called from the outside and acts as something like the `main' function: it coordinates which operations of this class shall be run in which order. Everything else in the class, i.e. all the functions that actually do anything, are in the private section of the class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step3 ();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run ();</div></div><!-- fragment --><p>Then there are the member functions that mostly do what their names suggest and whose have been discussed in the introduction already. Since they do not need to be called from outside, they are made private to this class.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid ();</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div></div><!-- fragment --><p>And finally we have some member variables. There are variables describing the triangulation and the global numbering of the degrees of freedom (we will specify the exact polynomial degree of the finite element in the constructor of this class)...</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>     triangulation;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>              fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>        dof_handler;</div></div><!-- fragment --><p>...variables for the sparsity pattern and values of the system matrix resulting from the discretization of the Laplace equation...</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div></div><!-- fragment --><p>...and variables which will hold the right hand side and solution vectors.</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Step3Step3"></a> </p><h4>Step3::Step3</h4>
<p>Here comes the constructor. It does not much more than first to specify that we want bi-linear elements (denoted by the parameter to the finite element object, which indicates the polynomial degree), and to associate the dof_handler variable to the triangulation we use. (Note that the triangulation isn't set up with a mesh at all at the present time, but the <a class="el" href="classDoFHandler.html">DoFHandler</a> doesn't care: it only wants to know which triangulation it will be associated with, and it only starts to care about an actual mesh once you try to distribute degree of freedom on the mesh using the distribute_dofs() function.) All the other member variables of the Step3 class have a default constructor which does all we want.</p>
<div class="fragment"><div class="line">Step3::Step3 ()</div><div class="line">  :</div><div class="line">  fe (1),</div><div class="line">  dof_handler (triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Step3make_grid"></a> </p><h4>Step3::make_grid</h4>
<p>Now, the first thing we've got to do is to generate the triangulation on which we would like to do our computation and number each vertex with a degree of freedom. We have seen these two steps in <a class="el" href="step_1.html">step-1</a> and <a class="el" href="step_2.html">step-2</a> before, respectively.</p>
<p>This function does the first part, creating the mesh. We create the grid and refine all cells five times. Since the initial grid (which is the square <img class="formulaInl" alt="$[-1,1] \times [-1,1]$" src="form_2476.png"/>) consists of only one cell, the final grid has 32 times 32 cells, for a total of 1024.</p>
<p>Unsure that 1024 is the correct number? We can check that by outputting the number of cells using the <code>n_active_cells()</code> function on the triangulation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::make_grid ()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We call the <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> function, rather than <a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">Triangulation::n_cells()</a>. Here, <em>active</em> means the cells that aren't refined any further. We stress the adjective "active" since there are more cells, namely the parent cells of the finest cells, their parents, etc, up to the one cell which made up the initial grid. Of course, on the next coarser level, the number of cells is one quarter that of the cells on the finest level, i.e. 256, then 64, 16, 4, and 1. If you called <code>triangulation.n_cells()</code> instead in the code above, you would consequently get a value of 1365 instead. On the other hand, the number of cells (as opposed to the number of active cells) is not typically of much interest, so there is no good reason to print it.</dd></dl>
<p><a class="anchor" id="Step3setup_system"></a> </p><h4>Step3::setup_system</h4>
<p>Next we enumerate all the degrees of freedom and set up matrix and vector objects to hold the system data. Enumerating is done by using <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>, as we have seen in the <a class="el" href="step_2.html">step-2</a> example. Since we use the <a class="el" href="classFE__Q.html">FE_Q</a> class and have set the polynomial degree to 1 in the constructor, i.e. bilinear elements, this associates one degree of freedom with each vertex. While we're at generating output, let us also take a look at how many degrees of freedom are generated:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div></div><!-- fragment --><p>There should be one DoF for each vertex. Since we have a 32 times 32 grid, the number of DoFs should be 33 times 33, or 1089.</p>
<p>As we have seen in the previous example, we set up a sparsity pattern by first creating a temporary structure, tagging those entries that might be nonzero, and then copying the data over to the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object that can then be used by the system matrix.</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div></div><!-- fragment --><p>Note that the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object does not hold the values of the matrix, it only stores the places where entries are. The entries themselves are stored in objects of type <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, of which our variable system_matrix is one.</p>
<p>The distinction between sparsity pattern and matrix was made to allow several matrices to use the same sparsity pattern. This may not seem relevant here, but when you consider the size which matrices can have, and that it may take some time to build the sparsity pattern, this becomes important in large-scale problems if you have to store several matrices in your program.</p>
<div class="fragment"><div class="line">system_matrix.reinit (sparsity_pattern);</div></div><!-- fragment --><p>The last thing to do in this function is to set the sizes of the right hand side vector and the solution vector to the right values:</p>
<div class="fragment"><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3assemble_system"></a> </p><h4>Step3::assemble_system</h4>
<p>The next step is to compute the entries of the matrix and right hand side that form the linear system from which we compute the solution. This is the central function of each finite element program and we have discussed the primary steps in the introduction already.</p>
<p>The general approach to assemble matrices and vectors is to loop over all cells, and on each cell compute the contribution of that cell to the global matrix and right hand side by quadrature. The point to realize now is that we need the values of the shape functions at the locations of quadrature points on the real cell. However, both the finite element shape functions as well as the quadrature points are only defined on the reference cell. They are therefore of little help to us, and we will in fact hardly ever query information about finite element shape functions or quadrature points from these objects directly.</p>
<p>Rather, what is required is a way to map this data from the reference cell to the real cell. Classes that can do that are derived from the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class, though one again often does not have to deal with them directly: many functions in the library can take a mapping object as argument, but when it is omitted they simply resort to the standard bilinear Q1 mapping. We will go this route, and not bother with it for the moment (we come back to this in <a class="el" href="step_10.html">step-10</a>, <a class="el" href="step_11.html">step-11</a>, and <a class="el" href="step_12.html">step-12</a>).</p>
<p>So what we now have is a collection of three classes to deal with: finite element, quadrature, and mapping objects. That's too much, so there is one type of class that orchestrates information exchange between these three: the <a class="el" href="classFEValues.html">FEValues</a> class. If given one instance of each three of these objects (or two, and an implicit linear mapping), it will be able to provide you with information about values and gradients of shape functions at quadrature points on a real cell.</p>
<p>Using all this, we will assemble the linear system for this problem in the following function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::assemble_system ()</div><div class="line">{</div></div><!-- fragment --><p>Ok, let's start: we need a quadrature formula for the evaluation of the integrals on each cell. Let's take a Gauss formula with two quadrature points in each direction, i.e. a total of four points since we are in 2D. This quadrature formula integrates polynomials of degrees up to three exactly (in 1D). It is easy to check that this is sufficient for the present problem:</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>  quadrature_formula(2);</div></div><!-- fragment --><p>And we initialize the object which we have briefly talked about above. It needs to be told which finite element we want to use, and the quadrature points and their weights (jointly described by a <a class="el" href="classQuadrature.html">Quadrature</a> object). As mentioned, we use the implied Q1 mapping, rather than specifying one ourselves explicitly. Finally, we have to tell it what we want it to compute on each cell: we need the values of the shape functions at the quadrature points (for the right hand side <img class="formulaInl" alt="$(\varphi_i,f)$" src="form_2477.png"/>), their gradients (for the matrix entries <img class="formulaInl" alt="$(\nabla \varphi_i, \nabla \varphi_j)$" src="form_2478.png"/>), and also the weights of the quadrature points and the determinants of the Jacobian transformations from the reference cell to the real cells.</p>
<p>This list of what kind of information we actually need is given as a collection of flags as the third argument to the constructor of <a class="el" href="classFEValues.html">FEValues</a>. Since these values have to be recomputed, or updated, every time we go to a new cell, all of these flags start with the prefix <code>update_</code> and then indicate what it actually is that we want updated. The flag to give if we want the values of the shape functions computed is <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea" title="Shape function values. ">update_values</a>; for the gradients it is <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20" title="Shape function gradients. ">update_gradients</a>. The determinants of the Jacobians and the quadrature weights are always used together, so only the products (Jacobians times weights, or short <code>JxW</code>) are computed; since we need them, we have to list <a class="el" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85" title="Transformed quadrature weights. ">update_JxW_values</a> as well:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>The advantage of this approach is that we can specify what kind of information we actually need on each cell. It is easily understandable that this approach can significantly speed up finite element computations, compared to approaches where everything, including second derivatives, normal vectors to cells, etc are computed on each cell, regardless of whether they are needed or not.</p>
<dl class="section note"><dt>Note</dt><dd>The syntax <code>update_values | update_gradients | update_JxW_values</code> is not immediately obvious to anyone not used to programming bit operations in C for years already. First, <code>operator|</code> is the <em>bitwise or operator</em>, i.e., it takes two integer arguments that are interpreted as bit patterns and returns an integer in which every bit is set for which the corresponding bit is set in at least one of the two arguments. For example, consider the operation <code>9|10</code>. In binary, <code>9=0b1001</code> (where the prefix <code>0b</code> indicates that the number is to be interpreted as a binary number) and <code>10=0b1010</code>. Going through each bit and seeing whether it is set in one of the argument, we arrive at <code>0b1001|0b1010=0b1011</code> or, in decimal notation, <code>9|10=11</code>. The second piece of information you need to know is that the various <code>update_*</code> flags are all integers that have <em>exactly one bit set</em>. For example, assume that <code>update_values=0b00001=1</code>, <code>update_gradients=0b00010=2</code>, <code>update_JxW_values=0b10000=16</code>. Then <code>update_values | update_gradients | update_JxW_values = 0b10011 = 19</code>. In other words, we obtain a number that <em>encodes a binary mask representing all of the operations you want to happen</em>, where each operation corresponds to exactly one bit in the integer that, if equal to one, means that a particular piece should be updated on each cell and, if it is zero, means that we need not compute it. In other words, even though <code>operator|</code> is the <em>bitwise OR operation</em>, what it really represents is <em>I want this AND that AND the other</em>. Such binary masks are quite common in C programming, but maybe not so in higher level languages like C++, but serve the current purpose quite well.</dd></dl>
<p>For use further down below, we define two shortcuts for values that will be used very frequently. First, an abbreviation for the number of degrees of freedom on each cell (since we are in 2D and degrees of freedom are associated with vertices only, this number is four, but we rather want to write the definition of this variable in a way that does not preclude us from later choosing a different finite element that has a different number of degrees of freedom per cell, or work in a different space dimension).</p>
<p>Secondly, we also define an abbreviation for the number of quadrature points (here that should be four). In general, it is a good idea to use their symbolic names instead of hard-coding these numbers even if you know them, since you may want to change the quadrature formula and/or finite element at some time; the program will just work with these changes, without the need to change anything in this function.</p>
<p>The shortcuts, finally, are only defined to make the following loops a bit more readable. You will see them in many places in larger programs, and `dofs_per_cell' and `n_q_points' are more or less by convention the standard names for these purposes:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.size();</div></div><!-- fragment --><p>Now, we said that we wanted to assemble the global matrix and vector cell-by-cell. We could write the results directly into the global matrix, but this is not very efficient since access to the elements of a sparse matrix is slow. Rather, we first compute the contribution of each cell in a small matrix with the degrees of freedom on the present cell, and only transfer them to the global matrix when the computations are finished for this cell. We do the same for the right hand side vector. So let's first allocate these objects (these being local objects, all degrees of freedom are coupling with all others, and we should use a full matrix object rather than a sparse one for the local operations; everything will be transferred to a global sparse matrix later on):</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div></div><!-- fragment --><p>When assembling the contributions of each cell, we do this with the local numbering of the degrees of freedom (i.e. the number running from zero through dofs_per_cell-1). However, when we transfer the result into the global matrix, we have to know the global numbers of the degrees of freedom. When we query them, we need a scratch (temporary) array for these numbers (see the discussion at the end of the introduction for the type, <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, used here):</p>
<div class="fragment"><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div></div><!-- fragment --><p>Now for the loop over all cells. We have seen before how this works, so the following code should be familiar including the conventional names for these variables:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2&gt;::active_cell_iterator</a> cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line"><a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2&gt;::active_cell_iterator</a> endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As already mentioned in <a class="el" href="step_1.html">step-1</a>, there is a more convenient way of writing such loops if your compiler supports the C++11 standard. See <a class="el" href="group__CPP11.html">the deal.II C++11 page</a> to see how this works.</dd></dl>
<p>We are now sitting on one cell, and we would like the values and gradients of the shape functions be computed, as well as the determinants of the Jacobian matrices of the mapping between reference cell and true cell, at the quadrature points. Since all these values depend on the geometry of the cell, we have to have the <a class="el" href="classFEValues.html">FEValues</a> object re-compute them on each cell:</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div></div><!-- fragment --><p>Next, reset the local cell's contributions to global matrix and global right hand side to zero, before we fill them:</p>
<div class="fragment"><div class="line">cell_matrix = 0;</div><div class="line">cell_rhs = 0;</div></div><!-- fragment --><p>Now it is time to start integration over the cell, which we do by looping over all quadrature points, which we will number by q_index.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index=0; q_index&lt;n_q_points; ++q_index)</div><div class="line">  {</div></div><!-- fragment --><p>First assemble the matrix: For the Laplace problem, the matrix on each cell is the integral over the gradients of shape function i and j. Since we do not integrate, but rather use quadrature, this is the sum over all quadrature points of the integrands times the determinant of the Jacobian matrix at the quadrature point times the weight of this quadrature point. You can get the gradient of shape function <img class="formulaInl" alt="$i$" src="form_90.png"/> at quadrature point with number q_index by using <code>fe_values.shape_grad(i,q_index)</code>; this gradient is a 2-dimensional vector (in fact it is of type <a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;, with here dim=2) and the product of two such vectors is the scalar product, i.e. the product of the two shape_grad function calls is the dot product. This is in turn multiplied by the Jacobian determinant and the quadrature point weight (that one gets together by the call to <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW()</a> ). Finally, this is repeated for all shape functions <img class="formulaInl" alt="$i$" src="form_90.png"/> and <img class="formulaInl" alt="$j$" src="form_513.png"/>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">    cell_matrix(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a> (i, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a> (j, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_index));</div></div><!-- fragment --><p>We then do the same thing for the right hand side. Here, the integral is over the shape function i times the right hand side function, which we choose to be the function with constant value one (more interesting examples will be considered in the following programs).</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i, q_index) *</div><div class="line">                    1 *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_index));</div><div class="line">}</div></div><!-- fragment --><p>Now that we have the contribution of this cell, we have to transfer it to the global matrix and right hand side. To this end, we first have to find out which global numbers the degrees of freedom on this cell have. Let's simply ask the cell for that information:</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices (local_dof_indices);</div></div><!-- fragment --><p>Then again loop over all shape functions i and j and transfer the local elements to the global matrix. The global numbers can be obtained using local_dof_indices[i]:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">    system_matrix.add (local_dof_indices[i],</div><div class="line">                       local_dof_indices[j],</div><div class="line">                       cell_matrix(i,j));</div></div><!-- fragment --><p>And again, we do the same thing for the right hand side vector.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">}</div></div><!-- fragment --><p>Now almost everything is set up for the solution of the discrete system. However, we have not yet taken care of boundary values (in fact, Laplace's equation without Dirichlet boundary values is not even uniquely solvable, since you can add an arbitrary constant to the discrete solution). We therefore have to do something about the situation.</p>
<p>For this, we first obtain a list of the degrees of freedom on the boundary and the value the shape function shall have there. For simplicity, we only interpolate the boundary value function, rather than projecting it onto the boundary. There is a function in the library which does exactly this: <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values()</a>. Its parameters are (omitting parameters for which default values exist and that we don't care about): the <a class="el" href="classDoFHandler.html">DoFHandler</a> object to get the global numbers of the degrees of freedom on the boundary; the component of the boundary where the boundary values shall be interpolated; the boundary value function itself; and the output object.</p>
<p>The component of the boundary is meant as follows: in many cases, you may want to impose certain boundary values only on parts of the boundary. For example, you may have inflow and outflow boundaries in fluid dynamics, or clamped and free parts of bodies in deformation computations of bodies. Then you will want to denote these different parts of the boundary by different numbers and tell the interpolate_boundary_values function to only compute the boundary values on a certain part of the boundary (e.g. the clamped part, or the inflow boundary). By default, all boundaries have the number `0', and since we have not changed that, this is still so; therefore, if we give `0' as the desired portion of the boundary, this means we get the whole boundary. If you have boundaries with kinds of boundaries, you have to number them differently. The function call below will then only determine boundary values for parts of the boundary.</p>
<p>The function describing the boundary values is an object of type <a class="el" href="classFunction.html">Function</a> or of a derived class. One of the derived classes is <a class="el" href="classZeroFunction.html">ZeroFunction</a>, which describes (not unexpectedly) a function which is zero everywhere. We create such an object in-place and pass it to the <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values()</a> function.</p>
<p>Finally, the output object is a list of pairs of global degree of freedom numbers (i.e. the number of the degrees of freedom on the boundary) and their boundary values (which are zero here for all entries). This mapping of DoF numbers to boundary values is done by the <code>std::map</code> class.</p>
<div class="fragment"><div class="line">std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                          0,</div><div class="line">                                          <a class="code" href="classZeroFunction.html">ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                          boundary_values);</div></div><!-- fragment --><p>Now that we got the list of boundary DoFs and their respective boundary values, let's use them to modify the system of equations accordingly. This is done by the following function call:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      system_matrix,</div><div class="line">                                      solution,</div><div class="line">                                      system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3solve"></a> </p><h4>Step3::solve</h4>
<p>The following function simply solves the discretized equation. As the system is quite a large one for direct solvers such as Gauss elimination or LU decomposition, we use a Conjugate Gradient algorithm. You should remember that the number of variables here (only 1089) is a very small number for finite element computations, where 100.000 is a more usual number. For this number of variables, direct methods are no longer usable and you are forced to use methods like CG.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::solve ()</div><div class="line">{</div></div><!-- fragment --><p>First, we need to have an object that knows how to tell the CG algorithm when to stop. This is done by using a <a class="el" href="classSolverControl.html">SolverControl</a> object, and as stopping criterion we say: stop after a maximum of 1000 iterations (which is far more than is needed for 1089 variables; see the results section to find out how many were really used), and stop if the norm of the residual is below <img class="formulaInl" alt="$10^{-12}$" src="form_2479.png"/>. In practice, the latter criterion will be the one which stops the iteration:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div></div><!-- fragment --><p>Then we need the solver itself. The template parameter to the <a class="el" href="classSolverCG.html">SolverCG</a> class is the type of the vectors, but the empty angle brackets indicate that we simply take the default argument (which is <code><a class="el" href="classVector.html">Vector</a>&lt;double&gt;</code>):</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              solver (solver_control);</div></div><!-- fragment --><p>Now solve the system of equations. The CG solver takes a preconditioner as its fourth argument. We don't feel ready to delve into this yet, so we tell it to use the identity operation as preconditioner:</p>
<div class="fragment"><div class="line">solver.solve (system_matrix, solution, system_rhs,</div><div class="line">              <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div></div><!-- fragment --><p>Now that the solver has done its job, the solution variable contains the nodal values of the solution function.</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3output_results"></a> </p><h4>Step3::output_results</h4>
<p>The last part of a typical finite element program is to output the results and maybe do some postprocessing (for example compute the maximal stress values at the boundary, or the average flux across the outflow, etc). We have no such postprocessing here, but we would like to write the solution to a file.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>To write the output to a file, we need an object which knows about output formats and the like. This is the <a class="el" href="classDataOut.html">DataOut</a> class, and we need an object of that type:</p>
<div class="fragment"><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div></div><!-- fragment --><p>Now we have to tell it where to take the values from which it shall write. We tell it which <a class="el" href="classDoFHandler.html">DoFHandler</a> object to use, and the solution vector (and the name by which the solution variable shall appear in the output file). If we had more than one vector which we would like to look at in the output (for example right hand sides, errors per cell, etc) we would add them as well:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div></div><!-- fragment --><p>After the <a class="el" href="classDataOut.html">DataOut</a> object knows which data it is to work on, we have to tell it to process them into something the back ends can handle. The reason is that we have separated the frontend (which knows about how to treat <a class="el" href="classDoFHandler.html">DoFHandler</a> objects and data vectors) from the back end (which knows many different output formats) and use an intermediate data format to transfer data from the front- to the backend. The data is transformed into this intermediate format by the following function:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div></div><!-- fragment --><p>Now we have everything in place for the actual output. Just open a file and write the data into it, using GNUPLOT format (there are other functions which write their data in postscript, AVS, GMV, or some other format):</p>
<div class="fragment"><div class="line">  std::ofstream output (<span class="stringliteral">&quot;solution.gpl&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Step3run"></a> </p><h4>Step3::run</h4>
<p>Finally, the last function of this class is the main function which calls all the other functions of the <code>Step3</code> class. The order in which this is done resembles the order in which most finite element programs work. Since the names are mostly self-explanatory, there is not much to comment about:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Step3::run ()</div><div class="line">{</div><div class="line">  make_grid ();</div><div class="line">  setup_system ();</div><div class="line">  assemble_system ();</div><div class="line">  solve ();</div><div class="line">  output_results ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>This is the main function of the program. Since the concept of a main function is mostly a remnant from the pre-object era in C/C++ programming, it often does not much more than creating an object of the top-level class and calling its principle function.</p>
<p>Finally, the first line of the function is used to enable output of the deal.II logstream to the screen. The deallog (which stands for deal-log, not de-allog) variable represents a stream to which some parts of the library write output. For example, iterative solvers will generate diagnostics (starting residual, number of solver steps, final residual) as can be seen when running this tutorial program.</p>
<p>The output of deallog can be redirected to the console, to a file, or both. But both are disabled by default. The output is nested in a way so that each function can use a prefix string (separated by colons) for each line of output; if it calls another function, that may also use its prefix which is then printed after the one of the calling function. By running this example (or looking at the "Results" section), you will see the solver statistics prefixed with "DEAL:CG", which is two prefixes. Since output from functions which are nested deep below is usually not as important as top-level output, you can give the deallog variable a maximal depth of nested output for output to console and file. A depth of 0 (the default) will disable output to the screen, while a value of 2 or higher will cause the solver info in this example to be printed. Imagine that different solvers can be nested, which we will see in <a class="el" href="step_22.html">step-22</a> for example, and you might not want to see all this information.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (2);</div><div class="line"></div><div class="line">  Step3 laplace_problem;</div><div class="line">  laplace_problem.run ();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of the program looks as follows: </p><div class="fragment"><div class="line">Number of active cells: 1024</div><div class="line">Number of degrees of freedom: 1089</div><div class="line">DEAL:cg::Starting value 0.121094</div><div class="line">DEAL:cg::Convergence step 48 value 5.33692e-13</div></div><!-- fragment --><p>The first three lines is what we wrote to <code>cout</code>. The last two lines were generated without our intervention by the CG solver. The first two lines state the residual at the start of the iteration, while the last line tells us that the solver needed 47 iterations to bring the norm of the residual to 5.3e-13, i.e. below the threshold 1e-12 which we have set in the `solve' function. We will show in the next program how to suppress this output, which is sometimes useful for debugging purposes, but often clutters up the screen display.</p>
<p>Apart from the output shown above, the program generated the file <code>solution.gpl</code>, which is in GNUPLOT format. It can be viewed as follows: invoke GNUPLOT and enter the following sequence of commands at its prompt: </p><div class="fragment"><div class="line">examples/step-3&gt; <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a></div><div class="line"></div><div class="line">        G N U P L O T</div><div class="line">        Version 3.7 patchlevel 3</div><div class="line">        last modified Thu Dec 12 13:00:00 GMT 2002</div><div class="line">        System: Linux 2.6.11.4-21.10-<span class="keywordflow">default</span></div><div class="line"></div><div class="line">        Copyright(C) 1986 - 1993, 1998 - 2002</div><div class="line">        Thomas Williams, Colin Kelley and many others</div><div class="line"></div><div class="line">        Type `help` to access the on-line reference manual</div><div class="line">        The <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a> FAQ is available from</div><div class="line">        http:<span class="comment">//www.gnuplot.info/gnuplot-faq.html</span></div><div class="line"></div><div class="line">        Send comments and requests <span class="keywordflow">for</span> help to &lt;info-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line">        Send bugs, suggestions and mods to &lt;bug-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line"></div><div class="line"></div><div class="line">Terminal type <span class="keyword">set</span> to <span class="stringliteral">&#39;x11&#39;</span></div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; <span class="keyword">set</span> style data lines</div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; splot <span class="stringliteral">&quot;solution.gpl&quot;</span></div></div><!-- fragment --><p> This produces the picture of the solution below left. Alternatively, you can order GNUPLOT to do some hidden line removal by the command </p><div class="fragment"><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; <span class="keyword">set</span> hidden3d</div></div><!-- fragment --><p> to get the result at the right:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.solution-1.png"/>
</div>
 <p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-3.solution-2.png"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>If you want to play around a little bit with this program, here are a few suggestions: </p>
<ul>
<li>
<p class="startli">Change the geometry and mesh: In the program, we have generated a square domain and mesh by using the <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></code> function. However, the <code><a class="el" href="namespaceGridGenerator.html">GridGenerator</a></code> has a good number of other functions as well. Try an L-shaped domain, a ring, or other domains you find there. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Change the boundary condition: The code uses the <code><a class="el" href="classZeroFunction.html">ZeroFunction</a></code> function to generate zero boundary conditions. However, you may want to try non-zero constant boundary values using <code><a class="el" href="classConstantFunction.html">ConstantFunction</a>&lt;2&gt; (1)</code> instead of <code><a class="el" href="classZeroFunction.html">ZeroFunction</a>&lt;2&gt; ()</code> to have unit Dirichlet boundary values. More exotic functions are described in the documentation of the <code><a class="el" href="namespaceFunctions.html">Functions</a></code> namespace, and you may pick one to describe your particular boundary values. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Modify the type of boundary condition: Presently, what happens is that we use Dirichlet boundary values all around, since the default is that all boundary parts have boundary indicator zero, and then we tell the <code><a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a></code> function to interpolate boundary values to zero on all boundary components with indicator zero. </p>
<p>We can change this behavior if we assign parts of the boundary different indicators. For example, try this immediately after calling <code><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></code>: </p><div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>()-&gt;face(0)-&gt;set_boundary_id(1);</div></div><!-- fragment --><p> What this does is it first asks the triangulation to return an iterator that points to the first active cell. Of course, this being the coarse mesh for the triangulation of a square, the triangulation has only a single cell at this moment, and it is active. Next, we ask the cell to return an iterator to its first face, and then we ask the face to reset the boundary indicator of that face to 1. What then follows is this: When the mesh is refined, faces of child cells inherit the boundary indicator of their parents, i.e. even on the finest mesh, the faces on one side of the square have boundary indicator 1. Later, when we get to interpolating boundary conditions, the <code>interpolate_boundary_values</code> will only produce boundary values for those faces that have zero boundary indicator, and leave those faces alone that have a different boundary indicator. What this then does is to impose Dirichlet boundary conditions on the former, and homogeneous Neumann conditions on the latter (i.e. zero normal derivative of the solution, unless one adds additional terms to the right hand side of the variational equality that deal with potentially non-zero Neumann conditions). You will see this if you run the program.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A slight variation of the last point would be to set different boundary values as above, but then use a different boundary value function for boundary indicator one. In practice, what you have to do is to add a second call to <code>interpolate_boundary_values</code> for boundary indicator one: </p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                          1,</div><div class="line">                                          <a class="code" href="classConstantFunction.html">ConstantFunction&lt;2&gt;</a>(1.),</div><div class="line">                                          boundary_values);</div></div><!-- fragment --><p> If you have this call immediately after the first one to this function, then it will interpolate boundary values on faces with boundary indicator 1 to the unit value, and merge these interpolated values with those previously computed for boundary indicator 0. The result will be that we will get discontinuous boundary values, zero on three sides of the square, and one on the fourth.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Observe convergence: We will only discuss computing errors in norms in <a class="el" href="step_7.html">step-7</a>, but it is easy to check that computations converge already here. For example, we could evaluate the value of the solution in a single point and compare the value for different numbers of global refinement (the number of global refinement steps is set in <code>LaplaceProblem::make_grid_and_dofs</code> above). To evaluate the solution at a point, say at <img class="formulaInl" alt="$(\frac 13, \frac 13)$" src="form_2480.png"/>, we could add the following code to the <code>LaplaceProblem::output_results</code> function: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Solution at (1/3,1/3): &quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceVectorTools.html#aaee3adabb3fb97ac5d8996cd712b20e1">VectorTools::point_value</a> (dof_handler, solution,</div><div class="line">                                       <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1./3, 1./3))</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p> For 1 through 9 global refinement steps, we then get the following sequence of point values: </p><table align="center">
<tr>
<td># of refinements </td><td><img class="formulaInl" alt="$u_h(\frac 13,\frac13)$" src="form_2481.png"/>  </td></tr>
<tr>
<td>1 </td><td>0.166667  </td></tr>
<tr>
<td>2 </td><td>0.227381  </td></tr>
<tr>
<td>3 </td><td>0.237375  </td></tr>
<tr>
<td>4 </td><td>0.240435  </td></tr>
<tr>
<td>5 </td><td>0.241140  </td></tr>
<tr>
<td>6 </td><td>0.241324  </td></tr>
<tr>
<td>7 </td><td>0.241369  </td></tr>
<tr>
<td>8 </td><td>0.241380  </td></tr>
<tr>
<td>9 </td><td>0.241383  </td></tr>
</table>
<p>By noticing that the difference between each two consecutive values reduces by about a factor of 4, we can conjecture that the "correct" value may be <img class="formulaInl" alt="$u(\frac 13, \frac 13)\approx 0.241384$" src="form_2482.png"/>. In fact, if we assumed this to be the correct value, we could show that the sequence above indeed shows <img class="formulaInl" alt="${\cal O}(h^2)$" src="form_2483.png"/> convergence &mdash; theoretically, the convergence order should be <img class="formulaInl" alt="${\cal O}(h^2 |\log h|)$" src="form_2484.png"/> but the symmetry of the domain and the mesh may lead to the better convergence order observed.</p>
<p>A slight variant of this would be to repeat the test with quadratic elements. All you need to do is to set the polynomial degree of the finite element to two in the constructor <code>LaplaceProblem::LaplaceProblem</code>.</p>
<p class="endli"></p>
</li>
<li>
Convergence of the mean: A different way to see that the solution actually converges (to something &mdash; we can't tell whether it's really the correct value!) is to compute the mean of the solution. To this end, add the following code to <code>LaplaceProblem::output_results</code>: <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Mean value: &quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">VectorTools::compute_mean_value</a> (dof_handler,</div><div class="line">                                              <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>(3),</div><div class="line">                                              solution,</div><div class="line">                                              0)</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --> The documentation of the function explains what the second and fourth parameters mean, while the first and third should be obvious. Doing the same study again where we change the number of global refinement steps, we get the following result: <table align="center">
<tr>
<td># of refinements </td><td><img class="formulaInl" alt="$\int_\Omega u_h(x)\; dx$" src="form_2485.png"/>  </td></tr>
<tr>
<td>1 </td><td>0.093750  </td></tr>
<tr>
<td>2 </td><td>0.127902  </td></tr>
<tr>
<td>3 </td><td>0.139761  </td></tr>
<tr>
<td>4 </td><td>0.139761  </td></tr>
<tr>
<td>5 </td><td>0.140373  </td></tr>
<tr>
<td>6 </td><td>0.140526  </td></tr>
<tr>
<td>7 </td><td>0.140564  </td></tr>
<tr>
<td>8 </td><td>0.140574  </td></tr>
<tr>
<td>9 </td><td>0.140576  </td></tr>
</table>
Again, the difference between two adjacent values goes down by about a factor of four, indicating convergence as <img class="formulaInl" alt="${\cal O}(h^2)$" src="form_2483.png"/>. </li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, 1999,</span></div><div class="line"><span class="comment"> *          Guido Kanschat, 2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step3 ();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid ();</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>     triangulation;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>              fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a>        dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">Step3::Step3 ()</div><div class="line">  :</div><div class="line">  fe (1),</div><div class="line">  dof_handler (triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::make_grid ()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::assemble_system ()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a>  quadrature_formula(2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2&gt;::active_cell_iterator</a> cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <a class="code" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler&lt;2&gt;::active_cell_iterator</a> endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index=0; q_index&lt;n_q_points; ++q_index)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              cell_matrix(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a> (i, q_index) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a> (j, q_index) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_index));</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i, q_index) *</div><div class="line">                            1 *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_index));</div><div class="line">        }</div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">          system_matrix.add (local_dof_indices[i],</div><div class="line">                             local_dof_indices[j],</div><div class="line">                             cell_matrix(i,j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            <a class="code" href="classZeroFunction.html">ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                            boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      system_matrix,</div><div class="line">                                      solution,</div><div class="line">                                      system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              solver (solver_control);</div><div class="line"></div><div class="line">  solver.solve (system_matrix, solution, system_rhs,</div><div class="line">                <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  std::ofstream output (<span class="stringliteral">&quot;solution.gpl&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Step3::run ()</div><div class="line">{</div><div class="line">  make_grid ();</div><div class="line">  setup_system ();</div><div class="line">  assemble_system ();</div><div class="line">  solve ();</div><div class="line">  output_results ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a> (2);</div><div class="line"></div><div class="line">  Step3 laplace_problem;</div><div class="line">  laplace_problem.run ();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
