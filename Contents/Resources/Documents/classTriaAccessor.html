<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TriaAccessor&lt; structdim, dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTriaAccessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TriaAccessor&lt; structdim, dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a> &raquo; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> &raquo; <a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tria__accessor_8h_source.html">deal.II/grid/tria_accessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TriaAccessor&lt; structdim, dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTriaAccessor__inherit__graph.svg" width="1492" height="178"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae36ecc7bf941b520c8820fece0ed2afd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae36ecc7bf941b520c8820fece0ed2afd">AccessorData</a></td></tr>
<tr class="separator:ae36ecc7bf941b520c8820fece0ed2afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a2d282e19d1d72abc52bb3bfddf551f30 inherit pub_types_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a2d282e19d1d72abc52bb3bfddf551f30">LocalData</a></td></tr>
<tr class="separator:a2d282e19d1d72abc52bb3bfddf551f30 inherit pub_types_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcbbfa481886d095df724cef84d92286"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#adcbbfa481886d095df724cef84d92286">TriaAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *parent=nullptr, const int <a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a>=-1, const int <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a> *local_data=nullptr)</td></tr>
<tr class="separator:adcbbfa481886d095df724cef84d92286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf81fa90cc1506bbdf6a54fb0626985"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:aeaf81fa90cc1506bbdf6a54fb0626985"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeaf81fa90cc1506bbdf6a54fb0626985">TriaAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:aeaf81fa90cc1506bbdf6a54fb0626985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397500f10867aa69f4a731cc9ab2de53"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:a397500f10867aa69f4a731cc9ab2de53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a397500f10867aa69f4a731cc9ab2de53">TriaAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:a397500f10867aa69f4a731cc9ab2de53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeb0b77c3f3c1de1f604d456d0718efc0">used</a> () const</td></tr>
<tr class="separator:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b363d9cf3b6911d41223c9ed5d82daa"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a1b363d9cf3b6911d41223c9ed5d82daa"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1b363d9cf3b6911d41223c9ed5d82daa">extent_in_direction</a> (const unsigned int axis) const</td></tr>
<tr class="separator:a1b363d9cf3b6911d41223c9ed5d82daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09623959e21c50be31d6e40b508c39b4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a09623959e21c50be31d6e40b508c39b4"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a09623959e21c50be31d6e40b508c39b4">extent_in_direction</a> (const unsigned int axis) const</td></tr>
<tr class="separator:a09623959e21c50be31d6e40b508c39b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f33cb96e76ff07eaf0052427907aeb3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7f33cb96e76ff07eaf0052427907aeb3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7f33cb96e76ff07eaf0052427907aeb3">extent_in_direction</a> (const unsigned int axis) const</td></tr>
<tr class="separator:a7f33cb96e76ff07eaf0052427907aeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing sub-objects</div></td></tr>
<tr class="memitem:a295994b8090ca189dc51504d24a6c96a"><td class="memItemLeft" align="right" valign="top">typename ::internal::Triangulation::Iterators&lt; dim, spacedim &gt;::vertex_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a295994b8090ca189dc51504d24a6c96a">vertex_iterator</a> (const unsigned int i) const</td></tr>
<tr class="separator:a295994b8090ca189dc51504d24a6c96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81afd26d765a4cec094b25767b8dd42a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a81afd26d765a4cec094b25767b8dd42a">vertex_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:a81afd26d765a4cec094b25767b8dd42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6518eb0cf5fccc5926470128415d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3dd6518eb0cf5fccc5926470128415d9">vertex</a> (const unsigned int i) const</td></tr>
<tr class="separator:a3dd6518eb0cf5fccc5926470128415d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ad1381ed45b14e434afffb25638be1"><td class="memItemLeft" align="right" valign="top">typename ::internal::Triangulation::Iterators&lt; dim, spacedim &gt;::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a89ad1381ed45b14e434afffb25638be1">line</a> (const unsigned int i) const</td></tr>
<tr class="separator:a89ad1381ed45b14e434afffb25638be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450f0e6e00b9711650f59143e2085d95"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a450f0e6e00b9711650f59143e2085d95">line_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:a450f0e6e00b9711650f59143e2085d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c530d9dd449bcd816a81d923af2b5b9"><td class="memItemLeft" align="right" valign="top">typename ::internal::Triangulation::Iterators&lt; dim, spacedim &gt;::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6c530d9dd449bcd816a81d923af2b5b9">quad</a> (const unsigned int i) const</td></tr>
<tr class="separator:a6c530d9dd449bcd816a81d923af2b5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab3f77d56ddde728b892e3c736a28cd0c">quad_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Orientation of sub-objects</div></td></tr>
<tr class="memitem:a452389bb368ba37c9c5542ef956526ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a452389bb368ba37c9c5542ef956526ee">face_orientation</a> (const unsigned int face) const</td></tr>
<tr class="separator:a452389bb368ba37c9c5542ef956526ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip</a> (const unsigned int face) const</td></tr>
<tr class="separator:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f831f5ca8626677089f94af9be43a5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation</a> (const unsigned int face) const</td></tr>
<tr class="separator:a2f831f5ca8626677089f94af9be43a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a08aaa41d4d6e0942d888efc21ca5d6c7">line_orientation</a> (const unsigned int <a class="el" href="classTriaAccessor.html#a89ad1381ed45b14e434afffb25638be1">line</a>) const</td></tr>
<tr class="separator:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing children</div></td></tr>
<tr class="memitem:a4ce77fc45536beea670a0b5c1d91539c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4ce77fc45536beea670a0b5c1d91539c">has_children</a> () const</td></tr>
<tr class="separator:a4ce77fc45536beea670a0b5c1d91539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a634bf3e1c46e9ba87dfafa8c869e8972">n_children</a> () const</td></tr>
<tr class="separator:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0c1e25935669a4b310671a26e9dcbd2">number_of_children</a> () const</td></tr>
<tr class="separator:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa39e613fd2e2c22bdc8ba340068e5713">max_refinement_depth</a> () const</td></tr>
<tr class="separator:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92719204d8ba105424f465336ddb915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af92719204d8ba105424f465336ddb915">child</a> (const unsigned int i) const</td></tr>
<tr class="separator:af92719204d8ba105424f465336ddb915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b513e2ff62a8add4d1316bd28f15897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6b513e2ff62a8add4d1316bd28f15897">isotropic_child</a> (const unsigned int i) const</td></tr>
<tr class="separator:a6b513e2ff62a8add4d1316bd28f15897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae6a4a753f2ef5b2615a7e2fec21e0dec">refinement_case</a> () const</td></tr>
<tr class="separator:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acd7551fc85831a3fd4d5cd339b81d8c6">child_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8adec5f5b7786cf43e6011d03cc7903a">isotropic_child_index</a> (const unsigned int i) const</td></tr>
<tr class="separator:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with boundary indicators</div></td></tr>
<tr class="memitem:af2b4887416074f2ecdcd06512e864e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">boundary_id</a> () const</td></tr>
<tr class="separator:af2b4887416074f2ecdcd06512e864e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga654de9ccd776b524a27cd64bded48e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga654de9ccd776b524a27cd64bded48e14">set_boundary_id</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const</td></tr>
<tr class="separator:ga654de9ccd776b524a27cd64bded48e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0304fb253839c45e64b60460ab040ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa0304fb253839c45e64b60460ab040ae">set_all_boundary_ids</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const</td></tr>
<tr class="separator:gaa0304fb253839c45e64b60460ab040ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211333148f7b1190db625ce91b23b65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af211333148f7b1190db625ce91b23b65">at_boundary</a> () const</td></tr>
<tr class="separator:af211333148f7b1190db625ce91b23b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7b3e39b0fd9e68a1b729fb62943828"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aaa7b3e39b0fd9e68a1b729fb62943828">get_boundary</a> () const</td></tr>
<tr class="separator:aaa7b3e39b0fd9e68a1b729fb62943828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f7767290ec8dcd1e4780efd9aa818f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a16f7767290ec8dcd1e4780efd9aa818f">get_manifold</a> () const</td></tr>
<tr class="separator:a16f7767290ec8dcd1e4780efd9aa818f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with manifold indicators</div></td></tr>
<tr class="memitem:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id</a> () const</td></tr>
<tr class="separator:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbeb21da36433dc2ec117b9694ca2557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>) const</td></tr>
<tr class="separator:gafbeb21da36433dc2ec117b9694ca2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>) const</td></tr>
<tr class="separator:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr class="memitem:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6aa91f3e086777b02a2f6eef7ac19ebb">user_flag_set</a> () const</td></tr>
<tr class="separator:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6dda85b6637fefd5db3d37ad7729fcb1">set_user_flag</a> () const</td></tr>
<tr class="separator:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">clear_user_flag</a> () const</td></tr>
<tr class="separator:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a63d791b3769c77bcfd1c56748a6c56fa">recursively_set_user_flag</a> () const</td></tr>
<tr class="separator:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a50b22f28a2baf2dd90b5309c3f0136af">recursively_clear_user_flag</a> () const</td></tr>
<tr class="separator:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3965091ec2c6ba6ed838a2479dd8110f">clear_user_data</a> () const</td></tr>
<tr class="separator:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaaa0940be75dd7436769b55538aaac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aceaaa0940be75dd7436769b55538aaac">set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:aceaaa0940be75dd7436769b55538aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd20837028286220f0b2ba9b0d4b219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1fd20837028286220f0b2ba9b0d4b219">clear_user_pointer</a> () const</td></tr>
<tr class="separator:a1fd20837028286220f0b2ba9b0d4b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer</a> () const</td></tr>
<tr class="separator:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484e590959847d514d42814efa3e25c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a484e590959847d514d42814efa3e25c2">recursively_set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:a484e590959847d514d42814efa3e25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad04d1802d9b1e8923dcfef41ea624edc">recursively_clear_user_pointer</a> () const</td></tr>
<tr class="separator:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a0cca979ccf43e19af78dcb91d19cfd87">set_user_index</a> (const unsigned int p) const</td></tr>
<tr class="separator:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1e59ae7328b4c75c69720826736c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a97a1e59ae7328b4c75c69720826736c0">clear_user_index</a> () const</td></tr>
<tr class="separator:a97a1e59ae7328b4c75c69720826736c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a24da10289811179abbfb57253e9d3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ac7a24da10289811179abbfb57253e9d3">user_index</a> () const</td></tr>
<tr class="separator:ac7a24da10289811179abbfb57253e9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a309ae29be30ad5a259b1cd942e7d9e9d">recursively_set_user_index</a> (const unsigned int p) const</td></tr>
<tr class="separator:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429e559fb261a631942d54c897243abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a429e559fb261a631942d54c897243abb">recursively_clear_user_index</a> () const</td></tr>
<tr class="separator:a429e559fb261a631942d54c897243abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometric information about an object</div></td></tr>
<tr class="memitem:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0e85725edb5d2bb43da61796f2fbbb9">diameter</a> () const</td></tr>
<tr class="separator:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a088728d7acb727fdc13bb6664d91a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49a088728d7acb727fdc13bb6664d91a">extent_in_direction</a> (const unsigned int axis) const</td></tr>
<tr class="separator:a49a088728d7acb727fdc13bb6664d91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b268c743742c3c9ab159ff916d9236"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a99b268c743742c3c9ab159ff916d9236">minimum_vertex_distance</a> () const</td></tr>
<tr class="separator:a99b268c743742c3c9ab159ff916d9236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49df04630565a833e168e9cab074305e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49df04630565a833e168e9cab074305e">intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;coordinates) const</td></tr>
<tr class="separator:a49df04630565a833e168e9cab074305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3213234c2c543ba86eb71c716c917972"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3213234c2c543ba86eb71c716c917972">center</a> (const bool respect_manifold=false, const bool use_laplace_transformation=false) const</td></tr>
<tr class="separator:a3213234c2c543ba86eb71c716c917972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cc737f4b28f8d28a576d2e3d32ef9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a56cc737f4b28f8d28a576d2e3d32ef9f">barycenter</a> () const</td></tr>
<tr class="separator:a56cc737f4b28f8d28a576d2e3d32ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a9cecb2b7c9a1644fb5fd44bbba40ab0c">measure</a> () const</td></tr>
<tr class="separator:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689c9bb532bb02e21d58eeabc83ef908"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a689c9bb532bb02e21d58eeabc83ef908">is_translation_of</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt; &amp;o) const</td></tr>
<tr class="separator:a689c9bb532bb02e21d58eeabc83ef908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:ae826bd9e6c976638366d9993e6a6c7c0 inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a> () const</td></tr>
<tr class="separator:ae826bd9e6c976638366d9993e6a6c7c0 inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bebfc1e42324fbf595487e1bf668a22 inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a> () const</td></tr>
<tr class="separator:a6bebfc1e42324fbf595487e1bf668a22 inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75f0d6c68a1a67ea03bd4727c29529 inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5f75f0d6c68a1a67ea03bd4727c29529">state</a> () const</td></tr>
<tr class="separator:a5f75f0d6c68a1a67ea03bd4727c29529 inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379811efcfa7e6fb3531a014fdf33d5d inherit pub_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a379811efcfa7e6fb3531a014fdf33d5d">get_triangulation</a> () const</td></tr>
<tr class="separator:a379811efcfa7e6fb3531a014fdf33d5d inherit pub_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a09d81693979927a7a966ddc18d243978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a09d81693979927a7a966ddc18d243978">set_boundary_id_internal</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> id) const</td></tr>
<tr class="separator:a09d81693979927a7a966ddc18d243978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f683af0ef327d821f91e70d4a720d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3f683af0ef327d821f91e70d4a720d4f">set</a> (const ::<a class="el" href="classinternal_1_1Triangulation_1_1TriaObject.html">internal::Triangulation::TriaObject</a>&lt; structdim &gt; &amp;o) const</td></tr>
<tr class="separator:a3f683af0ef327d821f91e70d4a720d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1947e00bce29b9e766546feb3bbd2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab1947e00bce29b9e766546feb3bbd2f4">set_line_orientation</a> (const unsigned int <a class="el" href="classTriaAccessor.html#a89ad1381ed45b14e434afffb25638be1">line</a>, const bool orientation) const</td></tr>
<tr class="separator:ab1947e00bce29b9e766546feb3bbd2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4e1cdc683814cbb505b66e088ded4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2d4e1cdc683814cbb505b66e088ded4f">set_face_orientation</a> (const unsigned int face, const bool orientation) const</td></tr>
<tr class="separator:a2d4e1cdc683814cbb505b66e088ded4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120f75f4b65a498bd55ceffe89db968b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a120f75f4b65a498bd55ceffe89db968b">set_face_flip</a> (const unsigned int face, const bool flip) const</td></tr>
<tr class="separator:a120f75f4b65a498bd55ceffe89db968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eac7c4a6195f66c016eeaef1283ada8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2eac7c4a6195f66c016eeaef1283ada8">set_face_rotation</a> (const unsigned int face, const bool rotation) const</td></tr>
<tr class="separator:a2eac7c4a6195f66c016eeaef1283ada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf46d7dd76ebe7b46e3e26d63859f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6bf46d7dd76ebe7b46e3e26d63859f0c">set_used_flag</a> () const</td></tr>
<tr class="separator:a6bf46d7dd76ebe7b46e3e26d63859f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7983a80711bcde0ea9ec5f2cc95a935c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7983a80711bcde0ea9ec5f2cc95a935c">clear_used_flag</a> () const</td></tr>
<tr class="separator:a7983a80711bcde0ea9ec5f2cc95a935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928a0f17388d3e7377fb216a0ca204a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a928a0f17388d3e7377fb216a0ca204a8">set_refinement_case</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt; &amp;ref_case) const</td></tr>
<tr class="separator:a928a0f17388d3e7377fb216a0ca204a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d0e9691107c5f5ed5b5fa54c71e92f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0d0e9691107c5f5ed5b5fa54c71e92f">clear_refinement_case</a> () const</td></tr>
<tr class="separator:af0d0e9691107c5f5ed5b5fa54c71e92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee3827c653602a10ae243bfd26242eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeee3827c653602a10ae243bfd26242eb">set_children</a> (const unsigned int i, const int <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>) const</td></tr>
<tr class="separator:aeee3827c653602a10ae243bfd26242eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048a39a28d4f2a4490a71e2edc8cfc3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a048a39a28d4f2a4490a71e2edc8cfc3f">clear_children</a> () const</td></tr>
<tr class="separator:a048a39a28d4f2a4490a71e2edc8cfc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03744b658fb595893706e7a1a38ed49f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a03744b658fb595893706e7a1a38ed49f">operator=</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;)</td></tr>
<tr class="separator:a03744b658fb595893706e7a1a38ed49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplParams" colspan="2"><a id="abe9e690d5d7904f804316e15362a2191"></a>
template&lt;int , int &gt; </td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Triangulation</b></td></tr>
<tr class="separator:abe9e690d5d7904f804316e15362a2191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:ac97bc3b07691e1a0ba9f32074642ae66 inherit pub_static_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ac97bc3b07691e1a0ba9f32074642ae66">space_dimension</a> = spacedim</td></tr>
<tr class="separator:ac97bc3b07691e1a0ba9f32074642ae66 inherit pub_static_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ed55a8362723639a14d083d9e745c inherit pub_static_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a> = dim</td></tr>
<tr class="separator:a125ed55a8362723639a14d083d9e745c inherit pub_static_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e42860babc727fc028adfb9a3200b7 inherit pub_static_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> = structdim</td></tr>
<tr class="separator:a35e42860babc727fc028adfb9a3200b7 inherit pub_static_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a66324ab281f0488f99fec29b1ffdda2b inherit pro_types_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a></td></tr>
<tr class="separator:a66324ab281f0488f99fec29b1ffdda2b inherit pro_types_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a3fcd7ae82e0aa33d326dc65bf45d36f8 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a3fcd7ae82e0aa33d326dc65bf45d36f8">TriaAccessorBase</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *parent=nullptr, const int <a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a>=-1, const int <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a> *=nullptr)</td></tr>
<tr class="separator:a3fcd7ae82e0aa33d326dc65bf45d36f8 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f2c7a72b6e0e7e36b9cff8533465ef inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a29f2c7a72b6e0e7e36b9cff8533465ef">TriaAccessorBase</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a29f2c7a72b6e0e7e36b9cff8533465ef inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436333e85278d0d4f3feb80abc2db97c inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a436333e85278d0d4f3feb80abc2db97c">copy_from</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a436333e85278d0d4f3feb80abc2db97c inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94225748a277e277ba31e3c40cad9bb1 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a94225748a277e277ba31e3c40cad9bb1">operator=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a94225748a277e277ba31e3c40cad9bb1 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4644115f0c10a4e07462029211274 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a7cd4644115f0c10a4e07462029211274">operator&lt;</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;other) const</td></tr>
<tr class="separator:a7cd4644115f0c10a4e07462029211274 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eea1999560f3131c3564c780ffacc38 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a2eea1999560f3131c3564c780ffacc38">operator=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> *)</td></tr>
<tr class="separator:a2eea1999560f3131c3564c780ffacc38 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fce14be63f6000f7b5d70618dc14b inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af88fce14be63f6000f7b5d70618dc14b">operator==</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:af88fce14be63f6000f7b5d70618dc14b inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044710b90a02f1d4e6c2e39c00f51ee7 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a044710b90a02f1d4e6c2e39c00f51ee7">operator!=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:a044710b90a02f1d4e6c2e39c00f51ee7 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05057502f25e21b64d4354494978cd4 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1Triangulation_1_1TriaObjects.html">internal::Triangulation::TriaObjects</a>&lt;::<a class="el" href="classinternal_1_1Triangulation_1_1TriaObject.html">internal::Triangulation::TriaObject</a>&lt; structdim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#aa05057502f25e21b64d4354494978cd4">objects</a> () const</td></tr>
<tr class="separator:aa05057502f25e21b64d4354494978cd4 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a24bd66635320e66d1dff07e3cb26e1 inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5a24bd66635320e66d1dff07e3cb26e1">operator++</a> ()</td></tr>
<tr class="separator:a5a24bd66635320e66d1dff07e3cb26e1 inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d4f1dc476691cf77e88f2c3ed15afe inherit pro_methods_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a85d4f1dc476691cf77e88f2c3ed15afe">operator--</a> ()</td></tr>
<tr class="separator:a85d4f1dc476691cf77e88f2c3ed15afe inherit pro_methods_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classTriaAccessorBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classTriaAccessorBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase&lt; structdim, dim, spacedim &gt;</a></td></tr>
<tr class="memitem:aeec476ccc498e89a9814bdf05888cc7a inherit pro_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriaAccessor_1_1PresentLevelType.html">internal::TriaAccessor::PresentLevelType</a>&lt; structdim, dim &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#aeec476ccc498e89a9814bdf05888cc7a">present_level</a></td></tr>
<tr class="separator:aeec476ccc498e89a9814bdf05888cc7a inherit pro_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf2d985abdb2c9a43ab97722305f34 inherit pro_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a11cf2d985abdb2c9a43ab97722305f34">present_index</a></td></tr>
<tr class="separator:a11cf2d985abdb2c9a43ab97722305f34 inherit pro_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d14a2d30b3298a8ebab41c0e005f1eb inherit pro_attribs_classTriaAccessorBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a9d14a2d30b3298a8ebab41c0e005f1eb">tria</a></td></tr>
<tr class="separator:a9d14a2d30b3298a8ebab41c0e005f1eb inherit pro_attribs_classTriaAccessorBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int structdim, int dim, int spacedim&gt;<br />
class TriaAccessor&lt; structdim, dim, spacedim &gt;</h3>

<p>A class that provides access to objects in a triangulation such as its vertices, sub-objects, children, geometric information, etc. This class represents objects of dimension <code>structdim</code> (i.e. 1 for lines, 2 for quads, 3 for hexes) in a triangulation of dimensionality <code>dim</code> (i.e. 1 for a triangulation of lines, 2 for a triangulation of quads, and 3 for a triangulation of hexes) that is embedded in a space of dimensionality <code>spacedim</code> (for <code>spacedim==dim</code> the triangulation represents a domain in <img class="formulaInl" alt="$R^{dim}$" src="form_902.png"/>, for <code>spacedim&gt;dim</code> the triangulation is of a manifold embedded in a higher dimensional space).</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth and others, 1998, 2000, 2008 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l00057">57</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae36ecc7bf941b520c8820fece0ed2afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36ecc7bf941b520c8820fece0ed2afd">&#9670;&nbsp;</a></span>AccessorData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt;structdim,dim,spacedim&gt;::<a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate typedef from base class to this class. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00590">590</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adcbbfa481886d095df724cef84d92286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbbfa481886d095df724cef84d92286">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html#a66324ab281f0488f99fec29b1ffdda2b">AccessorData</a> *&#160;</td>
          <td class="paramname"><em>local_data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="aeaf81fa90cc1506bbdf6a54fb0626985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf81fa90cc1506bbdf6a54fb0626985">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion constructor. This constructor exists to make certain constructs simpler to write in dimension independent code. For example, it allows assigning a face iterator to a line iterator, an operation that is useful in 2d but doesn't make any sense in 3d. The constructor here exists for the purpose of making the code conform to C++ but it will unconditionally abort; in other words, assigning a face iterator to a line iterator is better put into an if-statement that checks that the dimension is two, and assign to a quad iterator in 3d (an operator that, without this constructor would be illegal if we happen to compile for 2d). </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03192">3192</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a397500f10867aa69f4a731cc9ab2de53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397500f10867aa69f4a731cc9ab2de53">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another conversion operator between objects that don't make sense, just like the previous one. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03222">3222</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb0b77c3f3c1de1f604d456d0718efc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0b77c3f3c1de1f604d456d0718efc0">&#9670;&nbsp;</a></span>used()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for the element being used or not. The return value is <code>true</code> for all iterators that are either normal iterators or active iterators, only raw iterators can return <code>false</code>. Since raw iterators are only used in the interiors of the library, you will not usually need this function. </p>

</div>
</div>
<a id="a295994b8090ca189dc51504d24a6c96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295994b8090ca189dc51504d24a6c96a">&#9670;&nbsp;</a></span>vertex_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::Triangulation::Iterators&lt;dim,spacedim&gt;::vertex_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> vertex bounding this object. Throw an exception if <code>dim=1</code>. </p>

</div>
</div>
<a id="a81afd26d765a4cec094b25767b8dd42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81afd26d765a4cec094b25767b8dd42a">&#9670;&nbsp;</a></span>vertex_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the global index of i-th vertex of the current object. The convention regarding the numbering of vertices is laid down in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>Note that the returned value is only the index of the geometrical vertex. It has nothing to do with possible degrees of freedom associated with it. For this, see the <code><a class="el" href="classDoFAccessor.html#aac5ce6b7f98e947f52103db02990df5c">DoFAccessor::vertex_dof_index</a></code> functions.</p>
<dl class="section note"><dt>Note</dt><dd>Despite the name, the index returned here is only global in the sense that it is specific to a particular <a class="el" href="classTriangulation.html">Triangulation</a> object or, in the case the triangulation is actually of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, specific to that part of the distributed triangulation stored on the current processor. </dd></dl>

</div>
</div>
<a id="a3dd6518eb0cf5fccc5926470128415d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd6518eb0cf5fccc5926470128415d9">&#9670;&nbsp;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the <code>ith</code> vertex. The reference is not const, i.e., it is possible to call this function on the left hand side of an assignment, thereby moving the vertex of a cell within the triangulation. Of course, doing so requires that you ensure that the new location of the vertex remains useful &ndash; for example, avoiding inverted or otherwise distorted (see also <a class="el" href="DEALGlossary.html#GlossDistorted">this glossary entry</a>).</p>
<dl class="section note"><dt>Note</dt><dd>When a cell is refined, its children inherit the position of the vertex positions of those vertices they share with the mother cell (plus the locations of the new vertices on edges, faces, and cell interiors that are created for the new child cells). If the vertex of a cell is moved, this implies that its children will also use these new locations. On the other hand, imagine a 2d situation where you have one cell that is refined (with four children) and then you move the central vertex connecting all four children. If you coarsen these four children again to the mother cell, then the location of the moved vertex is lost and if, in a later step, you refine the mother cell again, the then again new vertex will be placed again at the same position as the first time around &ndash; i.e., not at the location you had previously moved it to.</dd>
<dd>
The behavior described above is relevant if you have a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. There, refining a mesh always involves a re-partitioning. In other words, vertices of locally owned cells (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">this glossary entry</a>) that you may have moved to a different location on one processor may be moved to a different processor upon mesh refinement (even if these particular cells were not refined) which will re-create their position based on the position of the coarse cells they previously had, not based on the position these vertices had on the processor that previously owned them. In other words, in parallel computations, you will probably have to move nodes explicitly after every mesh refinement because vertex positions may or may not be preserved across the re-partitioning that accompanies mesh refinement. </dd></dl>

</div>
</div>
<a id="a89ad1381ed45b14e434afffb25638be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ad1381ed45b14e434afffb25638be1">&#9670;&nbsp;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::Triangulation::Iterators&lt;dim,spacedim&gt;::line_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> line bounding this object. </p>

</div>
</div>
<a id="a450f0e6e00b9711650f59143e2085d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450f0e6e00b9711650f59143e2085d95">&#9670;&nbsp;</a></span>line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Line index of the <code>ith</code> line bounding this object.</p>
<p>Implemented only for <code>structdim&gt;1</code>, otherwise an exception generated. </p>

</div>
</div>
<a id="a6c530d9dd449bcd816a81d923af2b5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c530d9dd449bcd816a81d923af2b5b9">&#9670;&nbsp;</a></span>quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::Triangulation::Iterators&lt;dim,spacedim&gt;::quad_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> quad bounding this object. </p>

</div>
</div>
<a id="ab3f77d56ddde728b892e3c736a28cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f77d56ddde728b892e3c736a28cd0c">&#9670;&nbsp;</a></span>quad_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quad index of the <code>ith</code> quad bounding this object.</p>
<p>Implemented only for <code>structdim&gt;2</code>, otherwise an exception generated. </p>

</div>
</div>
<a id="a452389bb368ba37c9c5542ef956526ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452389bb368ba37c9c5542ef956526ee">&#9670;&nbsp;</a></span>face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the face with index <code>face</code> has its normal pointing in the standard direction (<code>true</code>) or whether it is the opposite (<code>false</code>). Which is the standard direction is documented with the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class. In 1d and 2d, this is always <code>true</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="ad90f5ff1a44cb8a6e08196dac6cdb22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90f5ff1a44cb8a6e08196dac6cdb22e">&#9670;&nbsp;</a></span>face_flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_flip </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the face with index <code>face</code> is rotated by 180 degrees (<code>true</code>) or or not (<code>false</code>). In 1d and 2d, this is always <code>false</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="a2f831f5ca8626677089f94af9be43a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f831f5ca8626677089f94af9be43a5b">&#9670;&nbsp;</a></span>face_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_rotation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the face with index <code>face</code> is rotated by 90 degrees (<code>true</code>) or or not (<code>false</code>). In 1d and 2d, this is always <code>false</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="a08aaa41d4d6e0942d888efc21ca5d6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aaa41d4d6e0942d888efc21ca5d6c7">&#9670;&nbsp;</a></span>line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the line with index <code>line</code> is oriented in standard direction. <code>true</code> indicates, that the line is oriented from vertex 0 to vertex 1, whereas it is the other way around otherwise. In 1d and 2d, this is always <code>true</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="a4ce77fc45536beea670a0b5c1d91539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce77fc45536beea670a0b5c1d91539c">&#9670;&nbsp;</a></span>has_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::has_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether the object has children. </p>

</div>
</div>
<a id="a634bf3e1c46e9ba87dfafa8c869e8972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634bf3e1c46e9ba87dfafa8c869e8972">&#9670;&nbsp;</a></span>n_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of immediate children of this object. The number of children of an unrefined cell is zero. </p>

</div>
</div>
<a id="aa0c1e25935669a4b310671a26e9dcbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1e25935669a4b310671a26e9dcbd2">&#9670;&nbsp;</a></span>number_of_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::number_of_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute and return the number of active descendants of this objects. For example, if all of the eight children of a hex are further refined isotropically exactly once, the returned number will be 64, not 80.</p>
<p>If the present cell is not refined, one is returned.</p>
<p>If one considers a triangulation as a forest where the root of each tree are the coarse mesh cells and nodes have descendants (the children of a cell), then this function returns the number of terminal nodes in the sub-tree originating from the current object; consequently, if the current object is not further refined, the answer is one. </p>

</div>
</div>
<a id="aa39e613fd2e2c22bdc8ba340068e5713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39e613fd2e2c22bdc8ba340068e5713">&#9670;&nbsp;</a></span>max_refinement_depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::max_refinement_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of times that this object is refined. Note that not all its children are refined that often (which is why we prepend <code>max_</code>), the returned number is rather the maximum number of refinement in any branch of children of this object.</p>
<p>For example, if this object is refined, and one of its children is refined exactly one more time, then <code>max_refinement_depth</code> should return 2.</p>
<p>If this object is not refined (i.e. it is active), then the return value is zero. </p>

</div>
</div>
<a id="af92719204d8ba105424f465336ddb915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92719204d8ba105424f465336ddb915">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;structdim,dim,spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the <code>ith</code> child. </p>

</div>
</div>
<a id="a6b513e2ff62a8add4d1316bd28f15897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b513e2ff62a8add4d1316bd28f15897">&#9670;&nbsp;</a></span>isotropic_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;structdim,dim,spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to that object that is identical to the ith child for isotropic refinement. If the current object is refined isotropically, then the returned object is the ith child. If the current object is refined anisotropically, the returned child may in fact be a grandchild of the object, or may not exist at all (in which case an exception is generated). </p>

</div>
</div>
<a id="ae6a4a753f2ef5b2615a7e2fec21e0dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a4a753f2ef5b2615a7e2fec21e0dec">&#9670;&nbsp;</a></span>refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;structdim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::refinement_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classRefinementCase.html">RefinementCase</a> of this cell. </p>

</div>
</div>
<a id="acd7551fc85831a3fd4d5cd339b81d8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7551fc85831a3fd4d5cd339b81d8c6">&#9670;&nbsp;</a></span>child_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index of the <code>ith</code> child. The level of the child is one higher than that of the present cell, if the children of a cell are accessed. The children of faces have no level. If the child does not exist, -1 is returned. </p>

</div>
</div>
<a id="a8adec5f5b7786cf43e6011d03cc7903a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adec5f5b7786cf43e6011d03cc7903a">&#9670;&nbsp;</a></span>isotropic_child_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index of the <code>ith</code> isotropic child. See the <a class="el" href="classTriaAccessor.html#a6b513e2ff62a8add4d1316bd28f15897">isotropic_child()</a> function for a definition of this concept. If the child does not exist, -1 is returned. </p>

</div>
</div>
<a id="af2b4887416074f2ecdcd06512e864e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b4887416074f2ecdcd06512e864e48">&#9670;&nbsp;</a></span>boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::boundary_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the boundary indicator of this object.</p>
<p>If the return value is the special value <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>, then this object is in the interior of the domain.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="af211333148f7b1190db625ce91b23b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af211333148f7b1190db625ce91b23b65">&#9670;&nbsp;</a></span>at_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this object is at the boundary. Obviously, the use of this function is only possible for <code>dim&gt;structdim</code>; however, for <code>dim==structdim</code>, an object is a cell and the <a class="el" href="classCellAccessor.html">CellAccessor</a> class offers another possibility to determine whether a cell is at the boundary or not. </p>

</div>
</div>
<a id="aaa7b3e39b0fd9e68a1b729fb62943828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7b3e39b0fd9e68a1b729fb62943828">&#9670;&nbsp;</a></span>get_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBoundary.html">Boundary</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::get_boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to the manifold object used for this object. This function exists for backward compatibility and calls <a class="el" href="classTriaAccessor.html#a16f7767290ec8dcd1e4780efd9aa818f">get_manifold()</a> internally. </p>

</div>
</div>
<a id="a16f7767290ec8dcd1e4780efd9aa818f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f7767290ec8dcd1e4780efd9aa818f">&#9670;&nbsp;</a></span>get_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to the manifold object used for this object.</p>
<p>As explained in <a class="el" href="group__boundary.html">Boundary and manifold description for triangulations</a>, the process involved in finding the appropriate manifold description involves querying both the manifold or boundary indicators. See there for more information. </p>

</div>
</div>
<a id="a6c28dbcfefe0ffe1e51fe315c3565f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c28dbcfefe0ffe1e51fe315c3565f94">&#9670;&nbsp;</a></span>manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::manifold_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the manifold indicator of this object.</p>
<p>If the return value is the special value <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>, then this object is associated with a standard Cartesian <a class="el" href="classManifold.html">Manifold</a> Description.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="a6aa91f3e086777b02a2f6eef7ac19ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa91f3e086777b02a2f6eef7ac19ebb">&#9670;&nbsp;</a></span>user_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the user flag. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a6dda85b6637fefd5db3d37ad7729fcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dda85b6637fefd5db3d37ad7729fcb1">&#9670;&nbsp;</a></span>set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user flag. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a59ff7c1bc2b4fc8abcd9b3ef44b5f485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">&#9670;&nbsp;</a></span>clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the user flag. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a63d791b3769c77bcfd1c56748a6c56fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d791b3769c77bcfd1c56748a6c56fa">&#9670;&nbsp;</a></span>recursively_set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user flag for this and all descendants. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a50b22f28a2baf2dd90b5309c3f0136af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b22f28a2baf2dd90b5309c3f0136af">&#9670;&nbsp;</a></span>recursively_clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the user flag for this and all descendants. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a3965091ec2c6ba6ed838a2479dd8110f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3965091ec2c6ba6ed838a2479dd8110f">&#9670;&nbsp;</a></span>clear_user_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the user data to zero, independent if pointer or index. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="aceaaa0940be75dd7436769b55538aaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaaa0940be75dd7436769b55538aaac">&#9670;&nbsp;</a></span>set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user pointer to <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a1fd20837028286220f0b2ba9b0d4b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd20837028286220f0b2ba9b0d4b219">&#9670;&nbsp;</a></span>clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the user pointer to a <code>nullptr</code> pointer. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="ad3700f2ce7587b2fbcaf85753c79bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3700f2ce7587b2fbcaf85753c79bf40">&#9670;&nbsp;</a></span>user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the user pointer. It is in the responsibility of the user to make sure that the pointer points to something useful. You should use the new style cast operator to maintain a minimum of type safety, e.g.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between. <code>A <em>a=static_cast&lt;A</em>&gt;(cell-&gt;<a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer()</a>);</code>.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a484e590959847d514d42814efa3e25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484e590959847d514d42814efa3e25c2">&#9670;&nbsp;</a></span>recursively_set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user pointer of this object and all its children to the given value. This is useful for example if all cells of a certain subdomain, or all faces of a certain part of the boundary should have user pointers pointing to objects describing this part of the domain or boundary.</p>
<p>Note that the user pointer is not inherited under mesh refinement, so after mesh refinement there might be cells or faces that don't have user pointers pointing to the describing object. In this case, simply loop over all the elements of the coarsest level that has this information, and use this function to recursively set the user pointer of all finer levels of the triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="ad04d1802d9b1e8923dcfef41ea624edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04d1802d9b1e8923dcfef41ea624edc">&#9670;&nbsp;</a></span>recursively_clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the user pointer of this object and all of its descendants. The same holds as said for the <a class="el" href="classTriaAccessor.html#a484e590959847d514d42814efa3e25c2">recursively_set_user_pointer()</a> function. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a0cca979ccf43e19af78dcb91d19cfd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cca979ccf43e19af78dcb91d19cfd87">&#9670;&nbsp;</a></span>set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user index to <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </dd></dl>

</div>
</div>
<a id="a97a1e59ae7328b4c75c69720826736c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a1e59ae7328b4c75c69720826736c0">&#9670;&nbsp;</a></span>clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the user index to 0. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="ac7a24da10289811179abbfb57253e9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a24da10289811179abbfb57253e9d3">&#9670;&nbsp;</a></span>user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the user index.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a309ae29be30ad5a259b1cd942e7d9e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309ae29be30ad5a259b1cd942e7d9e9d">&#9670;&nbsp;</a></span>recursively_set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user index of this object and all its children.</p>
<p>Note that the user index is not inherited under mesh refinement, so after mesh refinement there might be cells or faces that don't have the expected user indices. In this case, simply loop over all the elements of the coarsest level that has this information, and use this function to recursively set the user index of all finer levels of the triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a429e559fb261a631942d54c897243abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429e559fb261a631942d54c897243abb">&#9670;&nbsp;</a></span>recursively_clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the user index of this object and all of its descendants. The same holds as said for the <a class="el" href="classTriaAccessor.html#a309ae29be30ad5a259b1cd942e7d9e9d">recursively_set_user_index()</a> function.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="af0e85725edb5d2bb43da61796f2fbbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e85725edb5d2bb43da61796f2fbbb9">&#9670;&nbsp;</a></span>diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::diameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Diameter of the object.</p>
<p>The diameter of an object is computed to be the largest diagonal. This is not necessarily the true diameter for objects that may use higher order mappings, but completely sufficient for most computations. </p>

</div>
</div>
<a id="a49a088728d7acb727fdc13bb6664d91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a088728d7acb727fdc13bb6664d91a">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of an object in the direction of the given axis, specified in the local coordinate system. See the documentation of <a class="el" href="structGeometryInfo.html">GeometryInfo</a> for the meaning and enumeration of the local axes.</p>
<p>Note that the "length" of an object can be interpreted in a variety of ways. Here, we choose it as the maximal length of any of the edges of the object that are parallel to the chosen axis on the reference cell. </p>

</div>
</div>
<a id="a99b268c743742c3c9ab159ff916d9236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b268c743742c3c9ab159ff916d9236">&#9670;&nbsp;</a></span>minimum_vertex_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::minimum_vertex_distance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the minimal distance between any two vertices. </p>

</div>
</div>
<a id="a49df04630565a833e168e9cab074305e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49df04630565a833e168e9cab074305e">&#9670;&nbsp;</a></span>intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinates</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a point belonging to the Manifold&lt;dim,spacedim&gt; where this object lives, given its parametric coordinates on the reference <code>structdim</code> cell. This function queries the underlying manifold object, and can be used to obtain the exact geometrical location of arbitrary points on this object.</p>
<p>Notice that the argument <code>coordinates</code> are the coordinates on the <em>reference cell</em>, given in reference coordinates. In other words, the argument provides a weighting between the different vertices. For example, for lines, calling this function with argument Point&lt;1&gt;(.5), is equivalent to asking the line for its center. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01206">1206</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a3213234c2c543ba86eb71c716c917972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3213234c2c543ba86eb71c716c917972">&#9670;&nbsp;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::center </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>respect_manifold</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_laplace_transformation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Center of the object. The center of an object is defined to be the average of the locations of the vertices. If required, the user may ask this function to return the average of the point according to the underlying <a class="el" href="classManifold.html">Manifold</a> object, by setting to true the optional parameter <code>respect_manifold</code>.</p>
<p>When the geometry of a <a class="el" href="classTriaAccessor.html">TriaAccessor</a> is not flat, or when part of the bounding objects of this <a class="el" href="classTriaAccessor.html">TriaAccessor</a> are not flat, the result given by the <a class="el" href="classTriaAccessor.html#a3213234c2c543ba86eb71c716c917972">TriaAccessor::center()</a> function may not be accurate enough, even when parameter <code>respect_manifold</code> is set to true. If you find this to be case, than you can further refine the computation of the center by setting to true the second additional parameter <code>use_laplace_transformation</code>, which will force this function to compute the location of the center by solving a linear elasticity problem with Dirichlet boundary conditions set to the location of the bounding vertices and the centers of the bounding lines and quads. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01228">1228</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a56cc737f4b28f8d28a576d2e3d32ef9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cc737f4b28f8d28a576d2e3d32ef9f">&#9670;&nbsp;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::barycenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Barycenter of the object. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01091">1091</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a9cecb2b7c9a1644fb5fd44bbba40ab0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cecb2b7c9a1644fb5fd44bbba40ab0c">&#9670;&nbsp;</a></span>measure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::measure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the dim-dimensional measure of the object. For a dim-dimensional cell in dim-dimensional space, this equals its volume. On the other hand, for a 2d cell in 3d space, or if the current object pointed to is a 2d face of a 3d cell in 3d space, then the function computes the area the object occupies. For a one-dimensional object, return its length.</p>
<p>The function only computes the measure of cells, faces or edges assumed to be represented by (bi-/tri-)linear mappings. In other words, it only takes into account the locations of the vertices that bound the current object but not how the interior of the object may actually be mapped. In most simple cases, this is exactly what you want. However, for objects that are not "straight", e.g. 2d cells embedded in 3d space as part of a triangulation of a curved domain, two-dimensional faces of 3d cells that are not just parallelograms, or for faces that are at the boundary of a domain that is not just bounded by straight line segments or planes, this function only computes the dim-dimensional measure of a (bi-/tri-)linear interpolation of the "real" object as defined by the manifold or boundary object describing the real geometry of the object in question. If you want to consider the "real" geometry, you will need to compute the measure by integrating a function equal to one over the object, which after applying quadrature equals the summing the JxW values returned by the <a class="el" href="classFEValues.html">FEValues</a> or <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object you will want to use for the integral. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01103">1103</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a689c9bb532bb02e21d58eeabc83ef908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689c9bb532bb02e21d58eeabc83ef908">&#9670;&nbsp;</a></span>is_translation_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::is_translation_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the current object is a translation of the given argument.</p>
<dl class="section note"><dt>Note</dt><dd>For the purpose of a triangulation, cells, faces, etc are only characterized by their vertices. The current function therefore only compares the locations of vertices. For many practical applications, however, it is not only the vertices that determine whether one cell is a translation of another, but also how the cell is mapped from the reference cell to its location in real space. For example, if we are using higher order mappings, then not only do the vertices have to be translations of each other, but also the points along edges. In these questions, therefore, it would be appropriate to ask the mapping, not the current function, whether two objects are translations of each other. </dd></dl>

</div>
</div>
<a id="a09d81693979927a7a966ddc18d243978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d81693979927a7a966ddc18d243978">&#9670;&nbsp;</a></span>set_boundary_id_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_boundary_id_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like set_boundary_id but without checking for internal faces or invalid ids. </p>

</div>
</div>
<a id="a3f683af0ef327d821f91e70d4a720d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f683af0ef327d821f91e70d4a720d4f">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1Triangulation_1_1TriaObject.html">internal::Triangulation::TriaObject</a>&lt; structdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the data of the given object into the internal data structures of a triangulation. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01081">1081</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab1947e00bce29b9e766546feb3bbd2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1947e00bce29b9e766546feb3bbd2f4">&#9670;&nbsp;</a></span>set_line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the flag indicating, what <code><a class="el" href="classTriaAccessor.html#a08aaa41d4d6e0942d888efc21ca5d6c7">line_orientation()</a></code> will return.</p>
<p>It is only possible to set the line_orientation of faces in 3d (i.e. <code>structdim==2 &amp;&amp; dim==3</code>). </p>

</div>
</div>
<a id="a2d4e1cdc683814cbb505b66e088ded4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4e1cdc683814cbb505b66e088ded4f">&#9670;&nbsp;</a></span>set_face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether the quad with index <code>face</code> has its normal pointing in the standard direction (<code>true</code>) or whether it is the opposite (<code>false</code>). Which is the standard direction is documented with the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is only for internal use in the library. Setting this flag to any other value than the one that the triangulation has already set is bound to bring you disaster. </p>

</div>
</div>
<a id="a120f75f4b65a498bd55ceffe89db968b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120f75f4b65a498bd55ceffe89db968b">&#9670;&nbsp;</a></span>set_face_flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_face_flip </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the flag indicating, what <code><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip()</a></code> will return.</p>
<p>It is only possible to set the face_orientation of cells in 3d (i.e. <code>structdim==3 &amp;&amp; dim==3</code>). </p>

</div>
</div>
<a id="a2eac7c4a6195f66c016eeaef1283ada8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eac7c4a6195f66c016eeaef1283ada8">&#9670;&nbsp;</a></span>set_face_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_face_rotation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the flag indicating, what <code><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation()</a></code> will return.</p>
<p>It is only possible to set the face_orientation of cells in 3d (i.e. <code>structdim==3 &amp;&amp; dim==3</code>). </p>

</div>
</div>
<a id="a6bf46d7dd76ebe7b46e3e26d63859f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf46d7dd76ebe7b46e3e26d63859f0c">&#9670;&nbsp;</a></span>set_used_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_used_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <code>used</code> flag. Only for internal use in the library. </p>

</div>
</div>
<a id="a7983a80711bcde0ea9ec5f2cc95a935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7983a80711bcde0ea9ec5f2cc95a935c">&#9670;&nbsp;</a></span>clear_used_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_used_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the <code>used</code> flag. Only for internal use in the library. </p>

</div>
</div>
<a id="a928a0f17388d3e7377fb216a0ca204a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928a0f17388d3e7377fb216a0ca204a8">&#9670;&nbsp;</a></span>set_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_refinement_case </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_case</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <code>RefinementCase&lt;dim&gt;</code> this TriaObject is refined with. Not defined for <code>structdim=1</code> as lines are always refined resulting in 2 children lines (isotropic refinement).</p>
<p>You should know quite exactly what you are doing if you touch this function. It is exclusively for internal use in the library. </p>

</div>
</div>
<a id="af0d0e9691107c5f5ed5b5fa54c71e92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d0e9691107c5f5ed5b5fa54c71e92f">&#9670;&nbsp;</a></span>clear_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_refinement_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the RefinementCase&lt;dim&gt; of this TriaObject, i.e. reset it to <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase&lt;dim&gt;::no_refinement</a>.</p>
<p>You should know quite exactly what you are doing if you touch this function. It is exclusively for internal use in the library. </p>

</div>
</div>
<a id="aeee3827c653602a10ae243bfd26242eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee3827c653602a10ae243bfd26242eb">&#9670;&nbsp;</a></span>set_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_children </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the index of the ith child. Since the children come at least in pairs, we need to store the index of only every second child, i.e. of the even numbered children. Make sure, that the index of child i=0 is set first. Calling this function for odd numbered children is not allowed. </p>

</div>
</div>
<a id="a048a39a28d4f2a4490a71e2edc8cfc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048a39a28d4f2a4490a71e2edc8cfc3f">&#9670;&nbsp;</a></span>clear_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the child field, i.e. set it to a value which indicates that this cell has no children. </p>

</div>
</div>
<a id="a03744b658fb595893706e7a1a38ed49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03744b658fb595893706e7a1a38ed49f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. This is normally used in a context like <code>iterator a,b; *a=*b;</code>. Presumably, the intent here is to copy the object pointed to by <code>b</code> to the object pointed to by <code>a</code>. However, the result of dereferencing an iterator is not an object but an accessor; consequently, this operation is not useful for iterators on triangulations. We declare this function here private, thus it may not be used from outside. Furthermore it is not implemented and will give a linker error if used anyway. </p>

</div>
</div>
<a id="a1b363d9cf3b6911d41223c9ed5d82daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b363d9cf3b6911d41223c9ed5d82daa">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 2, 2, 2 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lines along x-axis, see <a class="el" href="structGeometryInfo.html">GeometryInfo</a></p>
<p>Lines along y-axis </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01133">1133</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a09623959e21c50be31d6e40b508c39b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09623959e21c50be31d6e40b508c39b4">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 2, 2, 3 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lines along x-axis, see <a class="el" href="structGeometryInfo.html">GeometryInfo</a></p>
<p>Lines along y-axis </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01146">1146</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a7f33cb96e76ff07eaf0052427907aeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f33cb96e76ff07eaf0052427907aeb3">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 3, 3, 3 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lines along x-axis, see <a class="el" href="structGeometryInfo.html">GeometryInfo</a></p>
<p>Lines along y-axis</p>
<p>Lines along z-axis </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01160">1160</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/grid/<a class="el" href="grid_2tria_8h_source.html">tria.h</a></li>
<li>deal.II/grid/<a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/grid/<a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
