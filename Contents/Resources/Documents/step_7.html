<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-7 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-7 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Verificationofcorrectness">Verification of correctness</a>
        <li><a href="#NonhomogeneousNeumannboundaryconditions">Non-homogeneous Neumann boundary conditions</a>
        <li><a href="#Anoteongoodprogrammingpractice">A note on good programming practice</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#TheHelmholtzsolverclass">The Helmholtz solver class</a>
        <li><a href="#TheHelmholtzProblemclassimplementation">The HelmholtzProblem class implementation</a>
      <ul>
        <li><a href="#HelmholtzProblemHelmholtzProblem">HelmholtzProblem::HelmholtzProblem</a>
        <li><a href="#HelmholtzProblemHelmholtzProblem">HelmholtzProblem::~HelmholtzProblem</a>
        <li><a href="#HelmholtzProblemsetup_system">HelmholtzProblem::setup_system</a>
        <li><a href="#HelmholtzProblemassemble_system">HelmholtzProblem::assemble_system</a>
        <li><a href="#HelmholtzProblemsolve">HelmholtzProblem::solve</a>
        <li><a href="#HelmholtzProblemrefine_grid">HelmholtzProblem::refine_grid</a>
        <li><a href="#HelmholtzProblemprocess_solution">HelmholtzProblem::process_solution</a>
        <li><a href="#HelmholtzProblemrun">HelmholtzProblem::run</a>
      <ul>
        <li><a href="#Outputofgraphicaldata">Output of graphical data</a>
        <li><a href="#Outputofconvergencetables">Output of convergence tables</a>
        <li><a href="#Furthertablemanipulations">Further table manipulations</a>
      </ul>
      </ul>
        <li><a href="#Mainfunction">Main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibleextensions"> Possible extensions </a>
      <ul>
        <li><a href="#HigherOrderElements"> Higher Order Elements </a>
        <li><a href="#ConvergenceComparison"> Convergence Comparison </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>In this program, we will mainly consider two aspects: </p><ol>
<li>
Verification of correctness of the program and generation of convergence tables; </li>
<li>
Non-homogeneous Neumann boundary conditions for the Helmholtz equation. </li>
</ol>
<p>Besides these topics, again a variety of improvements and tricks will be shown.</p>
<p><a class="anchor" id="Verificationofcorrectness"></a></p><h3>Verification of correctness</h3>
<p>There has probably never been a non-trivial finite element program that worked right from the start. It is therefore necessary to find ways to verify whether a computed solution is correct or not. Usually, this is done by choosing the set-up of a simulation in such a way that we know the exact continuous solution and evaluate the difference between continuous and computed discrete solution. If this difference converges to zero with the right order of convergence, this is already a good indication of correctness, although there may be other sources of error persisting which have only a small contribution to the total error or are of higher order. In the context of finite element simulations, this technique is often called the <em>Method of Manufactured Solution</em>.</p>
<p>In this example, we will not go into the theories of systematic software verification which is a very complicated problem. Rather we will demonstrate the tools which deal.II can offer in this respect. This is basically centered around the functionality of a single function, <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference()</a>. This function computes the difference between a given continuous function and a finite element field in various norms on each cell. At the time of writing this tutorial program, the norms this function can compute are the following, where <img class="formulaInl" alt="$u$" src="form_256.png"/> denotes the continuous function and <img class="formulaInl" alt="$u_h$" src="form_722.png"/> the finite element field, and <img class="formulaInl" alt="$K$" src="form_57.png"/> is an element of the triangulation: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} {\| u-u_h \|}_{L_1(K)} &amp;=&amp; \int_K |u-u_h| \; dx, \\ {\| u-u_h \|}_{L_2(K)} &amp;=&amp; \left( \int_K |u-u_h|^2 \; dx \right)^{1/2}, \\ {\| u-u_h \|}_{L_\infty(K)} &amp;=&amp; \max_{x \in K} |u(x) - u_h(x)|, \\ {| u-u_h |}_{H^1(K)} &amp;=&amp; \left( \int_K |\nabla(u-u_h)|^2 \; dx \right)^{1/2}, \\ {\| u-u_h \|}_{H^1(K)} &amp;=&amp; \left( {\| u-u_h \|}^2_{L_2(K)} +{| u-u_h |}^2_{H^1(K)} \right)^{1/2}. \end{eqnarray*}" src="form_4162.png"/>
</p>
<p> (All these norms and semi-norms can also be evaluated with weighting functions, for example in order to exclude singularities from the determination of the global error, and the function also works for vector-valued functions.) Of course, like with any other integral, we can only evaluate these norms using quadrature formulas; the choice of the right quadrature formula is therefore crucial to the accurate evaluation of the error. This holds in particular for the <img class="formulaInl" alt="$L_\infty$" src="form_1197.png"/> norm, where we evaluate the maximal deviation of numerical and exact solution only at the quadrature points; one should then not try to use a quadrature rule with points only at points where super-convergence might occur, such as the Gauss points of the lowest-order Gauss quadrature formula for which the integrals in the assembly of the matrix is correct (e.g., for linear elements, do not use the <a class="el" href="classQGauss.html">QGauss(2)</a> quadrature formula). In fact, this is generally good advice also for the other norms: if your quadrature points are fortuitously chosen at locations where the error happens to be particularly small due to superconvergence, the computed error will look like it is much smaller than it really is and may even suggest a higher convergence order. Consequently, we will choose a different quadrature formula for the integration of these error norms than for the assembly of the linear system.</p>
<p>The function <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference()</a> evaluates the desired norm on each cell <img class="formulaInl" alt="$K$" src="form_57.png"/> of the triangulation and returns a vector which holds these values for each cell. From the local values, we can then obtain the global error. For example, if the vector <img class="formulaInl" alt="$(e_i)$" src="form_4163.png"/> contains the local <img class="formulaInl" alt="$L_2$" src="form_608.png"/> norms, then </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \| {\mathbf e} \| = \left( \sum_i e_i^2 \right)^{1/2} \]" src="form_4164.png"/>
</p>
<p> is the global <img class="formulaInl" alt="$L_2$" src="form_608.png"/> error.</p>
<p>In the program, we will show how to evaluate and use these quantities, and we will monitor their values under mesh refinement. Of course, we have to choose the problem at hand such that we can explicitly state the solution and its derivatives, but since we want to evaluate the correctness of the program, this is only reasonable. If we know that the program produces the correct solution for one (or, if one wants to be really sure: many) specifically chosen right hand sides, we can be rather confident that it will also compute the correct solution for problems where we don't know the exact values.</p>
<p>In addition to simply computing these quantities, we will show how to generate nicely formatted tables from the data generated by this program that automatically computes convergence rates etc. In addition, we will compare different strategies for mesh refinement.</p>
<p><a class="anchor" id="NonhomogeneousNeumannboundaryconditions"></a></p><h3>Non-homogeneous Neumann boundary conditions</h3>
<p>The second, totally unrelated, subject of this example program is the use of non-homogeneous boundary conditions. These are included into the variational form using boundary integrals which we have to evaluate numerically when assembling the right hand side vector.</p>
<p>Before we go into programming, let's have a brief look at the mathematical formulation. The equation that we want to solve here is the Helmholtz equation "with the nice sign": </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\Delta u + u = f, \]" src="form_4165.png"/>
</p>
<p> on the square <img class="formulaInl" alt="$[-1,1]^2$" src="form_1961.png"/>, augmented by boundary conditions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u = g_1 \]" src="form_4166.png"/>
</p>
<p> on some part <img class="formulaInl" alt="$\Gamma_1$" src="form_2405.png"/> of the boundary <img class="formulaInl" alt="$\Gamma$" src="form_1193.png"/>, and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\mathbf n}\cdot \nabla u = g_2 \]" src="form_4167.png"/>
</p>
<p> on the rest <img class="formulaInl" alt="$\Gamma_2 = \Gamma \backslash \Gamma_1$" src="form_4168.png"/>. In our particular testcase, we will use <img class="formulaInl" alt="$\Gamma_1=\Gamma \cap\{\{x=1\} \cup \{y=1\}\}$" src="form_4169.png"/>.</p>
<p>Because we want to verify the convergence of our numerical solution <img class="formulaInl" alt="$u_h$" src="form_722.png"/>, we want a setup so that we know the exact solution <img class="formulaInl" alt="$u$" src="form_256.png"/>. This is where the Method of Manufactured Solutions comes in. To this end, let us choose a function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \bar u(x) = \sum_{i=1}^3 \exp\left(-\frac{|x-x_i|^2}{\sigma^2}\right) \]" src="form_4170.png"/>
</p>
<p> where the centers <img class="formulaInl" alt="$x_i$" src="form_320.png"/> of the exponentials are <img class="formulaInl" alt="$x_1=(-\frac 12,\frac 12)$" src="form_4171.png"/>, <img class="formulaInl" alt="$x_2=(-\frac 12,-\frac 12)$" src="form_4172.png"/>, and <img class="formulaInl" alt="$x_3=(\frac 12,-\frac 12)$" src="form_4173.png"/>, and the half width is set to <img class="formulaInl" alt="$\sigma=\frac {1}{8}$" src="form_4174.png"/>. The method of manufactured solution then says: choose </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} f &amp;= -\Delta \bar u + \bar u, \\ g_1 &amp;= \bar u|_{\Gamma_1}, \\ g_2 &amp;= {\mathbf n}\cdot \nabla\bar u|_{\Gamma_2}. \end{align*}" src="form_4175.png"/>
</p>
<p> With this particular choice, we infer that of course the solution of the original problem happens to be <img class="formulaInl" alt="$u=\bar u$" src="form_4176.png"/>. In other words, by choosing the right hand sides of the equation and the boundary conditions in a particular way, we have manufactured ourselves a problem to which we know the solution. This allows us then to compute the error of our numerical solution. In the code below, we represent <img class="formulaInl" alt="$\bar u$" src="form_4177.png"/> by the <code>Solution</code> class, and other classes will be used to denote <img class="formulaInl" alt="$\bar u|_{\Gamma_1}$" src="form_4178.png"/> and <img class="formulaInl" alt="${\mathbf n}\cdot \nabla\bar u|_{\Gamma_2}$" src="form_4179.png"/>.</p>
<p>Using the above definitions, we can state the weak formulation of the equation, which reads: find <img class="formulaInl" alt="$u\in H^1_g=\{v\in H^1: v|_{\Gamma_1}=g_1\}$" src="form_4180.png"/> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {(\nabla u, \nabla v)}_\Omega + {(u,v)}_\Omega = {(f,v)}_\Omega + {(g_2,v)}_{\Gamma_2} \]" src="form_4181.png"/>
</p>
<p> for all test functions <img class="formulaInl" alt="$v\in H^1_0=\{v\in H^1: v|_{\Gamma_1}=0\}$" src="form_4182.png"/>. The boundary term <img class="formulaInl" alt="${(g_2,v)}_{\Gamma_2}$" src="form_4183.png"/> has appeared by integration by parts and using <img class="formulaInl" alt="$\partial_n u=g_2$" src="form_4184.png"/> on <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/> and <img class="formulaInl" alt="$v=0$" src="form_4185.png"/> on <img class="formulaInl" alt="$\Gamma_1$" src="form_2405.png"/>. The cell matrices and vectors which we use to build the global matrices and right hand side vectors in the discrete formulation therefore look like this: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} A_{ij}^K &amp;=&amp; \left(\nabla \varphi_i, \nabla \varphi_j\right)_K +\left(\varphi_i, \varphi_j\right)_K, \\ f_i^K &amp;=&amp; \left(f,\varphi_i\right)_K +\left(g_2, \varphi_i\right)_{\partial K\cap \Gamma_2}. \end{eqnarray*}" src="form_4186.png"/>
</p>
<p> Since the generation of the domain integrals has been shown in previous examples several times, only the generation of the contour integral is of interest here. It basically works along the following lines: for domain integrals we have the <code><a class="el" href="classFEValues.html">FEValues</a></code> class that provides values and gradients of the shape values, as well as Jacobian determinants and other information and specified quadrature points in the cell; likewise, there is a class <code><a class="el" href="classFEFaceValues.html">FEFaceValues</a></code> that performs these tasks for integrations on faces of cells. One provides it with a quadrature formula for a manifold with dimension one less than the dimension of the domain is, and the cell and the number of its face on which we want to perform the integration. The class will then compute the values, gradients, normal vectors, weights, etc. at the quadrature points on this face, which we can then use in the same way as for the domain integrals. The details of how this is done are shown in the following program.</p>
<p><a class="anchor" id="Anoteongoodprogrammingpractice"></a></p><h3>A note on good programming practice</h3>
<p>Besides the mathematical topics outlined above, we also want to use this program to illustrate one aspect of good programming practice, namely the use of namespaces. In programming the deal.II library, we have take great care not to use names for classes and global functions that are overly generic, say <code>f(), sz(), rhs()</code> etc. Furthermore, we have put everything into namespace <code>dealii</code>. But when one writes application programs that aren't meant for others to use, one doesn't always pay this much attention. If you follow the programming style of <a class="el" href="step_1.html">step-1</a> through <a class="el" href="step_6.html">step-6</a>, these functions then end up in the global namespace where, unfortunately, a lot of other stuff also lives (basically everything the C language provides, along with everything you get from the operating system through header files). To make things a bit worse, the designers of the C language were also not always careful in avoiding generic names; for example, the symbols <code>j1, jn</code> are defined in C header files (they denote Bessel functions).</p>
<p>To avoid the problems that result if names of different functions or variables collide (often with confusing error messages), it is good practice to put everything you do into a <a href="http://en.wikipedia.org/wiki/Namespace_(computer_science)">namespace</a>. Following this style, we will open a namespace <code>Step7</code> at the top of the program, import the deal.II namespace into it, put everything that's specific to this program (with the exception of <code>main()</code>, which must be in the global namespace) into it, and only close it at the bottom of the file. In other words, the structure of the program is of the kind </p><div class="fragment"><div class="line">... #includes</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step7</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  ...everything to <span class="keywordflow">do</span> with the program...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  ...do whatever main() does...</div><div class="line">}</div></div><!-- fragment --><p> We will follow this scheme throughout the remainder of the deal.II tutorial. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>These first include files have all been treated in previous examples, so we won't explain what is in them again.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div></div><!-- fragment --><p>In this example, we will not use the numeration scheme which is used per default by the <a class="el" href="classDoFHandler.html">DoFHandler</a> class, but will renumber them using the Cuthill-McKee algorithm. As has already been explained in <a class="el" href="step_2.html">step-2</a>, the necessary functions are declared in the following file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div></div><!-- fragment --><p>Then we will show a little trick how we can make sure that objects are not deleted while they are still in use. For this purpose, deal.II has the <a class="el" href="classSmartPointer.html">SmartPointer</a> helper class, which is declared in this file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/smartpointer.h&gt;</span></div></div><!-- fragment --><p>Next, we will want to use the function <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference()</a> mentioned in the introduction, and we are going to use a <a class="el" href="classConvergenceTable.html">ConvergenceTable</a> that collects all important data during a run and prints it at the end as a table. These comes from the following two files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div></div><!-- fragment --><p>And finally, we need to use the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> class, which is declared in the same file as the <a class="el" href="classFEValues.html">FEValues</a> class:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>The last step before we go on with the actual implementation is to open a namespace <code>Step7</code> into which we will put everything, as discussed at the end of the introduction, and to import the members of namespace <code>dealii</code> into it:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step7</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before implementing the classes that actually solve something, we first declare and define some function classes that represent right hand side and solution classes. Since we want to compare the numerically obtained solution to the exact continuous one, we need a function object that represents the continuous solution. On the other hand, we need the right hand side function, and that one of course shares some characteristics with the solution. In order to reduce dependencies which arise if we have to change something in both classes at the same time, we move the common characteristics of both functions into a base class.</p>
<p>The common characteristics for solution (as explained in the introduction, we choose a sum of three exponentials) and right hand side, are these: the number of exponentials, their centers, and their half width. We declare them in the following class. Since the number of exponentials is a constant scalar integral quantity, C++ allows its definition (i.e. assigning a value) right at the place of declaration (i.e. where we declare that such a variable exists).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionBase</div><div class="line">{</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_source_centers = 3;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   source_centers[n_source_centers];</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>       width;</div><div class="line">};</div></div><!-- fragment --><p>The variables which denote the centers and the width of the exponentials have just been declared, now we still need to assign values to them. Here, we can show another small piece of template sorcery, namely how we can assign different values to these variables depending on the dimension. We will only use the 2d case in the program, but we show the 1d case for exposition of a useful technique.</p>
<p>First we assign values to the centers for the 1d case, where we place the centers equidistantly at -1/3, 0, and 1/3. The <code>template &lt;&gt;</code> header for this definition indicates an explicit specialization. This means, that the variable belongs to a template, but that instead of providing the compiler with a template from which it can specialize a concrete variable by substituting <code>dim</code> with some concrete value, we provide a specialization ourselves, in this case for <code>dim=1</code>. If the compiler then sees a reference to this variable in a place where the template argument equals one, it knows that it doesn't have to generate the variable from a template by substituting <code>dim</code>, but can immediately use the following definition:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers]</div><div class="line">  = { <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)</div><div class="line">    };</div></div><!-- fragment --><p>Likewise, we can provide an explicit specialization for <code>dim=2</code>. We place the centers for the 2d case as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers]</div><div class="line">  = { <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, -0.5),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5, -0.5)</div><div class="line">    };</div></div><!-- fragment --><p>There remains to assign a value to the half-width of the exponentials. We would like to use the same value for all dimensions. In this case, we simply provide the compiler with a template from which it can generate a concrete instantiation by substituting <code>dim</code> with a concrete value:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1./8.;</div></div><!-- fragment --><p>After declaring and defining the characteristics of solution and right hand side, we can declare the classes representing these two. They both represent continuous functions, so they are derived from the <a class="el" href="classFunction.html">Function</a>&lt;dim&gt; base class, and they also inherit the characteristics defined in the SolutionBase class.</p>
<p>The actual classes are declared in the following. Note that in order to compute the error of the numerical solution against the continuous one in the L2 and H1 (semi-)norms, we have to provide value and gradient of the exact solution. This is more than we have done in previous examples, where all we provided was the value at one or a list of points. Fortunately, the <a class="el" href="classFunction.html">Function</a> class also has virtual functions for the gradient, so we can simply overload the respective virtual member functions in the <a class="el" href="classFunction.html">Function</a> base class. Note that the gradient of a function in <code>dim</code> space dimensions is a vector of size <code>dim</code>, i.e. a tensor of rank 1 and dimension <code>dim</code>. As for so many other things, the library provides a suitable class for this. One new thing about this class is that it explicitly uses the <a class="el" href="classTensor.html">Tensor</a> objects, which previously appeared as intermediate terms in <a class="el" href="step_3.html">step-3</a> and <a class="el" href="step_4.html">step-4</a>. A tensor is a generalization of scalars (rank zero tensors), vectors (rank one tensors), and matrices (rank two tensors), as well as higher dimensional objects. The <a class="el" href="classTensor.html">Tensor</a> class requires two template arguments: the tensor rank and tensor dimension. For example, here we use tensors of rank one (vectors) with dimension <code>dim</code> (so they have <code>dim</code> entries.) While this is a bit less flexible than using <a class="el" href="classVector.html">Vector</a>, the compiler can generate faster code when the length of the vector is known at compile time. Additionally, specifying a <a class="el" href="classTensor.html">Tensor</a> of rank one and dimension <code>dim</code> guarantees that the tensor will have the right shape (since it is built into the type of the object itself), so the compiler can catch most size-related mistakes for us.</p>
<p>Like in <a class="el" href="step_4.html">step-4</a>, for compatibility with some compilers we explicitly declare the default constructor:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">  <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Solution () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> <a class="code" href="classFunction.html#ae0a836ba78787fed039c5a097bdda854">gradient</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>The actual definition of the values and gradients of the exact solution class is according to their mathematical definition and does not need much explanation.</p>
<p>The only thing that is worth mentioning is that if we access elements of a base class that is template dependent (in this case the elements of SolutionBase&lt;dim&gt;), then the C++ language forces us to write <code>this-&gt;n_source_centers</code> (for example). Note that the <code>this-&gt;</code> qualification is not necessary if the base class is not template dependent, and also that the gcc compilers prior to version 3.4 don't enforce this requirement of the C++ standard. The reason why this is necessary is complicated; some books on C++ may explain it, so if you are interested you can look it up under the phrase <code>two-stage (name) lookup</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Solution&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> return_value = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line">      return_value += std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                               (this-&gt;width * this-&gt;width));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>Likewise, this is the computation of the gradient of the solution. In order to accumulate the gradient from the contributions of the exponentials, we allocate an object <code>return_value</code> that denotes the mathematical quantity of a tensor of rank <code>1</code> and dimension <code>dim</code>. Its default constructor sets it to the vector containing only zeroes, so we need not explicitly care for its initialization.</p>
<p>Note that we could as well have taken the type of the object to be <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; instead of <a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;. Tensors of rank 1 and points are almost exchangeable, and have only very slightly different mathematical meanings. In fact, the <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; class is derived from the <a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt; class, which makes up for their mutual exchange ability. Their main difference is in what they logically mean: points are points in space, such as the location at which we want to evaluate a function (see the type of the first argument of this function for example). On the other hand, tensors of rank 1 share the same transformation properties, for example that they need to be rotated in a certain way when we change the coordinate system; however, they do not share the same connotation that points have and are only objects in a more abstract space than the one spanned by the coordinate directions. (In fact, gradients live in `reciprocal' space, since the dimension of their components is not that of a length, but of one over length).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> Solution&lt;dim&gt;::gradient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> return_value;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div></div><!-- fragment --><p>For the gradient, note that its direction is along (x-x_i), so we add up multiples of this distance vector, where the factor is given by the exponentials.</p>
<div class="fragment"><div class="line">      return_value += (-2 / (this-&gt;width * this-&gt;width) *</div><div class="line">                       std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                                (this-&gt;width * this-&gt;width)) *</div><div class="line">                       x_minus_xi);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>Besides the function that represents the exact solution, we also need a function which we can use as right hand side when assembling the linear system of discretized equations. This is accomplished using the following class and the following definition of its function. Note that here we only need the value of the function, not its gradients or higher derivatives.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">  <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>The value of the right hand side is given by the negative Laplacian of the solution plus the solution itself, since we wanted to solve Helmholtz's equation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> return_value = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div></div><!-- fragment --><p>The first contribution is the Laplacian:</p>
<div class="fragment"><div class="line">return_value += ((2*dim - 4*x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>()/</div><div class="line">                  (this-&gt;width * this-&gt;width)) /</div><div class="line">                 (this-&gt;width * this-&gt;width) *</div><div class="line">                 std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                          (this-&gt;width * this-&gt;width)));</div></div><!-- fragment --><p>And the second is the solution itself:</p>
<div class="fragment"><div class="line">      return_value += std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                               (this-&gt;width * this-&gt;width));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheHelmholtzsolverclass"></a> </p><h3>The Helmholtz solver class</h3>
<p>Then we need the class that does all the work. Except for its name, its interface is mostly the same as in previous examples.</p>
<p>One of the differences is that we will use this class in several modes: for different finite elements, as well as for adaptive and global refinement. The decision whether global or adaptive refinement shall be used is communicated to the constructor of this class through an enumeration type declared at the top of the class. The constructor then takes a finite element object and the refinement mode as arguments.</p>
<p>The rest of the member functions are as before except for the <code>process_solution</code> function: After the solution has been computed, we perform some analysis on it, such as computing the error in various norms. To enable some output, it requires the number of the refinement cycle, and consequently gets it as an argument.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> RefinementMode</div><div class="line">  {</div><div class="line">    global_refinement, adaptive_refinement</div><div class="line">  };</div><div class="line"></div><div class="line">  HelmholtzProblem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                    <span class="keyword">const</span> RefinementMode      refinement_mode);</div><div class="line"></div><div class="line">  ~HelmholtzProblem ();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> refine_grid ();</div><div class="line">  <span class="keywordtype">void</span> process_solution (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div></div><!-- fragment --><p>Now for the data elements of this class. Among the variables that we have already used in previous examples, only the finite element object differs: The finite elements which the objects of this class operate on are passed to the constructor of this class. It has to store a pointer to the finite element for the member functions to use. Now, for the present class there is no big deal in that, but since we want to show techniques rather than solutions in these programs, we will here point out a problem that often occurs &ndash; and of course the right solution as well.</p>
<p>Consider the following situation that occurs in all the example programs: we have a triangulation object, and we have a finite element object, and we also have an object of type <a class="el" href="classDoFHandler.html">DoFHandler</a> that uses both of the first two. These three objects all have a lifetime that is rather long compared to most other objects: they are basically set at the beginning of the program or an outer loop, and they are destroyed at the very end. The question is: can we guarantee that the two objects which the <a class="el" href="classDoFHandler.html">DoFHandler</a> uses, live at least as long as they are in use? This means that the <a class="el" href="classDoFHandler.html">DoFHandler</a> must have some kind of lock on the destruction of the other objects, and it can only release this lock once it has cleared all active references to these objects. We have seen what happens if we violate this order of destruction in the previous example program: an exception is thrown that terminates the program in order to notify the programmer of this potentially dangerous state where an object is pointed to that no longer persists.</p>
<p>We will show here how the library managed to find out that there are still active references to an object. Basically, the method is along the following line: all objects that are subject to such potentially dangerous pointers are derived from a class called <a class="el" href="classSubscriptor.html">Subscriptor</a>. For example, the <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and a base class of the <a class="el" href="classFiniteElement.html">FiniteElement</a> class are derived from <a class="el" href="classSubscriptor.html">Subscriptor</a>. This latter class does not offer much functionality, but it has a built-in counter which we can subscribe to, thus the name of the class. Whenever we initialize a pointer to that object, we can increase its use counter, and when we move away our pointer or do not need it any more, we decrease the counter again. This way, we can always check how many objects still use that object.</p>
<p>On the other hand, if an object of a class that is derived from the <a class="el" href="classSubscriptor.html">Subscriptor</a> class is destroyed, it also has to call the destructor of the <a class="el" href="classSubscriptor.html">Subscriptor</a> class. In this destructor, there will then be a check whether the counter is really zero. If yes, then there are no active references to this object any more, and we can safely destroy it. If the counter is non-zero, however, then the destruction would result in stale and thus potentially dangerous pointers, and we rather throw an exception to alert the programmer that this is doing something dangerous and the program better be fixed.</p>
<p>While this certainly all sounds very well, it has some problems in terms of usability: what happens if I forget to increase the counter when I let a pointer point to such an object? And what happens if I forget to decrease it again? Note that this may lead to extremely difficult to find bugs, since the place where we have forgotten something may be far away from the place where the check for zeroness of the counter upon destruction actually fails. This kind of bug is rather annoying and usually very hard to fix.</p>
<p>The solution to this problem is to again use some C++ trickery: we create a class that acts just like a pointer, i.e. can be dereferenced, can be assigned to and from other pointers, and so on. This can be done by overloading the several dereferencing operators of that class. Within the constructors, destructors, and assignment operators of that class, we can however also manage increasing or decreasing the use counters of the objects we point to. Objects of that class therefore can be used just like ordinary pointers to objects, but they also serve to change the use counters of those objects without the need for the programmer to do so herself. The class that actually does all this is called <a class="el" href="classSmartPointer.html">SmartPointer</a> and takes as template parameter the data type of the object which it shall point to. The latter type may be any class, as long as it is derived from the <a class="el" href="classSubscriptor.html">Subscriptor</a> class.</p>
<p>In the present example program, we want to protect the finite element object from the situation that for some reason the finite element pointed to is destroyed while still in use. We therefore use a <a class="el" href="classSmartPointer.html">SmartPointer</a> to the finite element object; since the finite element object is actually never changed in our computations, we pass a const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; as template argument to the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. Note that the pointer so declared is assigned at construction time of the solve object, and destroyed upon destruction, so the lock on the destruction of the finite element object extends throughout the lifetime of this HelmholtzProblem object.</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>                      triangulation;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                         dof_handler;</div><div class="line"></div><div class="line"><a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a> &gt; fe;</div><div class="line"></div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                        hanging_node_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>                         sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>                    system_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>                          solution;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>                          system_rhs;</div></div><!-- fragment --><p>The second to last variable stores the refinement mode passed to the constructor. Since it is only set in the constructor, we can declare this variable constant, to avoid that someone sets it involuntarily (e.g. in an `if'-statement where == was written as = by chance).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> RefinementMode                    refinement_mode;</div></div><!-- fragment --><p>For each refinement level some data (like the number of cells, or the L2 error of the numerical solution) will be generated and later printed. The <a class="el" href="classTableHandler.html">TableHandler</a> can be used to collect all this data and to output it at the end of the run as a table in a simple text or in LaTeX format. Here we don't only use the <a class="el" href="classTableHandler.html">TableHandler</a> but we use the derived class <a class="el" href="classConvergenceTable.html">ConvergenceTable</a> that additionally evaluates rates of convergence:</p>
<div class="fragment"><div class="line">  <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>                        convergence_table;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheHelmholtzProblemclassimplementation"></a> </p><h3>The HelmholtzProblem class implementation</h3>
<p><a class="anchor" id="HelmholtzProblemHelmholtzProblem"></a> </p><h4>HelmholtzProblem::HelmholtzProblem</h4>
<p>In the constructor of this class, we only set the variables passed as arguments, and associate the DoF handler object with the triangulation (which is empty at present, however).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">HelmholtzProblem&lt;dim&gt;::HelmholtzProblem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                         <span class="keyword">const</span> RefinementMode refinement_mode) :</div><div class="line">  dof_handler (triangulation),</div><div class="line">  fe (&amp;fe),</div><div class="line">  refinement_mode (refinement_mode)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="HelmholtzProblemHelmholtzProblem"></a> </p><h4>HelmholtzProblem::~HelmholtzProblem</h4>
<p>This is no different than before:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">HelmholtzProblem&lt;dim&gt;::~HelmholtzProblem ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HelmholtzProblemsetup_system"></a> </p><h4>HelmholtzProblem::setup_system</h4>
<p>The following function sets up the degrees of freedom, sizes of matrices and vectors, etc. Most of its functionality has been showed in previous examples, the only difference being the renumbering step immediately after first distributing degrees of freedom.</p>
<p>Renumbering the degrees of freedom is not overly difficult, as long as you use one of the algorithms included in the library. It requires only a single line of code. Some more information on this can be found in <a class="el" href="step_2.html">step-2</a>.</p>
<p>Note, however, that when you renumber the degrees of freedom, you must do so immediately after distributing them, since such things as hanging nodes, the sparsity pattern etc. depend on the absolute numbers which are altered by renumbering.</p>
<p>The reason why we introduce renumbering here is that it is a relatively cheap operation but often has a beneficial effect: While the CG iteration itself is independent of the actual ordering of degrees of freedom, we will use SSOR as a preconditioner. SSOR goes through all degrees of freedom and does some operations that depend on what happened before; the SSOR operation is therefore not independent of the numbering of degrees of freedom, and it is known that its performance improves by using renumbering techniques. A little experiment shows that indeed, for example, the number of CG iterations for the fifth refinement cycle of adaptive refinement with the Q1 program used here is 40 without, but 36 with renumbering. Similar savings can generally be observed for all the computations in this program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (*fe);</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a> (dof_handler);</div><div class="line"></div><div class="line">  hanging_node_constraints.clear ();</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                           hanging_node_constraints);</div><div class="line">  hanging_node_constraints.close ();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">  hanging_node_constraints.condense (dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a> (dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HelmholtzProblemassemble_system"></a> </p><h4>HelmholtzProblem::assemble_system</h4>
<p>Assembling the system of equations for the problem at hand is mostly as for the example programs before. However, some things have changed anyway, so we comment on this function fairly extensively.</p>
<p>At the top of the function you will find the usual assortment of variable declarations. Compared to previous programs, of importance is only that we expect to solve problems also with bi-quadratic elements and therefore have to use sufficiently accurate quadrature formula. In addition, we need to compute integrals over faces, i.e. <code>dim-1</code> dimensional objects. The declaration of a face quadrature formula is then straightforward:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(3);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(3);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div></div><!-- fragment --><p>Then we need objects which can evaluate the values, gradients, etc of the shape functions at the quadrature points. While it seems that it should be feasible to do it with one object for both domain and face integrals, there is a subtle difference since the weights in the domain integrals include the measure of the cell in the domain, while the face integral quadrature requires the measure of the face in a lower-dimensional manifold. Internally these two classes are rooted in a common base class which does most of the work and offers the same interface to both domain and interface integrals.</p>
<p>For the domain integrals in the bilinear form for Helmholtz's equation, we need to compute the values and gradients, as well as the weights at the quadrature points. Furthermore, we need the quadrature points on the real cell (rather than on the unit cell) to evaluate the right hand side function. The object we use to get at this information is the <a class="el" href="classFEValues.html">FEValues</a> class discussed previously.</p>
<p>For the face integrals, we only need the values of the shape functions, as well as the weights. We also need the normal vectors and quadrature points on the real cell since we want to determine the Neumann values from the exact solution object (see below). The class that gives us this information is called <a class="el" href="classFEFaceValues.html">FEFaceValues</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>  fe_values (*fe, quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (*fe, face_quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>         | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>Then we need some objects already known from previous examples: An object denoting the right hand side function, its values at the quadrature points on a cell, the cell matrix and right hand side, and the indices of the degrees of freedom on a cell.</p>
<p>Note that the operations we will do with the right hand side object are only querying data, never changing the object. We can therefore declare it <code>const</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line">std::vector&lt;double&gt;  rhs_values (n_q_points);</div></div><!-- fragment --><p>Finally we define an object denoting the exact solution function. We will use it to compute the Neumann values at the boundary from it. Usually, one would of course do so using a separate object, in particular since the exact solution is generally unknown while the Neumann values are prescribed. We will, however, be a little bit lazy and use what we already have in information. Real-life programs would to go other ways here, of course.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Solution&lt;dim&gt; exact_solution;</div></div><!-- fragment --><p>Now for the main loop over all cells. This is mostly unchanged from previous examples, so we only comment on the things that have changed.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    cell_matrix = 0;</div><div class="line">    cell_rhs = 0;</div><div class="line"></div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">    right_hand_side.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                rhs_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div></div><!-- fragment --><p>The first thing that has changed is the bilinear form. It now contains the additional term from the Helmholtz equation:</p>
<div class="fragment"><div class="line">    cell_matrix(i,j) += ((fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point)</div><div class="line">                          +</div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point)) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">  cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                  rhs_values [q_point] *</div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">}</div></div><!-- fragment --><p>Then there is that second term on the right hand side, the contour integral. First we have to find out whether the intersection of the faces of this cell with the boundary part Gamma2 is nonzero. To this end, we loop over all faces and check whether its boundary indicator equals <code>1</code>, which is the value that we have assigned to that portions of the boundary composing Gamma2 in the <code>run()</code> function further below. (The default value of boundary indicators is <code>0</code>, so faces can only have an indicator equal to <code>1</code> if we have explicitly set it.)</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number=0; face_number&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_number)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face_number)-&gt;at_boundary()</div><div class="line">      &amp;&amp;</div><div class="line">      (cell-&gt;face(face_number)-&gt;boundary_id() == 1))</div><div class="line">    {</div></div><!-- fragment --><p>If we came into here, then we have found an external face belonging to Gamma2. Next, we have to compute the values of the shape functions and the other quantities which we will need for the computation of the contour integral. This is done using the <code>reinit</code> function which we already know from the FEValue class:</p>
<div class="fragment"><div class="line">fe_face_values.<a class="code" href="classFEFaceValues.html#af6e079ca7429d54433343d50bd334c3c">reinit</a> (cell, face_number);</div></div><!-- fragment --><p>And we can then perform the integration by using a loop over all quadrature points.</p>
<p>On each quadrature point, we first compute the value of the normal derivative. We do so using the gradient of the exact solution and the normal vector to the face at the present quadrature point obtained from the <code>fe_face_values</code> object. This is then used to compute the additional contribution of this face to the right hand side:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value</div><div class="line">        = (exact_solution.gradient (fe_face_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point)) *</div><div class="line">           fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q_point));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        cell_rhs(i) += (neumann_value *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                        fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now that we have the contributions of the present cell, we can transfer it to the global matrix and right hand side vector, as in the examples before:</p>
<div class="fragment"><div class="line">  cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">        system_matrix.add (local_dof_indices[i],</div><div class="line">                           local_dof_indices[j],</div><div class="line">                           cell_matrix(i,j));</div><div class="line"></div><div class="line">      system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Likewise, elimination and treatment of boundary values has been shown previously.</p>
<p>We note, however that now the boundary indicator for which we interpolate boundary values (denoted by the second parameter to <code>interpolate_boundary_values</code>) does not represent the whole boundary any more. Rather, it is that portion of the boundary which we have not assigned another indicator (see below). The degrees of freedom at the boundary that do not belong to Gamma1 are therefore excluded from the interpolation of boundary values, just as we want.</p>
<div class="fragment"><div class="line">  hanging_node_constraints.condense (system_matrix);</div><div class="line">  hanging_node_constraints.condense (system_rhs);</div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            Solution&lt;dim&gt;(),</div><div class="line">                                            boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      system_matrix,</div><div class="line">                                      solution,</div><div class="line">                                      system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HelmholtzProblemsolve"></a> </p><h4>HelmholtzProblem::solve</h4>
<p>Solving the system of equations is done in the same way as before:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  cg.solve (system_matrix, solution, system_rhs,</div><div class="line">            preconditioner);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute (solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HelmholtzProblemrefine_grid"></a> </p><h4>HelmholtzProblem::refine_grid</h4>
<p>Now for the function doing grid refinement. Depending on the refinement mode passed to the constructor, we do global or adaptive refinement.</p>
<p>Global refinement is simple, so there is not much to comment on. In case of adaptive refinement, we use the same functions and classes as in the previous example program. Note that one could treat Neumann boundaries differently than Dirichlet boundaries, and one should in fact do so here since we have Neumann boundary conditions on part of the boundaries, but since we don't have a function here that describes the Neumann values (we only construct these values from the exact solution when assembling the matrix), we omit this detail even though doing this in a strictly correct way would not be hard to add.</p>
<p>At the end of the switch, we have a default case that looks slightly strange: an <code>Assert</code> statement with a <code>false</code> condition. Since the <code>Assert</code> macro raises an error whenever the condition is false, this means that whenever we hit this statement the program will be aborted. This in intentional: Right now we have only implemented two refinement strategies (global and adaptive), but someone might want to add a third strategy (for example adaptivity with a different refinement criterion) and add a third member to the enumeration that determines the refinement mode. If it weren't for the default case of the switch statement, this function would simply run to its end without doing anything. This is most likely not what was intended. One of the defensive programming techniques that you will find all over the deal.II library is therefore to always have default cases that abort, to make sure that values not considered when listing the cases in the switch statement are eventually caught, and forcing programmers to add code to handle them. We will use this same technique in other places further down as well.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::refine_grid ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> global_refinement:</div><div class="line">    {</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (1);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">    {</div><div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                          <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(3),</div><div class="line">                                          <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                          solution,</div><div class="line">                                          estimated_error_per_cell);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                       estimated_error_per_cell,</div><div class="line">                                                       0.3, 0.03);</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line"></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HelmholtzProblemprocess_solution"></a> </p><h4>HelmholtzProblem::process_solution</h4>
<p>Finally we want to process the solution after it has been computed. For this, we integrate the error in various (semi-)norms, and we generate tables that will later be used to display the convergence against the continuous solution in a nice format.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::process_solution (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div></div><!-- fragment --><p>Our first task is to compute error norms. In order to integrate the difference between computed numerical solution and the continuous solution (described by the Solution class defined at the top of this file), we first need a vector that will hold the norm of the error on each cell. Since accuracy with 16 digits is not so important for these quantities, we save some memory by using <code>float</code> instead of <code>double</code> values.</p>
<p>The next step is to use a function from the library which computes the error in the L2 norm on each cell. We have to pass it the DoF handler object, the vector holding the nodal values of the numerical solution, the continuous solution as a function object, the vector into which it shall place the norm of the error on each cell, a quadrature rule by which this norm shall be computed, and the type of norm to be used. Here, we use a Gauss formula with three points in each space direction, and compute the L2 norm.</p>
<p>Finally, we want to get the global L2 norm. This can of course be obtained by summing the squares of the norms on each cell, and taking the square root of that value. This is equivalent to taking the l2 (lower case <code>l</code>) norm of the vector of norms on each cell:</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler,</div><div class="line">                                   solution,</div><div class="line">                                   Solution&lt;dim&gt;(),</div><div class="line">                                   difference_per_cell,</div><div class="line">                                   <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                          difference_per_cell,</div><div class="line">                                                          <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div></div><!-- fragment --><p>By same procedure we get the H1 semi-norm. We re-use the <code>difference_per_cell</code> vector since it is no longer used after computing the <code>L2_error</code> variable above. The global <img class="formulaInl" alt="$H^1$" src="form_38.png"/> semi-norm error is then computed by taking the sum of squares of the errors on each individual cell, and then the square root of it &ndash; an operation that is conveniently performed by <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler,</div><div class="line">                                   solution,</div><div class="line">                                   Solution&lt;dim&gt;(),</div><div class="line">                                   difference_per_cell,</div><div class="line">                                   <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> H1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                          difference_per_cell,</div><div class="line">                                                          <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div></div><!-- fragment --><p>Finally, we compute the maximum norm. Of course, we can't actually compute the true maximum, but only the maximum at the quadrature points. Since this depends quite sensitively on the quadrature rule being used, and since we would like to avoid false results due to super-convergence effects at some points, we use a special quadrature rule that is obtained by iterating the trapezoidal rule five times in each space direction. Note that the constructor of the <a class="el" href="classQIterated.html">QIterated</a> class takes a one-dimensional quadrature rule and a number that tells it how often it shall use this rule in each space direction.</p>
<p>Using this special quadrature rule, we can then try to find the maximal error on each cell. Finally, we compute the global L infinity error from the L infinity errors on each cell with a call to <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>     q_trapez;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> q_iterated (q_trapez, 5);</div><div class="line"><a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler,</div><div class="line">                                   solution,</div><div class="line">                                   Solution&lt;dim&gt;(),</div><div class="line">                                   difference_per_cell,</div><div class="line">                                   q_iterated,</div><div class="line">                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> Linfty_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                            difference_per_cell,</div><div class="line">                            <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div></div><!-- fragment --><p>After all these errors have been computed, we finally write some output. In addition, we add the important data to the <a class="el" href="classTableHandler.html">TableHandler</a> by specifying the key of the column and the value. Note that it is not necessary to define column keys beforehand &ndash; it is sufficient to just add values, and columns will be introduced into the table in the order values are added the first time.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells=triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs=dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span></div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">            &lt;&lt; n_active_cells</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; n_dofs</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cycle&quot;</span>, cycle);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, n_active_cells);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, n_dofs);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;L2&quot;</span>, L2_error);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;H1&quot;</span>, H1_error);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;Linfty&quot;</span>, Linfty_error);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HelmholtzProblemrun"></a> </p><h4>HelmholtzProblem::run</h4>
<p>As in previous example programs, the <code>run</code> function controls the flow of execution. The basic layout is as in previous examples: an outer loop over successively refined grids, and in this loop first problem setup, assembling the linear system, solution, and post-processing.</p>
<p>The first task in the main loop is creation and refinement of grids. This is as in previous examples, with the only difference that we want to have part of the boundary marked as Neumann type, rather than Dirichlet.</p>
<p>For this, we will use the following convention: Faces belonging to Gamma1 will have the boundary indicator <code>0</code> (which is the default, so we don't have to set it explicitly), and faces belonging to Gamma2 will use <code>1</code> as boundary indicator. To set these values, we loop over all cells, then over all faces of a given cell, check whether it is part of the boundary that we want to denote by Gamma2, and if so set its boundary indicator to <code>1</code>. For the present program, we consider the left and bottom boundaries as Gamma2. We determine whether a face is part of that boundary by asking whether the x or y coordinates (i.e. vector components 0 and 1) of the midpoint of a face equals -1, up to some small wiggle room that we have to give since it is instable to compare floating point numbers that are subject to round off in intermediate computations.</p>
<p>It is worth noting that we have to loop over all cells here, not only the active ones. The reason is that upon refinement, newly created faces inherit the boundary indicator of their parent face. If we now only set the boundary indicator for active faces, coarsen some cells and refine them later on, they will again have the boundary indicator of the parent cell which we have not modified, instead of the one we intended. Consequently, we have to change the boundary indicators of faces of all cells on Gamma2, whether they are active or not. Alternatively, we could of course have done this job on the coarsest mesh (i.e. before the first refinement step) and refined the mesh only after that.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = (refinement_mode==global_refinement)?5:9;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;n_cycles; ++cycle)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">          triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div><div class="line"></div><div class="line">          <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line">          cell = triangulation.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a> (),</div><div class="line">          endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">          <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number=0;</div><div class="line">                 face_number&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">                 ++face_number)</div><div class="line">              <span class="keywordflow">if</span> ((std::fabs(cell-&gt;face(face_number)-&gt;center()(0) - (-1)) &lt; 1e-12)</div><div class="line">                  ||</div><div class="line">                  (std::fabs(cell-&gt;face(face_number)-&gt;center()(1) - (-1)) &lt; 1e-12))</div><div class="line">                cell-&gt;face(face_number)-&gt;set_boundary_id (1);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        refine_grid ();</div></div><!-- fragment --><p>The next steps are already known from previous examples. This is mostly the basic set-up of every finite element program:</p>
<div class="fragment"><div class="line">setup_system ();</div><div class="line"></div><div class="line">assemble_system ();</div><div class="line">solve ();</div></div><!-- fragment --><p>The last step in this chain of function calls is usually the evaluation of the computed solution for the quantities one is interested in. This is done in the following function. Since the function generates output that indicates the number of the present refinement step, we pass this number as an argument.</p>
<div class="fragment"><div class="line">  process_solution (cycle);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Outputofgraphicaldata"></a> </p><h5>Output of graphical data</h5>
<p>After the last iteration we output the solution on the finest grid. This is done using the following sequence of statements which we have already discussed in previous examples. The first step is to generate a suitable filename (called <code>vtk_filename</code> here, since we want to output data in VTK format; we add the prefix to distinguish the filename from that used for other output files further down below). Here, we augment the name by the mesh refinement algorithm, and as above we make sure that we abort the program if another refinement method is added and not handled by the following switch statement:</p>
<div class="fragment"><div class="line">std::string vtk_filename;</div><div class="line"><span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">  {</div><div class="line">  <span class="keywordflow">case</span> global_refinement:</div><div class="line">    vtk_filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">    vtk_filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">default</span>:</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div></div><!-- fragment --><p>We augment the filename by a postfix denoting the finite element which we have used in the computation. To this end, the finite element base class stores the maximal polynomial degree of shape functions in each coordinate variable as a variable <code>degree</code>, and we use for the switch statement (note that the polynomial degree of bilinear shape functions is really 2, since they contain the term <code>x*y</code>; however, the polynomial degree in each coordinate variable is still only 1). We again use the same defensive programming technique to safeguard against the case that the polynomial degree has an unexpected value, using the <code>Assert (false, <a class="el" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented()</a>)</code> idiom in the default branch of the switch statement:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>)</div><div class="line">  {</div><div class="line">  <span class="keywordflow">case</span> 1:</div><div class="line">    vtk_filename += <span class="stringliteral">&quot;-q1&quot;</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> 2:</div><div class="line">    vtk_filename += <span class="stringliteral">&quot;-q2&quot;</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">default</span>:</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div></div><!-- fragment --><p>Once we have the base name for the output file, we add an extension appropriate for VTK output, open a file, and add the solution vector to the object that will do the actual output:</p>
<div class="fragment"><div class="line">vtk_filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">std::ofstream output (vtk_filename.c_str());</div><div class="line"></div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">data_out.add_data_vector (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div></div><!-- fragment --><p>Now building the intermediate format as before is the next step. We introduce one more feature of deal.II here. The background is the following: in some of the runs of this function, we have used biquadratic finite elements. However, since almost all output formats only support bilinear data, the data is written only bilinear, and information is consequently lost. Of course, we can't change the format in which graphic programs accept their inputs, but we can write the data differently such that we more closely resemble the information available in the quadratic approximation. We can, for example, write each cell as four sub-cells with bilinear data each, such that we have nine data points for each cell in the triangulation. The graphic programs will, of course, display this data still only bilinear, but at least we have given some more of the information we have.</p>
<p>In order to allow writing more than one sub-cell per actual cell, the <code>build_patches</code> function accepts a parameter (the default is <code>1</code>, which is why you haven't seen this parameter in previous examples). This parameter denotes into how many sub-cells per space direction each cell shall be subdivided for output. For example, if you give <code>2</code>, this leads to 4 cells in 2D and 8 cells in 3D. For quadratic elements, two sub-cells per space direction is obviously the right choice, so this is what we choose. In general, for elements of polynomial order <code>q</code>, we use <code>q</code> subdivisions, and the order of the elements is determined in the same way as above.</p>
<p>With the intermediate format so generated, we can then actually write the graphical output:</p>
<div class="fragment"><div class="line">data_out.build_patches (fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">data_out.write_vtk (output);</div></div><!-- fragment --><p><a class="anchor" id="Outputofconvergencetables"></a> </p><h5>Output of convergence tables</h5>
<p>After graphical output, we would also like to generate tables from the error computations we have done in <code>process_solution</code>. There, we have filled a table object with the number of cells for each refinement step as well as the errors in different norms.</p>
<p>For a nicer textual output of this data, one may want to set the precision with which the values will be written upon output. We use 3 digits for this, which is usually sufficient for error norms. By default, data is written in fixed point notation. However, for columns one would like to see in scientific notation another function call sets the <code>scientific_flag</code> to <code>true</code>, leading to floating point representation of numbers.</p>
<div class="fragment"><div class="line">convergence_table.set_precision(<span class="stringliteral">&quot;L2&quot;</span>, 3);</div><div class="line">convergence_table.set_precision(<span class="stringliteral">&quot;H1&quot;</span>, 3);</div><div class="line">convergence_table.set_precision(<span class="stringliteral">&quot;Linfty&quot;</span>, 3);</div><div class="line"></div><div class="line">convergence_table.set_scientific(<span class="stringliteral">&quot;L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">convergence_table.set_scientific(<span class="stringliteral">&quot;H1&quot;</span>, <span class="keyword">true</span>);</div><div class="line">convergence_table.set_scientific(<span class="stringliteral">&quot;Linfty&quot;</span>, <span class="keyword">true</span>);</div></div><!-- fragment --><p>For the output of a table into a LaTeX file, the default captions of the columns are the keys given as argument to the <code>add_value</code> functions. To have TeX captions that differ from the default ones you can specify them by the following function calls. Note, that `\' is reduced to `\' by the compiler such that the real TeX caption is, e.g., ` <img class="formulaInl" alt="$L^\infty$" src="form_2795.png"/>-error'.</p>
<div class="fragment"><div class="line">convergence_table.set_tex_caption(<span class="stringliteral">&quot;cells&quot;</span>, <span class="stringliteral">&quot;\\# cells&quot;</span>);</div><div class="line">convergence_table.set_tex_caption(<span class="stringliteral">&quot;dofs&quot;</span>, <span class="stringliteral">&quot;\\# dofs&quot;</span>);</div><div class="line">convergence_table.set_tex_caption(<span class="stringliteral">&quot;L2&quot;</span>, <span class="stringliteral">&quot;L^2-error&quot;</span>);</div><div class="line">convergence_table.set_tex_caption(<span class="stringliteral">&quot;H1&quot;</span>, <span class="stringliteral">&quot;H^1-error&quot;</span>);</div><div class="line">convergence_table.set_tex_caption(<span class="stringliteral">&quot;Linfty&quot;</span>, <span class="stringliteral">&quot;L^\\infty-error&quot;</span>);</div></div><!-- fragment --><p>Finally, the default LaTeX format for each column of the table is `c' (centered). To specify a different (e.g. `right') one, the following function may be used:</p>
<div class="fragment"><div class="line">convergence_table.set_tex_format(<span class="stringliteral">&quot;cells&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">convergence_table.set_tex_format(<span class="stringliteral">&quot;dofs&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div></div><!-- fragment --><p>After this, we can finally write the table to the standard output stream <code>std::cout</code> (after one extra empty line, to make things look prettier). Note, that the output in text format is quite simple and that captions may not be printed directly above the specific columns.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; std::endl;</div><div class="line">convergence_table.write_text(std::cout);</div></div><!-- fragment --><p>The table can also be written into a LaTeX file. The (nicely) formatted table can be viewed at after calling `latex filename' and e.g. `xdvi filename', where filename is the name of the file to which we will write output now. We construct the file name in the same way as before, but with a different prefix "error":</p>
<div class="fragment"><div class="line">std::string error_filename = <span class="stringliteral">&quot;error&quot;</span>;</div><div class="line"><span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">  {</div><div class="line">  <span class="keywordflow">case</span> global_refinement:</div><div class="line">    error_filename += <span class="stringliteral">&quot;-global&quot;</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">    error_filename += <span class="stringliteral">&quot;-adaptive&quot;</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">default</span>:</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">switch</span> (fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>)</div><div class="line">  {</div><div class="line">  <span class="keywordflow">case</span> 1:</div><div class="line">    error_filename += <span class="stringliteral">&quot;-q1&quot;</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">case</span> 2:</div><div class="line">    error_filename += <span class="stringliteral">&quot;-q2&quot;</span>;</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  <span class="keywordflow">default</span>:</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line">error_filename += <span class="stringliteral">&quot;.tex&quot;</span>;</div><div class="line">std::ofstream error_table_file(error_filename.c_str());</div><div class="line"></div><div class="line">convergence_table.write_tex(error_table_file);</div></div><!-- fragment --><p><a class="anchor" id="Furthertablemanipulations"></a> </p><h5>Further table manipulations</h5>
<p>In case of global refinement, it might be of interest to also output the convergence rates. This may be done by the functionality the <a class="el" href="classConvergenceTable.html">ConvergenceTable</a> offers over the regular <a class="el" href="classTableHandler.html">TableHandler</a>. However, we do it only for global refinement, since for adaptive refinement the determination of something like an order of convergence is somewhat more involved. While we are at it, we also show a few other things that can be done with tables.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (refinement_mode==global_refinement)</div><div class="line">  {</div></div><!-- fragment --><p>The first thing is that one can group individual columns together to form so-called super columns. Essentially, the columns remain the same, but the ones that were grouped together will get a caption running across all columns in a group. For example, let's merge the "cycle" and "cells" columns into a super column named "n
   cells":</p>
<div class="fragment"><div class="line">convergence_table.add_column_to_supercolumn(<span class="stringliteral">&quot;cycle&quot;</span>, <span class="stringliteral">&quot;n cells&quot;</span>);</div><div class="line">convergence_table.add_column_to_supercolumn(<span class="stringliteral">&quot;cells&quot;</span>, <span class="stringliteral">&quot;n cells&quot;</span>);</div></div><!-- fragment --><p>Next, it isn't necessary to always output all columns, or in the order in which they were originally added during the run. Selecting and re-ordering the columns works as follows (note that this includes super columns):</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; new_order;</div><div class="line">new_order.push_back(<span class="stringliteral">&quot;n cells&quot;</span>);</div><div class="line">new_order.push_back(<span class="stringliteral">&quot;H1&quot;</span>);</div><div class="line">new_order.push_back(<span class="stringliteral">&quot;L2&quot;</span>);</div><div class="line">convergence_table.set_column_order (new_order);</div></div><!-- fragment --><p>For everything that happened to the <a class="el" href="classConvergenceTable.html">ConvergenceTable</a> until this point, it would have been sufficient to use a simple <a class="el" href="classTableHandler.html">TableHandler</a>. Indeed, the <a class="el" href="classConvergenceTable.html">ConvergenceTable</a> is derived from the <a class="el" href="classTableHandler.html">TableHandler</a> but it offers the additional functionality of automatically evaluating convergence rates. For example, here is how we can let the table compute reduction and convergence rates (convergence rates are the binary logarithm of the reduction rate):</p>
<div class="fragment"><div class="line">convergence_table</div><div class="line">.evaluate_convergence_rates(<span class="stringliteral">&quot;L2&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba7eb96994a8f6f2903e0d68ccae4c5a72">ConvergenceTable::reduction_rate</a>);</div><div class="line">convergence_table</div><div class="line">.evaluate_convergence_rates(<span class="stringliteral">&quot;L2&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">convergence_table</div><div class="line">.evaluate_convergence_rates(<span class="stringliteral">&quot;H1&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba7eb96994a8f6f2903e0d68ccae4c5a72">ConvergenceTable::reduction_rate</a>);</div><div class="line">convergence_table</div><div class="line">.evaluate_convergence_rates(<span class="stringliteral">&quot;H1&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div></div><!-- fragment --><p>Each of these function calls produces an additional column that is merged with the original column (in our example the `L2' and the `H1' column) to a supercolumn.</p>
<p>Finally, we want to write this convergence chart again, first to the screen and then, in LaTeX format, to disk. The filename is again constructed as above.</p>
<div class="fragment"><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">      convergence_table.write_text(std::cout);</div><div class="line"></div><div class="line">      std::string conv_filename = <span class="stringliteral">&quot;convergence&quot;</span>;</div><div class="line">      <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">        {</div><div class="line">        <span class="keywordflow">case</span> global_refinement:</div><div class="line">          conv_filename += <span class="stringliteral">&quot;-global&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">          conv_filename += <span class="stringliteral">&quot;-adaptive&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line">      <span class="keywordflow">switch</span> (fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>)</div><div class="line">        {</div><div class="line">        <span class="keywordflow">case</span> 1:</div><div class="line">          conv_filename += <span class="stringliteral">&quot;-q1&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          conv_filename += <span class="stringliteral">&quot;-q2&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line">      conv_filename += <span class="stringliteral">&quot;.tex&quot;</span>;</div><div class="line"></div><div class="line">      std::ofstream table_file(conv_filename.c_str());</div><div class="line">      convergence_table.write_tex(table_file);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The final step before going to <code>main()</code> is then to close the namespace <code>Step7</code> into which we have put everything we needed for this program:</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Mainfunction"></a> </p><h3>Main function</h3>
<p>The main function is mostly as before. The only difference is that we solve three times, once for Q1 and adaptive refinement, once for Q1 elements and global refinement, and once for Q2 elements and global refinement.</p>
<p>Since we instantiate several template classes below for two space dimensions, we make this more generic by declaring a constant at the beginning of the function denoting the number of space dimensions. If you want to run the program in 1d or 2d, you will then only have to change this one instance, rather than all uses below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step7;</div></div><!-- fragment --><p>Now for the three calls to the main class. Each call is blocked into curly braces in order to destroy the respective objects (i.e. the finite element and the HelmholtzProblem object) at the end of the block and before we go to the next run. This avoids conflicts with variable names, and also makes sure that memory is released immediately after one of the three runs has finished, and not only at the end of the <code>try</code> block.</p>
<div class="fragment"><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe(1);</div><div class="line">        HelmholtzProblem&lt;dim&gt;</div><div class="line">        helmholtz_problem_2d (fe, HelmholtzProblem&lt;dim&gt;::adaptive_refinement);</div><div class="line"></div><div class="line">        helmholtz_problem_2d.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe(1);</div><div class="line">        HelmholtzProblem&lt;dim&gt;</div><div class="line">        helmholtz_problem_2d (fe, HelmholtzProblem&lt;dim&gt;::global_refinement);</div><div class="line"></div><div class="line">        helmholtz_problem_2d.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q2 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe(2);</div><div class="line">        HelmholtzProblem&lt;dim&gt;</div><div class="line">        helmholtz_problem_2d (fe, HelmholtzProblem&lt;dim&gt;::global_refinement);</div><div class="line"></div><div class="line">        helmholtz_problem_2d.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q2 elements, adaptive refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe(2);</div><div class="line">        HelmholtzProblem&lt;dim&gt;</div><div class="line">        helmholtz_problem_2d (fe, HelmholtzProblem&lt;dim&gt;::adaptive_refinement);</div><div class="line"></div><div class="line">        helmholtz_problem_2d.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program generates two kinds of output. The first are the output files <code>solution-adaptive-q1.vtk</code>, <code>solution-global-q1.vtk</code>, and <code>solution-global-q2.vtk</code>. We show the latter in a 3d view here:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-7.solution.png"/>
</div>
<p>Secondly, the program writes tables not only to disk, but also to the screen while running. The output looks like the following (recall that columns labeled as "&lt;code&gt;H1&lt;/code&gt;" actually show the <img class="formulaInl" alt="$H^1$" src="form_38.png"/> <em>semi-</em>norm of the error, not the full <img class="formulaInl" alt="$H^1$" src="form_38.png"/> norm):</p>
<div class="fragment"><div class="line">examples/step-7&gt; make run</div><div class="line">Solving with Q1 elements, adaptive refinement</div><div class="line">=============================================</div><div class="line"></div><div class="line">Cycle 0:</div><div class="line">   Number of active cells:       64</div><div class="line">   Number of degrees of freedom: 81</div><div class="line">Cycle 1:</div><div class="line">   Number of active cells:       124</div><div class="line">   Number of degrees of freedom: 157</div><div class="line">Cycle 2:</div><div class="line">   Number of active cells:       280</div><div class="line">   Number of degrees of freedom: 341</div><div class="line">Cycle 3:</div><div class="line">   Number of active cells:       577</div><div class="line">   Number of degrees of freedom: 690</div><div class="line">Cycle 4:</div><div class="line">   Number of active cells:       1099</div><div class="line">   Number of degrees of freedom: 1264</div><div class="line">Cycle 5:</div><div class="line">   Number of active cells:       2191</div><div class="line">   Number of degrees of freedom: 2452</div><div class="line">Cycle 6:</div><div class="line">   Number of active cells:       4165</div><div class="line">   Number of degrees of freedom: 4510</div><div class="line">Cycle 7:</div><div class="line">   Number of active cells:       7915</div><div class="line">   Number of degrees of freedom: 8440</div><div class="line">Cycle 8:</div><div class="line">   Number of active cells:       15196</div><div class="line">   Number of degrees of freedom: 15912</div><div class="line"></div><div class="line">cycle cells dofs     <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        H1      Linfty   </div><div class="line">    0    64    81 1.576e-01 1.418e+00 2.707e-01 </div><div class="line">    1   124   157 4.285e-02 1.285e+00 1.469e-01 </div><div class="line">    2   280   341 1.593e-02 7.909e-01 8.034e-02 </div><div class="line">    3   577   690 9.359e-03 5.096e-01 2.784e-02 </div><div class="line">    4  1099  1264 2.865e-03 3.038e-01 9.822e-03 </div><div class="line">    5  2191  2452 1.480e-03 2.106e-01 5.679e-03 </div><div class="line">    6  4165  4510 6.907e-04 1.462e-01 2.338e-03 </div><div class="line">    7  7915  8440 4.743e-04 1.055e-01 1.442e-03 </div><div class="line">    8 15196 15912 1.920e-04 7.468e-02 7.259e-04 </div><div class="line"></div><div class="line">Solving with Q1 elements, global refinement</div><div class="line">===========================================</div><div class="line"></div><div class="line">Cycle 0:</div><div class="line">   Number of active cells:       64</div><div class="line">   Number of degrees of freedom: 81</div><div class="line">Cycle 1:</div><div class="line">   Number of active cells:       256</div><div class="line">   Number of degrees of freedom: 289</div><div class="line">Cycle 2:</div><div class="line">   Number of active cells:       1024</div><div class="line">   Number of degrees of freedom: 1089</div><div class="line">Cycle 3:</div><div class="line">   Number of active cells:       4096</div><div class="line">   Number of degrees of freedom: 4225</div><div class="line">Cycle 4:</div><div class="line">   Number of active cells:       16384</div><div class="line">   Number of degrees of freedom: 16641</div><div class="line"></div><div class="line">cycle cells dofs     <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        H1      Linfty   </div><div class="line">    0    64    81 1.576e-01 1.418e+00 2.707e-01 </div><div class="line">    1   256   289 4.280e-02 1.285e+00 1.444e-01 </div><div class="line">    2  1024  1089 1.352e-02 7.556e-01 7.772e-02 </div><div class="line">    3  4096  4225 3.423e-03 3.822e-01 2.332e-02 </div><div class="line">    4 16384 16641 8.586e-04 1.917e-01 6.097e-03 </div><div class="line"></div><div class="line">n cells         H1                  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>          </div><div class="line">0    64 1.418e+00    -    - 1.576e-01    -    - </div><div class="line">1   256 1.285e+00 1.10 0.14 4.280e-02 3.68 1.88 </div><div class="line">2  1024 7.556e-01 1.70 0.77 1.352e-02 3.17 1.66 </div><div class="line">3  4096 3.822e-01 1.98 0.98 3.423e-03 3.95 1.98 </div><div class="line">4 16384 1.917e-01 1.99 1.00 8.586e-04 3.99 2.00 </div><div class="line"></div><div class="line">Solving with Q2 elements, global refinement</div><div class="line">===========================================</div><div class="line"></div><div class="line">Cycle 0:</div><div class="line">   Number of active cells:       64</div><div class="line">   Number of degrees of freedom: 289</div><div class="line">Cycle 1:</div><div class="line">   Number of active cells:       256</div><div class="line">   Number of degrees of freedom: 1089</div><div class="line">Cycle 2:</div><div class="line">   Number of active cells:       1024</div><div class="line">   Number of degrees of freedom: 4225</div><div class="line">Cycle 3:</div><div class="line">   Number of active cells:       4096</div><div class="line">   Number of degrees of freedom: 16641</div><div class="line">Cycle 4:</div><div class="line">   Number of active cells:       16384</div><div class="line">   Number of degrees of freedom: 66049</div><div class="line"></div><div class="line">cycle cells dofs     <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        H1      Linfty   </div><div class="line">    0    64   289 1.606e-01 1.278e+00 3.029e-01 </div><div class="line">    1   256  1089 7.638e-03 5.248e-01 4.816e-02 </div><div class="line">    2  1024  4225 8.601e-04 1.086e-01 4.827e-03 </div><div class="line">    3  4096 16641 1.107e-04 2.756e-02 7.802e-04 </div><div class="line">    4 16384 66049 1.393e-05 6.915e-03 9.971e-05 </div><div class="line"></div><div class="line">n cells         H1                   <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>          </div><div class="line">0    64 1.278e+00    -    - 1.606e-01     -    - </div><div class="line">1   256 5.248e-01 2.43 1.28 7.638e-03 21.03 4.39 </div><div class="line">2  1024 1.086e-01 4.83 2.27 8.601e-04  8.88 3.15 </div><div class="line">3  4096 2.756e-02 3.94 1.98 1.107e-04  7.77 2.96 </div><div class="line">4 16384 6.915e-03 3.99 1.99 1.393e-05  7.94 2.99 </div><div class="line"></div><div class="line">Solving with Q2 elements, adaptive refinement</div><div class="line">===========================================</div><div class="line"></div><div class="line">Cycle 0:</div><div class="line">   Number of active cells:       64</div><div class="line">   Number of degrees of freedom: 289</div><div class="line">Cycle 1:</div><div class="line">   Number of active cells:       124</div><div class="line">   Number of degrees of freedom: 577</div><div class="line">Cycle 2:</div><div class="line">   Number of active cells:       289</div><div class="line">   Number of degrees of freedom: 1353</div><div class="line">Cycle 3:</div><div class="line">   Number of active cells:       547</div><div class="line">   Number of degrees of freedom: 2531</div><div class="line">Cycle 4:</div><div class="line">   Number of active cells:       1057</div><div class="line">   Number of degrees of freedom: 4919</div><div class="line">Cycle 5:</div><div class="line">   Number of active cells:       2059</div><div class="line">   Number of degrees of freedom: 9223</div><div class="line">Cycle 6:</div><div class="line">   Number of active cells:       3913</div><div class="line">   Number of degrees of freedom: 17887</div><div class="line">Cycle 7:</div><div class="line">   Number of active cells:       7441</div><div class="line">   Number of degrees of freedom: 33807</div><div class="line">Cycle 8:</div><div class="line">   Number of active cells:       14212</div><div class="line">   Number of degrees of freedom: 64731</div><div class="line"></div><div class="line">cycle cells dofs     <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        H1      Linfty   </div><div class="line">    0    64   289 1.606e-01 1.278e+00 3.029e-01 </div><div class="line">    1   124   577 7.891e-03 5.256e-01 4.852e-02 </div><div class="line">    2   289  1353 1.070e-03 1.155e-01 4.868e-03 </div><div class="line">    3   547  2531 5.962e-04 5.101e-02 1.876e-03 </div><div class="line">    4  1057  4919 1.977e-04 3.094e-02 7.923e-04 </div><div class="line">    5  2059  9223 7.738e-05 1.974e-02 7.270e-04 </div><div class="line">    6  3913 17887 2.925e-05 8.772e-03 1.463e-04 </div><div class="line">    7  7441 33807 1.024e-05 4.121e-03 8.567e-05 </div><div class="line">    8 14212 64731 3.761e-06 2.108e-03 2.167e-05 </div></div><!-- fragment --><p>One can see the error reduction upon grid refinement, and for the cases where global refinement was performed, also the convergence rates can be seen. The linear and quadratic convergence rates of Q1 and Q2 elements in the <img class="formulaInl" alt="$H^1$" src="form_38.png"/> semi-norm can clearly be seen, as are the quadratic and cubic rates in the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> norm.</p>
<p>Finally, the program also generated LaTeX versions of the tables (not shown here).</p>
<p><a class="anchor" id="Possibleextensions"></a></p><h3>Possible extensions </h3>
<p><a class="anchor" id="HigherOrderElements"></a></p><h4>Higher Order Elements </h4>
<p>Go ahead and run the program with higher order elements (Q3, Q4, ...). You will notice that assertions in several parts of the code will trigger (for example in the generation of the filename for the data output). After fixing these you will not see the correct convergence orders that the theory predicts. This is because the orders for the quadrature formulas are hard-coded in this program and this order is not enough for higher order discretizations. What is a good way to pick the orders dynamically?</p>
<p><a class="anchor" id="ConvergenceComparison"></a></p><h4>Convergence Comparison </h4>
<p>Is Q1 or Q2 better? What about adaptive versus global refinement? A (somewhat unfair but typical) metric to compare them, is to look at the error as a function of the number of unknowns.</p>
<p>To see this, create a plot in log-log style with the number of unknowns on the x axis and the L2 error on the y axis. You can add reference lines for <img class="formulaInl" alt="$h^2=N^{-1}$" src="form_4187.png"/> and <img class="formulaInl" alt="$h^3=N^{-3/2}$" src="form_4188.png"/> and check that global and adaptive refinement follow those.</p>
<p>Note that changing the half width of the peaks influences if adaptive or global refinement is more efficient (if the solution is very smooth, local refinement does not give any advantage over global refinement). Verify this.</p>
<p>Finally, a more fair comparison would be to plot runtime (switch to release mode first!) instead of number of unknowns on the x axis. Picking a better linear solver might be appropriate though. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2000 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth and Ralf Hartmann, University of Heidelberg, 2000</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/smartpointer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step7</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SolutionBase</div><div class="line">  {</div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_source_centers = 3;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   source_centers[n_source_centers];</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>       width;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">  SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers]</div><div class="line">    = { <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">  SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers]</div><div class="line">    = { <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, -0.5),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5, -0.5)</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1./8.;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">    <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Solution () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> gradient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span> return_value = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line">        return_value += std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                                 (this-&gt;width * this-&gt;width));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> Solution&lt;dim&gt;::gradient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> return_value;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">        return_value += (-2 / (this-&gt;width * this-&gt;width) *</div><div class="line">                         std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                                  (this-&gt;width * this-&gt;width)) *</div><div class="line">                         x_minus_xi);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">    <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span> return_value = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">        return_value += ((2*dim - 4*x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>()/</div><div class="line">                          (this-&gt;width * this-&gt;width)) /</div><div class="line">                         (this-&gt;width * this-&gt;width) *</div><div class="line">                         std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                                  (this-&gt;width * this-&gt;width)));</div><div class="line">        return_value += std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                                 (this-&gt;width * this-&gt;width));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>HelmholtzProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> RefinementMode</div><div class="line">    {</div><div class="line">      global_refinement, adaptive_refinement</div><div class="line">    };</div><div class="line"></div><div class="line">    HelmholtzProblem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                      <span class="keyword">const</span> RefinementMode      refinement_mode);</div><div class="line"></div><div class="line">    ~HelmholtzProblem ();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> refine_grid ();</div><div class="line">    <span class="keywordtype">void</span> process_solution (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>                      triangulation;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                         dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a> &gt; fe;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                        hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                         sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>                    system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                          solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                          system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RefinementMode                    refinement_mode;</div><div class="line"></div><div class="line">    <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>                        convergence_table;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  HelmholtzProblem&lt;dim&gt;::HelmholtzProblem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                           <span class="keyword">const</span> RefinementMode refinement_mode) :</div><div class="line">    dof_handler (triangulation),</div><div class="line">    fe (&amp;fe),</div><div class="line">    refinement_mode (refinement_mode)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  HelmholtzProblem&lt;dim&gt;::~HelmholtzProblem ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (*fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a> (dof_handler);</div><div class="line"></div><div class="line">    hanging_node_constraints.clear ();</div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                             hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close ();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">    hanging_node_constraints.condense (dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a> (dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(3);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(3);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>  fe_values (*fe, quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (*fe, face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>         | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line">    std::vector&lt;double&gt;  rhs_values (n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Solution&lt;dim&gt; exact_solution;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        right_hand_side.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                    rhs_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                cell_matrix(i,j) += ((fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                      fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point)</div><div class="line">                                      +</div><div class="line">                                      fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                      fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point)) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                              rhs_values [q_point] *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number=0; face_number&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_number)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face_number)-&gt;at_boundary()</div><div class="line">              &amp;&amp;</div><div class="line">              (cell-&gt;face(face_number)-&gt;boundary_id() == 1))</div><div class="line">            {</div><div class="line">              fe_face_values.<a class="code" href="classFEFaceValues.html#af6e079ca7429d54433343d50bd334c3c">reinit</a> (cell, face_number);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value</div><div class="line">                    = (exact_solution.gradient (fe_face_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point)) *</div><div class="line">                       fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q_point));</div><div class="line"></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                    cell_rhs(i) += (neumann_value *</div><div class="line">                                    fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                    fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              system_matrix.add (local_dof_indices[i],</div><div class="line">                                 local_dof_indices[j],</div><div class="line">                                 cell_matrix(i,j));</div><div class="line"></div><div class="line">            system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense (system_matrix);</div><div class="line">    hanging_node_constraints.condense (system_rhs);</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              0,</div><div class="line">                                              Solution&lt;dim&gt;(),</div><div class="line">                                              boundary_values);</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                        system_matrix,</div><div class="line">                                        solution,</div><div class="line">                                        system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    cg.solve (system_matrix, solution, system_rhs,</div><div class="line">              preconditioner);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute (solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::refine_grid ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> global_refinement:</div><div class="line">      {</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (1);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">      {</div><div class="line">        <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">        <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(3),</div><div class="line">                                            <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                            solution,</div><div class="line">                                            estimated_error_per_cell);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                         estimated_error_per_cell,</div><div class="line">                                                         0.3, 0.03);</div><div class="line"></div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::process_solution (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler,</div><div class="line">                                       solution,</div><div class="line">                                       Solution&lt;dim&gt;(),</div><div class="line">                                       difference_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                              difference_per_cell,</div><div class="line">                                                              <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler,</div><div class="line">                                       solution,</div><div class="line">                                       Solution&lt;dim&gt;(),</div><div class="line">                                       difference_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(3),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> H1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                              difference_per_cell,</div><div class="line">                                                              <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>     q_trapez;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> q_iterated (q_trapez, 5);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler,</div><div class="line">                                       solution,</div><div class="line">                                       Solution&lt;dim&gt;(),</div><div class="line">                                       difference_per_cell,</div><div class="line">                                       q_iterated,</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> Linfty_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                difference_per_cell,</div><div class="line">                                <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells=triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs=dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span></div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; n_active_cells</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; n_dofs</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;cycle&quot;</span>, cycle);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, n_active_cells);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, n_dofs);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;L2&quot;</span>, L2_error);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;H1&quot;</span>, H1_error);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;Linfty&quot;</span>, Linfty_error);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HelmholtzProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles = (refinement_mode==global_refinement)?5:9;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;n_cycles; ++cycle)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div><div class="line"></div><div class="line">            <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line">            cell = triangulation.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a> (),</div><div class="line">            endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">            <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_number=0;</div><div class="line">                   face_number&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">                   ++face_number)</div><div class="line">                <span class="keywordflow">if</span> ((std::fabs(cell-&gt;face(face_number)-&gt;center()(0) - (-1)) &lt; 1e-12)</div><div class="line">                    ||</div><div class="line">                    (std::fabs(cell-&gt;face(face_number)-&gt;center()(1) - (-1)) &lt; 1e-12))</div><div class="line">                  cell-&gt;face(face_number)-&gt;set_boundary_id (1);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid ();</div><div class="line"></div><div class="line"></div><div class="line">        setup_system ();</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line">        solve ();</div><div class="line"></div><div class="line">        process_solution (cycle);</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    std::string vtk_filename;</div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> global_refinement:</div><div class="line">        vtk_filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">        vtk_filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 1:</div><div class="line">        vtk_filename += <span class="stringliteral">&quot;-q1&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        vtk_filename += <span class="stringliteral">&quot;-q2&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    vtk_filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::ofstream output (vtk_filename.c_str());</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.add_data_vector (solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    data_out.build_patches (fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    data_out.write_vtk (output);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;L2&quot;</span>, 3);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;H1&quot;</span>, 3);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;Linfty&quot;</span>, 3);</div><div class="line"></div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;H1&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;Linfty&quot;</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    convergence_table.set_tex_caption(<span class="stringliteral">&quot;cells&quot;</span>, <span class="stringliteral">&quot;\\# cells&quot;</span>);</div><div class="line">    convergence_table.set_tex_caption(<span class="stringliteral">&quot;dofs&quot;</span>, <span class="stringliteral">&quot;\\# dofs&quot;</span>);</div><div class="line">    convergence_table.set_tex_caption(<span class="stringliteral">&quot;L2&quot;</span>, <span class="stringliteral">&quot;@f$L^2@f$-error&quot;</span>);</div><div class="line">    convergence_table.set_tex_caption(<span class="stringliteral">&quot;H1&quot;</span>, <span class="stringliteral">&quot;@f$H^1@f$-error&quot;</span>);</div><div class="line">    convergence_table.set_tex_caption(<span class="stringliteral">&quot;Linfty&quot;</span>, <span class="stringliteral">&quot;@f$L^\\infty@f$-error&quot;</span>);</div><div class="line"></div><div class="line">    convergence_table.set_tex_format(<span class="stringliteral">&quot;cells&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">    convergence_table.set_tex_format(<span class="stringliteral">&quot;dofs&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    convergence_table.write_text(std::cout);</div><div class="line"></div><div class="line">    std::string error_filename = <span class="stringliteral">&quot;error&quot;</span>;</div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> global_refinement:</div><div class="line">        error_filename += <span class="stringliteral">&quot;-global&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">        error_filename += <span class="stringliteral">&quot;-adaptive&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 1:</div><div class="line">        error_filename += <span class="stringliteral">&quot;-q1&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        error_filename += <span class="stringliteral">&quot;-q2&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    error_filename += <span class="stringliteral">&quot;.tex&quot;</span>;</div><div class="line">    std::ofstream error_table_file(error_filename.c_str());</div><div class="line"></div><div class="line">    convergence_table.write_tex(error_table_file);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (refinement_mode==global_refinement)</div><div class="line">      {</div><div class="line">        convergence_table.add_column_to_supercolumn(<span class="stringliteral">&quot;cycle&quot;</span>, <span class="stringliteral">&quot;n cells&quot;</span>);</div><div class="line">        convergence_table.add_column_to_supercolumn(<span class="stringliteral">&quot;cells&quot;</span>, <span class="stringliteral">&quot;n cells&quot;</span>);</div><div class="line"></div><div class="line">        std::vector&lt;std::string&gt; new_order;</div><div class="line">        new_order.push_back(<span class="stringliteral">&quot;n cells&quot;</span>);</div><div class="line">        new_order.push_back(<span class="stringliteral">&quot;H1&quot;</span>);</div><div class="line">        new_order.push_back(<span class="stringliteral">&quot;L2&quot;</span>);</div><div class="line">        convergence_table.set_column_order (new_order);</div><div class="line"></div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;L2&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba7eb96994a8f6f2903e0d68ccae4c5a72">ConvergenceTable::reduction_rate</a>);</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;L2&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;H1&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba7eb96994a8f6f2903e0d68ccae4c5a72">ConvergenceTable::reduction_rate</a>);</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;H1&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        convergence_table.write_text(std::cout);</div><div class="line"></div><div class="line">        std::string conv_filename = <span class="stringliteral">&quot;convergence&quot;</span>;</div><div class="line">        <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">          {</div><div class="line">          <span class="keywordflow">case</span> global_refinement:</div><div class="line">            conv_filename += <span class="stringliteral">&quot;-global&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">            conv_filename += <span class="stringliteral">&quot;-adaptive&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">          }</div><div class="line">        <span class="keywordflow">switch</span> (fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>)</div><div class="line">          {</div><div class="line">          <span class="keywordflow">case</span> 1:</div><div class="line">            conv_filename += <span class="stringliteral">&quot;-q1&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">case</span> 2:</div><div class="line">            conv_filename += <span class="stringliteral">&quot;-q2&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">          }</div><div class="line">        conv_filename += <span class="stringliteral">&quot;.tex&quot;</span>;</div><div class="line"></div><div class="line">        std::ofstream table_file(conv_filename.c_str());</div><div class="line">        convergence_table.write_tex(table_file);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step7;</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe(1);</div><div class="line">        HelmholtzProblem&lt;dim&gt;</div><div class="line">        helmholtz_problem_2d (fe, HelmholtzProblem&lt;dim&gt;::adaptive_refinement);</div><div class="line"></div><div class="line">        helmholtz_problem_2d.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe(1);</div><div class="line">        HelmholtzProblem&lt;dim&gt;</div><div class="line">        helmholtz_problem_2d (fe, HelmholtzProblem&lt;dim&gt;::global_refinement);</div><div class="line"></div><div class="line">        helmholtz_problem_2d.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q2 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe(2);</div><div class="line">        HelmholtzProblem&lt;dim&gt;</div><div class="line">        helmholtz_problem_2d (fe, HelmholtzProblem&lt;dim&gt;::global_refinement);</div><div class="line"></div><div class="line">        helmholtz_problem_2d.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q2 elements, adaptive refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a> fe(2);</div><div class="line">        HelmholtzProblem&lt;dim&gt;</div><div class="line">        helmholtz_problem_2d (fe, HelmholtzProblem&lt;dim&gt;::adaptive_refinement);</div><div class="line"></div><div class="line">        helmholtz_problem_2d.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
