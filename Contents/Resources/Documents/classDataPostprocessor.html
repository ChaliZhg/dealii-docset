<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataPostprocessor&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classDataPostprocessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataPostprocessor&lt; dim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="data__postprocessor_8h_source.html">deal.II/numerics/data_postprocessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataPostprocessor&lt; dim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataPostprocessor__inherit__graph.svg" width="671" height="188"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8e39311050d10ffa14c14910a88bbd1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#ab8e39311050d10ffa14c14910a88bbd1">~DataPostprocessor</a> ()</td></tr>
<tr class="separator:ab8e39311050d10ffa14c14910a88bbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf197b51f7557e327888be579531750c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#acf197b51f7557e327888be579531750c">evaluate_scalar_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:acf197b51f7557e327888be579531750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d9f42d2d8acaeab94da23442632796"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#ae6d9f42d2d8acaeab94da23442632796">compute_derived_quantities_scalar</a> (const std::vector&lt; double &gt; &amp;solution_values, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;solution_gradients, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &amp;solution_hessians, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;normals, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;evaluation_points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;computed_quantities) const 1</td></tr>
<tr class="separator:ae6d9f42d2d8acaeab94da23442632796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac907e98f8f03ea7e6ac25237271dc7b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">evaluate_vector_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:ac907e98f8f03ea7e6ac25237271dc7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101f6d3ada722478f89136eec9cbd290"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a101f6d3ada722478f89136eec9cbd290">compute_derived_quantities_vector</a> (const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;solution_values, const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;solution_gradients, const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &gt; &amp;solution_hessians, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;normals, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;evaluation_points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;computed_quantities) const 1</td></tr>
<tr class="separator:a101f6d3ada722478f89136eec9cbd290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254f38bcdf4bdb5aa94231b695da7d55"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names</a> () const =0</td></tr>
<tr class="separator:a254f38bcdf4bdb5aa94231b695da7d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae994223acf8a16471ab5e579a4d75053"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">get_data_component_interpretation</a> () const</td></tr>
<tr class="separator:ae994223acf8a16471ab5e579a4d75053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadecdd040447b395164397ea1196f721"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags</a> () const =0</td></tr>
<tr class="separator:aadecdd040447b395164397ea1196f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br />
class DataPostprocessor&lt; dim &gt;</h3>

<p>This class provides an interface to compute derived quantities from a solution that can then be output in graphical formats for visualization, using facilities such as the <a class="el" href="classDataOut.html">DataOut</a> class.</p>
<p>For the (graphical) output of a FE solution one frequently wants to include derived quantities, which are calculated from the values of the solution and possibly the first and second derivatives of the solution. Examples are the calculation of Mach numbers from velocity and density in supersonic flow computations, or the computation of the magnitude of a complex-valued solution as demonstrated in <a class="el" href="step_29.html">step-29</a>. Other uses are shown in <a class="el" href="step_32.html">step-32</a> and <a class="el" href="step_33.html">step-33</a>. This class offers the interface to perform such postprocessing. Given the values and derivatives of the solution at those points where we want to generated output, the functions of this class can be overloaded to compute new quantities.</p>
<p>A data vector and an object of a class derived from the current one can be given to the <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut::add_data_vector()</a> function (and similarly for <a class="el" href="classDataOutRotation.html">DataOutRotation</a> and <a class="el" href="classDataOutFaces.html">DataOutFaces</a>). This will cause <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches()</a> to compute the derived quantities instead of using the data provided by the data vector (typically the solution vector). Note that the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object (i.e., in reality the object of your derived class) has to live until the <a class="el" href="classDataOut.html">DataOut</a> object is destroyed as the latter keeps a pointer to the former and will complain if the object pointed to is destroyed while the latter still has a pointer to it. If both the data postprocessor and <a class="el" href="classDataOut.html">DataOut</a> objects are local variables of a function (as they are, for example, in <a class="el" href="step_29.html">step-29</a>), then you can avoid this error by declaring the data postprocessor variable before the <a class="el" href="classDataOut.html">DataOut</a> variable as objects are destroyed in reverse order of declaration.</p>
<p>In order not to perform needless calculations, <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> has to provide information which input data is needed for the calculation of the derived quantities, i.e. whether it needs the values, the first derivative and/or the second derivative of the provided data. <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> objects which are used in combination with a <a class="el" href="classDataOutFaces.html">DataOutFaces</a> object can also ask for the normal vectors at each point. The information which data is needed has to be provided via the UpdateFlags returned by the virtual function <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags()</a>. It is your responsibility to use only those values which were updated in the calculation of derived quantities. The <a class="el" href="classDataOut.html">DataOut</a> object will provide references to the requested data in the call to <a class="el" href="classDataPostprocessor.html#acf197b51f7557e327888be579531750c">evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">evaluate_vector_field()</a> (<a class="el" href="classDataOut.html">DataOut</a> decides which of the two functions to call depending on whether the finite element in use has only a single, or multiple vector components; note that this is only determined by the number of components in the finite element in use, and not by whether the data computed by a class derived from the current one is scalar or vector valued).</p>
<p>Furthermore, derived classes have to implement the <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names()</a> function, where the number of output variables returned by the latter function has to match the size of the vector returned by the former. Furthermore, this number has to match the number of computed quantities, of course.</p>
<h3>Use in simpler cases</h3>
<p>Deriving from the current class allows to implement very general postprocessors. For example, in the <a class="el" href="step_32.html">step-32</a> program, we implement a postprocessor that takes a solution that consists of velocity, pressure and temperature (dim+2 components) and computes a variety of output quantities, some of which are vector valued and some of which are scalar. On the other hand, in <a class="el" href="step_29.html">step-29</a> we implement a postprocessor that only computes the magnitude of a complex number given by a two-component finite element. It seems silly to have to implement four virtual functions for this (<a class="el" href="classDataPostprocessor.html#acf197b51f7557e327888be579531750c">evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">evaluate_vector_field()</a>, <a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names()</a>, get_update_flags() and <a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">get_data_component_interpretation()</a>).</p>
<p>To this end there are two classes <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> and <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a> that are meant to be used if the output quantity is either a single scalar or a single vector (here used meaning to have exactly dim components). When using these classes, one only has to write a constructor that passes the name of the output variable and the update flags to the constructor of the base class and overload the function that actually computes the results.</p>
<dl class="section author"><dt>Author</dt><dd>Tobias Leicht, 2007, Wolfgang Bangerth, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8h_source.html#l00415">415</a> of file <a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab8e39311050d10ffa14c14910a88bbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e39311050d10ffa14c14910a88bbd1">&#9670;&nbsp;</a></span>~DataPostprocessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::~<a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. This function doesn't actually do anything but is marked as virtual to ensure that data postprocessors can be destroyed through pointers to the base class. </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00025">25</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf197b51f7557e327888be579531750c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf197b51f7557e327888be579531750c">&#9670;&nbsp;</a></span>evaluate_scalar_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_scalar_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the main function which actually performs the postprocessing. The second argument is a reference to the postprocessed data which already has correct size and must be filled by this function.</p>
<p>The function takes the values, gradients, and higher derivatives of the solution at all evaluation points, as well as other data such as the cell, via the first argument. Not all of the member vectors of this argument will be filled with data &ndash; in fact, derivatives and other quantities will only be contain valid data if the corresponding flags are returned by by an overloaded version of the <a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags()</a> function (implemented in a user's derived class). Otherwise those vectors will be in an unspecified state.</p>
<p>This function is called when the finite element field that is being converted into graphical data by <a class="el" href="classDataOut.html">DataOut</a> or similar classes represents scalar data, i.e. the finite element in use has only a single vector component. </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00033">33</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="ae6d9f42d2d8acaeab94da23442632796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d9f42d2d8acaeab94da23442632796">&#9670;&nbsp;</a></span>compute_derived_quantities_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::compute_derived_quantities_scalar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>evaluation_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000109">Deprecated:</a></b></dt><dd>This function is deprecated. It has been superseded by the <a class="el" href="classDataPostprocessor.html#acf197b51f7557e327888be579531750c">evaluate_scalar_field()</a> function that receives a superset of the information provided to the current function through the members of the structure it receives as the first argument.</dd></dl>
<p>If a user class derived from the current class (or from <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>) does not overload the function above, but instead overloads the current (legacy) form of the function, then the default implementation of the function above will simply call the current function. However, not all elements of the <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a> argument the function above receives have corresponding function arguments in the current function, and consequently not all information that function has available is passed on to the current one. In other words, there are pieces of information you may need in an implementation of a postprocess that are available if you overload the new form of this function above, but that are not available if you overload the old form of the function here. </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00054">54</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="ac907e98f8f03ea7e6ac25237271dc7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac907e98f8f03ea7e6ac25237271dc7b7">&#9670;&nbsp;</a></span>evaluate_vector_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_vector_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the <a class="el" href="classDataPostprocessor.html#acf197b51f7557e327888be579531750c">evaluate_scalar_field()</a> function, but this function is called when the original data vector represents vector data, i.e. the finite element in use has multiple vector components. </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00070">70</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a101f6d3ada722478f89136eec9cbd290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101f6d3ada722478f89136eec9cbd290">&#9670;&nbsp;</a></span>compute_derived_quantities_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::compute_derived_quantities_vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>evaluation_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000110">Deprecated:</a></b></dt><dd>This function is deprecated. It has been superseded by the <a class="el" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">evaluate_vector_field()</a> function that receives a superset of the information provided to the current function through the members of the structure it receives as the first argument.</dd></dl>
<p>If a user class derived from the current class (or from <a class="el" href="classDataPostprocessorVector.html">DataPostprocessorVector</a>) does not overload the function above, but instead overloads the current (legacy) form of the function, then the default implementation of the function above will simply call the current function. However, not all elements of the <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a> argument the function above receives have corresponding function arguments in the current function, and consequently not all information that function has available is passed on to the current one. In other words, there are pieces of information you may need in an implementation of a postprocess that are available if you overload the new form of this function above, but that are not available if you overload the old form of the function here. </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00091">91</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a254f38bcdf4bdb5aa94231b695da7d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254f38bcdf4bdb5aa94231b695da7d55">&#9670;&nbsp;</a></span>get_names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::get_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the vector of strings describing the names of the computed quantities. </p>

<p>Implemented in <a class="el" href="classDataPostprocessorVector.html#a108eb72fc6f9a7a14ae8e5324d3045a7">DataPostprocessorVector&lt; dim &gt;</a>, and <a class="el" href="classDataPostprocessorScalar.html#a613f39264c82cb3ec631657a6cbc19a6">DataPostprocessorScalar&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="ae994223acf8a16471ab5e579a4d75053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae994223acf8a16471ab5e579a4d75053">&#9670;&nbsp;</a></span>get_data_component_interpretation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::get_data_component_interpretation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This functions returns information about how the individual components of output files that consist of more than one data set are to be interpreted.</p>
<p>For example, if one has a finite element for the Stokes equations in 2d, representing components (u,v,p), one would like to indicate that the first two, u and v, represent a logical vector so that later on when we generate graphical output we can hand them off to a visualization program that will automatically know to render them as a vector field, rather than as two separate and independent scalar fields.</p>
<p>The default implementation of this function returns a vector of values <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>, indicating that all output components are independent scalar fields. However, if a derived class produces data that represents vectors, it may return a vector that contains values <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>. In the example above, one would return a vector with components (<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>) for (u,v,p). </p>

<p>Reimplemented in <a class="el" href="classDataPostprocessorVector.html#a3376758a383d2e137b8ef60f959ff200">DataPostprocessorVector&lt; dim &gt;</a>, and <a class="el" href="classDataPostprocessorScalar.html#aa367eb999bc40f7d15135cbe14c39e08">DataPostprocessorScalar&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00106">106</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="aadecdd040447b395164397ea1196f721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadecdd040447b395164397ea1196f721">&#9670;&nbsp;</a></span>get_needed_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::get_needed_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return, which data has to be provided to compute the derived quantities. This has to be a combination of <code>update_values</code>, <code>update_gradients</code> and <code>update_hessians</code>. If the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> is to be used in combination with <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, you may also ask for a update of normals via the <code>update_normal_vectors</code> flag. </p>

<p>Implemented in <a class="el" href="classDataPostprocessorVector.html#a9c2230b56791600666043036d815860a">DataPostprocessorVector&lt; dim &gt;</a>, and <a class="el" href="classDataPostprocessorScalar.html#a938ae46813aa3183f8181ab42e45403f">DataPostprocessorScalar&lt; dim &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/numerics/<a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/numerics/<a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
