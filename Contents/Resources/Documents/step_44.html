<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-44 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-44 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Listofreferences">List of references</a>
        <li><a href="#Notation"> Notation </a>
        <li><a href="#Kinematics">Kinematics</a>
        <li><a href="#Kinetics">Kinetics</a>
        <li><a href="#Pushforwardandpullbackoperators"> Push-forward and pull-back operators </a>
        <li><a href="#Hyperelasticmaterials">Hyperelastic materials</a>
      <ul>
        <li><a href="#NeoHookeanmaterials"> Neo-Hookean materials </a>
      </ul>
        <li><a href="#Elasticitytensors">Elasticity tensors</a>
        <li><a href="#Principleofstationarypotentialenergyandthethreefieldformulation">Principle of stationary potential energy and the three-field formulation</a>
        <li><a href="#Discretisationofgoverningequations"> Discretisation of governing equations </a>
        <li><a href="#Thematerialclass"> The material class </a>
        <li><a href="#Numericalexample"> Numerical example </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Runtimeparameters">Run-time parameters</a>
      <ul>
        <li><a href="#FiniteElementsystem">Finite Element system</a>
        <li><a href="#Geometry">Geometry</a>
        <li><a href="#Materials">Materials</a>
        <li><a href="#Linearsolver">Linear solver</a>
        <li><a href="#Nonlinearsolver">Nonlinear solver</a>
        <li><a href="#Time">Time</a>
        <li><a href="#Allparameters">All parameters</a>
      </ul>
        <li><a href="#Timeclass">Time class</a>
        <li><a href="#CompressibleneoHookeanmaterialwithinathreefieldformulation">Compressible neo-Hookean material within a three-field formulation</a>
        <li><a href="#Quadraturepointhistory">Quadrature point history</a>
        <li><a href="#Quasistaticquasiincompressiblefinitestrainsolid">Quasi-static quasi-incompressible finite-strain solid</a>
        <li><a href="#ImplementationofthecodeSolidcodeclass">Implementation of the <code>Solid</code> class</a>
      <ul>
        <li><a href="#Publicinterface">Public interface</a>
      </ul>
        <li><a href="#Privateinterface">Private interface</a>
      <ul>
        <li><a href="#Threadingbuildingblocksstructures">Threading-building-blocks structures</a>
        <li><a href="#Solidmake_grid">Solid::make_grid</a>
        <li><a href="#Solidsystem_setup">Solid::system_setup</a>
        <li><a href="#Soliddetermine_component_extractors">Solid::determine_component_extractors</a>
        <li><a href="#Solidsetup_qph">Solid::setup_qph</a>
        <li><a href="#Solidupdate_qph_incremental">Solid::update_qph_incremental</a>
        <li><a href="#Solidsolve_nonlinear_timestep">Solid::solve_nonlinear_timestep</a>
        <li><a href="#Solidprint_conv_headerandSolidprint_conv_footer">Solid::print_conv_header and Solid::print_conv_footer</a>
        <li><a href="#Solidget_error_dilation">Solid::get_error_dilation</a>
        <li><a href="#Solidget_error_residual">Solid::get_error_residual</a>
        <li><a href="#Solidget_error_update">Solid::get_error_update</a>
        <li><a href="#Solidget_total_solution">Solid::get_total_solution</a>
        <li><a href="#Solidassemble_system_tangent">Solid::assemble_system_tangent</a>
        <li><a href="#Solidassemble_system_rhs">Solid::assemble_system_rhs</a>
        <li><a href="#Solidmake_constraints">Solid::make_constraints</a>
        <li><a href="#Solidassemble_sc">Solid::assemble_sc</a>
        <li><a href="#Solidsolve_linear_system">Solid::solve_linear_system</a>
        <li><a href="#Solidoutput_results">Solid::output_results</a>
      </ul>
        <li><a href="#Mainfunction">Main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Jean-Paul Pelteret and Andrew McBride. <br />
 This material is based upon work supported by the German Science Foundation (Deutsche Forschungsgemeinschaft, DFG), grant STE 544/39-1, and the National Research Foundation of South Africa. </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.439772"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.439772.svg" alt="10.5281/zenodo.439772"/></a> </dd></dl>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The subject of this tutorial is nonlinear solid mechanics. Classical single-field approaches (see e.g. <a class="el" href="step_18.html">step-18</a>) can not correctly describe the response of quasi-incompressible materials. The response is overly stiff; a phenomenon known as locking. Locking problems can be circumvented using a variety of alternative strategies. One such strategy is the three-field formulation. It is used here to model the three-dimensional, fully-nonlinear (geometrical and material) response of an isotropic continuum body. The material response is approximated as hyperelastic. Additionally, the three-field formulation employed is valid for quasi-incompressible as well as compressible materials.</p>
<p>The objective of this presentation is to provide a basis for using deal.II for problems in nonlinear solid mechanics. The linear problem was addressed in <a class="el" href="step_8.html">step-8</a>. A non-standard, hypoelastic-type form of the geometrically nonlinear problem was partially considered in <a class="el" href="step_18.html">step-18</a>: a rate form of the linearised constitutive relations is used and the problem domain evolves with the motion. Important concepts surrounding the nonlinear kinematics are absent in the theory and implementation. <a class="el" href="step_18.html">step-18</a> does, however, describe many of the key concepts to implement elasticity within the framework of deal.II.</p>
<p>We begin with a crash-course in nonlinear kinematics. For the sake of simplicity, we restrict our attention to the quasi-static problem. Thereafter, various key stress measures are introduced and the constitutive model described. We then describe the three-field formulation in detail prior to explaining the structure of the class used to manage the material. The setup of the example problem is then presented.</p>
<dl class="section note"><dt>Note</dt><dd>This tutorial has been developed (and is described in the introduction) for the problem of elasticity in three dimensions. While the space dimension could be changed in the main() routine, care needs to be taken. Two-dimensional elasticity problems, in general, exist only as idealisations of three-dimensional ones. That is, they are either plane strain or plane stress. The assumptions that follow either of these choices needs to be consistently imposed. For more information see the note in <a class="el" href="step_8.html">step-8</a>.</dd></dl>
<p><a class="anchor" id="Listofreferences"></a></p><h3>List of references</h3>
<p>The three-field formulation implemented here was pioneered by Simo et al. (1985) and is known as the mixed Jacobian-pressure formulation. Important related contributions include those by Simo and Taylor (1991), and Miehe (1994). The notation adopted here draws heavily on the excellent overview of the theoretical aspects of nonlinear solid mechanics by Holzapfel (2001). A nice overview of issues pertaining to incompressible elasticity (at small strains) is given in Hughes (2000).</p>
<ol>
<li>
J.C. Simo, R.L. Taylor and K.S. Pister (1985), Variational and projection methods for the volume constraint in finite deformation elasto-plasticity, <em> Computer Methods in Applied Mechanics and Engineering </em>, <b> 51 </b>, 1-3, 177-208. DOI: <a href="http://doi.org/10.1016/0045-7825(85)90033-7">10.1016/0045-7825(85)90033-7</a>; </li>
<li>
J.C. Simo and R.L. Taylor (1991), Quasi-incompressible finite elasticity in principal stretches. Continuum basis and numerical algorithms, <em> Computer Methods in Applied Mechanics and Engineering </em>, <b> 85 </b>, 3, 273-310. DOI: <a href="http://doi.org/10.1016/0045-7825(91)90100-K">10.1016/0045-7825(91)90100-K</a>; </li>
<li>
C. Miehe (1994), Aspects of the formulation and finite element implementation of large strain isotropic elasticity <em> International Journal for Numerical Methods in Engineering </em> <b> 37 </b>, 12, 1981-2004. DOI: <a href="http://doi.org/10.1002/nme.1620371202">10.1002/nme.1620371202</a>; </li>
<li>
G.A. Holzapfel (2001), Nonlinear Solid Mechanics. A Continuum Approach for Engineering, John Wiley &amp; Sons. ISBN: 0-471-82304-X; </li>
<li>
T.J.R. Hughes (2000), The Finite Element Method: Linear Static and Dynamic Finite Element Analysis, Dover. ISBN: 978-0486411811 </li>
</ol>
<p>An example where this three-field formulation is used in a coupled problem is documented in </p><ol>
<li>
J-P. V. Pelteret, D. Davydov, A. McBride, D. K. Vu, and P. Steinmann (2016), Computational electro- and magneto-elasticity for quasi-incompressible media immersed in free space, <em> International Journal for Numerical Methods in Engineering </em>. DOI: <a href="http://doi.org/10.1002/nme.5254">10.1002/nme.5254</a> </li>
</ol>
<p><a class="anchor" id="Notation"></a></p><h3>Notation </h3>
<p>One can think of fourth-order tensors as linear operators mapping second-order tensors (matrices) onto themselves in much the same way as matrices map vectors onto vectors. There are various fourth-order unit tensors that will be required in the forthcoming presentation. The fourth-order unit tensors <img class="formulaInl" alt="$\mathcal{I}$" src="form_155.png"/> and <img class="formulaInl" alt="$\overline{\mathcal{I}}$" src="form_156.png"/> are defined by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{A} = \mathcal{I}:\mathbf{A} \qquad \text{and} \qquad \mathbf{A}^T = \overline{\mathcal{I}}:\mathbf{A} \, . \]" src="form_3551.png"/>
</p>
<p> Note <img class="formulaInl" alt="$\mathcal{I} \neq \overline{\mathcal{I}}^T$" src="form_159.png"/>. Furthermore, we define the symmetric and skew-symmetric fourth-order unit tensors by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathcal{S} := \dfrac{1}{2}[\mathcal{I} + \overline{\mathcal{I}}] \qquad \text{and} \qquad \mathcal{W} := \dfrac{1}{2}[\mathcal{I} - \overline{\mathcal{I}}] \, , \]" src="form_160.png"/>
</p>
<p> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \dfrac{1}{2}[\mathbf{A} + \mathbf{A}^T] = \mathcal{S}:\mathbf{A} \qquad \text{and} \qquad \dfrac{1}{2}[\mathbf{A} - \mathbf{A}^T] = \mathcal{W}:\mathbf{A} \, . \]" src="form_3552.png"/>
</p>
<p> The fourth-order <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></code> returned by identity_tensor() is <img class="formulaInl" alt="$\mathcal{S}$" src="form_162.png"/>.</p>
<p><a class="anchor" id="Kinematics"></a></p><h3>Kinematics</h3>
<p>Let the time domain be denoted <img class="formulaInl" alt="$\mathbb{T} = [0,T_{\textrm{end}}]$" src="form_3553.png"/>, where <img class="formulaInl" alt="$t \in \mathbb{T}$" src="form_3554.png"/> and <img class="formulaInl" alt="$T_{\textrm{end}}$" src="form_3555.png"/> is the total problem duration. Consider a continuum body that occupies the reference configuration <img class="formulaInl" alt="$\Omega_0$" src="form_3556.png"/> at time <img class="formulaInl" alt="$t=0$" src="form_854.png"/>. Particles in the reference configuration are identified by the position vector <img class="formulaInl" alt="$\mathbf{X}$" src="form_145.png"/>. The configuration of the body at a later time <img class="formulaInl" alt="$t&gt;0$" src="form_2033.png"/> is termed the current configuration, denoted <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>, with particles identified by the vector <img class="formulaInl" alt="$\mathbf{x}$" src="form_146.png"/>. The nonlinear map between the reference and current configurations, denoted <img class="formulaInl" alt="$\boldsymbol{\varphi}$" src="form_3557.png"/>, acts as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{x} = \boldsymbol{\varphi}(\mathbf{X},t) \, . \]" src="form_3558.png"/>
</p>
<p> The material description of the displacement of a particle is defined by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{U}(\mathbf{X},t) = \mathbf{x}(\mathbf{X},t) - \mathbf{X} \, . \]" src="form_3559.png"/>
</p>
<p>The deformation gradient <img class="formulaInl" alt="$\mathbf{F}$" src="form_139.png"/> is defined as the material gradient of the motion: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{F}(\mathbf{X},t) := \dfrac{\partial \boldsymbol{\varphi}(\mathbf{X},t)}{\partial \mathbf{X}} = \textrm{Grad}\ \mathbf{x}(\mathbf{X},t) = \mathbf{I} + \textrm{Grad}\ \mathbf{U} \, . \]" src="form_3560.png"/>
</p>
<p> The determinant of the of the deformation gradient <img class="formulaInl" alt="$J(\mathbf{X},t):= \textrm{det}\ \mathbf{F}(\mathbf{X},t) &gt; 0$" src="form_3561.png"/> maps corresponding volume elements in the reference and current configurations, denoted <img class="formulaInl" alt="$\textrm{d}V$" src="form_3562.png"/> and <img class="formulaInl" alt="$\textrm{d}v$" src="form_3563.png"/>, respectively, as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \textrm{d}v = J(\mathbf{X},t)\; \textrm{d}V \, . \]" src="form_3564.png"/>
</p>
<p>Two important measures of the deformation in terms of the spatial and material coordinates are the left and right Cauchy-Green tensors, respectively, and denoted <img class="formulaInl" alt="$\mathbf{b} := \mathbf{F}\mathbf{F}^T$" src="form_3565.png"/> and <img class="formulaInl" alt="$\mathbf{C} := \mathbf{F}^T\mathbf{F}$" src="form_3566.png"/>. They are both symmetric and positive definite.</p>
<p>The Green-Lagrange strain tensor is defined by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{E}:= \frac{1}{2}[\mathbf{C} - \mathbf{I} ] = \underbrace{\frac{1}{2}[\textrm{Grad}^T \mathbf{U} + \textrm{Grad}\mathbf{U}]}_{\boldsymbol{\varepsilon}} + \frac{1}{2}[\textrm{Grad}^T\ \mathbf{U}][\textrm{Grad}\ \mathbf{U}] \, . \]" src="form_3567.png"/>
</p>
<p> If the assumption of infinitesimal deformations is made, then the second term on the right can be neglected, and <img class="formulaInl" alt="$\boldsymbol{\varepsilon}$" src="form_3568.png"/> (the linearised strain tensor) is the only component of the strain tensor. This assumption is, looking at the setup of the problem, not valid in <a class="el" href="step_18.html">step-18</a>, making the use of the linearized <img class="formulaInl" alt="$\boldsymbol{\varepsilon}$" src="form_3568.png"/> as the strain measure in that tutorial program questionable.</p>
<p>In order to handle the different response that materials exhibit when subjected to bulk and shear type deformations we consider the following decomposition of the deformation gradient <img class="formulaInl" alt="$\mathbf{F}$" src="form_139.png"/> and the left Cauchy-Green tensor <img class="formulaInl" alt="$\mathbf{b}$" src="form_1646.png"/> into volume-changing (volumetric) and volume-preserving (isochoric) parts: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{F} = (J^{1/3}\mathbf{I})\overline{\mathbf{F}} \qquad \text{and} \qquad \mathbf{b} = (J^{2/3}\mathbf{I})\overline{\mathbf{F}}\,\overline{\mathbf{F}}^T = (J^{2/3}\mathbf{I})\overline{\mathbf{b}} \, . \]" src="form_3569.png"/>
</p>
<p> Clearly, <img class="formulaInl" alt="$\textrm{det}\ \mathbf{F} = \textrm{det}\ (J^{1/3}\mathbf{I}) = J$" src="form_3570.png"/>.</p>
<p>The spatial velocity field is denoted <img class="formulaInl" alt="$\mathbf{v}(\mathbf{x},t)$" src="form_3571.png"/>. The derivative of the spatial velocity field with respect to the spatial coordinates gives the spatial velocity gradient <img class="formulaInl" alt="$\mathbf{l}(\mathbf{x},t)$" src="form_3572.png"/>, that is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{l}(\mathbf{x},t) := \dfrac{\partial \mathbf{v}(\mathbf{x},t)}{\partial \mathbf{x}} = \textrm{grad}\ \mathbf{v}(\mathbf{x},t) \, , \]" src="form_3573.png"/>
</p>
<p> where <img class="formulaInl" alt="$\textrm{grad} \{\bullet \} = \frac{\partial \{ \bullet \} }{ \partial \mathbf{x}} = \frac{\partial \{ \bullet \} }{ \partial \mathbf{X}}\frac{\partial \mathbf{X} }{ \partial \mathbf{x}} = \textrm{Grad} \{ \bullet \} \mathbf{F}^{-1}$" src="form_3574.png"/>.</p>
<p><a class="anchor" id="Kinetics"></a></p><h3>Kinetics</h3>
<p>Cauchy's stress theorem equates the Cauchy traction <img class="formulaInl" alt="$\mathbf{t}$" src="form_1342.png"/> acting on an infinitesimal surface element in the current configuration <img class="formulaInl" alt="$\mathrm{d}a$" src="form_3575.png"/> to the product of the Cauchy stress tensor <img class="formulaInl" alt="$\boldsymbol{\sigma}$" src="form_3576.png"/> (a spatial quantity) and the outward unit normal to the surface <img class="formulaInl" alt="$\mathbf{n}$" src="form_1349.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{t}(\mathbf{x},t, \mathbf{n}) = \boldsymbol{\sigma}\mathbf{n} \, . \]" src="form_3577.png"/>
</p>
<p> The Cauchy stress is symmetric. Similarly, the first Piola-Kirchhoff traction <img class="formulaInl" alt="$\mathbf{T}$" src="form_3578.png"/> which acts on an infinitesimal surface element in the reference configuration <img class="formulaInl" alt="$\mathrm{d}A$" src="form_3579.png"/> is the product of the first Piola-Kirchhoff stress tensor <img class="formulaInl" alt="$\mathbf{P}$" src="form_3580.png"/> (a two-point tensor) and the outward unit normal to the surface <img class="formulaInl" alt="$\mathbf{N}$" src="form_1348.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{T}(\mathbf{X},t, \mathbf{N}) = \mathbf{P}\mathbf{N} \, . \]" src="form_3581.png"/>
</p>
<p> The Cauchy traction <img class="formulaInl" alt="$\mathbf{t}$" src="form_1342.png"/> and the first Piola-Kirchhoff traction <img class="formulaInl" alt="$\mathbf{T}$" src="form_3578.png"/> are related as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{t}\mathrm{d}a = \mathbf{T}\mathrm{d}A \, . \]" src="form_3582.png"/>
</p>
<p> This can be demonstrated using <a href="http://en.wikipedia.org/wiki/Finite_strain_theory">Nanson's formula</a>.</p>
<p>The first Piola-Kirchhoff stress tensor is related to the Cauchy stress as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{P} = J \boldsymbol{\sigma}\mathbf{F}^{-T} \, . \]" src="form_3583.png"/>
</p>
<p> Further important stress measures are the (spatial) Kirchhoff stress <img class="formulaInl" alt="$\boldsymbol{\tau} = J \boldsymbol{\sigma}$" src="form_3584.png"/> and the (referential) second Piola-Kirchhoff stress <img class="formulaInl" alt="$\mathbf{S} = {\mathbf{F}}^{-1} \boldsymbol{\tau} {\mathbf{F}}^{-T}$" src="form_3585.png"/>.</p>
<p><a class="anchor" id="Pushforwardandpullbackoperators"></a></p><h3>Push-forward and pull-back operators </h3>
<p>Push-forward and pull-back operators allow one to transform various measures between the material and spatial settings. The stress measures used here are contravariant, while the strain measures are covariant.</p>
<p>The push-forward and-pull back operations for second-order covariant tensors <img class="formulaInl" alt="$(\bullet)^{\text{cov}}$" src="form_3586.png"/> are respectively given by: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \chi_{*}(\bullet)^{\text{cov}}:= \mathbf{F}^{-T} (\bullet)^{\text{cov}} \mathbf{F}^{-1} \qquad \text{and} \qquad \chi^{-1}_{*}(\bullet)^{\text{cov}}:= \mathbf{F}^{T} (\bullet)^{\text{cov}} \mathbf{F} \, . \]" src="form_3587.png"/>
</p>
<p>The push-forward and pull back operations for second-order contravariant tensors <img class="formulaInl" alt="$(\bullet)^{\text{con}}$" src="form_3588.png"/> are respectively given by: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \chi_{*}(\bullet)^{\text{con}}:= \mathbf{F} (\bullet)^{\text{con}} \mathbf{F}^T \qquad \text{and} \qquad \chi^{-1}_{*}(\bullet)^{\text{con}}:= \mathbf{F}^{-1} (\bullet)^{\text{con}} \mathbf{F}^{-T} \, . \]" src="form_3589.png"/>
</p>
<p> For example <img class="formulaInl" alt="$\boldsymbol{\tau} = \chi_{*}(\mathbf{S})$" src="form_3590.png"/>.</p>
<p><a class="anchor" id="Hyperelasticmaterials"></a></p><h3>Hyperelastic materials</h3>
<p>A hyperelastic material response is governed by a Helmholtz free energy function <img class="formulaInl" alt="$\Psi = \Psi(\mathbf{F}) = \Psi(\mathbf{C}) = \Psi(\mathbf{b})$" src="form_3591.png"/> which serves as a potential for the stress. For example, if the Helmholtz free energy depends on the right Cauchy-Green tensor <img class="formulaInl" alt="$\mathbf{C}$" src="form_3592.png"/> then the isotropic hyperelastic response is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{S} = 2 \dfrac{\partial \Psi(\mathbf{C})}{\partial \mathbf{C}} \, . \]" src="form_3593.png"/>
</p>
<p> If the Helmholtz free energy depends on the left Cauchy-Green tensor <img class="formulaInl" alt="$\mathbf{b}$" src="form_1646.png"/> then the isotropic hyperelastic response is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \boldsymbol{\tau} = 2 \dfrac{\partial \Psi(\mathbf{b})}{\partial \mathbf{b}} \mathbf{b} = 2 \mathbf{b} \dfrac{\partial \Psi(\mathbf{b})}{\partial \mathbf{b}} \, . \]" src="form_3594.png"/>
</p>
<p>Following the multiplicative decomposition of the deformation gradient, the Helmholtz free energy can be decomposed as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Psi(\mathbf{b}) = \Psi_{\text{vol}}(J) + \Psi_{\text{iso}}(\overline{\mathbf{b}}) \, . \]" src="form_3595.png"/>
</p>
<p> Similarly, the Kirchhoff stress can be decomposed into volumetric and isochoric parts as <img class="formulaInl" alt="$\boldsymbol{\tau} = \boldsymbol{\tau}_{\text{vol}} + \boldsymbol{\tau}_{\text{iso}}$" src="form_3596.png"/> where: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \boldsymbol{\tau}_{\text{vol}} &amp;= 2 \mathbf{b} \dfrac{\partial \Psi_{\textrm{vol}}(J)}{\partial \mathbf{b}} \\ &amp;= p J\mathbf{I} \, , \\ \boldsymbol{\tau}_{\text{iso}} &amp;= 2 \mathbf{b} \dfrac{\partial \Psi_{\textrm{iso}} (\overline{\mathbf{b}})}{\partial \mathbf{b}} \\ &amp;= \underbrace{( \mathcal{I} - \dfrac{1}{3} \mathbf{I} \otimes \mathbf{I})}_{\mathbb{P}} : \overline{\boldsymbol{\tau}} \, , \end{align*}" src="form_3597.png"/>
</p>
<p> where <img class="formulaInl" alt="$p := \dfrac{\partial \Psi_{\text{vol}}(J)}{\partial J}$" src="form_3598.png"/> is the pressure response. <img class="formulaInl" alt="$\mathbb{P}$" src="form_3599.png"/> is the projection tensor which provides the deviatoric operator in the Eulerian setting. The fictitious Kirchhoff stress tensor <img class="formulaInl" alt="$\overline{\boldsymbol{\tau}}$" src="form_3600.png"/> is defined by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \overline{\boldsymbol{\tau}} := 2 \overline{\mathbf{b}} \dfrac{\partial \Psi_{\textrm{iso}}(\overline{\mathbf{b}})}{\partial \overline{\mathbf{b}}} \, . \]" src="form_3601.png"/>
</p>
<dl class="section note"><dt>Note</dt><dd>The pressure response as defined above differs from the widely-used definition of the pressure in solid mechanics as <img class="formulaInl" alt="$p = - 1/3 \textrm{tr} \boldsymbol{\sigma} = - 1/3 J^{-1} \textrm{tr} \boldsymbol{\tau}$" src="form_3602.png"/>. Here <img class="formulaInl" alt="$p$" src="form_202.png"/> is the hydrostatic pressure. We make use of the pressure response throughout this tut (although we refer to it as the pressure).</dd></dl>
<p><a class="anchor" id="NeoHookeanmaterials"></a></p><h4>Neo-Hookean materials </h4>
<p>The Helmholtz free energy corresponding to a compressible <a href="http://en.wikipedia.org/wiki/Neo-Hookean_solid">neo-Hookean material</a> is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Psi \equiv \underbrace{\kappa [ \mathcal{G}(J) ] }_{\Psi_{\textrm{vol}}(J)} + \underbrace{\bigl[c_1 [ \overline{I}_1 - 3] \bigr]}_{\Psi_{\text{iso}}(\overline{\mathbf{b}})} \, , \]" src="form_3603.png"/>
</p>
<p> where <img class="formulaInl" alt="$\kappa := \lambda + 2/3 \mu$" src="form_3604.png"/> is the bulk modulus ( <img class="formulaInl" alt="$\lambda$" src="form_548.png"/> and <img class="formulaInl" alt="$\mu$" src="form_1643.png"/> are the Lame parameters) and <img class="formulaInl" alt="$\overline{I}_1 := \textrm{tr}\ \overline{\mathbf{b}}$" src="form_3605.png"/>. The function <img class="formulaInl" alt="$\mathcal{G}(J)$" src="form_3606.png"/> is required to be strictly convex and satisfy the condition <img class="formulaInl" alt="$\mathcal{G}(1) = 0$" src="form_3607.png"/>, among others, see Holzapfel (2001) for further details. In this work <img class="formulaInl" alt="$\mathcal{G}:=\frac{1}{4} [ J^2 - 1 - 2\textrm{ln}J ]$" src="form_3608.png"/>.</p>
<p>Incompressibility imposes the isochoric constraint that <img class="formulaInl" alt="$J=1$" src="form_3609.png"/> for all motions <img class="formulaInl" alt="$\boldsymbol{\varphi}$" src="form_3557.png"/>. The Helmholtz free energy corresponding to an incompressible neo-Hookean material is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Psi \equiv \underbrace{\bigl[ c_1 [ I_1 - 3] \bigr] }_{\Psi_{\textrm{iso}}(\mathbf{b})} \, , \]" src="form_3610.png"/>
</p>
<p> where <img class="formulaInl" alt="$ I_1 := \textrm{tr}\mathbf{b} $" src="form_3611.png"/>. Thus, the incompressible response is obtained by removing the volumetric component from the compressible free energy and enforcing <img class="formulaInl" alt="$J=1$" src="form_3609.png"/>.</p>
<p><a class="anchor" id="Elasticitytensors"></a></p><h3>Elasticity tensors</h3>
<p>We will use a Newton-Raphson strategy to solve the nonlinear boundary value problem. Thus, we will need to linearise the constitutive relations.</p>
<p>The fourth-order elasticity tensor in the material description is defined by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathfrak{C} = 2\dfrac{\partial \mathbf{S}(\mathbf{C})}{\partial \mathbf{C}} = 4\dfrac{\partial^2 \Psi(\mathbf{C})}{\partial \mathbf{C} \partial \mathbf{C}} \, . \]" src="form_3612.png"/>
</p>
<p> The fourth-order elasticity tensor in the spatial description <img class="formulaInl" alt="$\mathfrak{c}$" src="form_3613.png"/> is obtained from the push-forward of <img class="formulaInl" alt="$\mathfrak{C}$" src="form_3614.png"/> as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathfrak{c} = J^{-1} \chi_{*}(\mathfrak{C}) \qquad \text{and thus} \qquad J\mathfrak{c} = 4 \mathbf{b} \dfrac{\partial^2 \Psi(\mathbf{b})} {\partial \mathbf{b} \partial \mathbf{b}} \mathbf{b} \, . \]" src="form_3615.png"/>
</p>
<p> The fourth-order elasticity tensors (for hyperelastic materials) possess both major and minor symmetries.</p>
<p>The fourth-order spatial elasticity tensor can be written in the following decoupled form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathfrak{c} = \mathfrak{c}_{\text{vol}} + \mathfrak{c}_{\text{iso}} \, , \]" src="form_3616.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} J \mathfrak{c}_{\text{vol}} &amp;= 4 \mathbf{b} \dfrac{\partial^2 \Psi_{\text{vol}}(J)} {\partial \mathbf{b} \partial \mathbf{b}} \mathbf{b} \\ &amp;= J[\widehat{p}\, \mathbf{I} \otimes \mathbf{I} - 2p \mathcal{I}] \qquad \text{where} \qquad \widehat{p} := p + \dfrac{\textrm{d} p}{\textrm{d}J} \, , \\ J \mathfrak{c}_{\text{iso}} &amp;= 4 \mathbf{b} \dfrac{\partial^2 \Psi_{\text{iso}}(\overline{\mathbf{b}})} {\partial \mathbf{b} \partial \mathbf{b}} \mathbf{b} \\ &amp;= \mathbb{P} : \mathfrak{\overline{c}} : \mathbb{P} + \dfrac{2}{3}[\overline{\boldsymbol{\tau}}:\mathbf{I}]\mathbb{P} - \dfrac{2}{3}[ \mathbf{I}\otimes\boldsymbol{\tau}_{\text{iso}} + \boldsymbol{\tau}_{\text{iso}} \otimes \mathbf{I} ] \, , \end{align*}" src="form_3617.png"/>
</p>
<p> where the fictitious elasticity tensor <img class="formulaInl" alt="$\overline{\mathfrak{c}}$" src="form_3618.png"/> in the spatial description is defined by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \overline{\mathfrak{c}} = 4 \overline{\mathbf{b}} \dfrac{ \partial^2 \Psi_{\textrm{iso}}(\overline{\mathbf{b}})} {\partial \overline{\mathbf{b}} \partial \overline{\mathbf{b}}} \overline{\mathbf{b}} \, . \]" src="form_3619.png"/>
</p>
<p><a class="anchor" id="Principleofstationarypotentialenergyandthethreefieldformulation"></a></p><h3>Principle of stationary potential energy and the three-field formulation</h3>
<p>The total potential energy of the system <img class="formulaInl" alt="$\Pi$" src="form_3620.png"/> is the sum of the internal and external potential energies, denoted <img class="formulaInl" alt="$\Pi_{\textrm{int}}$" src="form_3621.png"/> and <img class="formulaInl" alt="$\Pi_{\textrm{ext}}$" src="form_3622.png"/>, respectively. We wish to find the equilibrium configuration by minimising the potential energy.</p>
<p>As mentioned above, we adopt a three-field formulation. We denote the set of primary unknowns by <img class="formulaInl" alt="$\mathbf{\Xi}:= \{ \mathbf{u}, \widetilde{p}, \widetilde{J} \}$" src="form_3623.png"/>. The independent kinematic variable <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> enters the formulation as a constraint on <img class="formulaInl" alt="$J$" src="form_777.png"/> enforced by the Lagrange multiplier <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> (the pressure, as we shall see).</p>
<p>The three-field variational principle used here is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Pi(\mathbf{\Xi}) := \int_\Omega \bigl[ \Psi_{\textrm{vol}}(\widetilde{J}) + \widetilde{p}\,[J(\mathbf{u}) - \widetilde{J}] + \Psi_{\textrm{iso}}(\overline{\mathbf{b}}(\mathbf{u})) \bigr] \textrm{d}v + \Pi_{\textrm{ext}} \, , \]" src="form_3626.png"/>
</p>
<p> where the external potential is defined by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Pi_{\textrm{ext}} = - \int_\Omega \mathbf{b}^\text{p} \cdot \mathbf{u}~\textrm{d}v - \int_{\partial \Omega_{\sigma}} \mathbf{t}^\text{p} \cdot \mathbf{u}~\textrm{d}a \, . \]" src="form_3627.png"/>
</p>
<p> The boundary of the current configuration <img class="formulaInl" alt="$\partial \Omega$" src="form_1561.png"/> is composed into two parts as <img class="formulaInl" alt="$\partial \Omega = \partial \Omega_{\mathbf{u}} \cup \partial \Omega_{\sigma}$" src="form_3628.png"/>, where <img class="formulaInl" alt="$\partial \Omega_{\mathbf{u}} \cap \partial \Omega_{\boldsymbol{\sigma}} = \emptyset$" src="form_3629.png"/>. The prescribed Cauchy traction, denoted <img class="formulaInl" alt="$\mathbf{t}^\text{p}$" src="form_3630.png"/>, is applied to <img class="formulaInl" alt="$ \partial \Omega_{\boldsymbol{\sigma}}$" src="form_3631.png"/> while the motion is prescribed on the remaining portion of the boundary <img class="formulaInl" alt="$\partial \Omega_{\mathbf{u}}$" src="form_3632.png"/>. The body force per unit current volume is denoted <img class="formulaInl" alt="$\mathbf{b}^\text{p}$" src="form_3633.png"/>.</p>
<p>The stationarity of the potential follows as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} R(\mathbf\Xi;\delta \mathbf{\Xi}) &amp;= D_{\delta \mathbf{\Xi}}\Pi(\mathbf{\Xi}) \\ &amp;= \dfrac{\partial \Pi(\mathbf{\Xi})}{\partial \mathbf{u}} \cdot \delta \mathbf{u} + \dfrac{\partial \Pi(\mathbf{\Xi})}{\partial \widetilde{p}} \delta \widetilde{p} + \dfrac{\partial \Pi(\mathbf{\Xi})}{\partial \widetilde{J}} \delta \tilde{J} \\ &amp;= \int_{\Omega_0} \left[ \textrm{grad}\ \delta\mathbf{u} : [ \underbrace{[\widetilde{p} J \mathbf{I}]}_{\equiv \boldsymbol{\tau}_{\textrm{vol}}} + \boldsymbol{\tau}_{\textrm{iso}}] + \delta \widetilde{p}\, [ J(\mathbf{u}) - \widetilde{J}] + \delta \widetilde{J}\left[ \dfrac{\textrm{d} \Psi_{\textrm{vol}}(\widetilde{J})}{\textrm{d} \widetilde{J}} -\widetilde{p}\right] \right]~\textrm{d}V \\ &amp;\quad - \int_{\Omega_0} \delta \mathbf{u} \cdot \mathbf{B}^\text{p}~\textrm{d}V - \int_{\partial \Omega_{0,\boldsymbol{\sigma}}} \delta \mathbf{u} \cdot \mathbf{T}^\text{p}~\textrm{d}A \\ &amp;=0 \, , \end{align*}" src="form_3634.png"/>
</p>
<p> for all virtual displacements <img class="formulaInl" alt="$\delta \mathbf{u} \in H^1(\Omega)$" src="form_3635.png"/> subject to the constraint that <img class="formulaInl" alt="$\delta \mathbf{u} = \mathbf{0}$" src="form_3636.png"/> on <img class="formulaInl" alt="$\partial \Omega_{\mathbf{u}}$" src="form_3632.png"/>, and all virtual pressures <img class="formulaInl" alt="$\delta \widetilde{p} \in L^2(\Omega)$" src="form_3637.png"/> and virtual dilatations <img class="formulaInl" alt="$\delta \widetilde{J} \in L^2(\Omega)$" src="form_3638.png"/>.</p>
<p>One should note that the definitions of the volumetric Kirchhoff stress in the three field formulation <img class="formulaInl" alt="$\boldsymbol{\tau}_{\textrm{vol}} \equiv \widetilde{p} J \mathbf{I}$" src="form_3639.png"/> and the subsequent volumetric tangent differs slightly from the general form given in the section on hyperelastic materials where <img class="formulaInl" alt="$\boldsymbol{\tau}_{\textrm{vol}} \equiv p J\mathbf{I}$" src="form_3640.png"/>. This is because the pressure <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> is now a primary field as opposed to a constitutively derived quantity. One needs to carefully distinguish between the primary fields and those obtained from the constitutive relations.</p>
<dl class="section note"><dt>Note</dt><dd>Although the variables are all expressed in terms of spatial quantities, the domain of integration is the initial configuration. This approach is called a <em> total-Lagrangian formulation </em>. The approach given in <a class="el" href="step_18.html">step-18</a>, where the domain of integration is the current configuration, could be called an <em> updated Lagrangian formulation </em>. The various merits of these two approaches are discussed widely in the literature. It should be noted however that they are equivalent.</dd></dl>
<p>The Euler-Lagrange equations corresponding to the residual are: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} &amp;\textrm{div}\ \boldsymbol{\sigma} + \mathbf{b}^\text{p} = \mathbf{0} &amp;&amp; \textrm{[equilibrium]} \\ &amp;J(\mathbf{u}) = \widetilde{J} &amp;&amp; \textrm{[dilatation]} \\ &amp;\widetilde{p} = \dfrac{\textrm{d} \Psi_{\textrm{vol}}(\widetilde{J})}{\textrm{d} \widetilde{J}} &amp;&amp; \textrm{[pressure]} \, . \end{align*}" src="form_3641.png"/>
</p>
<p> The first equation is the (quasi-static) equilibrium equation in the spatial setting. The second is the constraint that <img class="formulaInl" alt="$J(\mathbf{u}) = \widetilde{J}$" src="form_3642.png"/>. The third is the definition of the pressure <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>The simplified single-field derivation ( <img class="formulaInl" alt="$\mathbf{u}$" src="form_1365.png"/> is the only primary variable) below makes it clear how we transform the limits of integration to the reference domain: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \int_{\Omega}\delta \mathbf{u} \cdot [ \boldsymbol{\sigma} + \mathbf{b}^\text{p}]~\mathrm{d}v &amp;= \int_{\Omega} [-\mathrm{grad}\delta \mathbf{u}:\boldsymbol{\sigma} + \delta \mathbf{u} \cdot\mathbf{b}^\text{p}]~\mathrm{d}v + \int_{\partial \Omega} \delta \mathbf{u} \cdot \mathbf{t}^\text{p}~\mathrm{d}a \\ &amp;= - \int_{\Omega_0} \mathrm{grad}\delta \mathbf{u}:\boldsymbol{\tau}~\mathrm{d}V + \int_{\Omega_0} \delta \mathbf{u} \cdot J\mathbf{b}^\text{p}~\mathrm{d}V + \int_{\partial \Omega_0} \delta \mathbf{u} \cdot \mathbf{T}^\text{p}~\mathrm{d}A \\ &amp;= - \int_{\Omega_0} \mathrm{grad}\delta \mathbf{u}:\boldsymbol{\tau}~\mathrm{d}V + \int_{\Omega_0} \delta \mathbf{u} \cdot \mathbf{B}^\text{p}~\mathrm{d}V + \int_{\partial \Omega_{0,\sigma}} \delta \mathbf{u} \cdot \mathbf{T}^\text{p}~\mathrm{d}A \\ &amp;= - \int_{\Omega_0} [\mathrm{grad}\delta\mathbf{u}]^{\text{sym}} :\boldsymbol{\tau}~\mathrm{d}V + \int_{\Omega_0} \delta \mathbf{u} \cdot \mathbf{B}^\text{p}~\mathrm{d}V + \int_{\partial \Omega_{0,\sigma}} \delta \mathbf{u} \cdot \mathbf{T}^\text{p}~\mathrm{d}A \, , \end{align*}" src="form_3643.png"/>
</p>
 where <img class="formulaInl" alt="$[\mathrm{grad}\delta\mathbf{u}]^{\text{sym}} = 1/2[ \mathrm{grad}\delta\mathbf{u} + [\mathrm{grad}\delta\mathbf{u}]^T] $" src="form_3644.png"/>.</dd></dl>
<p>We will use an iterative Newton-Raphson method to solve the nonlinear residual equation <img class="formulaInl" alt="$R$" src="form_432.png"/>. For the sake of simplicity we assume dead loading, i.e. the loading does not change due to the deformation.</p>
<p>The change in a quantity between the known state at <img class="formulaInl" alt="$t_{\textrm{n}-1}$" src="form_3645.png"/> and the currently unknown state at <img class="formulaInl" alt="$t_{\textrm{n}}$" src="form_3646.png"/> is denoted <img class="formulaInl" alt="$\varDelta \{ \bullet \} = { \{ \bullet \} }^{\textrm{n}} - { \{ \bullet \} }^{\textrm{n-1}}$" src="form_3647.png"/>. The value of a quantity at the current iteration <img class="formulaInl" alt="$\textrm{i}$" src="form_3648.png"/> is denoted <img class="formulaInl" alt="${ \{ \bullet \} }^{\textrm{n}}_{\textrm{i}} = { \{ \bullet \} }_{\textrm{i}}$" src="form_3649.png"/>. The incremental change between iterations <img class="formulaInl" alt="$\textrm{i}$" src="form_3648.png"/> and <img class="formulaInl" alt="$\textrm{i}+1$" src="form_3650.png"/> is denoted <img class="formulaInl" alt="$d \{ \bullet \} := \{ \bullet \}_{\textrm{i}+1} - \{ \bullet \}_{\textrm{i}}$" src="form_3651.png"/>.</p>
<p>Assume that the state of the system is known for some iteration <img class="formulaInl" alt="$\textrm{i}$" src="form_3648.png"/>. The linearised approximation to nonlinear governing equations to be solved using the Newton-Raphson method is: Find <img class="formulaInl" alt="$d \mathbf{\Xi}$" src="form_3652.png"/> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R(\mathbf{\Xi}_{\mathsf{i}+1}) = R(\mathbf{\Xi}_{\mathsf{i}}) + D^2_{d \mathbf{\Xi}, \delta \mathbf{\Xi}} \Pi(\mathbf{\Xi_{\mathsf{i}}}) \cdot d \mathbf{\Xi} \equiv 0 \, , \]" src="form_3653.png"/>
</p>
<p> then set <img class="formulaInl" alt="$\mathbf{\Xi}_{\textrm{i}+1} = \mathbf{\Xi}_{\textrm{i}} + d \mathbf{\Xi}$" src="form_3654.png"/>. The tangent is given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ D^2_{d \mathbf{\Xi}, \delta \mathbf{\Xi}} \Pi( \mathbf{\Xi}_{\mathsf{i}} ) = D_{d \mathbf{\Xi}} R( \mathbf{\Xi}_{\mathsf{i}}; \delta \mathbf{\Xi}) =: K(\mathbf{\Xi}_{\mathsf{i}}; d \mathbf{\Xi}, \delta \mathbf{\Xi}) \, . \]" src="form_3655.png"/>
</p>
<p> Thus, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} K(\mathbf{\Xi}_{\mathsf{i}}; d \mathbf{\Xi}, \delta \mathbf{\Xi}) &amp;= D_{d \mathbf{u}} R( \mathbf{\Xi}_{\mathsf{i}}; \delta \mathbf{\Xi}) \cdot d \mathbf{u} \\ &amp;\quad + D_{d \widetilde{p}} R( \mathbf{\Xi}_{\mathsf{i}}; \delta \mathbf{\Xi}) d \widetilde{p} \\ &amp;\quad + D_{d \widetilde{J}} R( \mathbf{\Xi}_{\mathsf{i}}; \delta \mathbf{\Xi}) d \widetilde{J} \, , \end{align*}" src="form_3656.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} D_{d \mathbf{u}} R( \mathbf{\Xi}; \delta \mathbf{\Xi}) &amp;= \int_{\Omega_0} \bigl[ \textrm{grad}\ \delta \mathbf{u} : \textrm{grad}\ d \mathbf{u} [\boldsymbol{\tau}_{\textrm{iso}} + \boldsymbol{\tau}_{\textrm{vol}}] + \textrm{grad}\ \delta \mathbf{u} :[ \underbrace{[\widetilde{p}J[\mathbf{I}\otimes\mathbf{I} - 2 \mathcal{I}]}_{\equiv J\mathfrak{c}_{\textrm{vol}}} + J\mathfrak{c}_{\textrm{iso}}] :\textrm{grad} d \mathbf{u} \bigr]~\textrm{d}V \, , \\ &amp;\quad + \int_{\Omega_0} \delta \widetilde{p} J \mathbf{I} : \textrm{grad}\ d \mathbf{u} ~\textrm{d}V \\ D_{d \widetilde{p}} R( \mathbf{\Xi}; \delta \mathbf{\Xi}) &amp;= \int_{\Omega_0} \textrm{grad}\ \delta \mathbf{u} : J \mathbf{I} d \widetilde{p} ~\textrm{d}V - \int_{\Omega_0} \delta \widetilde{J} d \widetilde{p} ~\textrm{d}V \, , \\ D_{d \widetilde{J}} R( \mathbf{\Xi}; \delta \mathbf{\Xi}) &amp;= -\int_{\Omega_0} \delta \widetilde{p} d \widetilde{J}~\textrm{d}V + \int_{\Omega_0} \delta \widetilde{J} \dfrac{\textrm{d}^2 \Psi_{\textrm{vol}}(\widetilde{J})}{\textrm{d} \widetilde{J}\textrm{d}\widetilde{J}} d \widetilde{J} ~\textrm{d}V \, . \end{align*}" src="form_3657.png"/>
</p>
<p>Note that the following terms are termed the geometrical stress and the material contributions to the tangent matrix: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} &amp; \int_{\Omega_0} \textrm{grad}\ \delta \mathbf{u} : \textrm{grad}\ d \mathbf{u} [\boldsymbol{\tau}_{\textrm{iso}} + \boldsymbol{\tau}_{\textrm{vol}}]~\textrm{d}V &amp;&amp; \quad {[\textrm{Geometrical stress}]} \, , \\ &amp; \int_{\Omega_0} \textrm{grad} \delta \mathbf{u} : [J\mathfrak{c}_{\textrm{vol}} + J\mathfrak{c}_{\textrm{iso}}] :\textrm{grad}\ d \mathbf{u} ~\textrm{d}V &amp;&amp; \quad {[\textrm{Material}]} \, . \end{align*}" src="form_3658.png"/>
</p>
<p><a class="anchor" id="Discretisationofgoverningequations"></a></p><h3>Discretisation of governing equations </h3>
<p>The three-field formulation used here is effective for quasi-incompressible materials, that is where <img class="formulaInl" alt="$\nu \rightarrow 0.5$" src="form_3659.png"/> (where <img class="formulaInl" alt="$\nu$" src="form_1655.png"/> is <a href="http://en.wikipedia.org/wiki/Poisson&apos;s_ratio">Poisson's ratio</a>), subject to a good choice of the interpolation fields for <img class="formulaInl" alt="$\mathbf{u},~\widetilde{p}$" src="form_3660.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/>. Typically a choice of <img class="formulaInl" alt="$Q_n \times DGPM_{n-1} \times DGPM_{n-1}$" src="form_3661.png"/> is made. Here <img class="formulaInl" alt="$DGPM$" src="form_3662.png"/> is the <a class="el" href="classFE__DGPMonomial.html">FE_DGPMonomial</a> class. A popular choice is <img class="formulaInl" alt="$Q_1 \times DGPM_0 \times DGPM_0$" src="form_3663.png"/> which is known as the mean dilatation method (see Hughes (2000) for an intuitive discussion). This code can accommodate a <img class="formulaInl" alt="$Q_n \times DGPM_{n-1} \times DGPM_{n-1}$" src="form_3661.png"/> formulation. The discontinuous approximation allows <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> to be condensed out and a classical displacement based method is recovered.</p>
<p>For fully-incompressible materials <img class="formulaInl" alt="$\nu = 0.5$" src="form_3664.png"/> and the three-field formulation will still exhibit locking behaviour. This can be overcome by introducing an additional constraint into the free energy of the form <img class="formulaInl" alt="$\int_{\Omega_0} \Lambda [ \widetilde{J} - 1]~\textrm{d}V$" src="form_3665.png"/>. Here <img class="formulaInl" alt="$\Lambda$" src="form_3313.png"/> is a Lagrange multiplier to enforce the isochoric constraint. For further details see Miehe (1994).</p>
<p>The linearised problem can be written as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{\mathsf{K}}( \mathbf{\Xi}_{\textrm{i}}) d\mathbf{\Xi} = \mathbf{ \mathsf{F}}(\mathbf{\Xi}_{\textrm{i}}) \]" src="form_3666.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \underbrace{\begin{bmatrix} \mathbf{\mathsf{K}}_{uu} &amp; \mathbf{\mathsf{K}}_{u\widetilde{p}} &amp; \mathbf{0} \\ \mathbf{\mathsf{K}}_{\widetilde{p}u} &amp; \mathbf{0} &amp; \mathbf{\mathsf{K}}_{\widetilde{p}\widetilde{J}} \\ \mathbf{0} &amp; \mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{p}} &amp; \mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{J}} \end{bmatrix}}_{\mathbf{\mathsf{K}}(\mathbf{\Xi}_{\textrm{i}})} \underbrace{\begin{bmatrix} d \mathbf{\mathsf{u}}\\ d \widetilde{\mathbf{\mathsf{p}}} \\ d \widetilde{\mathbf{\mathsf{J}}} \end{bmatrix}}_{d \mathbf{\Xi}} = \underbrace{\begin{bmatrix} -\mathbf{\mathsf{R}}_{u}(\mathbf{u}_{\textrm{i}}) \\ -\mathbf{\mathsf{R}}_{\widetilde{p}}(\widetilde{p}_{\textrm{i}}) \\ -\mathbf{\mathsf{R}}_{\widetilde{J}}(\widetilde{J}_{\textrm{i}}) \end{bmatrix}}_{ -\mathbf{\mathsf{R}}(\mathbf{\Xi}_{\textrm{i}}) } = \underbrace{\begin{bmatrix} \mathbf{\mathsf{F}}_{u}(\mathbf{u}_{\textrm{i}}) \\ \mathbf{\mathsf{F}}_{\widetilde{p}}(\widetilde{p}_{\textrm{i}}) \\ \mathbf{\mathsf{F}}_{\widetilde{J}}(\widetilde{J}_{\textrm{i}}) \end{bmatrix}}_{ \mathbf{\mathsf{F}}(\mathbf{\Xi}_{\textrm{i}}) } \, . \end{align*}" src="form_3667.png"/>
</p>
<p>There are no derivatives of the pressure and dilatation (primary) variables present in the formulation. Thus the discontinuous finite element interpolation of the pressure and dilatation yields a block diagonal matrix for <img class="formulaInl" alt="$\mathbf{\mathsf{K}}_{\widetilde{p}\widetilde{J}}$" src="form_3668.png"/>, <img class="formulaInl" alt="$\mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{p}}$" src="form_3669.png"/> and <img class="formulaInl" alt="$\mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{J}}$" src="form_3670.png"/>. Therefore we can easily express the fields <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> on each cell simply by inverting a local matrix and multiplying it by the local right hand side. We can then insert the result into the remaining equations and recover a classical displacement-based method. In order to condense out the pressure and dilatation contributions at the element level we need the following results: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} d \widetilde{\mathbf{\mathsf{p}}} &amp; = \mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \bigl[ \mathbf{\mathsf{F}}_{\widetilde{J}} - \mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{J}} d \widetilde{\mathbf{\mathsf{J}}} \bigr] \\ d \widetilde{\mathbf{\mathsf{J}}} &amp; = \mathbf{\mathsf{K}}_{\widetilde{p}\widetilde{J}}^{-1} \bigl[ \mathbf{\mathsf{F}}_{\widetilde{p}} - \mathbf{\mathsf{K}}_{\widetilde{p}u} d \mathbf{\mathsf{u}} \bigr] \\ \Rightarrow d \widetilde{\mathbf{\mathsf{p}}} &amp;= \mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \mathbf{\mathsf{F}}_{\widetilde{J}} - \underbrace{\bigl[\mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{J}} \mathbf{\mathsf{K}}_{\widetilde{p}\widetilde{J}}^{-1}\bigr]}_{\overline{\mathbf{\mathsf{K}}}}\bigl[ \mathbf{\mathsf{F}}_{\widetilde{p}} - \mathbf{\mathsf{K}}_{\widetilde{p}u} d \mathbf{\mathsf{u}} \bigr] \end{align*}" src="form_3671.png"/>
</p>
<p> and thus </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \underbrace{\bigl[ \mathbf{\mathsf{K}}_{uu} + \overline{\overline{\mathbf{\mathsf{K}}}}~ \bigr] }_{\mathbf{\mathsf{K}}_{\textrm{con}}} d \mathbf{\mathsf{u}} = \underbrace{ \Bigl[ \mathbf{\mathsf{F}}_{u} - \mathbf{\mathsf{K}}_{u\widetilde{p}} \bigl[ \mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \mathbf{\mathsf{F}}_{\widetilde{J}} - \overline{\mathbf{\mathsf{K}}}\mathbf{\mathsf{F}}_{\widetilde{p}} \bigr] \Bigr]}_{\mathbf{\mathsf{F}}_{\textrm{con}}} \]" src="form_3672.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \overline{\overline{\mathbf{\mathsf{K}}}} := \mathbf{\mathsf{K}}_{u\widetilde{p}} \overline{\mathbf{\mathsf{K}}} \mathbf{\mathsf{K}}_{\widetilde{p}u} \, . \]" src="form_3673.png"/>
</p>
<p> Note that due to the choice of <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> as discontinuous at the element level, all matrices that need to be inverted are defined at the element level.</p>
<p>The procedure to construct the various contributions is as follows:</p><ul>
<li>Construct <img class="formulaInl" alt="$\mathbf{\mathsf{K}}$" src="form_3674.png"/>.</li>
<li>Form <img class="formulaInl" alt="$\mathbf{\mathsf{K}}_{\widetilde{p}\widetilde{J}}^{-1}$" src="form_3675.png"/> for element and store where <img class="formulaInl" alt="$\mathbf{\mathsf{K}}_{\widetilde{p}\widetilde{J}}$" src="form_3668.png"/> was stored in <img class="formulaInl" alt="$\mathbf{\mathsf{K}}$" src="form_3674.png"/>.</li>
<li>Form <img class="formulaInl" alt="$\overline{\overline{\mathbf{\mathsf{K}}}}$" src="form_3676.png"/> and add to <img class="formulaInl" alt="$\mathbf{\mathsf{K}}_{uu}$" src="form_3677.png"/> to get <img class="formulaInl" alt="$\mathbf{\mathsf{K}}_{\textrm{con}}$" src="form_3678.png"/></li>
<li>The modified system matrix is called <img class="formulaInl" alt="${\mathbf{\mathsf{K}}}_{\textrm{store}}$" src="form_3679.png"/>. That is <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{\mathsf{K}}_{\textrm{store}} := \begin{bmatrix} \mathbf{\mathsf{K}}_{\textrm{con}} &amp; \mathbf{\mathsf{K}}_{u\widetilde{p}} &amp; \mathbf{0} \\ \mathbf{\mathsf{K}}_{\widetilde{p}u} &amp; \mathbf{0} &amp; \mathbf{\mathsf{K}}_{\widetilde{p}\widetilde{J}}^{-1} \\ \mathbf{0} &amp; \mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{p}} &amp; \mathbf{\mathsf{K}}_{\widetilde{J}\widetilde{J}} \end{bmatrix} \, . \]" src="form_3680.png"/>
</p>
</li>
</ul>
<p><a class="anchor" id="Thematerialclass"></a></p><h3>The material class </h3>
<p>A good object-oriented design of a Material class would facilitate the extension of this tutorial to a wide range of material types. In this tutorial we simply have one Material class named Material_Compressible_Neo_Hook_Three_Field. Ideally this class would derive from a class HyperelasticMaterial which would derive from the base class Material. The three-field nature of the formulation used here also complicates the matter.</p>
<p>The Helmholtz free energy function for the three field formulation is <img class="formulaInl" alt="$\Psi = \Psi_\text{vol}(\widetilde{J}) + \Psi_\text{iso}(\overline{\mathbf{b}})$" src="form_3681.png"/>. The isochoric part of the Kirchhoff stress <img class="formulaInl" alt="${\boldsymbol{\tau}}_{\text{iso}}(\overline{\mathbf{b}})$" src="form_3682.png"/> is identical to that obtained using a one-field formulation for a hyperelastic material. However, the volumetric part of the free energy is now a function of the primary variable <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/>. Thus, for a three field formulation the constitutive response for the volumetric part of the Kirchhoff stress <img class="formulaInl" alt="${\boldsymbol{\tau}}_{\text{vol}}$" src="form_3683.png"/> (and the tangent) is not given by the hyperelastic constitutive law as in a one-field formulation. One can label the term <img class="formulaInl" alt="$\boldsymbol{\tau}_{\textrm{vol}} \equiv \widetilde{p} J \mathbf{I}$" src="form_3639.png"/> as the volumetric Kirchhoff stress, but the pressure <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> is not derived from the free energy; it is a primary field.</p>
<p>In order to have a flexible approach, it was decided that the Material_Compressible_Neo_Hook_Three_Field would still be able to calculate and return a volumetric Kirchhoff stress and tangent. In order to do this, we choose to store the interpolated primary fields <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> in the Material_Compressible_Neo_Hook_Three_Field class associated with the quadrature point. This decision should be revisited at a later stage when the tutorial is extended to account for other materials.</p>
<p><a class="anchor" id="Numericalexample"></a></p><h3>Numerical example </h3>
<p>The numerical example considered here is a nearly-incompressible block under compression. This benchmark problem is taken from</p><ul>
<li><p class="startli">S. Reese, P. Wriggers, B.D. Reddy (2000), A new locking-free brick element technique for large deformation problems in elasticity, <em> Computers and Structures </em>, <b> 75 </b>, 291-304. DOI: <a href="http://doi.org/10.1016/S0045-7949(99)00137-6">10.1016/S0045-7949(99)00137-6</a></p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.setup.png"/>
</div>
</li>
</ul>
<p>The material is quasi-incompressible neo-Hookean with <a href="http://en.wikipedia.org/wiki/Shear_modulus">shear modulus</a> <img class="formulaInl" alt="$\mu = 80.194e6$" src="form_3684.png"/> and <img class="formulaInl" alt="$\nu = 0.4999$" src="form_3685.png"/>. For such a choice of material properties a conventional single-field <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> approach would lock. That is, the response would be overly stiff. The initial and final configurations are shown in the image above. Using symmetry, we solve for only one quarter of the geometry (i.e. a cube with dimension <img class="formulaInl" alt="$0.001$" src="form_3686.png"/>). The inner-quarter of the upper surface of the domain is subject to a load of <img class="formulaInl" alt="$p_0$" src="form_3687.png"/>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>We start by including all the necessary deal.II header files and some C++ related ones. They have been discussed in detail in previous tutorial programs, so you need only refer to past tutorials for details.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/point.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/symmetric_tensor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/work_stream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div></div><!-- fragment --><p>This header gives us the functionality to store data at quadrature points</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_point_data.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgp_monomial.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q_eulerian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition_selector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div></div><!-- fragment --><p>Here are the headers necessary to use the <a class="el" href="classLinearOperator.html">LinearOperator</a> class. These are also all conveniently packaged into a single header file, namely &lt;deal.II/lac/linear_operator_tools.h&gt; but we list those specifically required here for the sake of transparency.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/linear_operator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/packaged_operation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/iterative_inverse.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div></div><!-- fragment --><p>Defined in these two headers are some operations that are pertinent to finite strain elasticity. The first will help us compute some kinematic quantities, and the second provides some stanard tensor definitions.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/physics/elasticity/kinematics.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/physics/elasticity/standard_tensors.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>We then stick everything that relates to this tutorial program into a namespace of its own, and import all the deal.II function and class names into it:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step44</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Runtimeparameters"></a> </p><h3>Run-time parameters</h3>
<p>There are several parameters that can be set in the code so we set up a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object to read in the choices at run-time.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Parameters</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="FiniteElementsystem"></a> </p><h4>Finite Element system</h4>
<p>As mentioned in the introduction, a different order interpolation should be used for the displacement <img class="formulaInl" alt="$\mathbf{u}$" src="form_1365.png"/> than for the pressure <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and the dilatation <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/>. Choosing <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> as discontinuous (constant) functions at the element level leads to the mean-dilatation method. The discontinuous approximation allows <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> to be condensed out and a classical displacement based method is recovered. Here we specify the polynomial order used to approximate the solution. The quadrature order should be adjusted accordingly.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classFESystem.html">FESystem</a></div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> poly_degree;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> quad_order;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> FESystem::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Finite element system&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Polynomial degree&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Displacement system polynomial order&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Gauss quadrature order&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> FESystem::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Finite element system&quot;</span>);</div><div class="line">  {</div><div class="line">    poly_degree = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Polynomial degree&quot;</span>);</div><div class="line">    quad_order = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Geometry"></a> </p><h4>Geometry</h4>
<p>Make adjustments to the problem geometry and the applied load. Since the problem modelled here is quite specific, the load scale can be altered to specific values to compare with the results given in the literature.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Geometry</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> global_refinement;</div><div class="line">  <span class="keywordtype">double</span>       <a class="code" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a>;</div><div class="line">  <span class="keywordtype">double</span>       p_p0;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Geometry::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Geometry&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Global refinement&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Global refinement level&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Grid scale&quot;</span>, <span class="stringliteral">&quot;1e-3&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Global grid scaling factor&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Pressure ratio p/p0&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;20|40|60|80|100&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Ratio of applied pressure to reference pressure&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Geometry::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Geometry&quot;</span>);</div><div class="line">  {</div><div class="line">    global_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Global refinement&quot;</span>);</div><div class="line">    <a class="code" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a> = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Grid scale&quot;</span>);</div><div class="line">    p_p0 = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Pressure ratio p/p0&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Materials"></a> </p><h4>Materials</h4>
<p>We also need the shear modulus <img class="formulaInl" alt="$ \mu $" src="form_3688.png"/> and Poisson ration <img class="formulaInl" alt="$ \nu $" src="form_3689.png"/> for the neo-Hookean material.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Materials</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> nu;</div><div class="line">  <span class="keywordtype">double</span> mu;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Materials::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Material properties&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>, <span class="stringliteral">&quot;0.4999&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(-1.0,0.5),</div><div class="line">                      <span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Shear modulus&quot;</span>, <span class="stringliteral">&quot;80.194e6&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Shear modulus&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Materials::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Material properties&quot;</span>);</div><div class="line">  {</div><div class="line">    nu = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>);</div><div class="line">    mu = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Shear modulus&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Linearsolver"></a> </p><h4>Linear solver</h4>
<p>Next, we choose both solver and preconditioner settings. The use of an effective preconditioner is critical to ensure convergence when a large nonlinear motion occurs within a Newton increment.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>LinearSolver</div><div class="line">{</div><div class="line">  std::string type_lin;</div><div class="line">  <span class="keywordtype">double</span>      tol_lin;</div><div class="line">  <span class="keywordtype">double</span>      max_iterations_lin;</div><div class="line">  <span class="keywordtype">bool</span>        use_static_condensation;</div><div class="line">  std::string preconditioner_type;</div><div class="line">  <span class="keywordtype">double</span>      preconditioner_relaxation;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearSolver::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Solver type&quot;</span>, <span class="stringliteral">&quot;CG&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|Direct&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Type of solver used to solve the linear system&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Residual&quot;</span>, <span class="stringliteral">&quot;1e-6&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Linear solver residual (scaled by residual norm)&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Max iteration multiplier&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Linear solver iterations (multiples of the system matrix size)&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Use static condensation&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Solve the full block system or a reduced problem&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Preconditioner type&quot;</span>, <span class="stringliteral">&quot;ssor&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;jacobi|ssor&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Type of preconditioner&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Preconditioner relaxation&quot;</span>, <span class="stringliteral">&quot;0.65&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Preconditioner relaxation value&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearSolver::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    type_lin = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Solver type&quot;</span>);</div><div class="line">    tol_lin = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Residual&quot;</span>);</div><div class="line">    max_iterations_lin = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Max iteration multiplier&quot;</span>);</div><div class="line">    use_static_condensation = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Use static condensation&quot;</span>);</div><div class="line">    preconditioner_type = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Preconditioner type&quot;</span>);</div><div class="line">    preconditioner_relaxation = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Preconditioner relaxation&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Nonlinearsolver"></a> </p><h4>Nonlinear solver</h4>
<p>A Newton-Raphson scheme is used to solve the nonlinear system of governing equations. We now define the tolerances and the maximum number of iterations for the Newton-Raphson nonlinear solver.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>NonlinearSolver</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations_NR;</div><div class="line">  <span class="keywordtype">double</span>       tol_f;</div><div class="line">  <span class="keywordtype">double</span>       tol_u;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> NonlinearSolver::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Max iterations Newton-Raphson&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Number of Newton-Raphson iterations allowed&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Tolerance force&quot;</span>, <span class="stringliteral">&quot;1.0e-9&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Force residual tolerance&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Tolerance displacement&quot;</span>, <span class="stringliteral">&quot;1.0e-6&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Displacement error tolerance&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> NonlinearSolver::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    max_iterations_NR = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Max iterations Newton-Raphson&quot;</span>);</div><div class="line">    tol_f = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Tolerance force&quot;</span>);</div><div class="line">    tol_u = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Tolerance displacement&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Time"></a> </p><h4>Time</h4>
<p>Set the timestep size <img class="formulaInl" alt="$ \varDelta t $" src="form_3690.png"/> and the simulation end-time.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Time</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> delta_t;</div><div class="line">  <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Time::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Time&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;End time&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                      <span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Time step size&quot;</span>, <span class="stringliteral">&quot;0.1&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Time step size&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Time::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Time&quot;</span>);</div><div class="line">  {</div><div class="line">    end_time = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line">    delta_t = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Time step size&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Allparameters"></a> </p><h4>All parameters</h4>
<p>Finally we consolidate all of the above structures into a single container that holds all of our run-time selections.</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>AllParameters : <span class="keyword">public</span> <a class="code" href="classFESystem.html">FESystem</a>,</div><div class="line">    <span class="keyword">public</span> Geometry,</div><div class="line">    <span class="keyword">public</span> Materials,</div><div class="line">    <span class="keyword">public</span> LinearSolver,</div><div class="line">    <span class="keyword">public</span> NonlinearSolver,</div><div class="line">    <span class="keyword">public</span> Time</div><div class="line"></div><div class="line">  {</div><div class="line">    AllParameters(<span class="keyword">const</span> std::string &amp;input_file);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">    declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">  };</div><div class="line"></div><div class="line">  AllParameters::AllParameters(<span class="keyword">const</span> std::string &amp;input_file)</div><div class="line">  {</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">    declare_parameters(prm);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a>(input_file);</div><div class="line">    parse_parameters(prm);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> AllParameters::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    FESystem::declare_parameters(prm);</div><div class="line">    Geometry::declare_parameters(prm);</div><div class="line">    Materials::declare_parameters(prm);</div><div class="line">    LinearSolver::declare_parameters(prm);</div><div class="line">    NonlinearSolver::declare_parameters(prm);</div><div class="line">    Time::declare_parameters(prm);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> AllParameters::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    FESystem::parse_parameters(prm);</div><div class="line">    Geometry::parse_parameters(prm);</div><div class="line">    Materials::parse_parameters(prm);</div><div class="line">    LinearSolver::parse_parameters(prm);</div><div class="line">    NonlinearSolver::parse_parameters(prm);</div><div class="line">    Time::parse_parameters(prm);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Timeclass"></a> </p><h3>Time class</h3>
<p>A simple class to store time data. Its functioning is transparent so no discussion is necessary. For simplicity we assume a constant time step size.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Time</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Time (<span class="keyword">const</span> <span class="keywordtype">double</span> time_end,</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t)</div><div class="line">    :</div><div class="line">    timestep(0),</div><div class="line">    time_current(0.0),</div><div class="line">    time_end(time_end),</div><div class="line">    delta_t(delta_t)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~Time()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> current()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> time_current;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">double</span> end()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> time_end;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">double</span> get_delta_t()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> delta_t;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> get_timestep()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> timestep;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> increment()</div><div class="line">  {</div><div class="line">    time_current += delta_t;</div><div class="line">    ++timestep;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep;</div><div class="line">  <span class="keywordtype">double</span>       time_current;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_end;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="CompressibleneoHookeanmaterialwithinathreefieldformulation"></a> </p><h3>Compressible neo-Hookean material within a three-field formulation</h3>
<p>As discussed in the Introduction, Neo-Hookean materials are a type of hyperelastic materials. The entire domain is assumed to be composed of a compressible neo-Hookean material. This class defines the behaviour of this material within a three-field formulation. Compressible neo-Hookean materials can be described by a strain-energy function (SEF) <img class="formulaInl" alt="$ \Psi = \Psi_{\text{iso}}(\overline{\mathbf{b}}) + \Psi_{\text{vol}}(\widetilde{J}) $" src="form_3691.png"/>.</p>
<p>The isochoric response is given by <img class="formulaInl" alt="$ \Psi_{\text{iso}}(\overline{\mathbf{b}}) = c_{1} [\overline{I}_{1} - 3] $" src="form_3692.png"/> where <img class="formulaInl" alt="$ c_{1} = \frac{\mu}{2} $" src="form_3693.png"/> and <img class="formulaInl" alt="$\overline{I}_{1}$" src="form_3694.png"/> is the first invariant of the left- or right-isochoric Cauchy-Green deformation tensors. That is <img class="formulaInl" alt="$\overline{I}_1 :=\textrm{tr}(\overline{\mathbf{b}})$" src="form_3695.png"/>. In this example the SEF that governs the volumetric response is defined as <img class="formulaInl" alt="$ \Psi_{\text{vol}}(\widetilde{J}) = \kappa \frac{1}{4} [ \widetilde{J}^2 - 1 - 2\textrm{ln}\; \widetilde{J} ]$" src="form_3696.png"/>, where <img class="formulaInl" alt="$\kappa:= \lambda + 2/3 \mu$" src="form_3697.png"/> is the <a href="http://en.wikipedia.org/wiki/Bulk_modulus">bulk modulus</a> and <img class="formulaInl" alt="$\lambda$" src="form_548.png"/> is <a href="http://en.wikipedia.org/wiki/Lam%C3%A9_parameters">Lame's first parameter</a>.</p>
<p>The following class will be used to characterize the material we work with, and provides a central point that one would need to modify if one were to implement a different material model. For it to work, we will store one object of this type per quadrature point, and in each of these objects store the current state (characterized by the values or measures of the three fields) so that we can compute the elastic coefficients linearized around the current state.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Material_Compressible_Neo_Hook_Three_Field</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Material_Compressible_Neo_Hook_Three_Field(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span> nu)</div><div class="line">    :</div><div class="line">    kappa((2.0 * mu * (1.0 + nu)) / (3.0 * (1.0 - 2.0 * nu))),</div><div class="line">    c_1(mu / 2.0),</div><div class="line">    det_F(1.0),</div><div class="line">    p_tilde(0.0),</div><div class="line">    J_tilde(1.0),</div><div class="line">    b_bar(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(kappa &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  }</div><div class="line"></div><div class="line">  ~Material_Compressible_Neo_Hook_Three_Field()</div><div class="line">  {}</div></div><!-- fragment --><p>We update the material model with various deformation dependent data based on <img class="formulaInl" alt="$F$" src="form_249.png"/> and the pressure <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and dilatation <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/>, and at the end of the function include a physical check for internal consistency:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> update_material_data(<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &amp;F,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> p_tilde_in,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> J_tilde_in)</div><div class="line">{</div><div class="line">  det_F = <a class="code" href="classSymmetricTensor.html#a31d48ca1d251a7a32db8b673e6010193">determinant</a>(F);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_bar = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae8c571720db885e3636e396f6e153317">Physics::Elasticity::Kinematics::F_iso</a>(F);</div><div class="line">  b_bar = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">Physics::Elasticity::Kinematics::b</a>(F_bar);</div><div class="line">  p_tilde = p_tilde_in;</div><div class="line">  J_tilde = J_tilde_in;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(det_F &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">}</div></div><!-- fragment --><p>The second function determines the Kirchhoff stress <img class="formulaInl" alt="$\boldsymbol{\tau} = \boldsymbol{\tau}_{\textrm{iso}} + \boldsymbol{\tau}_{\textrm{vol}}$" src="form_3698.png"/></p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau()</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> get_tau_iso() + get_tau_vol();</div><div class="line">}</div></div><!-- fragment --><p>The fourth-order elasticity tensor in the spatial setting <img class="formulaInl" alt="$\mathfrak{c}$" src="form_3613.png"/> is calculated from the SEF <img class="formulaInl" alt="$\Psi$" src="form_99.png"/> as <img class="formulaInl" alt="$ J \mathfrak{c}_{ijkl} = F_{iA} F_{jB} \mathfrak{C}_{ABCD} F_{kC} F_{lD}$" src="form_3699.png"/> where <img class="formulaInl" alt="$ \mathfrak{C} = 4 \frac{\partial^2 \Psi(\mathbf{C})}{\partial \mathbf{C} \partial \mathbf{C}}$" src="form_3700.png"/></p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_Jc()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> get_Jc_vol() + get_Jc_iso();</div><div class="line">}</div></div><!-- fragment --><p>Derivative of the volumetric free energy with respect to <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> return <img class="formulaInl" alt="$\frac{\partial \Psi_{\text{vol}}(\widetilde{J})}{\partial \widetilde{J}}$" src="form_3701.png"/></p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_dPsi_vol_dJ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (kappa / 2.0) * (J_tilde - 1.0 / J_tilde);</div><div class="line">}</div></div><!-- fragment --><p>Second derivative of the volumetric free energy wrt <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/>. We need the following computation explicitly in the tangent so we make it public. We calculate <img class="formulaInl" alt="$\frac{\partial^2 \Psi_{\textrm{vol}}(\widetilde{J})}{\partial \widetilde{J} \partial \widetilde{J}}$" src="form_3702.png"/></p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_d2Psi_vol_dJ2()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> ( (kappa / 2.0) * (1.0 + 1.0 / (J_tilde * J_tilde)));</div><div class="line">}</div></div><!-- fragment --><p>The next few functions return various data that we choose to store with the material:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> det_F;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_p_tilde()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> p_tilde;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_J_tilde()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> J_tilde;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div></div><!-- fragment --><p>Define constitutive model parameters <img class="formulaInl" alt="$\kappa$" src="form_2495.png"/> (bulk modulus) and the neo-Hookean model parameter <img class="formulaInl" alt="$c_1$" src="form_2130.png"/>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> c_1;</div></div><!-- fragment --><p>Model specific data that is convenient to store with the material:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> det_F;</div><div class="line"><span class="keywordtype">double</span> p_tilde;</div><div class="line"><span class="keywordtype">double</span> J_tilde;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> b_bar;</div></div><!-- fragment --><p>The following functions are used internally in determining the result of some of the public functions above. The first one determines the volumetric Kirchhoff stress <img class="formulaInl" alt="$\boldsymbol{\tau}_{\textrm{vol}}$" src="form_3703.png"/>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau_vol()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> p_tilde * det_F * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">}</div></div><!-- fragment --><p>Next, determine the isochoric Kirchhoff stress <img class="formulaInl" alt="$\boldsymbol{\tau}_{\textrm{iso}} = \mathcal{P}:\overline{\boldsymbol{\tau}}$" src="form_3704.png"/>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau_iso()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::dev_P</a> * get_tau_bar();</div><div class="line">}</div></div><!-- fragment --><p>Then, determine the fictitious Kirchhoff stress <img class="formulaInl" alt="$\overline{\boldsymbol{\tau}}$" src="form_3600.png"/>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau_bar()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 2.0 * c_1 * b_bar;</div><div class="line">}</div></div><!-- fragment --><p>Calculate the volumetric part of the tangent <img class="formulaInl" alt="$J \mathfrak{c}_\textrm{vol}$" src="form_3705.png"/>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_Jc_vol()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> p_tilde * det_F</div><div class="line">         * ( <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::IxI</a></div><div class="line">             - (2.0 * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::S</a>) );</div><div class="line">}</div></div><!-- fragment --><p>Calculate the isochoric part of the tangent <img class="formulaInl" alt="$J \mathfrak{c}_\textrm{iso}$" src="form_3706.png"/>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_Jc_iso()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau_bar = get_tau_bar();</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau_iso = get_tau_iso();</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> tau_iso_x_I</div><div class="line">    = <a class="code" href="classSymmetricTensor.html#ad8e50332a8602d09d12091217f775bec">outer_product</a>(tau_iso,</div><div class="line">                    <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> I_x_tau_iso</div><div class="line">    = <a class="code" href="classSymmetricTensor.html#ad8e50332a8602d09d12091217f775bec">outer_product</a>(<a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>,</div><div class="line">                    tau_iso);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> c_bar = get_c_bar();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (2.0 / dim) * <a class="code" href="classSymmetricTensor.html#a05096e7bc18fa734eae3bd1a5f08138e">trace</a>(tau_bar)</div><div class="line">         * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::dev_P</a></div><div class="line">         - (2.0 / dim) * (tau_iso_x_I + I_x_tau_iso)</div><div class="line">         + <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::dev_P</a> * c_bar</div><div class="line">         * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::dev_P</a>;</div><div class="line">}</div></div><!-- fragment --><p>Calculate the fictitious elasticity tensor <img class="formulaInl" alt="$\overline{\mathfrak{c}}$" src="form_3618.png"/>. For the material model chosen this is simply zero:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_c_bar()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a>();</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Quadraturepointhistory"></a> </p><h3><a class="el" href="classQuadrature.html">Quadrature</a> point history</h3>
<p>As seen in <a class="el" href="step_18.html">step-18</a>, the <code> PointHistory </code> class offers a method for storing data at the quadrature points. Here each quadrature point holds a pointer to a material description. Thus, different material models can be used in different regions of the domain. Among other data, we choose to store the Kirchhoff stress <img class="formulaInl" alt="$\boldsymbol{\tau}$" src="form_3707.png"/> and the tangent <img class="formulaInl" alt="$J\mathfrak{c}$" src="form_3708.png"/> for the quadrature points.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PointHistory</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PointHistory()</div><div class="line">    :</div><div class="line">    F_inv(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I),</div><div class="line">    tau(<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt;()),</div><div class="line">    d2Psi_vol_dJ2(0.0),</div><div class="line">    dPsi_vol_dJ(0.0),</div><div class="line">    Jc(<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;4, dim&gt;())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~PointHistory()</div><div class="line">  {}</div></div><!-- fragment --><p>The first function is used to create a material object and to initialize all tensors correctly: The second one updates the stored values and stresses based on the current deformation measure <img class="formulaInl" alt="$\textrm{Grad}\mathbf{u}_{\textrm{n}}$" src="form_3709.png"/>, pressure <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and dilation <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> field values.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_lqp (<span class="keyword">const</span> Parameters::AllParameters &amp;parameters)</div><div class="line">{</div><div class="line">  material.reset(<span class="keyword">new</span> Material_Compressible_Neo_Hook_Three_Field&lt;dim&gt;(parameters.mu,</div><div class="line">                 parameters.nu));</div><div class="line">  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(), 0.0, 1.0);</div><div class="line">}</div></div><!-- fragment --><p>To this end, we calculate the deformation gradient <img class="formulaInl" alt="$\mathbf{F}$" src="form_139.png"/> from the displacement gradient <img class="formulaInl" alt="$\textrm{Grad}\ \mathbf{u}$" src="form_3710.png"/>, i.e. <img class="formulaInl" alt="$\mathbf{F}(\mathbf{u}) = \mathbf{I} + \textrm{Grad}\ \mathbf{u}$" src="form_3711.png"/> and then let the material model associated with this quadrature point update itself. When computing the deformation gradient, we have to take care with which data types we compare the sum <img class="formulaInl" alt="$\mathbf{I} + \textrm{Grad}\ \mathbf{u}$" src="form_3712.png"/>: Since <img class="formulaInl" alt="$I$" src="form_3379.png"/> has data type <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>, just writing <code>I + Grad_u_n</code> would convert the second argument to a symmetric tensor, perform the sum, and then cast the result to a <a class="el" href="classTensor.html">Tensor</a> (i.e., the type of a possibly nonsymmetric tensor). However, since <code>Grad_u_n</code> is nonsymmetric in general, the conversion to <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> will fail. We can avoid this back and forth by converting <img class="formulaInl" alt="$I$" src="form_3379.png"/> to <a class="el" href="classTensor.html">Tensor</a> first, and then performing the addition as between nonsymmetric tensors:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> (<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &amp;Grad_u_n,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> p_tilde,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> J_tilde)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">Physics::Elasticity::Kinematics::F</a>(Grad_u_n);</div><div class="line">  material-&gt;update_material_data(F, p_tilde, J_tilde);</div></div><!-- fragment --><p>The material has been updated so we now calculate the Kirchhoff stress <img class="formulaInl" alt="$\mathbf{\tau}$" src="form_3713.png"/>, the tangent <img class="formulaInl" alt="$J\mathfrak{c}$" src="form_3708.png"/> and the first and second derivatives of the volumetric free energy.</p>
<p>We also store the inverse of the deformation gradient since we frequently use it:</p>
<div class="fragment"><div class="line">  F_inv = <a class="code" href="classSymmetricTensor.html#a6270f4610919ac288e2bb142588c1b2f">invert</a>(F);</div><div class="line">  tau = material-&gt;get_tau();</div><div class="line">  Jc = material-&gt;get_Jc();</div><div class="line">  dPsi_vol_dJ = material-&gt;get_dPsi_vol_dJ();</div><div class="line">  d2Psi_vol_dJ2 = material-&gt;get_d2Psi_vol_dJ2();</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>We offer an interface to retrieve certain data. Here are the kinematic variables:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_J_tilde()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> material-&gt;get_J_tilde();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> material-&gt;get_det_F();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &amp;get_F_inv()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> F_inv;</div><div class="line">}</div></div><!-- fragment --><p>...and the kinetic variables. These are used in the material and global tangent matrix and residual assembly operations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_p_tilde()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> material-&gt;get_p_tilde();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_tau()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> tau;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_dPsi_vol_dJ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> dPsi_vol_dJ;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_d2Psi_vol_dJ2()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> d2Psi_vol_dJ2;</div><div class="line">}</div></div><!-- fragment --><p>And finally the tangent:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_Jc()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> Jc;</div><div class="line">}</div></div><!-- fragment --><p>In terms of member functions, this class stores for the quadrature point it represents a copy of a material type in case different materials are used in different regions of the domain, as well as the inverse of the deformation gradient...</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::shared_ptr&lt; Material_Compressible_Neo_Hook_Three_Field&lt;dim&gt; &gt; material;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_inv;</div></div><!-- fragment --><p>... and stress-type variables along with the tangent <img class="formulaInl" alt="$J\mathfrak{c}$" src="form_3708.png"/>:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau;</div><div class="line">  <span class="keywordtype">double</span>                  d2Psi_vol_dJ2;</div><div class="line">  <span class="keywordtype">double</span>                  dPsi_vol_dJ;</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Jc;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Quasistaticquasiincompressiblefinitestrainsolid"></a> </p><h3>Quasi-static quasi-incompressible finite-strain solid</h3>
<p>The Solid class is the central class in that it represents the problem at hand. It follows the usual scheme in that all it really has is a constructor, destructor and a <code>run()</code> function that dispatches all the work to private functions of this class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solid</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Solid(<span class="keyword">const</span> std::string &amp;input_file);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  ~Solid();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  run();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>In the private section of this class, we first forward declare a number of objects that are used in parallelizing work using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> object (see the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> module for more information on this).</p>
<p>We declare such structures for the computation of tangent (stiffness) matrix, right hand side, static condensation, and for updating quadrature points:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PerTaskData_K;</div><div class="line"><span class="keyword">struct </span>ScratchData_K;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>PerTaskData_RHS;</div><div class="line"><span class="keyword">struct </span>ScratchData_RHS;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>PerTaskData_SC;</div><div class="line"><span class="keyword">struct </span>ScratchData_SC;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>PerTaskData_UQPH;</div><div class="line"><span class="keyword">struct </span>ScratchData_UQPH;</div></div><!-- fragment --><p>We start the collection of member functions with one that builds the grid:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">make_grid();</div></div><!-- fragment --><p>Set up the finite element system to be solved:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">system_setup();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">determine_component_extractors();</div></div><!-- fragment --><p>Several functions to assemble the system and right hand side matrices using multithreading. Each of them comes as a wrapper function, one that is executed to do the work in the <a class="el" href="namespaceWorkStream.html">WorkStream</a> model on one cell, and one that copies the work done on this one cell into the global object that represents it:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_system_tangent();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_system_tangent_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                 ScratchData_K &amp;scratch,</div><div class="line">                                 PerTaskData_K &amp;data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_K(<span class="keyword">const</span> PerTaskData_K &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_system_rhs();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_system_rhs_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                             ScratchData_RHS &amp;scratch,</div><div class="line">                             PerTaskData_RHS &amp;data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_rhs(<span class="keyword">const</span> PerTaskData_RHS &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_sc();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_sc_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                     ScratchData_SC &amp;scratch,</div><div class="line">                     PerTaskData_SC &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_sc(<span class="keyword">const</span> PerTaskData_SC &amp;data);</div></div><!-- fragment --><p>Apply Dirichlet boundary conditions on the displacement field</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">make_constraints(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;it_nr);</div></div><!-- fragment --><p>Create and update the quadrature points. Here, no data needs to be copied into a global object, so the copy_local_to_global function is empty:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">setup_qph();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">update_qph_incremental(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">update_qph_incremental_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                ScratchData_UQPH &amp;scratch,</div><div class="line">                                PerTaskData_UQPH &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_UQPH(<span class="keyword">const</span> PerTaskData_UQPH &amp;/ *data* /)</div><div class="line">{}</div></div><!-- fragment --><p>Solve for the displacement using a Newton-Raphson method. We break this function into the nonlinear loop and the function that solves the linearized Newton-Raphson step:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">solve_nonlinear_timestep(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta);</div><div class="line"></div><div class="line">std::pair&lt;unsigned int, double&gt;</div><div class="line">solve_linear_system(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update);</div></div><!-- fragment --><p>Solution retrieval as well as post-processing and writing data to file :</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">get_total_solution(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">output_results() <span class="keyword">const</span>;</div></div><!-- fragment --><p>Finally, some member variables that describe the current state: A collection of the parameters used to describe the problem setup...</p>
<div class="fragment"><div class="line">Parameters::AllParameters parameters;</div></div><!-- fragment --><p>...the volume of the reference configuration...</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>                    vol_reference;</div></div><!-- fragment --><p>...and description of the geometry on which the problem is solved:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        triangulation;</div></div><!-- fragment --><p>Also, keep track of the current time and the time spent evaluating certain functions</p>
<div class="fragment"><div class="line">Time                      time;</div><div class="line"><span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a>       timer;</div></div><!-- fragment --><p>A storage object for quadrature point information. As opposed to <a class="el" href="step_18.html">step-18</a>, deal.II's native quadrature point data manager is employed here.</p>
<div class="fragment"><div class="line"><a class="code" href="classCellDataStorage.html">CellDataStorage&lt;typename Triangulation&lt;dim&gt;::cell_iterator</a>,</div><div class="line">                PointHistory&lt;dim&gt; &gt; quadrature_point_history;</div></div><!-- fragment --><p>A description of the finite-element system including the displacement polynomial degree, the degree-of-freedom handler, number of DoFs per cell and the extractor objects used to retrieve information from the solution vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               degree;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>              fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                  dof_handler_ref;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               dofs_per_cell;</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> u_fe;</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> p_fe;</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> J_fe;</div></div><!-- fragment --><p>Description of how the block-system is arranged. There are 3 blocks, the first contains a vector DOF <img class="formulaInl" alt="$\mathbf{u}$" src="form_1365.png"/> while the other two describe scalar DOFs, <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/>.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_blocks = 3;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_components = dim + 2;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> first_u_component = 0;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_component = dim;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> J_component = dim + 1;</div><div class="line"></div><div class="line"><span class="keyword">enum</span></div><div class="line">{</div><div class="line">  u_dof = 0,</div><div class="line">  p_dof = 1,</div><div class="line">  J_dof = 2</div><div class="line">};</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; dofs_per_block;</div><div class="line">std::vector&lt;types::global_dof_index&gt; element_indices_u;</div><div class="line">std::vector&lt;types::global_dof_index&gt; element_indices_p;</div><div class="line">std::vector&lt;types::global_dof_index&gt; element_indices_J;</div></div><!-- fragment --><p>Rules for Gauss-quadrature on both the cell and faces. The number of quadrature points on both cells and faces is recorded.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     qf_cell;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; qf_face;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    n_q_points;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    n_q_points_f;</div></div><!-- fragment --><p>Objects that store the converged solution and right-hand side vectors, as well as the tangent matrix. There is a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object used to keep track of constraints. We make use of a sparsity pattern designed for a block system.</p>
<div class="fragment"><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>          constraints;</div><div class="line"><a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> tangent_matrix;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       system_rhs;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       solution_n;</div></div><!-- fragment --><p>Then define a number of variables to store norms and update norms and normalisation factors.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Errors</div><div class="line">{</div><div class="line">  Errors()</div><div class="line">    :</div><div class="line">    norm(1.0), u(1.0), p(1.0), J(1.0)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    norm = 1.0;</div><div class="line">    u = 1.0;</div><div class="line">    p = 1.0;</div><div class="line">    J = 1.0;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> normalise(<span class="keyword">const</span> Errors &amp;rhs)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rhs.norm != 0.0)</div><div class="line">      norm /= rhs.norm;</div><div class="line">    <span class="keywordflow">if</span> (rhs.u != 0.0)</div><div class="line">      u /= rhs.u;</div><div class="line">    <span class="keywordflow">if</span> (rhs.p != 0.0)</div><div class="line">      p /= rhs.p;</div><div class="line">    <span class="keywordflow">if</span> (rhs.J != 0.0)</div><div class="line">      J /= rhs.J;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> norm, u, p, J;</div><div class="line">};</div><div class="line"></div><div class="line">Errors error_residual, error_residual_0, error_residual_norm, error_update,</div><div class="line">       error_update_0, error_update_norm;</div></div><!-- fragment --><p>Methods to calculate error measures</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">get_error_residual(Errors &amp;error_residual);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">get_error_update(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update,</div><div class="line">                 Errors &amp;error_update);</div><div class="line"></div><div class="line">std::pair&lt;double, double&gt;</div><div class="line">get_error_dilation() <span class="keyword">const</span>;</div></div><!-- fragment --><p>Compute the volume in the spatial configuration</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span></div><div class="line">compute_vol_current () <span class="keyword">const</span>;</div></div><!-- fragment --><p>Print information to screen in a pleasing way...</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  print_conv_header();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  print_conv_footer();</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeSolidcodeclass"></a> </p><h3>Implementation of the <code>Solid</code> class</h3>
<p><a class="anchor" id="Publicinterface"></a> </p><h4>Public interface</h4>
<p>We initialise the Solid class using data extracted from the parameter file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solid&lt;dim&gt;::Solid(<span class="keyword">const</span> std::string &amp;input_file)</div><div class="line">  :</div><div class="line">  parameters(input_file),</div><div class="line">  vol_reference(0.),</div><div class="line">  triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing),</div><div class="line">  time(parameters.end_time, parameters.delta_t),</div><div class="line">  timer(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times),</div><div class="line">  degree(parameters.poly_degree),</div></div><!-- fragment --><p>The Finite Element System is composed of dim continuous displacement DOFs, and discontinuous pressure and dilatation DOFs. In an attempt to satisfy the Babuska-Brezzi or LBB stability conditions (see Hughes (2000)), we setup a <img class="formulaInl" alt="$Q_n \times DGPM_{n-1} \times DGPM_{n-1}$" src="form_3661.png"/> system. <img class="formulaInl" alt="$Q_2 \times DGPM_1 \times DGPM_1$" src="form_3714.png"/> elements satisfy this condition, while <img class="formulaInl" alt="$Q_1 \times DGPM_0 \times DGPM_0$" src="form_3663.png"/> elements do not. However, it has been shown that the latter demonstrate good convergence characteristics nonetheless.</p>
<div class="fragment"><div class="line">  fe(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(parameters.poly_degree), dim, <span class="comment">// displacement</span></div><div class="line">     <a class="code" href="classFE__DGPMonomial.html">FE_DGPMonomial&lt;dim&gt;</a>(parameters.poly_degree - 1), 1, <span class="comment">// pressure</span></div><div class="line">     <a class="code" href="classFE__DGPMonomial.html">FE_DGPMonomial&lt;dim&gt;</a>(parameters.poly_degree - 1), 1), <span class="comment">// dilatation</span></div><div class="line">  dof_handler_ref(triangulation),</div><div class="line">  dofs_per_cell (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>),</div><div class="line">  u_fe(first_u_component),</div><div class="line">  p_fe(p_component),</div><div class="line">  J_fe(J_component),</div><div class="line">  dofs_per_block(n_blocks),</div><div class="line">  qf_cell(parameters.quad_order),</div><div class="line">  qf_face(parameters.quad_order),</div><div class="line">  n_q_points (qf_cell.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>()),</div><div class="line">  n_q_points_f (qf_face.size())</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim==2 || dim==3, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;This problem only works in 2 or 3 space dimensions.&quot;</span>));</div><div class="line">  determine_component_extractors();</div><div class="line">}</div></div><!-- fragment --><p>The class destructor simply clears the data held by the DOFHandler</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solid&lt;dim&gt;::~Solid()</div><div class="line">{</div><div class="line">  dof_handler_ref.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">}</div></div><!-- fragment --><p>In solving the quasi-static problem, the time becomes a loading parameter, i.e. we increasing the loading linearly with time, making the two concepts interchangeable. We choose to increment time linearly using a constant time step size.</p>
<p>We start the function with preprocessing, setting the initial dilatation values, and then output the initial grid before starting the simulation proper with the first time (and loading) increment.</p>
<p>Care must be taken (or at least some thought given) when imposing the constraint <img class="formulaInl" alt="$\widetilde{J}=1$" src="form_3715.png"/> on the initial solution field. The constraint corresponds to the determinant of the deformation gradient in the undeformed configuration, which is the identity tensor. We use <a class="el" href="classFE__DGPMonomial.html">FE_DGPMonomial</a> bases to interpolate the dilatation field, thus we can't simply set the corresponding dof to unity as they correspond to the monomial coefficients. Thus we use the <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> function to do the work for us. The <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> function requires an argument indicating the hanging node constraints. We have none in this program So we have to create a constraint object. In its original state, constraint objects are unsorted, and have to be sorted (using the <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">ConstraintMatrix::close</a> function) before they can be used. Have a look at <a class="el" href="step_21.html">step-21</a> for more information. We only need to enforce the initial condition on the dilatation. In order to do this, we make use of a <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> which acts as a mask and sets the J_component of n_components to 1. This is exactly what we want. Have a look at its usage in <a class="el" href="step_20.html">step-20</a> for more information.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::run()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line">  system_setup();</div><div class="line">  {</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a></div><div class="line">    J_mask (J_component, n_components);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> (dof_handler_ref,</div><div class="line">                          constraints,</div><div class="line">                          <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree+2),</div><div class="line">                          J_mask,</div><div class="line">                          solution_n);</div><div class="line">  }</div><div class="line">  output_results();</div><div class="line">  time.increment();</div></div><!-- fragment --><p>We then declare the incremental solution update <img class="formulaInl" alt="$\varDelta \mathbf{\Xi}:= \{\varDelta \mathbf{u},\varDelta \widetilde{p}, \varDelta \widetilde{J} \}$" src="form_3716.png"/> and start the loop over the time domain.</p>
<p>At the beginning, we reset the solution update for this time step...</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution_delta(dofs_per_block);</div><div class="line"><span class="keywordflow">while</span> (time.current() &lt; time.end())</div><div class="line">  {</div><div class="line">    solution_delta = 0.0;</div></div><!-- fragment --><p>...solve the current time step and update total solution vector <img class="formulaInl" alt="$\mathbf{\Xi}_{\textrm{n}} = \mathbf{\Xi}_{\textrm{n-1}} + \varDelta \mathbf{\Xi}$" src="form_3717.png"/>...</p>
<div class="fragment"><div class="line">solve_nonlinear_timestep(solution_delta);</div><div class="line">solution_n += solution_delta;</div></div><!-- fragment --><p>...and plot the results before moving on happily to the next time step:</p>
<div class="fragment"><div class="line">      output_results();</div><div class="line">      time.increment();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Privateinterface"></a> </p><h3>Private interface</h3>
<p><a class="anchor" id="Threadingbuildingblocksstructures"></a> </p><h4>Threading-building-blocks structures</h4>
<p>The first group of private member functions is related to parallization. We use the Threading Building Blocks library (TBB) to perform as many computationally intensive distributed tasks as possible. In particular, we assemble the tangent matrix and right hand side vector, the static condensation contributions, and update data stored at the quadrature points using TBB. Our main tool for this is the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class (see the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> module for more information).</p>
<p>Firstly we deal with the tangent matrix assembly structures. The PerTaskData object stores local contributions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_K</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        cell_matrix;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  PerTaskData_K(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    :</div><div class="line">    cell_matrix(dofs_per_cell, dofs_per_cell),</div><div class="line">    local_dof_indices(dofs_per_cell)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    cell_matrix = 0.0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>On the other hand, the ScratchData object stores the larger objects such as the shape-function values array (<code>Nx</code>) and a shape function gradient and symmetric gradient vector which we will use during the assembly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_K</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_ref;</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;double&gt; &gt;                   Nx;</div><div class="line">  std::vector&lt;std::vector&lt;Tensor&lt;2, dim&gt; &gt; &gt;          grad_Nx;</div><div class="line">  std::vector&lt;std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; &gt; symm_grad_Nx;</div><div class="line"></div><div class="line">  ScratchData_K(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_cell,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;qf_cell,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell)</div><div class="line">    :</div><div class="line">    fe_values_ref(fe_cell, qf_cell, uf_cell),</div><div class="line">    Nx(qf_cell.size(),</div><div class="line">       <a class="code" href="namespacestd.html">std</a>::vector&lt;double&gt;(fe_cell.dofs_per_cell)),</div><div class="line">    grad_Nx(qf_cell.size(),</div><div class="line">            <a class="code" href="namespacestd.html">std</a>::vector&lt;<a class="code" href="classTensor.html">Tensor</a>&lt;2, dim&gt; &gt;(fe_cell.dofs_per_cell)),</div><div class="line">    symm_grad_Nx(qf_cell.size(),</div><div class="line">                 <a class="code" href="namespacestd.html">std</a>::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt; &gt;</div><div class="line">                 (fe_cell.dofs_per_cell))</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData_K(<span class="keyword">const</span> ScratchData_K &amp;rhs)</div><div class="line">    :</div><div class="line">    fe_values_ref(rhs.fe_values_ref.get_fe(),</div><div class="line">                  rhs.fe_values_ref.get_quadrature(),</div><div class="line">                  rhs.fe_values_ref.get_update_flags()),</div><div class="line">    Nx(rhs.Nx),</div><div class="line">    grad_Nx(rhs.grad_Nx),</div><div class="line">    symm_grad_Nx(rhs.symm_grad_Nx)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = Nx.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_per_cell = Nx[0].size();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( Nx[q_point].size() == n_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( grad_Nx[q_point].size() == n_dofs_per_cell,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( symm_grad_Nx[q_point].size() == n_dofs_per_cell,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; n_dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            Nx[q_point][k] = 0.0;</div><div class="line">            grad_Nx[q_point][k] = 0.0;</div><div class="line">            symm_grad_Nx[q_point][k] = 0.0;</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Next, the same approach is used for the right-hand side assembly. The PerTaskData object again stores local contributions and the ScratchData object the shape function object and precomputed values vector:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_RHS</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  PerTaskData_RHS(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    :</div><div class="line">    cell_rhs(dofs_per_cell),</div><div class="line">    local_dof_indices(dofs_per_cell)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    cell_rhs = 0.0;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_RHS</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_ref;</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_ref;</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;double&gt; &gt;                   Nx;</div><div class="line">  std::vector&lt;std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; &gt; symm_grad_Nx;</div><div class="line"></div><div class="line">  ScratchData_RHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_cell,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;qf_cell, <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a> &amp; qf_face, <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_face)</div><div class="line">    :</div><div class="line">    fe_values_ref(fe_cell, qf_cell, uf_cell),</div><div class="line">    fe_face_values_ref(fe_cell, qf_face, uf_face),</div><div class="line">    Nx(qf_cell.size(),</div><div class="line">       <a class="code" href="namespacestd.html">std</a>::vector&lt;double&gt;(fe_cell.dofs_per_cell)),</div><div class="line">    symm_grad_Nx(qf_cell.size(),</div><div class="line">                 <a class="code" href="namespacestd.html">std</a>::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt; &gt;</div><div class="line">                 (fe_cell.dofs_per_cell))</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData_RHS(<span class="keyword">const</span> ScratchData_RHS &amp;rhs)</div><div class="line">    :</div><div class="line">    fe_values_ref(rhs.fe_values_ref.get_fe(),</div><div class="line">                  rhs.fe_values_ref.get_quadrature(),</div><div class="line">                  rhs.fe_values_ref.get_update_flags()),</div><div class="line">    fe_face_values_ref(rhs.fe_face_values_ref.get_fe(),</div><div class="line">                       rhs.fe_face_values_ref.get_quadrature(),</div><div class="line">                       rhs.fe_face_values_ref.get_update_flags()),</div><div class="line">    Nx(rhs.Nx),</div><div class="line">    symm_grad_Nx(rhs.symm_grad_Nx)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = Nx.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_per_cell = Nx[0].size();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( Nx[q_point].size() == n_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( symm_grad_Nx[q_point].size() == n_dofs_per_cell,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; n_dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            Nx[q_point][k] = 0.0;</div><div class="line">            symm_grad_Nx[q_point][k] = 0.0;</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Then we define structures to assemble the statically condensed tangent matrix. Recall that we wish to solve for a displacement-based formulation. We do the condensation at the element level as the <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> fields are element-wise discontinuous. As these operations are matrix-based, we need to setup a number of matrices to store the local contributions from a number of the tangent matrix sub-blocks. We place these in the PerTaskData struct.</p>
<p>We choose not to reset any data in the <code>reset()</code> function as the matrix extraction and replacement tools will take care of this</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_SC</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        cell_matrix;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_orig;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_pu;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_pJ;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_JJ;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_pJ_inv;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_bbar;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        A;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        B;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>;</div><div class="line"></div><div class="line">  PerTaskData_SC(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell,</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u,</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p,</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_J)</div><div class="line">    :</div><div class="line">    cell_matrix(dofs_per_cell, dofs_per_cell),</div><div class="line">    local_dof_indices(dofs_per_cell),</div><div class="line">    k_orig(dofs_per_cell, dofs_per_cell),</div><div class="line">    k_pu(n_p, n_u),</div><div class="line">    k_pJ(n_p, n_J),</div><div class="line">    k_JJ(n_J, n_J),</div><div class="line">    k_pJ_inv(n_p, n_J),</div><div class="line">    k_bbar(n_u, n_u),</div><div class="line">    A(n_J,n_u),</div><div class="line">    B(n_J, n_u),</div><div class="line">    C(n_p, n_u)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p>The ScratchData object for the operations we wish to perform here is empty since we need no temporary data, but it still needs to be defined for the current implementation of TBB in deal.II. So we create a dummy struct for this purpose.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_SC</div><div class="line">{</div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p>And finally we define the structures to assist with updating the quadrature point information. Similar to the SC assembly process, we do not need the PerTaskData object (since there is nothing to store here) but must define one nonetheless. Note that this is because for the operation that we have here &ndash; updating the data on quadrature points &ndash; the operation is purely local: the things we do on every cell get consumed on every cell, without any global aggregation operation as is usually the case when using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class. The fact that we still have to define a per-task data structure points to the fact that the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class may be ill-suited to this operation (we could, in principle simply create a new task using <a class="el" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a> for each cell) but there is not much harm done to doing it this way anyway. Furthermore, should there be different material models associated with a quadrature point, requiring varying levels of computational expense, then the method used here could be advantageous.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_UQPH</div><div class="line">{</div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p>The ScratchData object will be used to store an alias for the solution vector so that we don't have to copy this large data structure. We then define a number of vectors to extract the solution values and gradients at the quadrature points.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_UQPH</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>   &amp;solution_total;</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt; &gt; solution_grads_u_total;</div><div class="line">  std::vector&lt;double&gt;          solution_values_p_total;</div><div class="line">  std::vector&lt;double&gt;          solution_values_J_total;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                fe_values_ref;</div><div class="line"></div><div class="line">  ScratchData_UQPH(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_cell,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;qf_cell,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_total)</div><div class="line">    :</div><div class="line">    solution_total(solution_total),</div><div class="line">    solution_grads_u_total(qf_cell.size()),</div><div class="line">    solution_values_p_total(qf_cell.size()),</div><div class="line">    solution_values_J_total(qf_cell.size()),</div><div class="line">    fe_values_ref(fe_cell, qf_cell, uf_cell)</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData_UQPH(<span class="keyword">const</span> ScratchData_UQPH &amp;rhs)</div><div class="line">    :</div><div class="line">    solution_total(rhs.solution_total),</div><div class="line">    solution_grads_u_total(rhs.solution_grads_u_total),</div><div class="line">    solution_values_p_total(rhs.solution_values_p_total),</div><div class="line">    solution_values_J_total(rhs.solution_values_J_total),</div><div class="line">    fe_values_ref(rhs.fe_values_ref.get_fe(),</div><div class="line">                  rhs.fe_values_ref.get_quadrature(),</div><div class="line">                  rhs.fe_values_ref.get_update_flags())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = solution_grads_u_total.size();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        solution_grads_u_total[q] = 0.0;</div><div class="line">        solution_values_p_total[q] = 0.0;</div><div class="line">        solution_values_J_total[q] = 0.0;</div><div class="line">      }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Solidmake_grid"></a> </p><h4>Solid::make_grid</h4>
<p>On to the first of the private member functions. Here we create the triangulation of the domain, for which we choose the scaled cube with each face given a boundary ID number. The grid must be refined at least once for the indentation problem.</p>
<p>We then determine the volume of the reference configuration and print it for comparison:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation,</div><div class="line">                                 (dim==3 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.0, 0.0, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.0, 0.0)),</div><div class="line">                                 (dim==3 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(1.0, 1.0, 1.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(1.0, 1.0)),</div><div class="line">                                 <span class="keyword">true</span>);</div><div class="line">  <a class="code" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>(parameters.scale, triangulation);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(std::max (1U, parameters.global_refinement));</div><div class="line"></div><div class="line">  vol_reference = <a class="code" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">GridTools::volume</a>(triangulation);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid:\n\t Reference volume: &quot;</span> &lt;&lt; vol_reference &lt;&lt; std::endl;</div></div><!-- fragment --><p>Since we wish to apply a Neumann BC to a patch on the top surface, we must find the cell faces in this part of the domain and mark them with a distinct boundary ID number. The faces we are looking for are on the +y surface and will get boundary ID 6 (zero through five are already used when creating the six faces of the cube domain):</p>
<div class="fragment"><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(), endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face = 0;</div><div class="line">         face &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary() == <span class="keyword">true</span></div><div class="line">            &amp;&amp;</div><div class="line">            cell-&gt;face(face)-&gt;center()[1] == 1.0 * parameters.scale)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (dim==3)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;center()[0] &lt; 0.5 * parameters.scale</div><div class="line">                    &amp;&amp;</div><div class="line">                    cell-&gt;face(face)-&gt;center()[2] &lt; 0.5 * parameters.scale)</div><div class="line">                  cell-&gt;face(face)-&gt;set_boundary_id(6);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;center()[0] &lt; 0.5 * parameters.scale)</div><div class="line">                  cell-&gt;face(face)-&gt;set_boundary_id(6);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidsystem_setup"></a> </p><h4>Solid::system_setup</h4>
<p>Next we describe how the FE system is setup. We first determine the number of components per block. Since the displacement is a vector component, the first dim components belong to it, while the next two describe scalar pressure and dilatation DOFs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::system_setup()</div><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Setup system&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; block_component(n_components, u_dof); <span class="comment">// Displacement</span></div><div class="line">  block_component[p_component] = p_dof; <span class="comment">// Pressure</span></div><div class="line">  block_component[J_component] = J_dof; <span class="comment">// Dilatation</span></div></div><!-- fragment --><p>The DOF handler is then initialised and we renumber the grid in an efficient manner. We also record the number of DOFs per block.</p>
<div class="fragment"><div class="line">dof_handler_ref.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"><a class="code" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a>(dof_handler_ref);</div><div class="line"><a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler_ref, block_component);</div><div class="line"><a class="code" href="namespaceDoFTools.html#abfd9796e22113e13b5802e384e56af4f">DoFTools::count_dofs_per_block</a>(dof_handler_ref, dofs_per_block,</div><div class="line">                               block_component);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Triangulation:&quot;</span></div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;\n\t Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;\n\t Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler_ref.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>Setup the sparsity pattern and tangent matrix</p>
<div class="fragment"><div class="line">tangent_matrix.<a class="code" href="classBlockSparseMatrix.html#acf098688a1a7db16a6582be07dcbeb6a">clear</a>();</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> n_dofs_u = dofs_per_block[u_dof];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> n_dofs_p = dofs_per_block[p_dof];</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> n_dofs_J = dofs_per_block[J_dof];</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(n_blocks, n_blocks);</div><div class="line"></div><div class="line">  dsp.block(u_dof, u_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_u, n_dofs_u);</div><div class="line">  dsp.block(u_dof, p_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_u, n_dofs_p);</div><div class="line">  dsp.block(u_dof, J_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_u, n_dofs_J);</div><div class="line"></div><div class="line">  dsp.block(p_dof, u_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_p, n_dofs_u);</div><div class="line">  dsp.block(p_dof, p_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_p, n_dofs_p);</div><div class="line">  dsp.block(p_dof, J_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_p, n_dofs_J);</div><div class="line"></div><div class="line">  dsp.block(J_dof, u_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_J, n_dofs_u);</div><div class="line">  dsp.block(J_dof, p_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_J, n_dofs_p);</div><div class="line">  dsp.block(J_dof, J_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_J, n_dofs_J);</div><div class="line">  dsp.collect_sizes();</div></div><!-- fragment --><p>The global system matrix initially has the following structure </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \underbrace{\begin{bmatrix} \mathsf{\mathbf{K}}_{uu} &amp; \mathsf{\mathbf{K}}_{u\widetilde{p}} &amp; \mathbf{0} \\ \mathsf{\mathbf{K}}_{\widetilde{p}u} &amp; \mathbf{0} &amp; \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}} \\ \mathbf{0} &amp; \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}} &amp; \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} \end{bmatrix}}_{\mathsf{\mathbf{K}}(\mathbf{\Xi}_{\textrm{i}})} \underbrace{\begin{bmatrix} d \mathsf{u} \\ d \widetilde{\mathsf{\mathbf{p}}} \\ d \widetilde{\mathsf{\mathbf{J}}} \end{bmatrix}}_{d \mathbf{\Xi}} = \underbrace{\begin{bmatrix} \mathsf{\mathbf{F}}_{u}(\mathbf{u}_{\textrm{i}}) \\ \mathsf{\mathbf{F}}_{\widetilde{p}}(\widetilde{p}_{\textrm{i}}) \\ \mathsf{\mathbf{F}}_{\widetilde{J}}(\widetilde{J}_{\textrm{i}}) \end{bmatrix}}_{ \mathsf{\mathbf{F}}(\mathbf{\Xi}_{\textrm{i}}) } \, . \end{align*}" src="form_3718.png"/>
</p>
<p> We optimise the sparsity pattern to reflect this structure and prevent unnecessary data creation for the right-diagonal block components.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(n_components, n_components);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii = 0; ii &lt; <a class="code" href="classDoFHandler.html#ac69f2dc12d3d013e11f7bfd70e328dcb">n_components</a>; ++ii)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj = 0; jj &lt; <a class="code" href="classDoFHandler.html#ac69f2dc12d3d013e11f7bfd70e328dcb">n_components</a>; ++jj)</div><div class="line">      <span class="keywordflow">if</span> (((ii &lt; p_component) &amp;&amp; (jj == J_component))</div><div class="line">          || ((ii == J_component) &amp;&amp; (jj &lt; p_component))</div><div class="line">          || ((ii == p_component) &amp;&amp; (jj == p_component)))</div><div class="line">        coupling[ii][jj] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[ii][jj] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler_ref,</div><div class="line">                                  coupling,</div><div class="line">                                  dsp,</div><div class="line">                                  constraints,</div><div class="line">                                  <span class="keyword">false</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">}</div><div class="line"></div><div class="line">tangent_matrix.<a class="code" href="classBlockSparseMatrix.html#a1e0a45e360458e7350bd93487d6bf1e5">reinit</a>(sparsity_pattern);</div></div><!-- fragment --><p>We then set up storage vectors</p>
<div class="fragment"><div class="line">system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dofs_per_block);</div><div class="line">system_rhs.<a class="code" href="classBlockVectorBase.html#a6a27b2a48e5b5780cd0a6640b928d794">collect_sizes</a>();</div><div class="line"></div><div class="line">solution_n.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dofs_per_block);</div><div class="line">solution_n.<a class="code" href="classBlockVectorBase.html#a6a27b2a48e5b5780cd0a6640b928d794">collect_sizes</a>();</div></div><!-- fragment --><p>...and finally set up the quadrature point history:</p>
<div class="fragment"><div class="line">  setup_qph();</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Soliddetermine_component_extractors"></a> </p><h4>Solid::determine_component_extractors</h4>
<p>Next we compute some information from the FE system that describes which local element DOFs are attached to which block component. This is used later to extract sub-blocks from the global matrix.</p>
<p>In essence, all we need is for the <a class="el" href="classFESystem.html">FESystem</a> object to indicate to which block component a DOF on the reference cell is attached to. Currently, the interpolation fields are setup such that 0 indicates a displacement DOF, 1 a pressure DOF and 2 a dilatation DOF.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::determine_component_extractors()</div><div class="line">{</div><div class="line">  element_indices_u.clear();</div><div class="line">  element_indices_p.clear();</div><div class="line">  element_indices_J.clear();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++k)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(k).first.first;</div><div class="line">      <span class="keywordflow">if</span> (k_group == u_dof)</div><div class="line">        element_indices_u.push_back(k);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == p_dof)</div><div class="line">        element_indices_p.push_back(k);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == J_dof)</div><div class="line">        element_indices_J.push_back(k);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(k_group &lt;= J_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidsetup_qph"></a> </p><h4>Solid::setup_qph</h4>
<p>The method used to store quadrature information is already described in <a class="el" href="step_18.html">step-18</a>. Here we implement a similar setup for a SMP machine.</p>
<p>Firstly the actual QPH data objects are created. This must be done only once the grid is refined to its finest level.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::setup_qph()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;    Setting up quadrature point data...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  quadrature_point_history.<a class="code" href="classCellDataStorage.html#a9ce38927ac1a1f96618c2624da89d65b">initialize</a>(triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">                                      triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(),</div><div class="line">                                      n_q_points);</div></div><!-- fragment --><p>Next we setup the initial quadrature point data. Note that when the quadrature point data is retrieved, it is returned as a vector of smart pointers.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">         triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">        quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        lqph[q_point]-&gt;setup_lqp(parameters);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidupdate_qph_incremental"></a> </p><h4>Solid::update_qph_incremental</h4>
<p>As the update of QP information occurs frequently and involves a number of expensive operations, we define a multithreaded approach to distributing the task across a number of CPU cores.</p>
<p>To start this, we first we need to obtain the total solution as it stands at this Newton increment and then create the initial copy of the scratch and copy data objects:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::update_qph_incremental(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta)</div><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Update QPH data&quot;</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; UQPH &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution_total(get_total_solution(solution_delta));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_UQPH(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">  PerTaskData_UQPH per_task_data_UQPH;</div><div class="line">  ScratchData_UQPH scratch_data_UQPH(fe, qf_cell, uf_UQPH, solution_total);</div></div><!-- fragment --><p>We then pass them and the one-cell update function to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> to be processed:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  *<span class="keyword">this</span>,</div><div class="line">                  &amp;Solid::update_qph_incremental_one_cell,</div><div class="line">                  &amp;Solid::copy_local_to_global_UQPH,</div><div class="line">                  scratch_data_UQPH,</div><div class="line">                  per_task_data_UQPH);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p>Now we describe how we extract data from the solution vector and pass it along to each QP storage object for processing.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::update_qph_incremental_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                            ScratchData_UQPH &amp;scratch,</div><div class="line">                                            PerTaskData_UQPH &amp;/ *data* /)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">    quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(scratch.solution_grads_u_total.size() == n_q_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(scratch.solution_values_p_total.size() == n_q_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(scratch.solution_values_J_total.size() == n_q_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  scratch.reset();</div></div><!-- fragment --><p>We first need to find the values and gradients at quadrature points inside the current cell and then we update each local QP using the displacement gradient and total pressure and dilatation solution values:</p>
<div class="fragment"><div class="line">  scratch.fe_values_ref.reinit(cell);</div><div class="line">  scratch.fe_values_ref[u_fe].get_function_gradients(scratch.solution_total,</div><div class="line">                                                     scratch.solution_grads_u_total);</div><div class="line">  scratch.fe_values_ref[p_fe].get_function_values(scratch.solution_total,</div><div class="line">                                                  scratch.solution_values_p_total);</div><div class="line">  scratch.fe_values_ref[J_fe].get_function_values(scratch.solution_total,</div><div class="line">                                                  scratch.solution_values_J_total);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    lqph[q_point]-&gt;<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>(scratch.solution_grads_u_total[q_point],</div><div class="line">                                 scratch.solution_values_p_total[q_point],</div><div class="line">                                 scratch.solution_values_J_total[q_point]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidsolve_nonlinear_timestep"></a> </p><h4>Solid::solve_nonlinear_timestep</h4>
<p>The next function is the driver method for the Newton-Raphson scheme. At its top we create a new vector to store the current Newton update step, reset the error storage objects and print solver header.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::solve_nonlinear_timestep(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; time.get_timestep() &lt;&lt; <span class="stringliteral">&quot; @ &quot;</span></div><div class="line">            &lt;&lt; time.current() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> newton_update(dofs_per_block);</div><div class="line"></div><div class="line">  error_residual.reset();</div><div class="line">  error_residual_0.reset();</div><div class="line">  error_residual_norm.reset();</div><div class="line">  error_update.reset();</div><div class="line">  error_update_0.reset();</div><div class="line">  error_update_norm.reset();</div><div class="line"></div><div class="line">  print_conv_header();</div></div><!-- fragment --><p>We now perform a number of Newton iterations to iteratively solve the nonlinear problem. Since the problem is fully nonlinear and we are using a full Newton method, the data stored in the tangent matrix and right-hand side vector is not reusable and must be cleared at each Newton step. We then initially build the right-hand side vector to check for convergence (and store this value in the first iteration). The unconstrained DOFs of the rhs vector hold the out-of-balance forces. The building is done before assembling the system matrix as the latter is an expensive operation and we can potentially avoid an extra assembly process by not assembling the tangent matrix when convergence is attained.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_iteration = 0;</div><div class="line"><span class="keywordflow">for</span> (; newton_iteration &lt; parameters.max_iterations_NR;</div><div class="line">     ++newton_iteration)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::setw(2) &lt;&lt; newton_iteration &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    tangent_matrix = 0.0;</div><div class="line">    system_rhs = 0.0;</div><div class="line"></div><div class="line">    assemble_system_rhs();</div><div class="line">    get_error_residual(error_residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (newton_iteration == 0)</div><div class="line">      error_residual_0 = error_residual;</div></div><!-- fragment --><p>We can now determine the normalised residual error and check for solution convergence:</p>
<div class="fragment"><div class="line">error_residual_norm = error_residual;</div><div class="line">error_residual_norm.normalise(error_residual_0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (newton_iteration &gt; 0 &amp;&amp; error_update_norm.u &lt;= parameters.tol_u</div><div class="line">    &amp;&amp; error_residual_norm.u &lt;= parameters.tol_f)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; CONVERGED! &quot;</span> &lt;&lt; std::endl;</div><div class="line">    print_conv_footer();</div><div class="line"></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div></div><!-- fragment --><p>If we have decided that we want to continue with the iteration, we assemble the tangent, make and impose the Dirichlet constraints, and do the solve of the linearised system:</p>
<div class="fragment"><div class="line">assemble_system_tangent();</div><div class="line">make_constraints(newton_iteration);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">condense</a>(tangent_matrix, system_rhs);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::pair&lt;unsigned int, double&gt;</div><div class="line">lin_solver_output = solve_linear_system(newton_update);</div><div class="line"></div><div class="line">get_error_update(newton_update, error_update);</div><div class="line"><span class="keywordflow">if</span> (newton_iteration == 0)</div><div class="line">  error_update_0 = error_update;</div></div><!-- fragment --><p>We can now determine the normalised Newton update error, and perform the actual update of the solution increment for the current time step, update all quadrature point information pertaining to this new displacement and stress state and continue iterating:</p>
<div class="fragment"><div class="line">  error_update_norm = error_update;</div><div class="line">  error_update_norm.normalise(error_update_0);</div><div class="line"></div><div class="line">  solution_delta += newton_update;</div><div class="line">  update_qph_incremental(solution_delta);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; | &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; std::setw(7)</div><div class="line">            &lt;&lt; std::scientific &lt;&lt; lin_solver_output.first &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div><div class="line">            &lt;&lt; lin_solver_output.second &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_residual_norm.norm</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_residual_norm.u &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div><div class="line">            &lt;&lt; error_residual_norm.p &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_residual_norm.J</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.norm &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.u</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.p &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.J</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>At the end, if it turns out that we have in fact done more iterations than the parameter file allowed, we raise an exception that can be caught in the main() function. The call <code>AssertThrow(condition, exc_object)</code> is in essence equivalent to <code>if (!cond) throw exc_object;</code> but the former form fills certain fields in the exception object that identify the location (filename and line number) where the exception was raised to make it simpler to identify where the problem happened.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (newton_iteration &lt; parameters.max_iterations_NR,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No convergence in nonlinear solver!&quot;</span>));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidprint_conv_headerandSolidprint_conv_footer"></a> </p><h4>Solid::print_conv_header and Solid::print_conv_footer</h4>
<p>This program prints out data in a nice table that is updated on a per-iteration basis. The next two functions set up the table header and footer:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::print_conv_header()</div><div class="line">{</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l_width = 155;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;                 SOLVER STEP                  &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; |  LIN_IT   LIN_RES    RES_NORM    &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; RES_U     RES_P      RES_J     NU_NORM     &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; NU_U       NU_P       NU_J &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::print_conv_footer()</div><div class="line">{</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l_width = 155;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::pair&lt;double,double&gt; error_dil = get_error_dilation();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Relative errors:&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Displacement:\t&quot;</span> &lt;&lt; error_update.u / error_update_0.u &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Force: \t\t&quot;</span> &lt;&lt; error_residual.u / error_residual_0.u &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Dilatation:\t&quot;</span> &lt;&lt; error_dil.first &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;v / V_0:\t&quot;</span> &lt;&lt; error_dil.second *vol_reference &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; vol_reference</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; error_dil.second &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidget_error_dilation"></a> </p><h4>Solid::get_error_dilation</h4>
<p>Calculate the volume of the domain in the spatial configuration</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Solid&lt;dim&gt;::compute_vol_current()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> vol_current = 0.0;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_ref(fe, qf_cell, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">       cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">    {</div><div class="line">      fe_values_ref.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div></div><!-- fragment --><p>In contrast to that which was previously called for, in this instance the quadrature point data is specifically non-modifiable since we will only be accessing data. We ensure that the right get_data function is called by marking this update function as constant.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;const PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">        quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> det_F_qp = lqph[q_point]-&gt;get_det_F();</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = fe_values_ref.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">          vol_current += det_F_qp * JxW;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(vol_current &gt; 0.0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <span class="keywordflow">return</span> vol_current;</div><div class="line">}</div></div><!-- fragment --><p>Calculate how well the dilatation <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> agrees with <img class="formulaInl" alt="$J := \textrm{det}\ \mathbf{F}$" src="form_3719.png"/> from the <img class="formulaInl" alt="$L^2$" src="form_700.png"/> error <img class="formulaInl" alt="$ \bigl[ \int_{\Omega_0} {[ J - \widetilde{J}]}^{2}\textrm{d}V \bigr]^{1/2}$" src="form_3720.png"/>. We also return the ratio of the current volume of the domain to the reference volume. This is of interest for incompressible media where we want to check how well the isochoric constraint has been enforced.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt;</div><div class="line">Solid&lt;dim&gt;::get_error_dilation()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> dil_L2_error = 0.0;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_ref(fe, qf_cell, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">       cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">    {</div><div class="line">      fe_values_ref.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;const PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">        quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> det_F_qp = lqph[q_point]-&gt;get_det_F();</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> J_tilde_qp = lqph[q_point]-&gt;get_J_tilde();</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> the_error_qp_squared = std::pow((det_F_qp - J_tilde_qp),</div><div class="line">                                                       2);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = fe_values_ref.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">          dil_L2_error += the_error_qp_squared * JxW;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> std::make_pair(std::sqrt(dil_L2_error),</div><div class="line">                        compute_vol_current() / vol_reference);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidget_error_residual"></a> </p><h4>Solid::get_error_residual</h4>
<p>Determine the true residual error for the problem. That is, determine the error in the residual for the unconstrained degrees of freedom. Note that to do so, we need to ignore constrained DOFs by setting the residual in these vector components to zero.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::get_error_residual(Errors &amp;error_residual)</div><div class="line">{</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> error_res(dofs_per_block);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler_ref.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (!constraints.<a class="code" href="classConstraintMatrix.html#a997d5e0e75f237a2be3fb37d84e1d53c">is_constrained</a>(i))</div><div class="line">      error_res(i) = system_rhs(i);</div><div class="line"></div><div class="line">  error_residual.norm = error_res.l2_norm();</div><div class="line">  error_residual.u = error_res.block(u_dof).l2_norm();</div><div class="line">  error_residual.p = error_res.block(p_dof).l2_norm();</div><div class="line">  error_residual.J = error_res.block(J_dof).l2_norm();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidget_error_update"></a> </p><h4>Solid::get_error_update</h4>
<p>Determine the true Newton update error for the problem</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::get_error_update(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update,</div><div class="line">                                  Errors &amp;error_update)</div><div class="line">{</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> error_ud(dofs_per_block);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler_ref.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (!constraints.<a class="code" href="classConstraintMatrix.html#a997d5e0e75f237a2be3fb37d84e1d53c">is_constrained</a>(i))</div><div class="line">      error_ud(i) = newton_update(i);</div><div class="line"></div><div class="line">  error_update.norm = error_ud.l2_norm();</div><div class="line">  error_update.u = error_ud.block(u_dof).l2_norm();</div><div class="line">  error_update.p = error_ud.block(p_dof).l2_norm();</div><div class="line">  error_update.J = error_ud.block(J_dof).l2_norm();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidget_total_solution"></a> </p><h4>Solid::get_total_solution</h4>
<p>This function provides the total solution, which is valid at any Newton step. This is required as, to reduce computational error, the total solution is only updated at the end of the timestep.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">Solid&lt;dim&gt;::get_total_solution(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution_total(solution_n);</div><div class="line">  solution_total += solution_delta;</div><div class="line">  <span class="keywordflow">return</span> solution_total;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidassemble_system_tangent"></a> </p><h4>Solid::assemble_system_tangent</h4>
<p>Since we use TBB for assembly, we simply setup a copy of the data structures required for the process and pass them, along with the memory addresses of the assembly functions to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> object for processing. Note that we must ensure that the matrix is reset before any assembly operations can occur.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::assemble_system_tangent()</div><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Assemble tangent matrix&quot;</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; ASM_K &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  tangent_matrix = 0.0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  PerTaskData_K per_task_data(dofs_per_cell);</div><div class="line">  ScratchData_K scratch_data(fe, qf_cell, uf_cell);</div></div><!-- fragment --><p>The syntax used here to pass data to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class is discussed in <a class="el" href="step_14.html">step-14</a>. We need to use this particular call to <a class="el" href="namespaceWorkStream.html">WorkStream</a> because assemble_system_tangent_one_cell is a constant function and copy_local_to_global_K is non-constant.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  std::bind(&amp;Solid&lt;dim&gt;::assemble_system_tangent_one_cell,</div><div class="line">                            <span class="keyword">this</span>,</div><div class="line">                            std::placeholders::_1,</div><div class="line">                            std::placeholders::_2,</div><div class="line">                            std::placeholders::_3),</div><div class="line">                  std::bind(&amp;Solid&lt;dim&gt;::copy_local_to_global_K,</div><div class="line">                            <span class="keyword">this</span>,</div><div class="line">                            std::placeholders::_1),</div><div class="line">                  scratch_data,</div><div class="line">                  per_task_data);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p>This function adds the local contribution to the system matrix. Note that we choose not to use the constraint matrix to do the job for us because the tangent matrix and residual processes have been split up into two separate functions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::copy_local_to_global_K(<span class="keyword">const</span> PerTaskData_K &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      tangent_matrix.<a class="code" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add</a>(data.local_dof_indices[i],</div><div class="line">                         data.local_dof_indices[j],</div><div class="line">                         data.cell_matrix(i, j));</div><div class="line">}</div></div><!-- fragment --><p>Of course, we still have to define how we assemble the tangent matrix contribution for a single cell. We first need to reset and initialise some of the scratch data structures and retrieve some basic information regarding the DOF numbering on this cell. We can precalculate the cell shape function values and gradients. Note that the shape function gradients are defined with regard to the current configuration. That is <img class="formulaInl" alt="$\textrm{grad}\ \boldsymbol{\varphi} = \textrm{Grad}\ \boldsymbol{\varphi} \ \mathbf{F}^{-1}$" src="form_3721.png"/>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::assemble_system_tangent_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                             ScratchData_K &amp;scratch,</div><div class="line">                                             PerTaskData_K &amp;data)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  data.reset();</div><div class="line">  scratch.reset();</div><div class="line">  scratch.fe_values_ref.reinit(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;const PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">    quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_inv = lqph[q_point]-&gt;get_F_inv();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(k).first.first;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (k_group == u_dof)</div><div class="line">            {</div><div class="line">              scratch.grad_Nx[q_point][k] = scratch.fe_values_ref[u_fe].gradient(k, q_point)</div><div class="line">                                            * F_inv;</div><div class="line">              scratch.symm_grad_Nx[q_point][k] = <a class="code" href="classSymmetricTensor.html#a4acdda923e9b04d2d70308f3c095e12f">symmetrize</a>(scratch.grad_Nx[q_point][k]);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == p_dof)</div><div class="line">            scratch.Nx[q_point][k] = scratch.fe_values_ref[p_fe].value(k,</div><div class="line">                                                                       q_point);</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == J_dof)</div><div class="line">            scratch.Nx[q_point][k] = scratch.fe_values_ref[J_fe].value(k,</div><div class="line">                                                                       q_point);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(k_group &lt;= J_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Now we build the local cell stiffness matrix. Since the global and local system matrices are symmetric, we can exploit this property by building only the lower half of the local matrix and copying the values to the upper half. So we only assemble half of the <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{uu}$" src="form_3722.png"/>, <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{p}} = \mathbf{0}$" src="form_3723.png"/>, <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{J} \widetilde{J}}$" src="form_3724.png"/> blocks, while the whole <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$" src="form_3725.png"/>, <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{u \widetilde{J}} = \mathbf{0}$" src="form_3726.png"/>, <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{u \widetilde{p}}$" src="form_3727.png"/> blocks are built.</p>
<p>In doing so, we first extract some configuration dependent variables from our quadrature history objects for the current quadrature point.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> tau         = lqph[q_point]-&gt;get_tau();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Jc = lqph[q_point]-&gt;get_Jc();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d2Psi_vol_dJ2       = lqph[q_point]-&gt;get_d2Psi_vol_dJ2();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> det_F               = lqph[q_point]-&gt;get_det_F();</div></div><!-- fragment --><p>Next we define some aliases to make the assembly process easier to follow</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt;</div><div class="line">&amp;N = scratch.Nx[q_point];</div><div class="line"><span class="keyword">const</span> std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt;</div><div class="line">&amp;symm_grad_Nx = scratch.symm_grad_Nx[q_point];</div><div class="line"><span class="keyword">const</span> std::vector&lt;Tensor&lt;2, dim&gt; &gt;</div><div class="line">&amp;grad_Nx = scratch.grad_Nx[q_point];</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_ref.JxW(q_point);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i = fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_group     = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(i).first.first;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_j = fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_group     = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(j).first.first;</div></div><!-- fragment --><p>This is the <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{uu}$" src="form_3722.png"/> contribution. It comprises a material contribution, and a geometrical stress contribution which is only added along the local matrix diagonals:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((i_group == j_group) &amp;&amp; (i_group == u_dof))</div><div class="line">  {</div><div class="line">    data.cell_matrix(i, j) += symm_grad_Nx[i] * Jc <span class="comment">// The material contribution:</span></div><div class="line">                              * symm_grad_Nx[j] * JxW;</div><div class="line">    <span class="keywordflow">if</span> (component_i == component_j) <span class="comment">// geometrical stress contribution</span></div><div class="line">      data.cell_matrix(i, j) += grad_Nx[i][component_i] * tau</div><div class="line">                                * grad_Nx[j][component_j] * JxW;</div><div class="line">  }</div></div><!-- fragment --><p>Next is the <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{ \widetilde{p} u}$" src="form_3728.png"/> contribution</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i_group == p_dof) &amp;&amp; (j_group == u_dof))</div><div class="line">  {</div><div class="line">    data.cell_matrix(i, j) += N[i] * det_F</div><div class="line">                              * (symm_grad_Nx[j]</div><div class="line">                                 * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>)</div><div class="line">                              * JxW;</div><div class="line">  }</div></div><!-- fragment --><p>and lastly the <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{ \widetilde{J} \widetilde{p}}$" src="form_3729.png"/> and <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{ \widetilde{J} \widetilde{J}}$" src="form_3730.png"/> contributions:</p>
<div class="fragment"><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i_group == J_dof) &amp;&amp; (j_group == p_dof))</div><div class="line">            data.cell_matrix(i, j) -= N[i] * N[j] * JxW;</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i_group == j_group) &amp;&amp; (i_group == J_dof))</div><div class="line">            data.cell_matrix(i, j) += N[i] * d2Psi_vol_dJ2 * N[j] * JxW;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((i_group &lt;= J_dof) &amp;&amp; (j_group &lt;= J_dof),</div><div class="line">                   <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, we need to copy the lower half of the local matrix into the upper half:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">      data.cell_matrix(i, j) = data.cell_matrix(j, i);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidassemble_system_rhs"></a> </p><h4>Solid::assemble_system_rhs</h4>
<p>The assembly of the right-hand side process is similar to the tangent matrix, so we will not describe it in too much detail. Note that since we are describing a problem with Neumann BCs, we will need the face normals and so must specify this in the update flags.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::assemble_system_rhs()</div><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Assemble system right-hand side&quot;</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; ASM_R &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  system_rhs = 0.0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_face(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  PerTaskData_RHS per_task_data(dofs_per_cell);</div><div class="line">  ScratchData_RHS scratch_data(fe, qf_cell, uf_cell, qf_face, uf_face);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  std::bind(&amp;Solid&lt;dim&gt;::assemble_system_rhs_one_cell,</div><div class="line">                            <span class="keyword">this</span>,</div><div class="line">                            std::placeholders::_1,</div><div class="line">                            std::placeholders::_2,</div><div class="line">                            std::placeholders::_3),</div><div class="line">                  std::bind(&amp;Solid&lt;dim&gt;::copy_local_to_global_rhs,</div><div class="line">                            <span class="keyword">this</span>,</div><div class="line">                            std::placeholders::_1),</div><div class="line">                  scratch_data,</div><div class="line">                  per_task_data);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::copy_local_to_global_rhs(<span class="keyword">const</span> PerTaskData_RHS &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    system_rhs(data.local_dof_indices[i]) += data.cell_rhs(i);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::assemble_system_rhs_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                         ScratchData_RHS &amp;scratch,</div><div class="line">                                         PerTaskData_RHS &amp;data)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  data.reset();</div><div class="line">  scratch.reset();</div><div class="line">  scratch.fe_values_ref.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;const PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">    quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_inv = lqph[q_point]-&gt;get_F_inv();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(k).first.first;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (k_group == u_dof)</div><div class="line">            scratch.symm_grad_Nx[q_point][k]</div><div class="line">              = <a class="code" href="classSymmetricTensor.html#a4acdda923e9b04d2d70308f3c095e12f">symmetrize</a>(scratch.fe_values_ref[u_fe].gradient(k, q_point)</div><div class="line">                           * F_inv);</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == p_dof)</div><div class="line">            scratch.Nx[q_point][k] = scratch.fe_values_ref[p_fe].value(k,</div><div class="line">                                                                       q_point);</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == J_dof)</div><div class="line">            scratch.Nx[q_point][k] = scratch.fe_values_ref[J_fe].value(k,</div><div class="line">                                                                       q_point);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(k_group &lt;= J_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau = lqph[q_point]-&gt;get_tau();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> det_F = lqph[q_point]-&gt;get_det_F();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> J_tilde = lqph[q_point]-&gt;get_J_tilde();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> p_tilde = lqph[q_point]-&gt;get_p_tilde();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dPsi_vol_dJ = lqph[q_point]-&gt;get_dPsi_vol_dJ();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt;</div><div class="line">      &amp;N = scratch.Nx[q_point];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt;</div><div class="line">      &amp;symm_grad_Nx = scratch.symm_grad_Nx[q_point];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_ref.JxW(q_point);</div></div><!-- fragment --><p>We first compute the contributions from the internal forces. Note, by definition of the rhs as the negative of the residual, these contributions are subtracted.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(i).first.first;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (i_group == u_dof)</div><div class="line">        data.cell_rhs(i) -= (symm_grad_Nx[i] * tau) * JxW;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i_group == p_dof)</div><div class="line">        data.cell_rhs(i) -= N[i] * (det_F - J_tilde) * JxW;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i_group == J_dof)</div><div class="line">        data.cell_rhs(i) -= N[i] * (dPsi_vol_dJ - p_tilde) * JxW;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(i_group &lt;= J_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next we assemble the Neumann contribution. We first check to see it the cell face exists on a boundary on which a traction is applied and add the contribution if this is the case.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face = 0; face &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">     ++face)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary() == <span class="keyword">true</span></div><div class="line">      &amp;&amp; cell-&gt;face(face)-&gt;boundary_id() == 6)</div><div class="line">    {</div><div class="line">      scratch.fe_face_values_ref.reinit(cell, face);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f_q_point = 0; f_q_point &lt; n_q_points_f;</div><div class="line">           ++f_q_point)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;N =</div><div class="line">            scratch.fe_face_values_ref.normal_vector(f_q_point);</div></div><!-- fragment --><p>Using the face normal at this quadrature point we specify the traction in reference configuration. For this problem, a defined pressure is applied in the reference configuration. The direction of the applied traction is assumed not to evolve with the deformation of the domain. The traction is defined using the first Piola-Kirchhoff stress is simply <img class="formulaInl" alt="$\mathbf{t} = \mathbf{P}\mathbf{N} = [p_0 \mathbf{I}] \mathbf{N} = p_0 \mathbf{N}$" src="form_3731.png"/> We use the time variable to linearly ramp up the pressure load.</p>
<p>Note that the contributions to the right hand side vector we compute here only exist in the displacement components of the vector.</p>
<div class="fragment"><div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>  p0        = -4.0</div><div class="line">                                             /</div><div class="line">                                             (parameters.scale * parameters.scale);</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>         time_ramp = (time.current() / time.end());</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span>         pressure  = p0 * parameters.p_p0 * time_ramp;</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction  = pressure * N;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_group =</div><div class="line">                  fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(i).first.first;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (i_group == u_dof)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> Ni =</div><div class="line">                      scratch.fe_face_values_ref.shape_value(i,</div><div class="line">                                                             f_q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_face_values_ref.JxW(</div><div class="line">                                         f_q_point);</div><div class="line"></div><div class="line">                    data.cell_rhs(i) += (Ni * traction[component_i])</div><div class="line">                                        * JxW;</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidmake_constraints"></a> </p><h4>Solid::make_constraints</h4>
<p>The constraints for this problem are simple to describe. However, since we are dealing with an iterative Newton method, it should be noted that any displacement constraints should only be specified at the zeroth iteration and subsequently no additional contributions are to be made since the constraints are already exactly satisfied.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::make_constraints(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;it_nr)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; CST &quot;</span> &lt;&lt; std::flush;</div></div><!-- fragment --><p>Since the constraints are different at different Newton iterations, we need to clear the constraints matrix and completely rebuild it. However, after the first iteration, the constraints remain the same and we can simply skip the rebuilding step if we do not clear it.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (it_nr &gt; 1)</div><div class="line">  <span class="keywordflow">return</span>;</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> apply_dirichlet_bc = (it_nr == 0);</div></div><!-- fragment --><p>The boundary conditions for the indentation problem are as follows: On the -x, -y and -z faces (IDs 0,2,4) we set up a symmetry condition to allow only planar movement while the +x and +z faces (IDs 1,5) are traction free. In this contrived problem, part of the +y face (ID 3) is set to have no motion in the x- and z-component. Finally, as described earlier, the other part of the +y face has an the applied pressure but is also constrained in the x- and z-directions.</p>
<p>In the following, we will have to tell the function interpolation boundary values which components of the solution vector should be constrained (i.e., whether it's the x-, y-, z-displacements or combinations thereof). This is done using <a class="el" href="classComponentMask.html">ComponentMask</a> objects (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>) which we can get from the finite element if we provide it with an extractor object for the component we wish to select. To this end we first set up such extractor objects and later use it when generating the relevant component masks:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> x_displacement(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> y_displacement(1);</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                               boundary_id,</div><div class="line">                                               <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                               constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement));</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                               boundary_id,</div><div class="line">                                               <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                               constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement));</div><div class="line">  }</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 2;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                               boundary_id,</div><div class="line">                                               <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                               constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(y_displacement));</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                               boundary_id,</div><div class="line">                                               <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                               constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(y_displacement));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (dim==3)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> z_displacement(2);</div><div class="line"></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 3;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)</div><div class="line">                                                    |</div><div class="line">                                                    fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement)));</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)</div><div class="line">                                                    |</div><div class="line">                                                    fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement)));</div><div class="line">      }</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 4;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement));</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement));</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 6;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)</div><div class="line">                                                    |</div><div class="line">                                                    fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement)));</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)</div><div class="line">                                                    |</div><div class="line">                                                    fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement)));</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 3;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)));</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)));</div><div class="line">      }</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 6;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)));</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                   boundary_id,</div><div class="line">                                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                   constraints,</div><div class="line">                                                   (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)));</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidassemble_sc"></a> </p><h4>Solid::assemble_sc</h4>
<p>Solving the entire block system is a bit problematic as there are no contributions to the <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{ \widetilde{J} \widetilde{J}}$" src="form_3732.png"/> block, rendering it noninvertible (when using an iterative solver). Since the pressure and dilatation variables DOFs are discontinuous, we can condense them out to form a smaller displacement-only system which we will then solve and subsequently post-process to retrieve the pressure and dilatation solutions.</p>
<p>The static condensation process could be performed at a global level but we need the inverse of one of the blocks. However, since the pressure and dilatation variables are discontinuous, the static condensation (SC) operation can also be done on a per-cell basis and we can produce the inverse of the block-diagonal <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}$" src="form_3733.png"/> block by inverting the local blocks. We can again use TBB to do this since each operation will be independent of one another.</p>
<p>Using the TBB via the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class, we assemble the contributions to form <img class="formulaInl" alt="$ \mathsf{\mathbf{K}}_{\textrm{con}} = \bigl[ \mathsf{\mathbf{K}}_{uu} + \overline{\overline{\mathsf{\mathbf{K}}}}~ \bigr] $" src="form_3734.png"/> from each element's contributions. These contributions are then added to the global stiffness matrix. Given this description, the following two functions should be clear:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::assemble_sc()</div><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Perform static condensation&quot;</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; ASM_SC &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  PerTaskData_SC per_task_data(dofs_per_cell, element_indices_u.size(),</div><div class="line">                               element_indices_p.size(),</div><div class="line">                               element_indices_J.size());</div><div class="line">  ScratchData_SC scratch_data;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  *<span class="keyword">this</span>,</div><div class="line">                  &amp;Solid::assemble_sc_one_cell,</div><div class="line">                  &amp;Solid::copy_local_to_global_sc,</div><div class="line">                  scratch_data,</div><div class="line">                  per_task_data);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::copy_local_to_global_sc(<span class="keyword">const</span> PerTaskData_SC &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      tangent_matrix.<a class="code" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add</a>(data.local_dof_indices[i],</div><div class="line">                         data.local_dof_indices[j],</div><div class="line">                         data.cell_matrix(i, j));</div><div class="line">}</div></div><!-- fragment --><p>Now we describe the static condensation process. As per usual, we must first find out which global numbers the degrees of freedom on this cell have and reset some data structures:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::assemble_sc_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                 ScratchData_SC &amp;scratch,</div><div class="line">                                 PerTaskData_SC &amp;data)</div><div class="line">{</div><div class="line">  data.reset();</div><div class="line">  scratch.reset();</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div></div><!-- fragment --><p>We now extract the contribution of the dofs associated with the current cell to the global stiffness matrix. The discontinuous nature of the <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> interpolations mean that their is no coupling of the local contributions at the global level. This is not the case with the <img class="formulaInl" alt="$\mathbf{u}$" src="form_1365.png"/> dof. In other words, <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{J} \widetilde{p}}$" src="form_3735.png"/>, <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{p}}$" src="form_3736.png"/> and <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{J} \widetilde{p}}$" src="form_3735.png"/>, when extracted from the global stiffness matrix are the element contributions. This is not the case for <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{uu}$" src="form_3722.png"/>.</p>
<p>Note: A lower-case symbol is used to denote element stiffness matrices.</p>
<p>Currently the matrix corresponding to the dof associated with the current element (denoted somewhat loosely as <img class="formulaInl" alt="$\mathsf{\mathbf{k}}$" src="form_3737.png"/>) is of the form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \begin{bmatrix} \mathsf{\mathbf{k}}_{uu} &amp; \mathsf{\mathbf{k}}_{u\widetilde{p}} &amp; \mathbf{0} \\ \mathsf{\mathbf{k}}_{\widetilde{p}u} &amp; \mathbf{0} &amp; \mathsf{\mathbf{k}}_{\widetilde{p}\widetilde{J}} \\ \mathbf{0} &amp; \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{p}} &amp; \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{J}} \end{bmatrix} \end{align*}" src="form_3738.png"/>
</p>
<p>We now need to modify it such that it appear as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \begin{bmatrix} \mathsf{\mathbf{k}}_{\textrm{con}} &amp; \mathsf{\mathbf{k}}_{u\widetilde{p}} &amp; \mathbf{0} \\ \mathsf{\mathbf{k}}_{\widetilde{p}u} &amp; \mathbf{0} &amp; \mathsf{\mathbf{k}}_{\widetilde{p}\widetilde{J}}^{-1} \\ \mathbf{0} &amp; \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{p}} &amp; \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{J}} \end{bmatrix} \end{align*}" src="form_3739.png"/>
</p>
<p> with <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\textrm{con}} = \bigl[ \mathsf{\mathbf{k}}_{uu} +\overline{\overline{\mathsf{\mathbf{k}}}}~ \bigr]$" src="form_3740.png"/> where <img class="formulaInl" alt="$ \overline{\overline{\mathsf{\mathbf{k}}}} := \mathsf{\mathbf{k}}_{u\widetilde{p}} \overline{\mathsf{\mathbf{k}}} \mathsf{\mathbf{k}}_{\widetilde{p}u} $" src="form_3741.png"/> and <img class="formulaInl" alt="$ \overline{\mathsf{\mathbf{k}}} = \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{p}}^{-1} \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{J}} \mathsf{\mathbf{k}}_{\widetilde{p}\widetilde{J}}^{-1} $" src="form_3742.png"/>.</p>
<p>At this point, we need to take note of the fact that global data already exists in the <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{uu}$" src="form_3743.png"/>, <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\widetilde{p} \widetilde{J}}$" src="form_3744.png"/> and <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{p}}$" src="form_3745.png"/> sub-blocks. So if we are to modify them, we must account for the data that is already there (i.e. simply add to it or remove it if necessary). Since the copy_local_to_global operation is a "+=" operation, we need to take this into account</p>
<p>For the <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{uu}$" src="form_3743.png"/> block in particular, this means that contributions have been added from the surrounding cells, so we need to be careful when we manipulate this block. We can't just erase the sub-blocks.</p>
<p>This is the strategy we will employ to get the sub-blocks we want:</p>
<ul>
<li><img class="formulaInl" alt="$ {\mathsf{\mathbf{k}}}_{\textrm{store}}$" src="form_3746.png"/>: Since we don't have access to <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{uu}$" src="form_3722.png"/>, but we know its contribution is added to the global <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{uu}$" src="form_3743.png"/> matrix, we just want to add the element wise static-condensation <img class="formulaInl" alt="$\overline{\overline{\mathsf{\mathbf{k}}}}$" src="form_3747.png"/>.</li>
<li><img class="formulaInl" alt="$\mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}}$" src="form_3748.png"/>: Similarly, <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$" src="form_3725.png"/> exists in the subblock. Since the copy operation is a += operation, we need to subtract the existing <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$" src="form_3725.png"/> submatrix in addition to "adding" that which we wish to replace it with.</li>
<li><img class="formulaInl" alt="$\mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{p}}$" src="form_3749.png"/>: Since the global matrix is symmetric, this block is the same as the one above and we can simply use <img class="formulaInl" alt="$\mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}}$" src="form_3748.png"/> as a substitute for this one.</li>
</ul>
<p>We first extract element data from the system matrix. So first we get the entire subblock for the cell, then extract <img class="formulaInl" alt="$\mathsf{\mathbf{k}}$" src="form_3737.png"/> for the dofs associated with the current element</p>
<div class="fragment"><div class="line">data.k_orig.extract_submatrix_from(tangent_matrix,</div><div class="line">                                   data.local_dof_indices,</div><div class="line">                                   data.local_dof_indices);</div></div><!-- fragment --><p>and next the local matrices for <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{ \widetilde{p} u}$" src="form_3728.png"/> <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{ \widetilde{p} \widetilde{J}}$" src="form_3750.png"/> and <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{ \widetilde{J} \widetilde{J}}$" src="form_3730.png"/>:</p>
<div class="fragment"><div class="line">data.k_pu.extract_submatrix_from(data.k_orig,</div><div class="line">                                 element_indices_p,</div><div class="line">                                 element_indices_u);</div><div class="line">data.k_pJ.extract_submatrix_from(data.k_orig,</div><div class="line">                                 element_indices_p,</div><div class="line">                                 element_indices_J);</div><div class="line">data.k_JJ.extract_submatrix_from(data.k_orig,</div><div class="line">                                 element_indices_J,</div><div class="line">                                 element_indices_J);</div></div><!-- fragment --><p>To get the inverse of <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$" src="form_3725.png"/>, we invert it directly. This operation is relatively inexpensive since <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$" src="form_3725.png"/> since block-diagonal.</p>
<div class="fragment"><div class="line">data.k_pJ_inv.invert(data.k_pJ);</div></div><!-- fragment --><p>Now we can make condensation terms to add to the <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{uu}$" src="form_3722.png"/> block and put them in the cell local matrix <img class="formulaInl" alt="$ \mathsf{\mathbf{A}} = \mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{k}}_{\widetilde{p} u} $" src="form_3751.png"/>:</p>
<div class="fragment"><div class="line">data.k_pJ_inv.mmult(data.A, data.k_pu);</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{B}} = \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{J}} \mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{k}}_{\widetilde{p} u} $" src="form_3752.png"/></p>
<div class="fragment"><div class="line">data.k_JJ.mmult(data.B, data.A);</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{C}} = \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{p}} \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{J}} \mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{k}}_{\widetilde{p} u} $" src="form_3753.png"/></p>
<div class="fragment"><div class="line">data.k_pJ_inv.Tmmult(data.C, data.B);</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \overline{\overline{\mathsf{\mathbf{k}}}} = \mathsf{\mathbf{k}}_{u \widetilde{p}} \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{p}} \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{J}} \mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{k}}_{\widetilde{p} u} $" src="form_3754.png"/></p>
<div class="fragment"><div class="line">data.k_pu.Tmmult(data.k_bbar, data.C);</div><div class="line">data.k_bbar.scatter_matrix_to(element_indices_u,</div><div class="line">                              element_indices_u,</div><div class="line">                              data.cell_matrix);</div></div><!-- fragment --><p>Next we place <img class="formulaInl" alt="$\mathsf{\mathbf{k}}^{-1}_{ \widetilde{p} \widetilde{J}}$" src="form_3755.png"/> in the <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{ \widetilde{p} \widetilde{J}}$" src="form_3750.png"/> block for post-processing. Note again that we need to remove the contribution that already exists there.</p>
<div class="fragment"><div class="line">  data.k_pJ_inv.add(-1.0, data.k_pJ);</div><div class="line">  data.k_pJ_inv.scatter_matrix_to(element_indices_p,</div><div class="line">                                  element_indices_J,</div><div class="line">                                  data.cell_matrix);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidsolve_linear_system"></a> </p><h4>Solid::solve_linear_system</h4>
<p>We now have all of the necessary components to use one of two possible methods to solve the linearised system. The first is to perform static condensation on an element level, which requires some alterations to the tangent matrix and RHS vector. Alternatively, the full block system can be solved by performing condensation on a global level. Below we implement both approaches.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;unsigned int, double&gt;</div><div class="line">Solid&lt;dim&gt;::solve_linear_system(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update)</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lin_it = 0;</div><div class="line">  <span class="keywordtype">double</span> lin_res = 0.0;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (parameters.use_static_condensation == <span class="keyword">true</span>)</div><div class="line">    {</div></div><!-- fragment --><p>Firstly, here is the approach using the (permanent) augmentation of the tangent matrix. For the following, recall that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathsf{\mathbf{K}}_{\textrm{store}} := \begin{bmatrix} \mathsf{\mathbf{K}}_{\textrm{con}} &amp; \mathsf{\mathbf{K}}_{u\widetilde{p}} &amp; \mathbf{0} \\ \mathsf{\mathbf{K}}_{\widetilde{p}u} &amp; \mathbf{0} &amp; \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1} \\ \mathbf{0} &amp; \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}} &amp; \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} \end{bmatrix} \, . \end{align*}" src="form_3756.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} d \widetilde{\mathsf{\mathbf{p}}} &amp; = \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \bigl[ \mathsf{\mathbf{F}}_{\widetilde{J}} - \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} d \widetilde{\mathsf{\mathbf{J}}} \bigr] \\ d \widetilde{\mathsf{\mathbf{J}}} &amp; = \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1} \bigl[ \mathsf{\mathbf{F}}_{\widetilde{p}} - \mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}} \bigr] \\ \Rightarrow d \widetilde{\mathsf{\mathbf{p}}} &amp;= \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \mathsf{\mathbf{F}}_{\widetilde{J}} - \underbrace{\bigl[\mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1}\bigr]}_{\overline{\mathsf{\mathbf{K}}}}\bigl[ \mathsf{\mathbf{F}}_{\widetilde{p}} - \mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}} \bigr] \end{align*}" src="form_3757.png"/>
</p>
<p> and thus </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \underbrace{\bigl[ \mathsf{\mathbf{K}}_{uu} + \overline{\overline{\mathsf{\mathbf{K}}}}~ \bigr] }_{\mathsf{\mathbf{K}}_{\textrm{con}}} d \mathsf{\mathbf{u}} = \underbrace{ \Bigl[ \mathsf{\mathbf{F}}_{u} - \mathsf{\mathbf{K}}_{u\widetilde{p}} \bigl[ \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \mathsf{\mathbf{F}}_{\widetilde{J}} - \overline{\mathsf{\mathbf{K}}}\mathsf{\mathbf{F}}_{\widetilde{p}} \bigr] \Bigr]}_{\mathsf{\mathbf{F}}_{\textrm{con}}} \]" src="form_3758.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \overline{\overline{\mathsf{\mathbf{K}}}} := \mathsf{\mathbf{K}}_{u\widetilde{p}} \overline{\mathsf{\mathbf{K}}} \mathsf{\mathbf{K}}_{\widetilde{p}u} \, . \]" src="form_3759.png"/>
</p>
<p>At the top, we allocate two temporary vectors to help with the static condensation, and variables to store the number of linear solver iterations and the (hopefully converged) residual.</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> A(dofs_per_block);</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> B(dofs_per_block);</div></div><!-- fragment --><p>In the first step of this function, we solve for the incremental displacement <img class="formulaInl" alt="$d\mathbf{u}$" src="form_3760.png"/>. To this end, we perform static condensation to make <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\textrm{con}} = \bigl[ \mathsf{\mathbf{K}}_{uu} + \overline{\overline{\mathsf{\mathbf{K}}}}~ \bigr]$" src="form_3761.png"/> and put <img class="formulaInl" alt="$\mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}}$" src="form_3762.png"/> in the original <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\widetilde{p} \widetilde{J}}$" src="form_3744.png"/> block. That is, we make <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\textrm{store}}$" src="form_3763.png"/>.</p>
<div class="fragment"><div class="line">{</div><div class="line"></div><div class="line">  assemble_sc();</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{\widetilde{J}} = \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{F}}_{\widetilde{p}} $" src="form_3764.png"/></p>
<div class="fragment"><div class="line">tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, J_dof).vmult(A.block(J_dof),</div><div class="line">                                         system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof));</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{B}}_{\widetilde{J}} = \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}} \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{F}}_{\widetilde{p}} $" src="form_3765.png"/></p>
<div class="fragment"><div class="line">tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, J_dof).vmult(B.block(J_dof),</div><div class="line">                                         A.block(J_dof));</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{\widetilde{J}} = \mathsf{\mathbf{F}}_{\widetilde{J}} - \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}} \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{F}}_{\widetilde{p}} $" src="form_3766.png"/></p>
<div class="fragment"><div class="line">A.block(J_dof) = system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof);</div><div class="line">A.block(J_dof) -= B.block(J_dof);</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{\widetilde{J}} = \mathsf{\mathbf{K}}^{-1}_{\widetilde{J} \widetilde{p}} [ \mathsf{\mathbf{F}}_{\widetilde{J}} - \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}} \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{F}}_{\widetilde{p}} ] $" src="form_3767.png"/></p>
<div class="fragment"><div class="line">tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, J_dof).Tvmult(A.block(p_dof),</div><div class="line">                                          A.block(J_dof));</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{u} = \mathsf{\mathbf{K}}_{u \widetilde{p}} \mathsf{\mathbf{K}}^{-1}_{\widetilde{J} \widetilde{p}} [ \mathsf{\mathbf{F}}_{\widetilde{J}} - \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}} \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{F}}_{\widetilde{p}} ] $" src="form_3768.png"/></p>
<div class="fragment"><div class="line">tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, p_dof).vmult(A.block(u_dof),</div><div class="line">                                         A.block(p_dof));</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{F}}_{\text{con}} = \mathsf{\mathbf{F}}_{u} - \mathsf{\mathbf{K}}_{u \widetilde{p}} \mathsf{\mathbf{K}}^{-1}_{\widetilde{J} \widetilde{p}} [ \mathsf{\mathbf{F}}_{\widetilde{J}} - \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}} \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}} \mathsf{\mathbf{F}}_{\widetilde{p}} ] $" src="form_3769.png"/></p>
<div class="fragment"><div class="line">system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof) -= A.block(u_dof);</div><div class="line"></div><div class="line">timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; SLV &quot;</span> &lt;&lt; std::flush;</div><div class="line"><span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;CG&quot;</span>)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> solver_its = tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof).m()</div><div class="line">                           * parameters.max_iterations_lin;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tol_sol = parameters.tol_lin</div><div class="line">                           * system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof).l2_norm();</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(solver_its, tol_sol);</div><div class="line"></div><div class="line">    <a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;Vector&lt;double&gt;</a> &gt; GVM;</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a> &gt; solver_CG(solver_control, GVM);</div></div><!-- fragment --><p>We've chosen by default a SSOR preconditioner as it appears to provide the fastest solver convergence characteristics for this problem on a single-thread machine. However, this might not be true for different problem sizes.</p>
<div class="fragment"><div class="line">    <a class="code" href="classPreconditionSelector.html">PreconditionSelector&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">    preconditioner (parameters.preconditioner_type,</div><div class="line">                    parameters.preconditioner_relaxation);</div><div class="line">    preconditioner.use_matrix(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line"></div><div class="line">    solver_CG.solve(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof),</div><div class="line">                    newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof),</div><div class="line">                    system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof),</div><div class="line">                    preconditioner);</div><div class="line"></div><div class="line">    lin_it = solver_control.last_step();</div><div class="line">    lin_res = solver_control.last_value();</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;Direct&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>Otherwise if the problem is small enough, a direct solver can be utilised.</p>
<div class="fragment"><div class="line">      <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">      A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line">      A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof), system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof));</div><div class="line"></div><div class="line">      lin_it = 1;</div><div class="line">      lin_res = 0.0;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Linear solver type not implemented&quot;</span>));</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p>Now that we have the displacement update, distribute the constraints back to the Newton update:</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line"></div><div class="line">timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver postprocessing&quot;</span>);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; PP &quot;</span> &lt;&lt; std::flush;</div></div><!-- fragment --><p>The next step after solving the displacement problem is to post-process to get the dilatation solution from the substitution: <img class="formulaInl" alt="$ d \widetilde{\mathsf{\mathbf{J}}} = \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1} \bigl[ \mathsf{\mathbf{F}}_{\widetilde{p}} - \mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}} \bigr] $" src="form_3770.png"/></p>
<div class="fragment"><div class="line">{</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{\widetilde{p}} = \mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}} $" src="form_3771.png"/></p>
<div class="fragment"><div class="line">tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, u_dof).vmult(A.block(p_dof),</div><div class="line">                                         newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof));</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{\widetilde{p}} = -\mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}} $" src="form_3772.png"/></p>
<div class="fragment"><div class="line">A.block(p_dof) *= -1.0;</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{\widetilde{p}} = \mathsf{\mathbf{F}}_{\widetilde{p}} -\mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}} $" src="form_3773.png"/></p>
<div class="fragment"><div class="line">A.block(p_dof) += system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof);</div></div><!-- fragment --><p><img class="formulaInl" alt="$ d\mathsf{\mathbf{\widetilde{J}}} = \mathsf{\mathbf{K}}^{-1}_{\widetilde{p}\widetilde{J}} [ \mathsf{\mathbf{F}}_{\widetilde{p}} -\mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}} ] $" src="form_3774.png"/></p>
<div class="fragment"><div class="line">  tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, J_dof).vmult(newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof),</div><div class="line">                                           A.block(p_dof));</div><div class="line">}</div></div><!-- fragment --><p>we ensure here that any Dirichlet constraints are distributed on the updated solution:</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div></div><!-- fragment --><p>Finally we solve for the pressure update with the substitution: <img class="formulaInl" alt="$ d \widetilde{\mathsf{\mathbf{p}}} = \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \bigl[ \mathsf{\mathbf{F}}_{\widetilde{J}} - \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} d \widetilde{\mathsf{\mathbf{J}}} \bigr] $" src="form_3775.png"/></p>
<div class="fragment"><div class="line">{</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{\widetilde{J}} = \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} d \widetilde{\mathsf{\mathbf{J}}} $" src="form_3776.png"/></p>
<div class="fragment"><div class="line">tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, J_dof).vmult(A.block(J_dof),</div><div class="line">                                         newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof));</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{\widetilde{J}} = -\mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} d \widetilde{\mathsf{\mathbf{J}}} $" src="form_3777.png"/></p>
<div class="fragment"><div class="line">A.block(J_dof) *= -1.0;</div></div><!-- fragment --><p><img class="formulaInl" alt="$ \mathsf{\mathbf{A}}_{\widetilde{J}} = \mathsf{\mathbf{F}}_{\widetilde{J}} - \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} d \widetilde{\mathsf{\mathbf{J}}} $" src="form_3778.png"/></p>
<div class="fragment"><div class="line">A.block(J_dof) += system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof);</div></div><!-- fragment --><p>and finally.... <img class="formulaInl" alt="$ d \widetilde{\mathsf{\mathbf{p}}} = \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1} \bigl[ \mathsf{\mathbf{F}}_{\widetilde{J}} - \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} d \widetilde{\mathsf{\mathbf{J}}} \bigr] $" src="form_3775.png"/></p>
<div class="fragment"><div class="line">  tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, J_dof).Tvmult(newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof),</div><div class="line">                                            A.block(J_dof));</div><div class="line">}</div></div><!-- fragment --><p>We are now at the end, so we distribute all constrained dofs back to the Newton update:</p>
<div class="fragment"><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; ------ &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; SLV &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;CG&quot;</span>)</div><div class="line">      {</div></div><!-- fragment --><p>Manual condensation of the dilatation and pressure fields on a local level, and subsequent post-processing, took quite a bit of effort to achieve. To recap, we had to produce the inverse matrix <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1}$" src="form_3779.png"/>, which was permanently written into the global tangent matrix. We then permanently modified <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{uu}$" src="form_3743.png"/> to produce <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\textrm{con}}$" src="form_3780.png"/>. This involved the extraction and manipulation of local sub-blocks of the tangent matrix. After solving for the displacement, the individual matrix-vector operations required to solve for dilatation and pressure were carefully implemented. Contrast these many sequence of steps to the much simpler and transparent implementation using functionality provided by the <a class="el" href="classLinearOperator.html">LinearOperator</a> class.</p>
<p>For ease of later use, we define some aliases for blocks in the RHS vector</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;f_u = system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;f_p = system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;f_J = system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof);</div></div><!-- fragment --><p>... and for blocks in the Newton update vector.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;d_u = newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;d_p = newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;d_J = newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof);</div></div><!-- fragment --><p>We next define some linear operators for the tangent matrix sub-blocks We will exploit the symmetry of the system, so not all blocks are required.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_uu = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_up = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, p_dof));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_pu = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, u_dof));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_Jp = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, p_dof));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_JJ = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, J_dof));</div></div><!-- fragment --><p>We then construct a <a class="el" href="classLinearOperator.html">LinearOperator</a> that represents the inverse of (square block) <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}$" src="form_3781.png"/>. Since it is diagonal (or, when a higher order ansatz it used, nearly diagonal), a Jacobi preconditioner is suitable.</p>
<div class="fragment"><div class="line"><a class="code" href="classPreconditionSelector.html">PreconditionSelector&lt; SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">preconditioner_K_Jp_inv (<span class="stringliteral">&quot;jacobi&quot;</span>);</div><div class="line">preconditioner_K_Jp_inv.use_matrix(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, p_dof));</div><div class="line"><a class="code" href="classReductionControl.html">ReductionControl</a> solver_control_K_Jp_inv (tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, p_dof).m() * parameters.max_iterations_lin,</div><div class="line">                                          1.0e-30, parameters.tol_lin);</div><div class="line"><a class="code" href="classSolverSelector.html">SolverSelector&lt; Vector&lt;double&gt;</a> &gt; solver_K_Jp_inv;</div><div class="line">solver_K_Jp_inv.<a class="code" href="classSolverSelector.html#a3da215c843356cdab3b603ce98991b53">select</a>(<span class="stringliteral">&quot;cg&quot;</span>);</div><div class="line">solver_K_Jp_inv.set_control(solver_control_K_Jp_inv);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_Jp_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(K_Jp,</div><div class="line">                                       solver_K_Jp_inv,</div><div class="line">                                       preconditioner_K_Jp_inv);</div></div><!-- fragment --><p>Now we can construct that transpose of <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1}$" src="form_3782.png"/> and a linear operator that represents the condensed operations <img class="formulaInl" alt="$\overline{\mathsf{\mathbf{K}}}$" src="form_3783.png"/> and <img class="formulaInl" alt="$\overline{\overline{\mathsf{\mathbf{K}}}}$" src="form_3784.png"/> and the final augmented matrix <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\textrm{con}}$" src="form_3780.png"/>. Note that the <a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement()</a> operator could also be of use here, but for clarity and the purpose of demonstrating the similarities between the formulation and implementation of the linear solution scheme, we will perform these operations manually.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_pJ_inv     = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(K_Jp_inv);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_pp_bar     = K_Jp_inv * K_JJ * K_pJ_inv;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_uu_bar_bar = K_up * K_pp_bar * K_pu;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_uu_con     = K_uu + K_uu_bar_bar;</div></div><!-- fragment --><p>Lastly, we define an operator for inverse of augmented stiffness matrix, namely <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\textrm{con}}^{-1}$" src="form_3785.png"/>. Note that the preconditioner for the augmented stiffness matrix is different to the case when we use static condensation. In this instance, the preconditioner is based on a non-modified <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{uu}$" src="form_3743.png"/>, while with the first approach we actually modified the entries of this sub-block. However, since <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{\textrm{con}}$" src="form_3780.png"/> and <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{uu}$" src="form_3743.png"/> operate on the same space, it remains adequate for this problem.</p>
<div class="fragment"><div class="line"><a class="code" href="classPreconditionSelector.html">PreconditionSelector&lt; SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">preconditioner_K_con_inv (parameters.preconditioner_type,</div><div class="line">                          parameters.preconditioner_relaxation);</div><div class="line">preconditioner_K_con_inv.use_matrix(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line"><a class="code" href="classReductionControl.html">ReductionControl</a> solver_control_K_con_inv (tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof).m() * parameters.max_iterations_lin,</div><div class="line">                                           1.0e-30, parameters.tol_lin);</div><div class="line"><a class="code" href="classSolverSelector.html">SolverSelector&lt; Vector&lt;double&gt;</a> &gt; solver_K_con_inv;</div><div class="line">solver_K_con_inv.<a class="code" href="classSolverSelector.html#a3da215c843356cdab3b603ce98991b53">select</a>(<span class="stringliteral">&quot;cg&quot;</span>);</div><div class="line">solver_K_con_inv.set_control(solver_control_K_con_inv);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> K_uu_con_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(K_uu_con,</div><div class="line">                                           solver_K_con_inv,</div><div class="line">                                           preconditioner_K_con_inv);</div></div><!-- fragment --><p>Now we are in a position to solve for the displacement field. We can nest the linear operations, and the result is immediately written to the Newton update vector. It is clear that the implementation closely mimics the derivation stated in the introduction.</p>
<div class="fragment"><div class="line">d_u = K_uu_con_inv*(f_u - K_up*(K_Jp_inv*f_J - K_pp_bar*f_p));</div><div class="line"></div><div class="line">timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div></div><!-- fragment --><p>The operations need to post-process for the dilatation and pressure fields are just as easy to express.</p>
<div class="fragment"><div class="line">    timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver postprocessing&quot;</span>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; PP &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    d_J = K_pJ_inv*(f_p - K_pu*d_u);</div><div class="line">    d_p = K_Jp_inv*(f_J - K_JJ*d_J);</div><div class="line"></div><div class="line">    lin_it = solver_control_K_con_inv.last_step();</div><div class="line">    lin_res = solver_control_K_con_inv.last_value();</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;Direct&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>Solve the full block system with a direct solver. As it is relatively robust, it may be immune to problem arising from the presence of the zero <img class="formulaInl" alt="$\mathsf{\mathbf{K}}_{ \widetilde{J} \widetilde{J}}$" src="form_3732.png"/> block.</p>
<div class="fragment"><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(tangent_matrix);</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(newton_update, system_rhs);</div><div class="line"></div><div class="line">    lin_it = 1;</div><div class="line">    lin_res = 0.0;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span> &lt;&lt; std::flush;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Linear solver type not implemented&quot;</span>));</div><div class="line"></div><div class="line">timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div></div><!-- fragment --><p>Finally, we again ensure here that any Dirichlet constraints are distributed on the updated solution:</p>
<div class="fragment"><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> std::make_pair(lin_it, lin_res);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidoutput_results"></a> </p><h4>Solid::output_results</h4>
<p>Here we present how the results are written to file to be viewed using ParaView or Visit. The method is similar to that shown in previous tutorials so will not be discussed in detail.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  data_component_interpretation(dim,</div><div class="line">                                <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  data_component_interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; solution_name(dim, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">  solution_name.push_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  solution_name.push_back(<span class="stringliteral">&quot;dilatation&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler_ref);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution_n,</div><div class="line">                           solution_name,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div></div><!-- fragment --><p>Since we are dealing with a large deformation problem, it would be nice to display the result on a displaced grid! The <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> class linked with the <a class="el" href="classDataOut.html">DataOut</a> class provides an interface through which this can be achieved without physically moving the grid points in the <a class="el" href="classTriangulation.html">Triangulation</a> object ourselves. We first need to copy the solution to a temporary vector and then create the Eulerian mapping. We also specify the polynomial degree to the <a class="el" href="classDataOut.html">DataOut</a> object in order to produce a more refined output data set when higher order polynomials are used.</p>
<div class="fragment"><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> soln(solution_n.<a class="code" href="classBlockVectorBase.html#a69b8dc1f71903659eb44f12e02359ac6">size</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; soln.size(); ++i)</div><div class="line">      soln(i) = solution_n(i);</div><div class="line">    <a class="code" href="classMappingQEulerian.html">MappingQEulerian&lt;dim&gt;</a> q_mapping(degree, dof_handler_ref, soln);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>(q_mapping, degree);</div><div class="line"></div><div class="line">    std::ostringstream filename;</div><div class="line">    filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot;d-&quot;</span> &lt;&lt; time.get_timestep() &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line"></div><div class="line">    std::ofstream output(filename.str().c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Mainfunction"></a> </p><h3>Main function</h3>
<p>Lastly we provide the main driver function which appears no different to the other tutorials.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <span class="keyword">using namespace </span>Step44;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div><div class="line">      Solid&lt;dim&gt; solid(<span class="stringliteral">&quot;parameters.prm&quot;</span>);</div><div class="line">      solid.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl &lt;&lt; exc.what()</div><div class="line">                &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span></div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Firstly, we present a comparison of a series of 3-d results with those in the literature (see Reese et al (2000)) to demonstrate that the program works as expected.</p>
<p>We begin with a comparison of the convergence with mesh refinement for the <img class="formulaInl" alt="$Q_1-DGPM_0-DGPM_0$" src="form_3786.png"/> and <img class="formulaInl" alt="$Q_2-DGPM_1-DGPM_1$" src="form_3787.png"/> formulations, as summarised in the figure below. The vertical displacement of the midpoint of the upper surface of the block is used to assess convergence. Both schemes demonstrate good convergence properties for varying values of the load parameter <img class="formulaInl" alt="$p/p_0$" src="form_3788.png"/>. The results agree with those in the literature. The lower-order formulation typically overestimates the displacement for low levels of refinement, while the higher-order interpolation scheme underestimates it, but be a lesser degree. This benchmark, and a series of others not shown here, give us confidence that the code is working as it should.</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.Q1-P0_convergence.png"/>
</div>
 <p>Convergence of the <img class="formulaInl" alt="$Q_1-DGPM_0-DGPM_0$" src="form_3786.png"/> formulation in 3-d. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.Q2-P1_convergence.png"/>
</div>
 <p>Convergence of the <img class="formulaInl" alt="$Q_2-DGPM_1-DGPM_1$" src="form_3787.png"/> formulation in 3-d. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>A typical screen output generated by running the problem is shown below. The particular case demonstrated is that of the <img class="formulaInl" alt="$Q_2-DGPM_1-DGPM_1$" src="form_3787.png"/> formulation. It is clear that, using the Newton-Raphson method, quadratic convergence of the solution is obtained. Solution convergence is achieved within 5 Newton increments for all time-steps. The converged displacement's <img class="formulaInl" alt="$L_2$" src="form_608.png"/>-norm is several orders of magnitude less than the geometry scale.</p>
<div class="fragment"><div class="line">Grid:</div><div class="line">         Reference <a class="code" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">volume</a>: 1e-09</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation</a>:</div><div class="line">         Number of active cells: 64</div><div class="line">         Number of degrees of freedom: 2699</div><div class="line">    Setting up quadrature <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a> data...</div><div class="line"></div><div class="line">Timestep 1 @ 0.1s</div><div class="line">___________________________________________________________________________________________________________________________________________________________</div><div class="line">                 SOLVER STEP                   |  LIN_IT   LIN_RES    RES_NORM     RES_U     RES_P      RES_J     NU_NORM      NU_U       NU_P       NU_J</div><div class="line">___________________________________________________________________________________________________________________________________________________________</div><div class="line">  0  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     786  2.118e-06  1.000e+00  1.000e+00  0.000e+00  0.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00</div><div class="line">  1  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     552  1.031e-03  8.563e-02  8.563e-02  9.200e-13  3.929e-08  1.060e-01  3.816e-02  1.060e-01  1.060e-01</div><div class="line">  2  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     667  5.602e-06  2.482e-03  2.482e-03  3.373e-15  2.982e-10  2.936e-03  2.053e-04  2.936e-03  2.936e-03</div><div class="line">  3  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     856  6.469e-10  2.129e-06  2.129e-06  2.245e-19  1.244e-13  1.887e-06  7.289e-07  1.887e-06  1.887e-06</div><div class="line">  4  ASM_R  CONVERGED!</div><div class="line">___________________________________________________________________________________________________________________________________________________________</div><div class="line">Relative errors:</div><div class="line">Displacement:   7.289e-07</div><div class="line">Force:          2.451e-10</div><div class="line">Dilatation:     1.353e-07</div><div class="line">v / V_0:        1.000e-09 / 1.000e-09 = 1.000e+00</div><div class="line"></div><div class="line"></div><div class="line">[...]</div><div class="line"></div><div class="line">Timestep 10 @ 1.000e+00s</div><div class="line">___________________________________________________________________________________________________________________________________________________________</div><div class="line">                 SOLVER STEP                   |  LIN_IT   LIN_RES    RES_NORM     RES_U     RES_P      RES_J     NU_NORM      NU_U       NU_P       NU_J</div><div class="line">___________________________________________________________________________________________________________________________________________________________</div><div class="line">  0  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     874  2.358e-06  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00  1.000e+00</div><div class="line">  1  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     658  2.942e-04  1.544e-01  1.544e-01  1.208e+13  1.855e+06  6.014e-02  7.398e-02  6.014e-02  6.014e-02</div><div class="line">  2  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     790  2.206e-06  2.908e-03  2.908e-03  7.302e+10  2.067e+03  2.716e-03  1.433e-03  2.716e-03  2.717e-03</div><div class="line">  3  ASM_R  ASM_K  CST  ASM_SC  SLV  PP  UQPH  |     893  2.374e-09  1.919e-06  1.919e-06  4.527e+07  4.100e+00  1.672e-06  6.842e-07  1.672e-06  1.672e-06</div><div class="line">  4  ASM_R  CONVERGED!</div><div class="line">___________________________________________________________________________________________________________________________________________________________</div><div class="line">Relative errors:</div><div class="line">Displacement:   6.842e-07</div><div class="line">Force:          8.995e-10</div><div class="line">Dilatation:     1.528e-06</div><div class="line">v / V_0:        1.000e-09 / 1.000e-09 = 1.000e+00</div></div><!-- fragment --><p>Using the <a class="el" href="classTimer.html">Timer</a> class, we can discern which parts of the code require the highest computational expense. For a case with a large number of degrees-of-freedom (i.e. a high level of refinement), a typical output of the <a class="el" href="classTimer.html">Timer</a> is given below. Much of the code in the tutorial has been developed based on the optimisations described, discussed and demonstrated in <a class="el" href="step_18.html">step-18</a> and others. With over 93% of the time being spent in the linear solver, it is obvious that it may be necessary to invest in a better solver for large three-dimensional problems. The SSOR preconditioner is not multithreaded but is effective for this class of solid problems. It may be beneficial to investigate the use of another solver such as those available through the Trilinos library.</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    | 9.874e+02s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble system right-hand side |        53 | 1.727e+00s |  1.75e-01% |</div><div class="line">| Assemble tangent matrix         |        43 | 2.707e+01s |  2.74e+00% |</div><div class="line">| Linear solver                   |        43 | 9.248e+02s |  9.37e+01% |</div><div class="line">| Linear solver postprocessing    |        43 | 2.743e-02s |  2.78e-03% |</div><div class="line">| Perform <span class="keyword">static</span> condensation     |        43 | 1.437e+01s |  1.46e+00% |</div><div class="line">| Setup system                    |         1 | 3.897e-01s |  3.95e-02% |</div><div class="line">| Update QPH data                 |        43 | 5.770e-01s |  5.84e-02% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>We then used ParaView to visualise the results for two cases. The first was for the coarsest grid and the lowest-order interpolation method: <img class="formulaInl" alt="$Q_1-DGPM_0-DGPM_0$" src="form_3786.png"/>. The second was on a refined grid using a <img class="formulaInl" alt="$Q_2-DGPM_1-DGPM_1$" src="form_3787.png"/> formulation. The vertical component of the displacement, the pressure <img class="formulaInl" alt="$\widetilde{p}$" src="form_3625.png"/> and the dilatation <img class="formulaInl" alt="$\widetilde{J}$" src="form_3624.png"/> fields are shown below.</p>
<p>For the first case it is clear that the coarse spatial discretisation coupled with large displacements leads to a low quality solution (the loading ratio is <img class="formulaInl" alt="$p/p_0=80$" src="form_3789.png"/>). Additionally, the pressure difference between elements is very large. The constant pressure field on the element means that the large pressure gradient is not captured. However, it should be noted that locking, which would be present in a standard <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> displacement formulation does not arise even in this poorly discretised case. The final vertical displacement of the tracked node on the top surface of the block is still within 12.5% of the converged solution. The pressure solution is very coarse and has large jumps between adjacent cells. It is clear that the volume nearest to the applied traction undergoes compression while the outer extents of the domain are in a state of expansion. The dilatation solution field and pressure field are clearly linked, with positive dilatation indicating regions of positive pressure and negative showing regions placed in compression. As discussed in the Introduction, a compressive pressure has a negative sign while an expansive pressure takes a positive sign. This stems from the definition of the volumetric strain energy function and is opposite to the physically realistic interpretation of pressure.</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.Q1-P0_gr_1_p_ratio_80-displacement.png"/>
</div>
 <p>Z-displacement solution for the 3-d problem. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.Q1-P0_gr_1_p_ratio_80-pressure.png"/>
</div>
 <p>Discontinuous piece-wise constant pressure field. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.Q1-P0_gr_1_p_ratio_80-dilatation.png"/>
</div>
 <p>Discontinuous piece-wise constant dilatation field. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>Combining spatial refinement and a higher-order interpolation scheme results in a high-quality solution. Three grid refinements coupled with a <img class="formulaInl" alt="$Q_2-DGPM_1-DGPM_1$" src="form_3787.png"/> formulation produces a result that clearly captures the mechanics of the problem. The deformation of the traction surface is well resolved. We can now observe the actual extent of the applied traction, with the maximum force being applied at the central point of the surface causing the largest compression. Even though very high strains are experienced in the domain, especially at the boundary of the region of applied traction, the solution remains accurate. The pressure field is captured in far greater detail than before. There is a clear distinction and transition between regions of compression and expansion, and the linear approximation of the pressure field allows a refined visualisation of the pressure at the sub-element scale. It should however be noted that the pressure field remains discontinuous and could be smoothed on a continuous grid for the post-processing purposes.</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.Q2-P1_gr_3_p_ratio_80-displacement.png"/>
</div>
 <p>Z-displacement solution for the 3-d problem. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.Q2-P1_gr_3_p_ratio_80-pressure.png"/>
</div>
 <p>Discontinuous linear pressure field. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.Q2-P1_gr_3_p_ratio_80-dilatation.png"/>
</div>
 <p>Discontinuous linear dilatation field. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>This brief analysis of the results demonstrates that the three-field formulation is effective in circumventing volumetric locking for highly-incompressible media. The mixed formulation is able to accurately simulate the displacement of a near-incompressible block under compression. The command-line output indicates that the volumetric change under extreme compression resulted in less than 0.01% volume change for a Poisson's ratio of 0.4999.</p>
<p>In terms of run-time, the <img class="formulaInl" alt="$Q_2-DGPM_1-DGPM_1$" src="form_3787.png"/> formulation tends to be more computationally expensive than the <img class="formulaInl" alt="$Q_1-DGPM_0-DGPM_0$" src="form_3786.png"/> for a similar number of degrees-of-freedom (produced by adding an extra grid refinement level for the lower-order interpolation). This is shown in the graph below for a batch of tests run consecutively on a single 4-core (8-thread) machine. The increase in computational time for the higher-order method is likely due to the increased band-width required for the higher-order elements. As previously mentioned, the use of a better solver and preconditioner may mitigate the expense of using a higher-order formulation. It was observed that for the given problem using the multithreaded Jacobi preconditioner can reduce the computational runtime by up to 72% (for the worst case being a higher-order formulation with a large number of degrees-of-freedom) in comparison to the single-thread SSOR preconditioner. However, it is the author's experience that the Jacobi method of preconditioning may not be suitable for some finite-strain problems involving alternative constitutive models.</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.Normalised_runtime.png"/>
</div>
 <p>Runtime on a 4-core machine, normalised against the lowest grid resolution <img class="formulaInl" alt="$Q_1-DGPM_0-DGPM_0$" src="form_3786.png"/> solution that utilised a SSOR preconditioner. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>Lastly, results for the displacement solution for the 2-d problem are showcased below for two different levels of grid refinement. It is clear that due to the extra constraints imposed by simulating in 2-d that the resulting displacement field, although qualitatively similar, is different to that of the 3-d case.</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.2d-gr_2.png"/>
</div>
 <p>Y-displacement solution in 2-d for 2 global grid refinement levels. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-44.2d-gr_5.png"/>
</div>
 <p>Y-displacement solution in 2-d for 5 global grid refinement levels. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>There are a number of obvious extensions for this work:</p>
<ul>
<li>Firstly, an additional constraint could be added to the free-energy function in order to enforce a high degree of incompressibility in materials. An additional Lagrange multiplier would be introduced, but this could most easily be dealt with using the principle of augmented Lagrange multipliers. This is demonstrated in <em>Simo and Taylor (1991) </em>.</li>
<li>The constitutive relationship used in this model is relatively basic. It may be beneficial to split the material class into two separate classes, one dealing with the volumetric response and the other the isochoric response, and produce a generic materials class (i.e. having abstract virtual functions that derived classes have to implement) that would allow for the addition of more complex material models. Such models could include other hyperelastic materials, plasticity and viscoelastic materials and others.</li>
<li>The program has been developed for solving problems on single-node multicore machines. With a little effort, the program could be extended to a large-scale computing environment through the use of Petsc or Trilinos, using a similar technique to that demonstrated in <a class="el" href="step_40.html">step-40</a>. This would mostly involve changes to the setup, assembly, <code>PointHistory</code> and linear solver routines.</li>
<li>As this program assumes quasi-static equilibrium, extensions to include dynamic effects would be necessary to study problems where inertial effects are important, e.g. problems involving impact.</li>
<li>Load and solution limiting procedures may be necessary for highly nonlinear problems. It is possible to add a linesearch algorithm to limit the step size within a Newton increment to ensure optimum convergence. It may also be necessary to use a load limiting method, such as the Riks method, to solve unstable problems involving geometric instability such as buckling and snap-through.</li>
<li>Many physical problems involve contact. It is possible to include the effect of frictional or frictionless contact between objects into this program. This would involve the addition of an extra term in the free-energy functional and therefore an addition to the assembly routine. One would also need to manage the contact problem (detection and stress calculations) itself. An alternative to additional penalty terms in the free-energy functional would be to use active set methods such as the one used in <a class="el" href="step_41.html">step-41</a>.</li>
<li>The complete condensation procedure using LinearOperators has been coded into the linear solver routine. This could also have been achieved through the application of the <a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement()</a> operator to condense out one or more of the fields in a more automated manner.</li>
<li>Finally, adaptive mesh refinement, as demonstrated in <a class="el" href="step_6.html">step-6</a> and <a class="el" href="step_18.html">step-18</a>, could provide additional solution accuracy. <a class="anchor" id="PlainProg"></a> <h1>The plain program</h1>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2010 - 2017 by the deal.II authors and</span></div><div class="line"><span class="comment"> *                              &amp; Jean-Paul Pelteret and Andrew McBride</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Jean-Paul Pelteret, University of Cape Town,</span></div><div class="line"><span class="comment"> *          Andrew McBride, University of Erlangen-Nuremberg, 2010</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/point.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/symmetric_tensor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/work_stream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_point_data.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgp_monomial.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q_eulerian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition_selector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/linear_operator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/packaged_operation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/iterative_inverse.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/physics/elasticity/kinematics.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/physics/elasticity/standard_tensors.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step44</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>Parameters</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="classFESystem.html">FESystem</a></div><div class="line">    {</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> poly_degree;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> quad_order;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">      declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span></div><div class="line">      parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> FESystem::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Finite element system&quot;</span>);</div><div class="line">      {</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Polynomial degree&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                          <span class="stringliteral">&quot;Displacement system polynomial order&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                          <span class="stringliteral">&quot;Gauss quadrature order&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> FESystem::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Finite element system&quot;</span>);</div><div class="line">      {</div><div class="line">        poly_degree = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Polynomial degree&quot;</span>);</div><div class="line">        quad_order = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">struct </span>Geometry</div><div class="line">    {</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> global_refinement;</div><div class="line">      <span class="keywordtype">double</span>       <a class="code" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a>;</div><div class="line">      <span class="keywordtype">double</span>       p_p0;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">      declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span></div><div class="line">      parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Geometry::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Geometry&quot;</span>);</div><div class="line">      {</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Global refinement&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                          <span class="stringliteral">&quot;Global refinement level&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Grid scale&quot;</span>, <span class="stringliteral">&quot;1e-3&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                          <span class="stringliteral">&quot;Global grid scaling factor&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Pressure ratio p/p0&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;20|40|60|80|100&quot;</span>),</div><div class="line">                          <span class="stringliteral">&quot;Ratio of applied pressure to reference pressure&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Geometry::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Geometry&quot;</span>);</div><div class="line">      {</div><div class="line">        global_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Global refinement&quot;</span>);</div><div class="line">        <a class="code" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a> = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Grid scale&quot;</span>);</div><div class="line">        p_p0 = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Pressure ratio p/p0&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">struct </span>Materials</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> nu;</div><div class="line">      <span class="keywordtype">double</span> mu;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">      declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span></div><div class="line">      parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Materials::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Material properties&quot;</span>);</div><div class="line">      {</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>, <span class="stringliteral">&quot;0.4999&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(-1.0,0.5),</div><div class="line">                          <span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Shear modulus&quot;</span>, <span class="stringliteral">&quot;80.194e6&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                          <span class="stringliteral">&quot;Shear modulus&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Materials::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Material properties&quot;</span>);</div><div class="line">      {</div><div class="line">        nu = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>);</div><div class="line">        mu = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Shear modulus&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">struct </span>LinearSolver</div><div class="line">    {</div><div class="line">      std::string type_lin;</div><div class="line">      <span class="keywordtype">double</span>      tol_lin;</div><div class="line">      <span class="keywordtype">double</span>      max_iterations_lin;</div><div class="line">      <span class="keywordtype">bool</span>        use_static_condensation;</div><div class="line">      std::string preconditioner_type;</div><div class="line">      <span class="keywordtype">double</span>      preconditioner_relaxation;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">      declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span></div><div class="line">      parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> LinearSolver::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">      {</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Solver type&quot;</span>, <span class="stringliteral">&quot;CG&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|Direct&quot;</span>),</div><div class="line">                          <span class="stringliteral">&quot;Type of solver used to solve the linear system&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Residual&quot;</span>, <span class="stringliteral">&quot;1e-6&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                          <span class="stringliteral">&quot;Linear solver residual (scaled by residual norm)&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Max iteration multiplier&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                          <span class="stringliteral">&quot;Linear solver iterations (multiples of the system matrix size)&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Use static condensation&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                          <span class="stringliteral">&quot;Solve the full block system or a reduced problem&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Preconditioner type&quot;</span>, <span class="stringliteral">&quot;ssor&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;jacobi|ssor&quot;</span>),</div><div class="line">                          <span class="stringliteral">&quot;Type of preconditioner&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Preconditioner relaxation&quot;</span>, <span class="stringliteral">&quot;0.65&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                          <span class="stringliteral">&quot;Preconditioner relaxation value&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> LinearSolver::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">      {</div><div class="line">        type_lin = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Solver type&quot;</span>);</div><div class="line">        tol_lin = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Residual&quot;</span>);</div><div class="line">        max_iterations_lin = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Max iteration multiplier&quot;</span>);</div><div class="line">        use_static_condensation = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Use static condensation&quot;</span>);</div><div class="line">        preconditioner_type = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Preconditioner type&quot;</span>);</div><div class="line">        preconditioner_relaxation = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Preconditioner relaxation&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">struct </span>NonlinearSolver</div><div class="line">    {</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations_NR;</div><div class="line">      <span class="keywordtype">double</span>       tol_f;</div><div class="line">      <span class="keywordtype">double</span>       tol_u;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">      declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span></div><div class="line">      parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> NonlinearSolver::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">      {</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Max iterations Newton-Raphson&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                          <span class="stringliteral">&quot;Number of Newton-Raphson iterations allowed&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Tolerance force&quot;</span>, <span class="stringliteral">&quot;1.0e-9&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                          <span class="stringliteral">&quot;Force residual tolerance&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Tolerance displacement&quot;</span>, <span class="stringliteral">&quot;1.0e-6&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                          <span class="stringliteral">&quot;Displacement error tolerance&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> NonlinearSolver::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">      {</div><div class="line">        max_iterations_NR = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Max iterations Newton-Raphson&quot;</span>);</div><div class="line">        tol_f = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Tolerance force&quot;</span>);</div><div class="line">        tol_u = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Tolerance displacement&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">struct </span>Time</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> delta_t;</div><div class="line">      <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">      declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span></div><div class="line">      parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Time::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Time&quot;</span>);</div><div class="line">      {</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;End time&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                          <span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line"></div><div class="line">        prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Time step size&quot;</span>, <span class="stringliteral">&quot;0.1&quot;</span>,</div><div class="line">                          <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                          <span class="stringliteral">&quot;Time step size&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Time::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Time&quot;</span>);</div><div class="line">      {</div><div class="line">        end_time = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line">        delta_t = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Time step size&quot;</span>);</div><div class="line">      }</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">struct </span>AllParameters : <span class="keyword">public</span> <a class="code" href="classFESystem.html">FESystem</a>,</div><div class="line">      <span class="keyword">public</span> Geometry,</div><div class="line">      <span class="keyword">public</span> Materials,</div><div class="line">      <span class="keyword">public</span> LinearSolver,</div><div class="line">      <span class="keyword">public</span> NonlinearSolver,</div><div class="line">      <span class="keyword">public</span> Time</div><div class="line"></div><div class="line">    {</div><div class="line">      AllParameters(<span class="keyword">const</span> std::string &amp;input_file);</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">      declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span></div><div class="line">      parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    };</div><div class="line"></div><div class="line">    AllParameters::AllParameters(<span class="keyword">const</span> std::string &amp;input_file)</div><div class="line">    {</div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      declare_parameters(prm);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a>(input_file);</div><div class="line">      parse_parameters(prm);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> AllParameters::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      FESystem::declare_parameters(prm);</div><div class="line">      Geometry::declare_parameters(prm);</div><div class="line">      Materials::declare_parameters(prm);</div><div class="line">      LinearSolver::declare_parameters(prm);</div><div class="line">      NonlinearSolver::declare_parameters(prm);</div><div class="line">      Time::declare_parameters(prm);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> AllParameters::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    {</div><div class="line">      FESystem::parse_parameters(prm);</div><div class="line">      Geometry::parse_parameters(prm);</div><div class="line">      Materials::parse_parameters(prm);</div><div class="line">      LinearSolver::parse_parameters(prm);</div><div class="line">      NonlinearSolver::parse_parameters(prm);</div><div class="line">      Time::parse_parameters(prm);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>Time</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Time (<span class="keyword">const</span> <span class="keywordtype">double</span> time_end,</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t)</div><div class="line">      :</div><div class="line">      timestep(0),</div><div class="line">      time_current(0.0),</div><div class="line">      time_end(time_end),</div><div class="line">      delta_t(delta_t)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> ~Time()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> current()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> time_current;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> end()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> time_end;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> get_delta_t()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> delta_t;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> get_timestep()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> timestep;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> increment()</div><div class="line">    {</div><div class="line">      time_current += delta_t;</div><div class="line">      ++timestep;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep;</div><div class="line">    <span class="keywordtype">double</span>       time_current;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_end;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Material_Compressible_Neo_Hook_Three_Field</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Material_Compressible_Neo_Hook_Three_Field(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                               <span class="keyword">const</span> <span class="keywordtype">double</span> nu)</div><div class="line">      :</div><div class="line">      kappa((2.0 * mu * (1.0 + nu)) / (3.0 * (1.0 - 2.0 * nu))),</div><div class="line">      c_1(mu / 2.0),</div><div class="line">      det_F(1.0),</div><div class="line">      p_tilde(0.0),</div><div class="line">      J_tilde(1.0),</div><div class="line">      b_bar(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(kappa &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    ~Material_Compressible_Neo_Hook_Three_Field()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> update_material_data(<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &amp;F,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">double</span> p_tilde_in,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">double</span> J_tilde_in)</div><div class="line">    {</div><div class="line">      det_F = determinant(F);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_bar = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae8c571720db885e3636e396f6e153317">Physics::Elasticity::Kinematics::F_iso</a>(F);</div><div class="line">      b_bar = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">Physics::Elasticity::Kinematics::b</a>(F_bar);</div><div class="line">      p_tilde = p_tilde_in;</div><div class="line">      J_tilde = J_tilde_in;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(det_F &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau()</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> get_tau_iso() + get_tau_vol();</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_Jc()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> get_Jc_vol() + get_Jc_iso();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_dPsi_vol_dJ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (kappa / 2.0) * (J_tilde - 1.0 / J_tilde);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_d2Psi_vol_dJ2()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> ( (kappa / 2.0) * (1.0 + 1.0 / (J_tilde * J_tilde)));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> det_F;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_p_tilde()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> p_tilde;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_J_tilde()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> J_tilde;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c_1;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> det_F;</div><div class="line">    <span class="keywordtype">double</span> p_tilde;</div><div class="line">    <span class="keywordtype">double</span> J_tilde;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> b_bar;</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau_vol()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> p_tilde * det_F * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau_iso()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::dev_P</a> * get_tau_bar();</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau_bar()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * c_1 * b_bar;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_Jc_vol()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> p_tilde * det_F</div><div class="line">             * ( <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::IxI</a></div><div class="line">                 - (2.0 * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::S</a>) );</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_Jc_iso()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau_bar = get_tau_bar();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau_iso = get_tau_iso();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> tau_iso_x_I</div><div class="line">        = outer_product(tau_iso,</div><div class="line">                        <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> I_x_tau_iso</div><div class="line">        = outer_product(<a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>,</div><div class="line">                        tau_iso);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> c_bar = get_c_bar();</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> (2.0 / dim) * trace(tau_bar)</div><div class="line">             * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::dev_P</a></div><div class="line">             - (2.0 / dim) * (tau_iso_x_I + I_x_tau_iso)</div><div class="line">             + <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::dev_P</a> * c_bar</div><div class="line">             * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::dev_P</a>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_c_bar()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a>();</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PointHistory</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PointHistory()</div><div class="line">      :</div><div class="line">      F_inv(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I),</div><div class="line">      tau(<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt;()),</div><div class="line">      d2Psi_vol_dJ2(0.0),</div><div class="line">      dPsi_vol_dJ(0.0),</div><div class="line">      Jc(<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;4, dim&gt;())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> ~PointHistory()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_lqp (<span class="keyword">const</span> Parameters::AllParameters &amp;parameters)</div><div class="line">    {</div><div class="line">      material.reset(<span class="keyword">new</span> Material_Compressible_Neo_Hook_Three_Field&lt;dim&gt;(parameters.mu,</div><div class="line">                     parameters.nu));</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(), 0.0, 1.0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> (<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &amp;Grad_u_n,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> p_tilde,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> J_tilde)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">Physics::Elasticity::Kinematics::F</a>(Grad_u_n);</div><div class="line">      material-&gt;update_material_data(F, p_tilde, J_tilde);</div><div class="line"></div><div class="line">      F_inv = invert(F);</div><div class="line">      tau = material-&gt;get_tau();</div><div class="line">      Jc = material-&gt;get_Jc();</div><div class="line">      dPsi_vol_dJ = material-&gt;get_dPsi_vol_dJ();</div><div class="line">      d2Psi_vol_dJ2 = material-&gt;get_d2Psi_vol_dJ2();</div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_J_tilde()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> material-&gt;get_J_tilde();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> material-&gt;get_det_F();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &amp;get_F_inv()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> F_inv;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_p_tilde()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> material-&gt;get_p_tilde();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_tau()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> tau;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_dPsi_vol_dJ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> dPsi_vol_dJ;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_d2Psi_vol_dJ2()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> d2Psi_vol_dJ2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_Jc()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> Jc;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    std::shared_ptr&lt; Material_Compressible_Neo_Hook_Three_Field&lt;dim&gt; &gt; material;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_inv;</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau;</div><div class="line">    <span class="keywordtype">double</span>                  d2Psi_vol_dJ2;</div><div class="line">    <span class="keywordtype">double</span>                  dPsi_vol_dJ;</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Jc;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solid</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Solid(<span class="keyword">const</span> std::string &amp;input_file);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    ~Solid();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    run();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PerTaskData_K;</div><div class="line">    <span class="keyword">struct </span>ScratchData_K;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PerTaskData_RHS;</div><div class="line">    <span class="keyword">struct </span>ScratchData_RHS;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PerTaskData_SC;</div><div class="line">    <span class="keyword">struct </span>ScratchData_SC;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PerTaskData_UQPH;</div><div class="line">    <span class="keyword">struct </span>ScratchData_UQPH;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    make_grid();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    system_setup();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    determine_component_extractors();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_system_tangent();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_system_tangent_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                     ScratchData_K &amp;scratch,</div><div class="line">                                     PerTaskData_K &amp;data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    copy_local_to_global_K(<span class="keyword">const</span> PerTaskData_K &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_system_rhs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_system_rhs_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                 ScratchData_RHS &amp;scratch,</div><div class="line">                                 PerTaskData_RHS &amp;data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    copy_local_to_global_rhs(<span class="keyword">const</span> PerTaskData_RHS &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_sc();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    assemble_sc_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                         ScratchData_SC &amp;scratch,</div><div class="line">                         PerTaskData_SC &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    copy_local_to_global_sc(<span class="keyword">const</span> PerTaskData_SC &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    make_constraints(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;it_nr);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    setup_qph();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    update_qph_incremental(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    update_qph_incremental_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                    ScratchData_UQPH &amp;scratch,</div><div class="line">                                    PerTaskData_UQPH &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    copy_local_to_global_UQPH(<span class="keyword">const</span> PerTaskData_UQPH &amp;<span class="comment">/*data*/</span>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    solve_nonlinear_timestep(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta);</div><div class="line"></div><div class="line">    std::pair&lt;unsigned int, double&gt;</div><div class="line">    solve_linear_system(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update);</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">    get_total_solution(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Parameters::AllParameters parameters;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>                    vol_reference;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>        triangulation;</div><div class="line"></div><div class="line">    Time                      time;</div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a>       timer;</div><div class="line"></div><div class="line">    <a class="code" href="classCellDataStorage.html">CellDataStorage&lt;typename Triangulation&lt;dim&gt;::cell_iterator</a>,</div><div class="line">                    PointHistory&lt;dim&gt; &gt; quadrature_point_history;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               degree;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>              fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                  dof_handler_ref;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> u_fe;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> p_fe;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> J_fe;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_blocks = 3;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_components = dim + 2;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> first_u_component = 0;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_component = dim;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> J_component = dim + 1;</div><div class="line"></div><div class="line">    <span class="keyword">enum</span></div><div class="line">    {</div><div class="line">      u_dof = 0,</div><div class="line">      p_dof = 1,</div><div class="line">      J_dof = 2</div><div class="line">    };</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; dofs_per_block;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; element_indices_u;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; element_indices_p;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; element_indices_J;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     qf_cell;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; qf_face;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    n_q_points;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    n_q_points_f;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>          constraints;</div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> tangent_matrix;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       system_rhs;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       solution_n;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>Errors</div><div class="line">    {</div><div class="line">      Errors()</div><div class="line">        :</div><div class="line">        norm(1.0), u(1.0), p(1.0), J(1.0)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> reset()</div><div class="line">      {</div><div class="line">        norm = 1.0;</div><div class="line">        u = 1.0;</div><div class="line">        p = 1.0;</div><div class="line">        J = 1.0;</div><div class="line">      }</div><div class="line">      <span class="keywordtype">void</span> normalise(<span class="keyword">const</span> Errors &amp;rhs)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (rhs.norm != 0.0)</div><div class="line">          norm /= rhs.norm;</div><div class="line">        <span class="keywordflow">if</span> (rhs.u != 0.0)</div><div class="line">          u /= rhs.u;</div><div class="line">        <span class="keywordflow">if</span> (rhs.p != 0.0)</div><div class="line">          p /= rhs.p;</div><div class="line">        <span class="keywordflow">if</span> (rhs.J != 0.0)</div><div class="line">          J /= rhs.J;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> norm, u, p, J;</div><div class="line">    };</div><div class="line"></div><div class="line">    Errors error_residual, error_residual_0, error_residual_norm, error_update,</div><div class="line">           error_update_0, error_update_norm;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    get_error_residual(Errors &amp;error_residual);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    get_error_update(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update,</div><div class="line">                     Errors &amp;error_update);</div><div class="line"></div><div class="line">    std::pair&lt;double, double&gt;</div><div class="line">    get_error_dilation() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    compute_vol_current () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    print_conv_header();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    print_conv_footer();</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  Solid&lt;dim&gt;::Solid(<span class="keyword">const</span> std::string &amp;input_file)</div><div class="line">    :</div><div class="line">    parameters(input_file),</div><div class="line">    vol_reference(0.),</div><div class="line">    triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing),</div><div class="line">    time(parameters.end_time, parameters.delta_t),</div><div class="line">    timer(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">          <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">          <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times),</div><div class="line">    degree(parameters.poly_degree),</div><div class="line">    fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.poly_degree), dim, <span class="comment">// displacement</span></div><div class="line">       <a class="code" href="classFE__DGPMonomial.html">FE_DGPMonomial</a>&lt;dim&gt;(parameters.poly_degree - 1), 1, <span class="comment">// pressure</span></div><div class="line">       <a class="code" href="classFE__DGPMonomial.html">FE_DGPMonomial</a>&lt;dim&gt;(parameters.poly_degree - 1), 1), <span class="comment">// dilatation</span></div><div class="line">    dof_handler_ref(triangulation),</div><div class="line">    dofs_per_cell (fe.dofs_per_cell),</div><div class="line">    u_fe(first_u_component),</div><div class="line">    p_fe(p_component),</div><div class="line">    J_fe(J_component),</div><div class="line">    dofs_per_block(n_blocks),</div><div class="line">    qf_cell(parameters.quad_order),</div><div class="line">    qf_face(parameters.quad_order),</div><div class="line">    n_q_points (qf_cell.size()),</div><div class="line">    n_q_points_f (qf_face.size())</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim==2 || dim==3, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;This problem only works in 2 or 3 space dimensions.&quot;</span>));</div><div class="line">    determine_component_extractors();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  Solid&lt;dim&gt;::~Solid()</div><div class="line">  {</div><div class="line">    dof_handler_ref.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::run()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    system_setup();</div><div class="line">    {</div><div class="line">      <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a></div><div class="line">      J_mask (J_component, n_components);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> (dof_handler_ref,</div><div class="line">                            constraints,</div><div class="line">                            <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree+2),</div><div class="line">                            J_mask,</div><div class="line">                            solution_n);</div><div class="line">    }</div><div class="line">    output_results();</div><div class="line">    time.increment();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution_delta(dofs_per_block);</div><div class="line">    <span class="keywordflow">while</span> (time.current() &lt; time.end())</div><div class="line">      {</div><div class="line">        solution_delta = 0.0;</div><div class="line"></div><div class="line">        solve_nonlinear_timestep(solution_delta);</div><div class="line">        solution_n += solution_delta;</div><div class="line"></div><div class="line">        output_results();</div><div class="line">        time.increment();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_K</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        cell_matrix;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">    PerTaskData_K(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">      :</div><div class="line">      cell_matrix(dofs_per_cell, dofs_per_cell),</div><div class="line">      local_dof_indices(dofs_per_cell)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> reset()</div><div class="line">    {</div><div class="line">      cell_matrix = 0.0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_K</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_ref;</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;double&gt; &gt;                   Nx;</div><div class="line">    std::vector&lt;std::vector&lt;Tensor&lt;2, dim&gt; &gt; &gt;          grad_Nx;</div><div class="line">    std::vector&lt;std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; &gt; symm_grad_Nx;</div><div class="line"></div><div class="line">    ScratchData_K(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_cell,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;qf_cell,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell)</div><div class="line">      :</div><div class="line">      fe_values_ref(fe_cell, qf_cell, uf_cell),</div><div class="line">      Nx(qf_cell.size(),</div><div class="line">         <a class="code" href="namespacestd.html">std</a>::vector&lt;double&gt;(fe_cell.dofs_per_cell)),</div><div class="line">      grad_Nx(qf_cell.size(),</div><div class="line">              <a class="code" href="namespacestd.html">std</a>::vector&lt;<a class="code" href="classTensor.html">Tensor</a>&lt;2, dim&gt; &gt;(fe_cell.dofs_per_cell)),</div><div class="line">      symm_grad_Nx(qf_cell.size(),</div><div class="line">                   <a class="code" href="namespacestd.html">std</a>::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt; &gt;</div><div class="line">                   (fe_cell.dofs_per_cell))</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData_K(<span class="keyword">const</span> ScratchData_K &amp;rhs)</div><div class="line">      :</div><div class="line">      fe_values_ref(rhs.fe_values_ref.get_fe(),</div><div class="line">                    rhs.fe_values_ref.get_quadrature(),</div><div class="line">                    rhs.fe_values_ref.get_update_flags()),</div><div class="line">      Nx(rhs.Nx),</div><div class="line">      grad_Nx(rhs.grad_Nx),</div><div class="line">      symm_grad_Nx(rhs.symm_grad_Nx)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> reset()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = Nx.size();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_per_cell = Nx[0].size();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( Nx[q_point].size() == n_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( grad_Nx[q_point].size() == n_dofs_per_cell,</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( symm_grad_Nx[q_point].size() == n_dofs_per_cell,</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; n_dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              Nx[q_point][k] = 0.0;</div><div class="line">              grad_Nx[q_point][k] = 0.0;</div><div class="line">              symm_grad_Nx[q_point][k] = 0.0;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_RHS</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">    PerTaskData_RHS(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">      :</div><div class="line">      cell_rhs(dofs_per_cell),</div><div class="line">      local_dof_indices(dofs_per_cell)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> reset()</div><div class="line">    {</div><div class="line">      cell_rhs = 0.0;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_RHS</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_ref;</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_ref;</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;double&gt; &gt;                   Nx;</div><div class="line">    std::vector&lt;std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; &gt; symm_grad_Nx;</div><div class="line"></div><div class="line">    ScratchData_RHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_cell,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;qf_cell, <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a> &amp; qf_face, <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_face)</div><div class="line">      :</div><div class="line">      fe_values_ref(fe_cell, qf_cell, uf_cell),</div><div class="line">      fe_face_values_ref(fe_cell, qf_face, uf_face),</div><div class="line">      Nx(qf_cell.size(),</div><div class="line">         <a class="code" href="namespacestd.html">std</a>::vector&lt;double&gt;(fe_cell.dofs_per_cell)),</div><div class="line">      symm_grad_Nx(qf_cell.size(),</div><div class="line">                   <a class="code" href="namespacestd.html">std</a>::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt; &gt;</div><div class="line">                   (fe_cell.dofs_per_cell))</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData_RHS(<span class="keyword">const</span> ScratchData_RHS &amp;rhs)</div><div class="line">      :</div><div class="line">      fe_values_ref(rhs.fe_values_ref.get_fe(),</div><div class="line">                    rhs.fe_values_ref.get_quadrature(),</div><div class="line">                    rhs.fe_values_ref.get_update_flags()),</div><div class="line">      fe_face_values_ref(rhs.fe_face_values_ref.get_fe(),</div><div class="line">                         rhs.fe_face_values_ref.get_quadrature(),</div><div class="line">                         rhs.fe_face_values_ref.get_update_flags()),</div><div class="line">      Nx(rhs.Nx),</div><div class="line">      symm_grad_Nx(rhs.symm_grad_Nx)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> reset()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = Nx.size();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_per_cell = Nx[0].size();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( Nx[q_point].size() == n_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( symm_grad_Nx[q_point].size() == n_dofs_per_cell,</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; n_dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              Nx[q_point][k] = 0.0;</div><div class="line">              symm_grad_Nx[q_point][k] = 0.0;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_SC</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        cell_matrix;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_orig;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_pu;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_pJ;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_JJ;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_pJ_inv;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        k_bbar;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        A;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        B;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>;</div><div class="line"></div><div class="line">    PerTaskData_SC(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_p,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_J)</div><div class="line">      :</div><div class="line">      cell_matrix(dofs_per_cell, dofs_per_cell),</div><div class="line">      local_dof_indices(dofs_per_cell),</div><div class="line">      k_orig(dofs_per_cell, dofs_per_cell),</div><div class="line">      k_pu(n_p, n_u),</div><div class="line">      k_pJ(n_p, n_J),</div><div class="line">      k_JJ(n_J, n_J),</div><div class="line">      k_pJ_inv(n_p, n_J),</div><div class="line">      k_bbar(n_u, n_u),</div><div class="line">      A(n_J,n_u),</div><div class="line">      B(n_J, n_u),</div><div class="line">      C(n_p, n_u)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> reset()</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_SC</div><div class="line">  {</div><div class="line">    <span class="keywordtype">void</span> reset()</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_UQPH</div><div class="line">  {</div><div class="line">    <span class="keywordtype">void</span> reset()</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_UQPH</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>   &amp;solution_total;</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt; &gt; solution_grads_u_total;</div><div class="line">    std::vector&lt;double&gt;          solution_values_p_total;</div><div class="line">    std::vector&lt;double&gt;          solution_values_J_total;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                fe_values_ref;</div><div class="line"></div><div class="line">    ScratchData_UQPH(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_cell,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;qf_cell,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_total)</div><div class="line">      :</div><div class="line">      solution_total(solution_total),</div><div class="line">      solution_grads_u_total(qf_cell.size()),</div><div class="line">      solution_values_p_total(qf_cell.size()),</div><div class="line">      solution_values_J_total(qf_cell.size()),</div><div class="line">      fe_values_ref(fe_cell, qf_cell, uf_cell)</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData_UQPH(<span class="keyword">const</span> ScratchData_UQPH &amp;rhs)</div><div class="line">      :</div><div class="line">      solution_total(rhs.solution_total),</div><div class="line">      solution_grads_u_total(rhs.solution_grads_u_total),</div><div class="line">      solution_values_p_total(rhs.solution_values_p_total),</div><div class="line">      solution_values_J_total(rhs.solution_values_J_total),</div><div class="line">      fe_values_ref(rhs.fe_values_ref.get_fe(),</div><div class="line">                    rhs.fe_values_ref.get_quadrature(),</div><div class="line">                    rhs.fe_values_ref.get_update_flags())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> reset()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = solution_grads_u_total.size();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          solution_grads_u_total[q] = 0.0;</div><div class="line">          solution_values_p_total[q] = 0.0;</div><div class="line">          solution_values_J_total[q] = 0.0;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation,</div><div class="line">                                   (dim==3 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.0, 0.0, 0.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.0, 0.0)),</div><div class="line">                                   (dim==3 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(1.0, 1.0, 1.0) : <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(1.0, 1.0)),</div><div class="line">                                   <span class="keyword">true</span>);</div><div class="line">    <a class="code" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>(parameters.scale, triangulation);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(std::max (1U, parameters.global_refinement));</div><div class="line"></div><div class="line">    vol_reference = <a class="code" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">GridTools::volume</a>(triangulation);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Grid:\n\t Reference volume: &quot;</span> &lt;&lt; vol_reference &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(), endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face = 0;</div><div class="line">           face &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary() == <span class="keyword">true</span></div><div class="line">              &amp;&amp;</div><div class="line">              cell-&gt;face(face)-&gt;center()[1] == 1.0 * parameters.scale)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (dim==3)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;center()[0] &lt; 0.5 * parameters.scale</div><div class="line">                      &amp;&amp;</div><div class="line">                      cell-&gt;face(face)-&gt;center()[2] &lt; 0.5 * parameters.scale)</div><div class="line">                    cell-&gt;face(face)-&gt;set_boundary_id(6);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                  <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;center()[0] &lt; 0.5 * parameters.scale)</div><div class="line">                    cell-&gt;face(face)-&gt;set_boundary_id(6);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::system_setup()</div><div class="line">  {</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Setup system&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; block_component(n_components, u_dof); <span class="comment">// Displacement</span></div><div class="line">    block_component[p_component] = p_dof; <span class="comment">// Pressure</span></div><div class="line">    block_component[J_component] = J_dof; <span class="comment">// Dilatation</span></div><div class="line"></div><div class="line">    dof_handler_ref.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a>(dof_handler_ref);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler_ref, block_component);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#abfd9796e22113e13b5802e384e56af4f">DoFTools::count_dofs_per_block</a>(dof_handler_ref, dofs_per_block,</div><div class="line">                                   block_component);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Triangulation:&quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n\t Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n\t Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler_ref.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    tangent_matrix.<a class="code" href="classBlockSparseMatrix.html#acf098688a1a7db16a6582be07dcbeb6a">clear</a>();</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> n_dofs_u = dofs_per_block[u_dof];</div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> n_dofs_p = dofs_per_block[p_dof];</div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> n_dofs_J = dofs_per_block[J_dof];</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(n_blocks, n_blocks);</div><div class="line"></div><div class="line">      dsp.block(u_dof, u_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_u, n_dofs_u);</div><div class="line">      dsp.block(u_dof, p_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_u, n_dofs_p);</div><div class="line">      dsp.block(u_dof, J_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_u, n_dofs_J);</div><div class="line"></div><div class="line">      dsp.block(p_dof, u_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_p, n_dofs_u);</div><div class="line">      dsp.block(p_dof, p_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_p, n_dofs_p);</div><div class="line">      dsp.block(p_dof, J_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_p, n_dofs_J);</div><div class="line"></div><div class="line">      dsp.block(J_dof, u_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_J, n_dofs_u);</div><div class="line">      dsp.block(J_dof, p_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_J, n_dofs_p);</div><div class="line">      dsp.block(J_dof, J_dof).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_dofs_J, n_dofs_J);</div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(n_components, n_components);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii = 0; ii &lt; n_components; ++ii)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj = 0; jj &lt; n_components; ++jj)</div><div class="line">          <span class="keywordflow">if</span> (((ii &lt; p_component) &amp;&amp; (jj == J_component))</div><div class="line">              || ((ii == J_component) &amp;&amp; (jj &lt; p_component))</div><div class="line">              || ((ii == p_component) &amp;&amp; (jj == p_component)))</div><div class="line">            coupling[ii][jj] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[ii][jj] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler_ref,</div><div class="line">                                      coupling,</div><div class="line">                                      dsp,</div><div class="line">                                      constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    tangent_matrix.<a class="code" href="classBlockSparseMatrix.html#a1e0a45e360458e7350bd93487d6bf1e5">reinit</a>(sparsity_pattern);</div><div class="line"></div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dofs_per_block);</div><div class="line">    system_rhs.<a class="code" href="classBlockVectorBase.html#a6a27b2a48e5b5780cd0a6640b928d794">collect_sizes</a>();</div><div class="line"></div><div class="line">    solution_n.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dofs_per_block);</div><div class="line">    solution_n.<a class="code" href="classBlockVectorBase.html#a6a27b2a48e5b5780cd0a6640b928d794">collect_sizes</a>();</div><div class="line"></div><div class="line">    setup_qph();</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  Solid&lt;dim&gt;::determine_component_extractors()</div><div class="line">  {</div><div class="line">    element_indices_u.clear();</div><div class="line">    element_indices_p.clear();</div><div class="line">    element_indices_J.clear();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++k)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(k).first.first;</div><div class="line">        <span class="keywordflow">if</span> (k_group == u_dof)</div><div class="line">          element_indices_u.push_back(k);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == p_dof)</div><div class="line">          element_indices_p.push_back(k);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == J_dof)</div><div class="line">          element_indices_J.push_back(k);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(k_group &lt;= J_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::setup_qph()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;    Setting up quadrature point data...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    quadrature_point_history.<a class="code" href="classCellDataStorage.html#a9ce38927ac1a1f96618c2624da89d65b">initialize</a>(triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">                                        triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(),</div><div class="line">                                        n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">           triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">          quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          lqph[q_point]-&gt;setup_lqp(parameters);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::update_qph_incremental(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta)</div><div class="line">  {</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Update QPH data&quot;</span>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; UQPH &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution_total(get_total_solution(solution_delta));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_UQPH(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">    PerTaskData_UQPH per_task_data_UQPH;</div><div class="line">    ScratchData_UQPH scratch_data_UQPH(fe, qf_cell, uf_UQPH, solution_total);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                    dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                    *<span class="keyword">this</span>,</div><div class="line">                    &amp;Solid::update_qph_incremental_one_cell,</div><div class="line">                    &amp;Solid::copy_local_to_global_UQPH,</div><div class="line">                    scratch_data_UQPH,</div><div class="line">                    per_task_data_UQPH);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  Solid&lt;dim&gt;::update_qph_incremental_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                              ScratchData_UQPH &amp;scratch,</div><div class="line">                                              PerTaskData_UQPH &amp;<span class="comment">/*data*/</span>)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">      quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(scratch.solution_grads_u_total.size() == n_q_points,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(scratch.solution_values_p_total.size() == n_q_points,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(scratch.solution_values_J_total.size() == n_q_points,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    scratch.reset();</div><div class="line"></div><div class="line">    scratch.fe_values_ref.reinit(cell);</div><div class="line">    scratch.fe_values_ref[u_fe].get_function_gradients(scratch.solution_total,</div><div class="line">                                                       scratch.solution_grads_u_total);</div><div class="line">    scratch.fe_values_ref[p_fe].get_function_values(scratch.solution_total,</div><div class="line">                                                    scratch.solution_values_p_total);</div><div class="line">    scratch.fe_values_ref[J_fe].get_function_values(scratch.solution_total,</div><div class="line">                                                    scratch.solution_values_J_total);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      lqph[q_point]-&gt;<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>(scratch.solution_grads_u_total[q_point],</div><div class="line">                                   scratch.solution_values_p_total[q_point],</div><div class="line">                                   scratch.solution_values_J_total[q_point]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  Solid&lt;dim&gt;::solve_nonlinear_timestep(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; time.get_timestep() &lt;&lt; <span class="stringliteral">&quot; @ &quot;</span></div><div class="line">              &lt;&lt; time.current() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> newton_update(dofs_per_block);</div><div class="line"></div><div class="line">    error_residual.reset();</div><div class="line">    error_residual_0.reset();</div><div class="line">    error_residual_norm.reset();</div><div class="line">    error_update.reset();</div><div class="line">    error_update_0.reset();</div><div class="line">    error_update_norm.reset();</div><div class="line"></div><div class="line">    print_conv_header();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_iteration = 0;</div><div class="line">    <span class="keywordflow">for</span> (; newton_iteration &lt; parameters.max_iterations_NR;</div><div class="line">         ++newton_iteration)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::setw(2) &lt;&lt; newton_iteration &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">        tangent_matrix = 0.0;</div><div class="line">        system_rhs = 0.0;</div><div class="line"></div><div class="line">        assemble_system_rhs();</div><div class="line">        get_error_residual(error_residual);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (newton_iteration == 0)</div><div class="line">          error_residual_0 = error_residual;</div><div class="line"></div><div class="line">        error_residual_norm = error_residual;</div><div class="line">        error_residual_norm.normalise(error_residual_0);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (newton_iteration &gt; 0 &amp;&amp; error_update_norm.u &lt;= parameters.tol_u</div><div class="line">            &amp;&amp; error_residual_norm.u &lt;= parameters.tol_f)</div><div class="line">          {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; CONVERGED! &quot;</span> &lt;&lt; std::endl;</div><div class="line">            print_conv_footer();</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        assemble_system_tangent();</div><div class="line">        make_constraints(newton_iteration);</div><div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">condense</a>(tangent_matrix, system_rhs);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::pair&lt;unsigned int, double&gt;</div><div class="line">        lin_solver_output = solve_linear_system(newton_update);</div><div class="line"></div><div class="line">        get_error_update(newton_update, error_update);</div><div class="line">        <span class="keywordflow">if</span> (newton_iteration == 0)</div><div class="line">          error_update_0 = error_update;</div><div class="line"></div><div class="line">        error_update_norm = error_update;</div><div class="line">        error_update_norm.normalise(error_update_0);</div><div class="line"></div><div class="line">        solution_delta += newton_update;</div><div class="line">        update_qph_incremental(solution_delta);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; | &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; std::setw(7)</div><div class="line">                  &lt;&lt; std::scientific &lt;&lt; lin_solver_output.first &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div><div class="line">                  &lt;&lt; lin_solver_output.second &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_residual_norm.norm</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_residual_norm.u &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div><div class="line">                  &lt;&lt; error_residual_norm.p &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_residual_norm.J</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.norm &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.u</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.p &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.J</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (newton_iteration &lt; parameters.max_iterations_NR,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No convergence in nonlinear solver!&quot;</span>));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::print_conv_header()</div><div class="line">  {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l_width = 155;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                 SOLVER STEP                  &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; |  LIN_IT   LIN_RES    RES_NORM    &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; RES_U     RES_P      RES_J     NU_NORM     &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; NU_U       NU_P       NU_J &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::print_conv_footer()</div><div class="line">  {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l_width = 155;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double,double&gt; error_dil = get_error_dilation();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Relative errors:&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Displacement:\t&quot;</span> &lt;&lt; error_update.u / error_update_0.u &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Force: \t\t&quot;</span> &lt;&lt; error_residual.u / error_residual_0.u &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Dilatation:\t&quot;</span> &lt;&lt; error_dil.first &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;v / V_0:\t&quot;</span> &lt;&lt; error_dil.second *vol_reference &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; vol_reference</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; error_dil.second &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Solid&lt;dim&gt;::compute_vol_current()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span> vol_current = 0.0;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_ref(fe, qf_cell, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">         cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">      {</div><div class="line">        fe_values_ref.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;const PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">          quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> det_F_qp = lqph[q_point]-&gt;get_det_F();</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = fe_values_ref.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">            vol_current += det_F_qp * JxW;</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(vol_current &gt; 0.0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <span class="keywordflow">return</span> vol_current;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  Solid&lt;dim&gt;::get_error_dilation()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span> dil_L2_error = 0.0;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_ref(fe, qf_cell, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">         cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">      {</div><div class="line">        fe_values_ref.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;const PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">          quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> det_F_qp = lqph[q_point]-&gt;get_det_F();</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> J_tilde_qp = lqph[q_point]-&gt;get_J_tilde();</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> the_error_qp_squared = std::pow((det_F_qp - J_tilde_qp),</div><div class="line">                                                         2);</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = fe_values_ref.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">            dil_L2_error += the_error_qp_squared * JxW;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> std::make_pair(std::sqrt(dil_L2_error),</div><div class="line">                          compute_vol_current() / vol_reference);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::get_error_residual(Errors &amp;error_residual)</div><div class="line">  {</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> error_res(dofs_per_block);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler_ref.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (!constraints.<a class="code" href="classConstraintMatrix.html#a997d5e0e75f237a2be3fb37d84e1d53c">is_constrained</a>(i))</div><div class="line">        error_res(i) = system_rhs(i);</div><div class="line"></div><div class="line">    error_residual.norm = error_res.l2_norm();</div><div class="line">    error_residual.u = error_res.block(u_dof).l2_norm();</div><div class="line">    error_residual.p = error_res.block(p_dof).l2_norm();</div><div class="line">    error_residual.J = error_res.block(J_dof).l2_norm();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::get_error_update(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update,</div><div class="line">                                    Errors &amp;error_update)</div><div class="line">  {</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> error_ud(dofs_per_block);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler_ref.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (!constraints.<a class="code" href="classConstraintMatrix.html#a997d5e0e75f237a2be3fb37d84e1d53c">is_constrained</a>(i))</div><div class="line">        error_ud(i) = newton_update(i);</div><div class="line"></div><div class="line">    error_update.norm = error_ud.l2_norm();</div><div class="line">    error_update.u = error_ud.block(u_dof).l2_norm();</div><div class="line">    error_update.p = error_ud.block(p_dof).l2_norm();</div><div class="line">    error_update.J = error_ud.block(J_dof).l2_norm();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">  Solid&lt;dim&gt;::get_total_solution(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution_total(solution_n);</div><div class="line">    solution_total += solution_delta;</div><div class="line">    <span class="keywordflow">return</span> solution_total;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::assemble_system_tangent()</div><div class="line">  {</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Assemble tangent matrix&quot;</span>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; ASM_K &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    tangent_matrix = 0.0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PerTaskData_K per_task_data(dofs_per_cell);</div><div class="line">    ScratchData_K scratch_data(fe, qf_cell, uf_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                    dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                    std::bind(&amp;Solid&lt;dim&gt;::assemble_system_tangent_one_cell,</div><div class="line">                              <span class="keyword">this</span>,</div><div class="line">                              std::placeholders::_1,</div><div class="line">                              std::placeholders::_2,</div><div class="line">                              std::placeholders::_3),</div><div class="line">                    std::bind(&amp;Solid&lt;dim&gt;::copy_local_to_global_K,</div><div class="line">                              <span class="keyword">this</span>,</div><div class="line">                              std::placeholders::_1),</div><div class="line">                    scratch_data,</div><div class="line">                    per_task_data);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::copy_local_to_global_K(<span class="keyword">const</span> PerTaskData_K &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        tangent_matrix.<a class="code" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add</a>(data.local_dof_indices[i],</div><div class="line">                           data.local_dof_indices[j],</div><div class="line">                           data.cell_matrix(i, j));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  Solid&lt;dim&gt;::assemble_system_tangent_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                               ScratchData_K &amp;scratch,</div><div class="line">                                               PerTaskData_K &amp;data)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    data.reset();</div><div class="line">    scratch.reset();</div><div class="line">    scratch.fe_values_ref.reinit(cell);</div><div class="line">    cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;const PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">      quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_inv = lqph[q_point]-&gt;get_F_inv();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(k).first.first;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (k_group == u_dof)</div><div class="line">              {</div><div class="line">                scratch.grad_Nx[q_point][k] = scratch.fe_values_ref[u_fe].gradient(k, q_point)</div><div class="line">                                              * F_inv;</div><div class="line">                scratch.symm_grad_Nx[q_point][k] = symmetrize(scratch.grad_Nx[q_point][k]);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == p_dof)</div><div class="line">              scratch.Nx[q_point][k] = scratch.fe_values_ref[p_fe].value(k,</div><div class="line">                                                                         q_point);</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == J_dof)</div><div class="line">              scratch.Nx[q_point][k] = scratch.fe_values_ref[J_fe].value(k,</div><div class="line">                                                                         q_point);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(k_group &lt;= J_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> tau         = lqph[q_point]-&gt;get_tau();</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Jc = lqph[q_point]-&gt;get_Jc();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> d2Psi_vol_dJ2       = lqph[q_point]-&gt;get_d2Psi_vol_dJ2();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> det_F               = lqph[q_point]-&gt;get_det_F();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::vector&lt;double&gt;</div><div class="line">        &amp;N = scratch.Nx[q_point];</div><div class="line">        <span class="keyword">const</span> std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt;</div><div class="line">        &amp;symm_grad_Nx = scratch.symm_grad_Nx[q_point];</div><div class="line">        <span class="keyword">const</span> std::vector&lt;Tensor&lt;2, dim&gt; &gt;</div><div class="line">        &amp;grad_Nx = scratch.grad_Nx[q_point];</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_ref.JxW(q_point);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i = fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_group     = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(i).first.first;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_j = fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first;</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_group     = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(j).first.first;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((i_group == j_group) &amp;&amp; (i_group == u_dof))</div><div class="line">                  {</div><div class="line">                    data.cell_matrix(i, j) += symm_grad_Nx[i] * Jc <span class="comment">// The material contribution:</span></div><div class="line">                                              * symm_grad_Nx[j] * JxW;</div><div class="line">                    <span class="keywordflow">if</span> (component_i == component_j) <span class="comment">// geometrical stress contribution</span></div><div class="line">                      data.cell_matrix(i, j) += grad_Nx[i][component_i] * tau</div><div class="line">                                                * grad_Nx[j][component_j] * JxW;</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i_group == p_dof) &amp;&amp; (j_group == u_dof))</div><div class="line">                  {</div><div class="line">                    data.cell_matrix(i, j) += N[i] * det_F</div><div class="line">                                              * (symm_grad_Nx[j]</div><div class="line">                                                 * <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>)</div><div class="line">                                              * JxW;</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i_group == J_dof) &amp;&amp; (j_group == p_dof))</div><div class="line">                  data.cell_matrix(i, j) -= N[i] * N[j] * JxW;</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i_group == j_group) &amp;&amp; (i_group == J_dof))</div><div class="line">                  data.cell_matrix(i, j) += N[i] * d2Psi_vol_dJ2 * N[j] * JxW;</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((i_group &lt;= J_dof) &amp;&amp; (j_group &lt;= J_dof),</div><div class="line">                         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">        data.cell_matrix(i, j) = data.cell_matrix(j, i);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::assemble_system_rhs()</div><div class="line">  {</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Assemble system right-hand side&quot;</span>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; ASM_R &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    system_rhs = 0.0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_face(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PerTaskData_RHS per_task_data(dofs_per_cell);</div><div class="line">    ScratchData_RHS scratch_data(fe, qf_cell, uf_cell, qf_face, uf_face);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                    dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                    std::bind(&amp;Solid&lt;dim&gt;::assemble_system_rhs_one_cell,</div><div class="line">                              <span class="keyword">this</span>,</div><div class="line">                              std::placeholders::_1,</div><div class="line">                              std::placeholders::_2,</div><div class="line">                              std::placeholders::_3),</div><div class="line">                    std::bind(&amp;Solid&lt;dim&gt;::copy_local_to_global_rhs,</div><div class="line">                              <span class="keyword">this</span>,</div><div class="line">                              std::placeholders::_1),</div><div class="line">                    scratch_data,</div><div class="line">                    per_task_data);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::copy_local_to_global_rhs(<span class="keyword">const</span> PerTaskData_RHS &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      system_rhs(data.local_dof_indices[i]) += data.cell_rhs(i);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  Solid&lt;dim&gt;::assemble_system_rhs_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                           ScratchData_RHS &amp;scratch,</div><div class="line">                                           PerTaskData_RHS &amp;data)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    data.reset();</div><div class="line">    scratch.reset();</div><div class="line">    scratch.fe_values_ref.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(cell);</div><div class="line">    cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;const PointHistory&lt;dim&gt; &gt; &gt; lqph =</div><div class="line">      quadrature_point_history.<a class="code" href="classCellDataStorage.html#ac9702fd0e031af11ccdc28e7908ec487">get_data</a>(cell);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph.size() == n_q_points, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_inv = lqph[q_point]-&gt;get_F_inv();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(k).first.first;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (k_group == u_dof)</div><div class="line">              scratch.symm_grad_Nx[q_point][k]</div><div class="line">                = symmetrize(scratch.fe_values_ref[u_fe].gradient(k, q_point)</div><div class="line">                             * F_inv);</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == p_dof)</div><div class="line">              scratch.Nx[q_point][k] = scratch.fe_values_ref[p_fe].value(k,</div><div class="line">                                                                         q_point);</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k_group == J_dof)</div><div class="line">              scratch.Nx[q_point][k] = scratch.fe_values_ref[J_fe].value(k,</div><div class="line">                                                                         q_point);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(k_group &lt;= J_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau = lqph[q_point]-&gt;get_tau();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> det_F = lqph[q_point]-&gt;get_det_F();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> J_tilde = lqph[q_point]-&gt;get_J_tilde();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> p_tilde = lqph[q_point]-&gt;get_p_tilde();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dPsi_vol_dJ = lqph[q_point]-&gt;get_dPsi_vol_dJ();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::vector&lt;double&gt;</div><div class="line">        &amp;N = scratch.Nx[q_point];</div><div class="line">        <span class="keyword">const</span> std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt;</div><div class="line">        &amp;symm_grad_Nx = scratch.symm_grad_Nx[q_point];</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_ref.JxW(q_point);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(i).first.first;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (i_group == u_dof)</div><div class="line">              data.cell_rhs(i) -= (symm_grad_Nx[i] * tau) * JxW;</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i_group == p_dof)</div><div class="line">              data.cell_rhs(i) -= N[i] * (det_F - J_tilde) * JxW;</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i_group == J_dof)</div><div class="line">              data.cell_rhs(i) -= N[i] * (dPsi_vol_dJ - p_tilde) * JxW;</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(i_group &lt;= J_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face = 0; face &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">         ++face)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary() == <span class="keyword">true</span></div><div class="line">          &amp;&amp; cell-&gt;face(face)-&gt;boundary_id() == 6)</div><div class="line">        {</div><div class="line">          scratch.fe_face_values_ref.reinit(cell, face);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f_q_point = 0; f_q_point &lt; n_q_points_f;</div><div class="line">               ++f_q_point)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;N =</div><div class="line">                scratch.fe_face_values_ref.normal_vector(f_q_point);</div><div class="line"></div><div class="line">              <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>  p0        = -4.0</div><div class="line">                                               /</div><div class="line">                                               (parameters.scale * parameters.scale);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>         time_ramp = (time.current() / time.end());</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>         pressure  = p0 * parameters.p_p0 * time_ramp;</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction  = pressure * N;</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_group =</div><div class="line">                    fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(i).first.first;</div><div class="line"></div><div class="line">                  <span class="keywordflow">if</span> (i_group == u_dof)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                        fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> Ni =</div><div class="line">                        scratch.fe_face_values_ref.shape_value(i,</div><div class="line">                                                               f_q_point);</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_face_values_ref.JxW(</div><div class="line">                                           f_q_point);</div><div class="line"></div><div class="line">                      data.cell_rhs(i) += (Ni * traction[component_i])</div><div class="line">                                          * JxW;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::make_constraints(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;it_nr)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; CST &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (it_nr &gt; 1)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> apply_dirichlet_bc = (it_nr == 0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> x_displacement(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> y_displacement(1);</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                 boundary_id,</div><div class="line">                                                 <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                 constraints,</div><div class="line">                                                 fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement));</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                 boundary_id,</div><div class="line">                                                 <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                 constraints,</div><div class="line">                                                 fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement));</div><div class="line">    }</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 2;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                 boundary_id,</div><div class="line">                                                 <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                 constraints,</div><div class="line">                                                 fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(y_displacement));</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                 boundary_id,</div><div class="line">                                                 <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                 constraints,</div><div class="line">                                                 fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(y_displacement));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (dim==3)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> z_displacement(2);</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 3;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)</div><div class="line">                                                      |</div><div class="line">                                                      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement)));</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)</div><div class="line">                                                      |</div><div class="line">                                                      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement)));</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 4;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement));</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement));</div><div class="line">        }</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 6;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)</div><div class="line">                                                      |</div><div class="line">                                                      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement)));</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)</div><div class="line">                                                      |</div><div class="line">                                                      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement)));</div><div class="line">        }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 3;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)));</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)));</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 6;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)));</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                                     boundary_id,</div><div class="line">                                                     <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                                     constraints,</div><div class="line">                                                     (fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement)));</div><div class="line">        }</div><div class="line">      }</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::assemble_sc()</div><div class="line">  {</div><div class="line">    timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Perform static condensation&quot;</span>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; ASM_SC &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    PerTaskData_SC per_task_data(dofs_per_cell, element_indices_u.size(),</div><div class="line">                                 element_indices_p.size(),</div><div class="line">                                 element_indices_J.size());</div><div class="line">    ScratchData_SC scratch_data;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                    dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                    *<span class="keyword">this</span>,</div><div class="line">                    &amp;Solid::assemble_sc_one_cell,</div><div class="line">                    &amp;Solid::copy_local_to_global_sc,</div><div class="line">                    scratch_data,</div><div class="line">                    per_task_data);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::copy_local_to_global_sc(<span class="keyword">const</span> PerTaskData_SC &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        tangent_matrix.<a class="code" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add</a>(data.local_dof_indices[i],</div><div class="line">                           data.local_dof_indices[j],</div><div class="line">                           data.cell_matrix(i, j));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  Solid&lt;dim&gt;::assemble_sc_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                   ScratchData_SC &amp;scratch,</div><div class="line">                                   PerTaskData_SC &amp;data)</div><div class="line">  {</div><div class="line">    data.reset();</div><div class="line">    scratch.reset();</div><div class="line">    cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line"></div><div class="line">    data.k_orig.extract_submatrix_from(tangent_matrix,</div><div class="line">                                       data.local_dof_indices,</div><div class="line">                                       data.local_dof_indices);</div><div class="line">    data.k_pu.extract_submatrix_from(data.k_orig,</div><div class="line">                                     element_indices_p,</div><div class="line">                                     element_indices_u);</div><div class="line">    data.k_pJ.extract_submatrix_from(data.k_orig,</div><div class="line">                                     element_indices_p,</div><div class="line">                                     element_indices_J);</div><div class="line">    data.k_JJ.extract_submatrix_from(data.k_orig,</div><div class="line">                                     element_indices_J,</div><div class="line">                                     element_indices_J);</div><div class="line"></div><div class="line">    data.k_pJ_inv.invert(data.k_pJ);</div><div class="line"></div><div class="line">    data.k_pJ_inv.mmult(data.A, data.k_pu);</div><div class="line">    data.k_JJ.mmult(data.B, data.A);</div><div class="line">    data.k_pJ_inv.Tmmult(data.C, data.B);</div><div class="line">    data.k_pu.Tmmult(data.k_bbar, data.C);</div><div class="line">    data.k_bbar.scatter_matrix_to(element_indices_u,</div><div class="line">                                  element_indices_u,</div><div class="line">                                  data.cell_matrix);</div><div class="line"></div><div class="line">    data.k_pJ_inv.add(-1.0, data.k_pJ);</div><div class="line">    data.k_pJ_inv.scatter_matrix_to(element_indices_p,</div><div class="line">                                    element_indices_J,</div><div class="line">                                    data.cell_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;unsigned int, double&gt;</div><div class="line">  Solid&lt;dim&gt;::solve_linear_system(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lin_it = 0;</div><div class="line">    <span class="keywordtype">double</span> lin_res = 0.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (parameters.use_static_condensation == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line"></div><div class="line">        <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> A(dofs_per_block);</div><div class="line">        <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> B(dofs_per_block);</div><div class="line"></div><div class="line"></div><div class="line">        {</div><div class="line"></div><div class="line">          assemble_sc();</div><div class="line"></div><div class="line">          tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, J_dof).vmult(A.block(J_dof),</div><div class="line">                                                   system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof));</div><div class="line">          tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, J_dof).vmult(B.block(J_dof),</div><div class="line">                                                   A.block(J_dof));</div><div class="line">          A.block(J_dof) = system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof);</div><div class="line">          A.block(J_dof) -= B.block(J_dof);</div><div class="line">          tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, J_dof).Tvmult(A.block(p_dof),</div><div class="line">                                                    A.block(J_dof));</div><div class="line">          tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, p_dof).vmult(A.block(u_dof),</div><div class="line">                                                   A.block(p_dof));</div><div class="line">          system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof) -= A.block(u_dof);</div><div class="line"></div><div class="line">          timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot; SLV &quot;</span> &lt;&lt; std::flush;</div><div class="line">          <span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;CG&quot;</span>)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">int</span> solver_its = tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof).m()</div><div class="line">                                     * parameters.max_iterations_lin;</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> tol_sol = parameters.tol_lin</div><div class="line">                                     * system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof).l2_norm();</div><div class="line"></div><div class="line">              <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(solver_its, tol_sol);</div><div class="line"></div><div class="line">              <a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;Vector&lt;double&gt;</a> &gt; GVM;</div><div class="line">              <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a> &gt; solver_CG(solver_control, GVM);</div><div class="line"></div><div class="line">              <a class="code" href="classPreconditionSelector.html">PreconditionSelector&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">              preconditioner (parameters.preconditioner_type,</div><div class="line">                              parameters.preconditioner_relaxation);</div><div class="line">              preconditioner.use_matrix(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line"></div><div class="line">              solver_CG.solve(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof),</div><div class="line">                              newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof),</div><div class="line">                              system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof),</div><div class="line">                              preconditioner);</div><div class="line"></div><div class="line">              lin_it = solver_control.last_step();</div><div class="line">              lin_res = solver_control.last_value();</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;Direct&quot;</span>)</div><div class="line">            {</div><div class="line">              <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">              A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line">              A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof), system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof));</div><div class="line"></div><div class="line">              lin_it = 1;</div><div class="line">              lin_res = 0.0;</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Linear solver type not implemented&quot;</span>));</div><div class="line"></div><div class="line">          timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">        }</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver postprocessing&quot;</span>);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; PP &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">        {</div><div class="line">          tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, u_dof).vmult(A.block(p_dof),</div><div class="line">                                                   newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof));</div><div class="line">          A.block(p_dof) *= -1.0;</div><div class="line">          A.block(p_dof) += system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof);</div><div class="line">          tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, J_dof).vmult(newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof),</div><div class="line">                                                   A.block(p_dof));</div><div class="line">        }</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line"></div><div class="line">        {</div><div class="line">          tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, J_dof).vmult(A.block(J_dof),</div><div class="line">                                                   newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof));</div><div class="line">          A.block(J_dof) *= -1.0;</div><div class="line">          A.block(J_dof) += system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof);</div><div class="line">          tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, J_dof).Tvmult(newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof),</div><div class="line">                                                    A.block(J_dof));</div><div class="line">        }</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; ------ &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; SLV &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;CG&quot;</span>)</div><div class="line">          {</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;f_u = system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;f_p = system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;f_J = system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof);</div><div class="line"></div><div class="line">            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;d_u = newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof);</div><div class="line">            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;d_p = newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(p_dof);</div><div class="line">            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;d_J = newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(J_dof);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_uu = linear_operator(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_up = linear_operator(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, p_dof));</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_pu = linear_operator(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(p_dof, u_dof));</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_Jp = linear_operator(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, p_dof));</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_JJ = linear_operator(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, J_dof));</div><div class="line"></div><div class="line">            <a class="code" href="classPreconditionSelector.html">PreconditionSelector&lt; SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">            preconditioner_K_Jp_inv (<span class="stringliteral">&quot;jacobi&quot;</span>);</div><div class="line">            preconditioner_K_Jp_inv.use_matrix(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, p_dof));</div><div class="line">            <a class="code" href="classReductionControl.html">ReductionControl</a> solver_control_K_Jp_inv (tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(J_dof, p_dof).m() * parameters.max_iterations_lin,</div><div class="line">                                                      1.0e-30, parameters.tol_lin);</div><div class="line">            <a class="code" href="classSolverSelector.html">SolverSelector&lt; Vector&lt;double&gt;</a> &gt; solver_K_Jp_inv;</div><div class="line">            solver_K_Jp_inv.<a class="code" href="classSolverSelector.html#a3da215c843356cdab3b603ce98991b53">select</a>(<span class="stringliteral">&quot;cg&quot;</span>);</div><div class="line">            solver_K_Jp_inv.set_control(solver_control_K_Jp_inv);</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_Jp_inv = inverse_operator(K_Jp,</div><div class="line">                                                   solver_K_Jp_inv,</div><div class="line">                                                   preconditioner_K_Jp_inv);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_pJ_inv     = transpose_operator(K_Jp_inv);</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_pp_bar     = K_Jp_inv * K_JJ * K_pJ_inv;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_uu_bar_bar = K_up * K_pp_bar * K_pu;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_uu_con     = K_uu + K_uu_bar_bar;</div><div class="line"></div><div class="line">            PreconditionSelector&lt; SparseMatrix&lt;double&gt;, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">            preconditioner_K_con_inv (parameters.preconditioner_type,</div><div class="line">                                      parameters.preconditioner_relaxation);</div><div class="line">            preconditioner_K_con_inv.use_matrix(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line">            <a class="code" href="classReductionControl.html">ReductionControl</a> solver_control_K_con_inv (tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof).m() * parameters.max_iterations_lin,</div><div class="line">                                                       1.0e-30, parameters.tol_lin);</div><div class="line">            <a class="code" href="classSolverSelector.html">SolverSelector&lt; Vector&lt;double&gt;</a> &gt; solver_K_con_inv;</div><div class="line">            solver_K_con_inv.<a class="code" href="classSolverSelector.html#a3da215c843356cdab3b603ce98991b53">select</a>(<span class="stringliteral">&quot;cg&quot;</span>);</div><div class="line">            solver_K_con_inv.set_control(solver_control_K_con_inv);</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> K_uu_con_inv = inverse_operator(K_uu_con,</div><div class="line">                                                       solver_K_con_inv,</div><div class="line">                                                       preconditioner_K_con_inv);</div><div class="line"></div><div class="line">            d_u = K_uu_con_inv*(f_u - K_up*(K_Jp_inv*f_J - K_pp_bar*f_p));</div><div class="line"></div><div class="line">            timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line"></div><div class="line">            timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver postprocessing&quot;</span>);</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; PP &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">            d_J = K_pJ_inv*(f_p - K_pu*d_u);</div><div class="line">            d_p = K_Jp_inv*(f_J - K_JJ*d_J);</div><div class="line"></div><div class="line">            lin_it = solver_control_K_con_inv.last_step();</div><div class="line">            lin_res = solver_control_K_con_inv.last_value();</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;Direct&quot;</span>)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">            A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(tangent_matrix);</div><div class="line">            A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(newton_update, system_rhs);</div><div class="line"></div><div class="line">            lin_it = 1;</div><div class="line">            lin_res = 0.0;</div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span> &lt;&lt; std::flush;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Linear solver type not implemented&quot;</span>));</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> std::make_pair(lin_it, lin_res);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(dim,</div><div class="line">                                  <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    data_component_interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_name(dim, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">    solution_name.push_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    solution_name.push_back(<span class="stringliteral">&quot;dilatation&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler_ref);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution_n,</div><div class="line">                             solution_name,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> soln(solution_n.<a class="code" href="classBlockVectorBase.html#a69b8dc1f71903659eb44f12e02359ac6">size</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; soln.size(); ++i)</div><div class="line">      soln(i) = solution_n(i);</div><div class="line">    <a class="code" href="classMappingQEulerian.html">MappingQEulerian&lt;dim&gt;</a> q_mapping(degree, dof_handler_ref, soln);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>(q_mapping, degree);</div><div class="line"></div><div class="line">    std::ostringstream filename;</div><div class="line">    filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot;d-&quot;</span> &lt;&lt; time.get_timestep() &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line"></div><div class="line">    std::ofstream output(filename.str().c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <span class="keyword">using namespace </span>Step44;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div><div class="line">      Solid&lt;dim&gt; solid(<span class="stringliteral">&quot;parameters.prm&quot;</span>);</div><div class="line">      solid.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl &lt;&lt; exc.what()</div><div class="line">                &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span></div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
