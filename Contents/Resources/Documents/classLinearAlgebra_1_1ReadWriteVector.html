<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: LinearAlgebra::ReadWriteVector&lt; Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>LinearAlgebra</b></li><li class="navelem"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classLinearAlgebra_1_1ReadWriteVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LinearAlgebra::ReadWriteVector&lt; Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="read__write__vector_8h_source.html">deal.II/lac/read_write_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LinearAlgebra::ReadWriteVector&lt; Number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classLinearAlgebra_1_1ReadWriteVector__inherit__graph.svg" width="186" height="210"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector_1_1FunctorTemplate.html">FunctorTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a44a1b7eced911372389845dffd5c80c6"><td class="memItemLeft" align="right" valign="top">typedef Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a44a1b7eced911372389845dffd5c80c6">value_type</a></td></tr>
<tr class="separator:a44a1b7eced911372389845dffd5c80c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">1: Basic Object-handling</div></td></tr>
<tr class="memitem:aa019c2aa2c09503086bcb0604679f2ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aa019c2aa2c09503086bcb0604679f2ba">ReadWriteVector</a> ()</td></tr>
<tr class="separator:aa019c2aa2c09503086bcb0604679f2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e113f1d04f1faebde287699f2d4585c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a0e113f1d04f1faebde287699f2d4585c">ReadWriteVector</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;in_vector)</td></tr>
<tr class="separator:a0e113f1d04f1faebde287699f2d4585c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f57e4d076b7772b7ba15928070c2315"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a0f57e4d076b7772b7ba15928070c2315">ReadWriteVector</a> (const size_type <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a0e20857fed96063ebd2d3edaea1082bf">size</a>)</td></tr>
<tr class="separator:a0f57e4d076b7772b7ba15928070c2315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ebd721f36c364d3207672265406469"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#ad3ebd721f36c364d3207672265406469">ReadWriteVector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_stored_indices)</td></tr>
<tr class="separator:ad3ebd721f36c364d3207672265406469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a5d38e57f4f5c61f1f888d41a953a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aa3a5d38e57f4f5c61f1f888d41a953a9">~ReadWriteVector</a> ()</td></tr>
<tr class="separator:aa3a5d38e57f4f5c61f1f888d41a953a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee2ea7c671f9ece558b081b0d104295"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aaee2ea7c671f9ece558b081b0d104295">reinit</a> (const size_type <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a0e20857fed96063ebd2d3edaea1082bf">size</a>, const bool omit_zeroing_entries=false)</td></tr>
<tr class="separator:aaee2ea7c671f9ece558b081b0d104295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa62727797cde32d9dafb4dbcdd107f"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a0aa62727797cde32d9dafb4dbcdd107f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a0aa62727797cde32d9dafb4dbcdd107f">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;in_vector, const bool omit_zeroing_entries=false)</td></tr>
<tr class="separator:a0aa62727797cde32d9dafb4dbcdd107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5d0c1a26755df4f451091e051a5277"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aaa5d0c1a26755df4f451091e051a5277">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_stored_indices, const bool omit_zeroing_entries=false)</td></tr>
<tr class="separator:aaa5d0c1a26755df4f451091e051a5277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245371b4cfb447d8f39fcfd4646c5435"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a245371b4cfb447d8f39fcfd4646c5435"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a245371b4cfb447d8f39fcfd4646c5435">apply</a> (const Functor &amp;func)</td></tr>
<tr class="separator:a245371b4cfb447d8f39fcfd4646c5435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3562c39eaa838680a68cd85ffd81fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aed3562c39eaa838680a68cd85ffd81fa">swap</a> (<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:aed3562c39eaa838680a68cd85ffd81fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ce4785132ec1e65de894c7e6198bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a62ce4785132ec1e65de894c7e6198bc3">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;in_vector)</td></tr>
<tr class="separator:a62ce4785132ec1e65de894c7e6198bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a983cd43825afc39d1466a6d468d18c"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a0a983cd43825afc39d1466a6d468d18c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a0a983cd43825afc39d1466a6d468d18c">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;in_vector)</td></tr>
<tr class="separator:a0a983cd43825afc39d1466a6d468d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699aa5c6cb9dad6bd0b93f0e744f74c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a699aa5c6cb9dad6bd0b93f0e744f74c4">operator=</a> (const Number s)</td></tr>
<tr class="separator:a699aa5c6cb9dad6bd0b93f0e744f74c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5ce3e6a89d9e4ee327f9c4c2bb0066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a8d5ce3e6a89d9e4ee327f9c4c2bb0066">import</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">distributed::Vector</a>&lt; Number &gt; &amp;vec, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt; communication_pattern=std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;())</td></tr>
<tr class="separator:a8d5ce3e6a89d9e4ee327f9c4c2bb0066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52ccb8c92203fb645473fb4dd9c1f60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#af52ccb8c92203fb645473fb4dd9c1f60">import</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;petsc_vec, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt; communication_pattern=std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;())</td></tr>
<tr class="separator:af52ccb8c92203fb645473fb4dd9c1f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc746d51575b3bc8f2d4ba8f95f9d3d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#afc746d51575b3bc8f2d4ba8f95f9d3d9">import</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;trilinos_vec, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt; communication_pattern=std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;())</td></tr>
<tr class="separator:afc746d51575b3bc8f2d4ba8f95f9d3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7802111f4ddcf4ede3cbaee885c3ab8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a7802111f4ddcf4ede3cbaee885c3ab8f">import</a> (const <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html">EpetraWrappers::Vector</a> &amp;epetra_vec, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt; communication_pattern=std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;())</td></tr>
<tr class="separator:a7802111f4ddcf4ede3cbaee885c3ab8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e20857fed96063ebd2d3edaea1082bf"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a0e20857fed96063ebd2d3edaea1082bf">size</a> () const</td></tr>
<tr class="separator:a0e20857fed96063ebd2d3edaea1082bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedac815f15ee3c78363e02baa97457e0"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aedac815f15ee3c78363e02baa97457e0">n_elements</a> () const</td></tr>
<tr class="separator:aedac815f15ee3c78363e02baa97457e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee475607463efff722ce083b6cd4f7d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aaee475607463efff722ce083b6cd4f7d">get_stored_elements</a> () const</td></tr>
<tr class="separator:aaee475607463efff722ce083b6cd4f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0f991527a8dd09601b764e59d097fc"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a1c0f991527a8dd09601b764e59d097fc">begin</a> ()</td></tr>
<tr class="separator:a1c0f991527a8dd09601b764e59d097fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4138913e659866ebba5801a88167270"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#ac4138913e659866ebba5801a88167270">begin</a> () const</td></tr>
<tr class="separator:ac4138913e659866ebba5801a88167270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbfbf3b3c7dcb1e96174eba41f3734c"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a4dbfbf3b3c7dcb1e96174eba41f3734c">end</a> ()</td></tr>
<tr class="separator:a4dbfbf3b3c7dcb1e96174eba41f3734c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61f02fa9f52e7aa88d56310c6c0176a"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#ab61f02fa9f52e7aa88d56310c6c0176a">end</a> () const</td></tr>
<tr class="separator:ab61f02fa9f52e7aa88d56310c6c0176a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2: Data-Access</div></td></tr>
<tr class="memitem:a233998157aa2acdbde9717aec827ccbf"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a233998157aa2acdbde9717aec827ccbf">operator()</a> (const size_type global_index) const</td></tr>
<tr class="separator:a233998157aa2acdbde9717aec827ccbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a325d56a1d1c7f8db022eb442867d34"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a4a325d56a1d1c7f8db022eb442867d34">operator()</a> (const size_type global_index)</td></tr>
<tr class="separator:a4a325d56a1d1c7f8db022eb442867d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71445351bd4b9dfb4ff0c1c516658fe6"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a71445351bd4b9dfb4ff0c1c516658fe6">operator[]</a> (const size_type global_index) const</td></tr>
<tr class="separator:a71445351bd4b9dfb4ff0c1c516658fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cf2035df2a9ba8777c80ffe4c1a914"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#af9cf2035df2a9ba8777c80ffe4c1a914">operator[]</a> (const size_type global_index)</td></tr>
<tr class="separator:af9cf2035df2a9ba8777c80ffe4c1a914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe49ac3785c3ed8cdf2c2200c9dd3b94"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:abe49ac3785c3ed8cdf2c2200c9dd3b94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#abe49ac3785c3ed8cdf2c2200c9dd3b94">extract_subvector_to</a> (const std::vector&lt; size_type &gt; &amp;indices, std::vector&lt; Number2 &gt; &amp;values) const</td></tr>
<tr class="separator:abe49ac3785c3ed8cdf2c2200c9dd3b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3387187c82a78eabb153f0d7bf1af4"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:aae3387187c82a78eabb153f0d7bf1af4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aae3387187c82a78eabb153f0d7bf1af4">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:aae3387187c82a78eabb153f0d7bf1af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722901ebee9fe3e68a29549ca30259a8"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a722901ebee9fe3e68a29549ca30259a8">local_element</a> (const size_type local_index) const</td></tr>
<tr class="separator:a722901ebee9fe3e68a29549ca30259a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a1d6b3129693772cc2ae757d1f3c36"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aa7a1d6b3129693772cc2ae757d1f3c36">local_element</a> (const size_type local_index)</td></tr>
<tr class="separator:aa7a1d6b3129693772cc2ae757d1f3c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3: Modification of vectors</div></td></tr>
<tr class="memitem:a20d03806be45070a19e1c809819b4b74"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a20d03806be45070a19e1c809819b4b74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a20d03806be45070a19e1c809819b4b74">add</a> (const std::vector&lt; size_type &gt; &amp;indices, const std::vector&lt; Number2 &gt; &amp;values)</td></tr>
<tr class="separator:a20d03806be45070a19e1c809819b4b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557e8adec1fd28216d0ebb7ca4a9b213"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a557e8adec1fd28216d0ebb7ca4a9b213"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a557e8adec1fd28216d0ebb7ca4a9b213">add</a> (const std::vector&lt; size_type &gt; &amp;indices, const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;values)</td></tr>
<tr class="separator:a557e8adec1fd28216d0ebb7ca4a9b213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cc92419018a05c262f946cef212f63"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a77cc92419018a05c262f946cef212f63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a77cc92419018a05c262f946cef212f63">add</a> (const size_type <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aedac815f15ee3c78363e02baa97457e0">n_elements</a>, const size_type *indices, const Number2 *values)</td></tr>
<tr class="separator:a77cc92419018a05c262f946cef212f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e936065ac760ac8ce71741374a2576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a30e936065ac760ac8ce71741374a2576">print</a> (std::ostream &amp;out, const unsigned int precision=3, const bool scientific=true) const</td></tr>
<tr class="separator:a30e936065ac760ac8ce71741374a2576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2457ff17e4f00e2a964769dfcefebdb3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a2457ff17e4f00e2a964769dfcefebdb3">memory_consumption</a> () const</td></tr>
<tr class="separator:a2457ff17e4f00e2a964769dfcefebdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adbea835864b25f03b3ee26ba8e34b8a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#adbea835864b25f03b3ee26ba8e34b8a5">import</a> (const Epetra_MultiVector &amp;multivector, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_elements, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, const MPI_Comm &amp;mpi_comm, std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt; communication_pattern)</td></tr>
<tr class="separator:adbea835864b25f03b3ee26ba8e34b8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f246ddfbf22f0f8a54274a6540228d7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a6f246ddfbf22f0f8a54274a6540228d7">global_to_local</a> (const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> global_index) const</td></tr>
<tr class="separator:a6f246ddfbf22f0f8a54274a6540228d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714412eda5ff0683842db5a92947db2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a714412eda5ff0683842db5a92947db2f">resize_val</a> (const size_type new_allocated_size)</td></tr>
<tr class="separator:a714412eda5ff0683842db5a92947db2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79499404d7d07670c72c36e065e5e060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1CommunicationPattern.html">EpetraWrappers::CommunicationPattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a79499404d7d07670c72c36e065e5e060">create_epetra_comm_pattern</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;source_index_set, const MPI_Comm &amp;mpi_comm)</td></tr>
<tr class="separator:a79499404d7d07670c72c36e065e5e060"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afc5ab96d5e5729daebc67f6972cf7d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#afc5ab96d5e5729daebc67f6972cf7d7e">stored_elements</a></td></tr>
<tr class="separator:afc5ab96d5e5729daebc67f6972cf7d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc229cf3f043c2d7ecc0ecacc2f39f2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#abc229cf3f043c2d7ecc0ecacc2f39f2e">source_stored_elements</a></td></tr>
<tr class="separator:abc229cf3f043c2d7ecc0ecacc2f39f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ae0774078f2e5751f135033daecdab"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a72ae0774078f2e5751f135033daecdab">comm_pattern</a></td></tr>
<tr class="separator:a72ae0774078f2e5751f135033daecdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad91a104f9fd81f36b3cf01dece109d"><td class="memItemLeft" align="right" valign="top">Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a1ad91a104f9fd81f36b3cf01dece109d">val</a></td></tr>
<tr class="separator:a1ad91a104f9fd81f36b3cf01dece109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8852808bfef76ea3a5c7d6e8225403"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; ::parallel::internal::TBBPartitioner &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aff8852808bfef76ea3a5c7d6e8225403">thread_loop_partitioner</a></td></tr>
<tr class="separator:aff8852808bfef76ea3a5c7d6e8225403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1c84d108d27ea3c0df7f0d8417b08f11"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a1c84d108d27ea3c0df7f0d8417b08f11"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a1c84d108d27ea3c0df7f0d8417b08f11">ReadWriteVector</a></td></tr>
<tr class="separator:a1c84d108d27ea3c0df7f0d8417b08f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Number&gt;<br />
class LinearAlgebra::ReadWriteVector&lt; Number &gt;</h3>

<p><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> is intended to represent vectors in <img class="formulaInl" alt="${\mathbb R}^N$" src="form_1062.png"/> for which it stores all or a subset of elements. The latter case in important in parallel computations, where <img class="formulaInl" alt="$N$" src="form_104.png"/> may be so large that no processor can actually all elements of a solution vector, but where this is also not necessary: one typically only has to store the values of degrees of freedom that live on cells that are locally owned plus potentially those degrees of freedom that live on ghost cells.</p>
<p>This class allows to access individual elements to be read or written. However, it does not allow global operations such as taking the norm. <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> can be used to read and write elements in vectors derived from <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a> such as <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> and <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>.</p>
<h3>Storing elements</h3>
<p>Most of the time, one will simply read from or write into a vector of the current class using the global numbers of these degrees of freedom. This is done using operator() or operator[] which call <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a6f246ddfbf22f0f8a54274a6540228d7">global_to_local()</a> to transform the <em>global</em> index into a <em>local</em> one. In such cases, it is clear that one can only access elements of the vector that the current object indeed stores.</p>
<p>However, it is also possible to access elements in the order in which they are stored by the current object. In other words, one is not interested in accessing elements with their <em>global</em> indices, but instead using an enumeration that only takes into account the elements that are actually stored. This is facilitated by the <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a722901ebee9fe3e68a29549ca30259a8">local_element()</a> function. To this end, it is necessary to know <em>in which order</em> the current class stores its element. The elements of all the consecutive ranges are stored in ascending order of the first index of each range. The function largest_range_starting_index() of <a class="el" href="classIndexSet.html">IndexSet</a> can be used to get the first index of the largest range.</p>
<dl class="section author"><dt>Author</dt><dd>Bruno Turcksin, 2015. </dd></dl>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00042">42</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a44a1b7eced911372389845dffd5c80c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a1b7eced911372389845dffd5c80c6">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Number <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a44a1b7eced911372389845dffd5c80c6">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare standard types used in all containers. These types parallel those in the <code>C++</code> standard libraries <code>vector&lt;...&gt;</code> class. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00129">129</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa019c2aa2c09503086bcb0604679f2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa019c2aa2c09503086bcb0604679f2ba">&#9670;&nbsp;</a></span>ReadWriteVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty constructor. </p>

</div>
</div>
<a id="a0e113f1d04f1faebde287699f2d4585c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e113f1d04f1faebde287699f2d4585c">&#9670;&nbsp;</a></span>ReadWriteVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="a0f57e4d076b7772b7ba15928070c2315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f57e4d076b7772b7ba15928070c2315">&#9670;&nbsp;</a></span>ReadWriteVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a vector given the size, the stored elements have their index in [0,size). </p>

</div>
</div>
<a id="ad3ebd721f36c364d3207672265406469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ebd721f36c364d3207672265406469">&#9670;&nbsp;</a></span>ReadWriteVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_stored_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a vector whose stored elements indices are given by the <a class="el" href="classIndexSet.html">IndexSet</a> <code>locally_stored_indices</code>. </p>

</div>
</div>
<a id="aa3a5d38e57f4f5c61f1f888d41a953a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a5d38e57f4f5c61f1f888d41a953a9">&#9670;&nbsp;</a></span>~ReadWriteVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::~<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaee2ea7c671f9ece558b081b0d104295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee2ea7c671f9ece558b081b0d104295">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the global size of the vector to <code>size</code>. The stored elements have their index in [0,size).</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). </p>

<p>Reimplemented in <a class="el" href="classLinearAlgebra_1_1Vector.html#ad90bdf4ac3761d70fd90e502b2c67020">LinearAlgebra::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a0aa62727797cde32d9dafb4dbcdd107f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa62727797cde32d9dafb4dbcdd107f">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses the same <a class="el" href="classIndexSet.html">IndexSet</a> as the one of the input vector <code>in_vector</code> and allocates memory for this vector.</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). </p>

</div>
</div>
<a id="aaa5d0c1a26755df4f451091e051a5277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5d0c1a26755df4f451091e051a5277">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_stored_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the vector. The indices are specified by <code>locally_stored_indices</code>.</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). locally_stored_indices. </p>

<p>Reimplemented in <a class="el" href="classLinearAlgebra_1_1Vector.html#a275b9098813ae76a68b42efe31a325c5">LinearAlgebra::Vector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a245371b4cfb447d8f39fcfd4646c5435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245371b4cfb447d8f39fcfd4646c5435">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the functor <code>func</code> to each element of the vector. The functor should look like </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Functor</div><div class="line">{</div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html#a233998157aa2acdbde9717aec827ccbf">operator() </a>(Number &amp;value);</div><div class="line">};</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function requires C++11 and read_write_vector.templates.h needs to be included. </dd></dl>

</div>
</div>
<a id="aed3562c39eaa838680a68cd85ffd81fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3562c39eaa838680a68cd85ffd81fa">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="a62ce4785132ec1e65de894c7e6198bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ce4785132ec1e65de894c7e6198bc3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the data and the <a class="el" href="classIndexSet.html">IndexSet</a> of the input vector <code>in_vector</code>. </p>

</div>
</div>
<a id="a0a983cd43825afc39d1466a6d468d18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a983cd43825afc39d1466a6d468d18c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the data and the <a class="el" href="classIndexSet.html">IndexSet</a> of the input vector <code>in_vector</code>. </p>

</div>
</div>
<a id="a699aa5c6cb9dad6bd0b93f0e744f74c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699aa5c6cb9dad6bd0b93f0e744f74c4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all elements of the vector to the scalar <code>s</code>. This operation is only allowed if <code>s</code> is equal to zero. </p>

</div>
</div>
<a id="a8d5ce3e6a89d9e4ee327f9c4c2bb0066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5ce3e6a89d9e4ee327f9c4c2bb0066">&#9670;&nbsp;</a></span>import() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">distributed::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>std::shared_ptr&lt;&#160;const&#160;<a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>vec</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

</div>
</div>
<a id="af52ccb8c92203fb645473fb4dd9c1f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52ccb8c92203fb645473fb4dd9c1f60">&#9670;&nbsp;</a></span>import() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>petsc_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>std::shared_ptr&lt;&#160;const&#160;<a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>petsc_vec</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

</div>
</div>
<a id="afc746d51575b3bc8f2d4ba8f95f9d3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc746d51575b3bc8f2d4ba8f95f9d3d9">&#9670;&nbsp;</a></span>import() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>trilinos_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>std::shared_ptr&lt;&#160;const&#160;<a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>trilinos_vec</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

</div>
</div>
<a id="a7802111f4ddcf4ede3cbaee885c3ab8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7802111f4ddcf4ede3cbaee885c3ab8f">&#9670;&nbsp;</a></span>import() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html">EpetraWrappers::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>epetra_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>std::shared_ptr&lt;&#160;const&#160;<a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>epetra_vec</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

</div>
</div>
<a id="a0e20857fed96063ebd2d3edaea1082bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e20857fed96063ebd2d3edaea1082bf">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The value returned by this function denotes the dimension of the vector spaces that are modeled by objects of this kind. However, objects of the current class do not actually stores all elements of vectors of this space but may, in fact store only a subset. The number of elements stored is returned by <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#aedac815f15ee3c78363e02baa97457e0">n_elements()</a> and is smaller or equal to the number returned by the current function. </p>

</div>
</div>
<a id="aedac815f15ee3c78363e02baa97457e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedac815f15ee3c78363e02baa97457e0">&#9670;&nbsp;</a></span>n_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::n_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the number of elements stored. It is smaller or equal to the dimension of the vector space that is modeled by an object of this kind. This dimension is return by <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a0e20857fed96063ebd2d3edaea1082bf">size()</a>. </p>

</div>
</div>
<a id="aaee475607463efff722ce083b6cd4f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee475607463efff722ce083b6cd4f7d">&#9670;&nbsp;</a></span>get_stored_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::get_stored_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classIndexSet.html">IndexSet</a> that represents the indices of the elements stored. </p>

</div>
</div>
<a id="a1c0f991527a8dd09601b764e59d097fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0f991527a8dd09601b764e59d097fc">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <code><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a></code> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the <em>locally stored</em> elements of this vector. </p>

</div>
</div>
<a id="ac4138913e659866ebba5801a88167270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4138913e659866ebba5801a88167270">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the locally stored elements of the vector. </p>

</div>
</div>
<a id="a4dbfbf3b3c7dcb1e96174eba41f3734c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbfbf3b3c7dcb1e96174eba41f3734c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array of locally stored entries. </p>

</div>
</div>
<a id="ab61f02fa9f52e7aa88d56310c6c0176a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61f02fa9f52e7aa88d56310c6c0176a">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array of the locally stored entries. </p>

</div>
</div>
<a id="a233998157aa2acdbde9717aec827ccbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233998157aa2acdbde9717aec827ccbf">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data in the position corresponding to <code>global_index</code>. An exception is thrown if <code>global_index</code> is not stored by the current object. </p>

</div>
</div>
<a id="a4a325d56a1d1c7f8db022eb442867d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a325d56a1d1c7f8db022eb442867d34">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data in the position corresponding to <code>global_index</code>. An exception is thrown if <code>global_index</code> is not stored by the current object. </p>

</div>
</div>
<a id="a71445351bd4b9dfb4ff0c1c516658fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71445351bd4b9dfb4ff0c1c516658fe6">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data in the position corresponding to <code>global_index</code>. An exception is thrown if <code>global_index</code> is not stored by the current object.</p>
<p>This function does the same thing as operator(). </p>

</div>
</div>
<a id="af9cf2035df2a9ba8777c80ffe4c1a914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cf2035df2a9ba8777c80ffe4c1a914">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data in the position corresponding to <code>global_index</code>. An exception is thrown if <code>global_index</code> is not stored by the current object.</p>
<p>This function does the same thing as operator(). </p>

</div>
</div>
<a id="abe49ac3785c3ed8cdf2c2200c9dd3b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe49ac3785c3ed8cdf2c2200c9dd3b94">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector, this function allows to get a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second. </p>

</div>
</div>
<a id="aae3387187c82a78eabb153f0d7bf1af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3387187c82a78eabb153f0d7bf1af4">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Just as the above, but with pointers. Useful in minimizing copying of data around. </p>

</div>
</div>
<a id="a722901ebee9fe3e68a29549ca30259a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722901ebee9fe3e68a29549ca30259a8">&#9670;&nbsp;</a></span>local_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data field specified by <code>local_index</code>. When you access elements in the order in which they are stored, it is necessary that you know in which they are stored. In other words, you need to know the map between the global indices of the elements this class stores, and the local indices into the contiguous array of these global elements. For this, see the general documentation of this class.</p>
<p>Performance: Direct array access (fast). </p>

</div>
</div>
<a id="aa7a1d6b3129693772cc2ae757d1f3c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a1d6b3129693772cc2ae757d1f3c36">&#9670;&nbsp;</a></span>local_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data field specified by <code>local_index</code>. When you access elements in the order in which they are stored, it is necessary that you know in which they are stored. In other words, you need to know the map between the global indices of the elements this class stores, and the local indices into the contiguous array of these global elements. For this, see the general documentation of this class.</p>
<p>Performance: Direct array access (fast). </p>

</div>
</div>
<a id="a20d03806be45070a19e1c809819b4b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d03806be45070a19e1c809819b4b74">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="a557e8adec1fd28216d0ebb7ca4a9b213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557e8adec1fd28216d0ebb7ca4a9b213">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the previous one but takes a <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> of values. </p>

</div>
</div>
<a id="a77cc92419018a05c262f946cef212f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cc92419018a05c262f946cef212f63">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number2 *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where <code>n_elements</code> are stored contiguously and add them into the vector. Handles all cases which are not covered by the other two <code><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html#a20d03806be45070a19e1c809819b4b74">add()</a></code> functions above. </p>

</div>
</div>
<a id="a30e936065ac760ac8ce71741374a2576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e936065ac760ac8ce71741374a2576">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the vector to the output stream <code>out</code>. </p>

</div>
</div>
<a id="a2457ff17e4f00e2a964769dfcefebdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2457ff17e4f00e2a964769dfcefebdb3">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the memory consumption of this class in bytes. </p>

</div>
</div>
<a id="adbea835864b25f03b3ee26ba8e34b8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbea835864b25f03b3ee26ba8e34b8a5">&#9670;&nbsp;</a></span>import() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const Epetra_MultiVector &amp;&#160;</td>
          <td class="paramname"><em>multivector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>multivector</code>. This is an helper function and it should not be used directly. </p>

</div>
</div>
<a id="a6f246ddfbf22f0f8a54274a6540228d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f246ddfbf22f0f8a54274a6540228d7">&#9670;&nbsp;</a></span>global_to_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::global_to_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the local position of <code>global_index</code>. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00518">518</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="a714412eda5ff0683842db5a92947db2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714412eda5ff0683842db5a92947db2f">&#9670;&nbsp;</a></span>resize_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::resize_val </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>new_allocated_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function that is used to resize the val array. </p>

</div>
</div>
<a id="a79499404d7d07670c72c36e065e5e060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79499404d7d07670c72c36e065e5e060">&#9670;&nbsp;</a></span>create_epetra_comm_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1CommunicationPattern.html">EpetraWrappers::CommunicationPattern</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::create_epetra_comm_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>source_index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a EpetraWrappers::Communication pattern and store it for future use. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a1c84d108d27ea3c0df7f0d8417b08f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c84d108d27ea3c0df7f0d8417b08f11">&#9670;&nbsp;</a></span>ReadWriteVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make all other <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> types friends. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00570">570</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afc5ab96d5e5729daebc67f6972cf7d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5ab96d5e5729daebc67f6972cf7d7e">&#9670;&nbsp;</a></span>stored_elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::stored_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indices of the elements stored. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00543">543</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="abc229cf3f043c2d7ecc0ecacc2f39f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc229cf3f043c2d7ecc0ecacc2f39f2e">&#9670;&nbsp;</a></span>source_stored_elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::source_stored_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classIndexSet.html">IndexSet</a> of the elements of the last imported vector; </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00548">548</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="a72ae0774078f2e5751f135033daecdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ae0774078f2e5751f135033daecdab">&#9670;&nbsp;</a></span>comm_pattern</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classLinearAlgebra_1_1CommunicationPatternBase.html">CommunicationPatternBase</a>&gt; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::comm_pattern</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CommunicationPattern for the communication between the source_stored_elements <a class="el" href="classIndexSet.html">IndexSet</a> and the current vector. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00554">554</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="a1ad91a104f9fd81f36b3cf01dece109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad91a104f9fd81f36b3cf01dece109d">&#9670;&nbsp;</a></span>val</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number* <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::val</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the array of local elements of this vector. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00559">559</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<a id="aff8852808bfef76ea3a5c7d6e8225403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8852808bfef76ea3a5c7d6e8225403">&#9670;&nbsp;</a></span>thread_loop_partitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; ::parallel::internal::TBBPartitioner&gt; <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt;::thread_loop_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For parallel loops with TBB, this member variable stores the affinity information of loops. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00565">565</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/lac/<a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a></li>
<li>deal.II/lac/<a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
