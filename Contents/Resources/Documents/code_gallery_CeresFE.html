<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The &#39;Viscoelastoplastic topography evolution&#39; code gallery program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The 'Viscoelastoplastic topography evolution' code gallery program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<p align="center"> 
  This program was contributed by Roger Fu &lt;rogerfu@fas.harvard.edu&gt;.
  <br>
  It comes without any warranty or support by its authors or the authors of deal.II.
</p>

</p>
<p>This program is part of the <a class="el" href="CodeGallery.html">deal.II code gallery</a> and consists of the following files (click to inspect):</p><ul>
<li><a href="../code-gallery/CeresFE/Readme.md">Readme.md</a> (<a href="#ann-Readme.md">annotated version</a>)</li>
<li><a href="../code-gallery/CeresFE/CMakeLists.txt">CMakeLists.txt</a></li>
<li><a href="../code-gallery/CeresFE/config/sample_CeresFE_config.cfg">config/sample_CeresFE_config.cfg</a></li>
<li><a href="../code-gallery/CeresFE/doc/entry-name">doc/entry-name</a></li>
<li><a href="../code-gallery/CeresFE/meshes/sample_CeresFE_mesh.inp">meshes/sample_CeresFE_mesh.inp</a></li>
<li><a href="../code-gallery/CeresFE/sample_CMakeCache/CMakeCache.txt">sample_CMakeCache/CMakeCache.txt</a></li>
<li><a href="../code-gallery/CeresFE/sample_output/hard_surface.mp4">sample_output/hard_surface.mp4</a></li>
<li><a href="../code-gallery/CeresFE/src/ceres.cc">src/ceres.cc</a> (<a href="#ann-src/ceres.cc">annotated version</a>)</li>
<li><a href="../code-gallery/CeresFE/support_code/config_in.h">support_code/config_in.h</a> (<a href="#ann-support_code/config_in.h">annotated version</a>)</li>
<li><a href="../code-gallery/CeresFE/support_code/ellipsoid_fit.h">support_code/ellipsoid_fit.h</a> (<a href="#ann-support_code/ellipsoid_fit.h">annotated version</a>)</li>
<li><a href="../code-gallery/CeresFE/support_code/ellipsoid_grav.h">support_code/ellipsoid_grav.h</a> (<a href="#ann-support_code/ellipsoid_grav.h">annotated version</a>)</li>
<li><a href="../code-gallery/CeresFE/support_code/local_math.h">support_code/local_math.h</a> (<a href="#ann-support_code/local_math.h">annotated version</a>)</li>
</ul>
<p><a class="anchor" id="ann-Readme.md"></a> </p><h1>Annotated version of Readme.md</h1>
<h1>Readme file for CeresFE </h1>
<h2>Motivation for project </h2>
<p>This code was made to simulate the evolution of global-scale topography on planetary bodies. Specifically, it is designed to compute the rates of topography relaxation on the dwarf planet Ceres. The NASA Dawn mission, in orbit around Ceres since March, 2015, has produced a high resolution shape model of its surface. As on other planets including the Earth, topography on Ceres is subject to decay over time due to processes such as viscous flow and brittle failure. Because the efficiency of these processes is dependent on the material properties of the body at depth, simulating the decay of topography and comparing it to the observed shape model permits insights into Ceres' internal stucture.</p>
<p>Some previous applications of this basic idea- using topography to constrain internal structure- may be found in the following references:</p>
<ol type="1">
<li>Takeuchi, H. and Hasegawa, Y. (1965) Viscosity distribution within the Earth. Geophys. J. R. astr. Soc. 9, 503-508.</li>
<li>Anderson, D. L. and O'Connell, R. (1967) Viscosity of the Earth. Geophys. J. R. astr. Soc. 14, 287-295.</li>
<li>Solomon, S. C., Comer, R. P., Head, J. W. (1982) The Evolution of impact basins: Viscous relaxation of topographic relief.</li>
<li>Zuber, M. T. et al. (2000) Internal structure and early thermal evolution of Mars from Mars Global Surveyor topography and gravity. Science 287, 1788-1793.</li>
<li>Fu, R. R. et al. (2014) Efficient early global relaxation of asteroid Vesta. Icarus 240, 133-145.</li>
</ol>
<p>The code included here is a development of a simpler code for the asteroid Vesta, published as reference 5 above. Because both versions of the code were written specifically to model long wavelength topography on these small bodies, the code is rather specific. We hope certain components of it may be useful to the reader even if the problem of topographic relaxation on asteroid belt bodies is not on everyone's radar.</p>
<h2>Quick facts about the code </h2>
<p>Viscoelastoplastic Asymmetric Lagrangian Uses analytical self-gravity One sentence purpose: Simulates evolution of topography due to self-gravity on axisymmetry planetary body.</p>
<h2>More detailed properties of the code in CeresFE </h2>
<h3>Viscoelastoplasticity</h3>
<p>The code is viscoelastoplastic: it solves the Stokes equations modified to include elasticity and iteratively uses the stress solution to account for displacement due to brittle failure The implementation of viscoelasticity follows mainly section 2.2.3 of Keller, T. et al. (2013) Numerical modelling of magma dynamics coupled to tectonic deformation of lithosphere and crust. Geophys. J. Int. 195, 1406-1442. At the end of each FE calculation, the principle stresses (in 3D) are computed in all cells. Each cell is evaluated according to either Byerlee's Rule or a damaged rock brittle failure criterion to determine if failure occurred. See Byerlee, J. (1978) Friction of rocks, Pageoph. 116, 615-626. and Schultz, R. A. (1993) Brittle strength of basalitc rock masses with applications to Venus. J. Geophys. Res. 98, 10,883-10,895. If a cell failed, its viscosity is lowered by a computed amount to simulate plastic yielding. The viscosity fields is smoothed and the FE model run again. This is repeated until the number of failed cells falls below a prescribed number. The final viscosity field (i.e., the effective viscosity) is then used to compute velocities and advance the mesh.</p>
<h3>Domain and boundary conditions</h3>
<p>The domain of the model is 2D, but the Stokes equations are cast in axisymmetric form. The domain consists of approximately a quarter ellipse, with two straight edges corresponding to the rotation axis and equator of the body. No normal flux boundary conditions are applied to these edges. The remaining curved edge that corresponds to the surface of the body is assigned a zero pressure boundary condition With respect to self-gravity, an ellipse is fitted to the outer surface and any internal density surfaces at each time step and a gravity field is computed analytically following Pohanka, V. (2011) Gravitational field of the homogeneous rotational ellipsoidal body: a simple derivation and applications. Contrib. Geophys. Geodesy 41, 117-157.</p>
<h2>Description of files in repo </h2>
<p>src/ceres.cc Main code support_code/config_in.h Reads config file and intializes system parameters support_code/ellipsoid_fit.h Finds best-fit ellipse for surface and internal density boundaries. Also uses deal.II support_code/ellipsoid_grav.h Analytically computes self gravity of layered ellipsoids structure support_code/local_math.h Defines some constants for convenience meshes/sample_CeresFE_mesh.inp Sample input mesh config/sample_CeresFE_config.cfg Sample configurations file with simulation parameters</p>
<h2>Other dependencies </h2>
<p>Two more code packages are necessary to run CeresFE:</p>
<ol type="1">
<li>config++: <a href="https://sourceforge.net/projects/config/">https://sourceforge.net/projects/config/</a></li>
<li>Armadillo: <a href="http://arma.sourceforge.net">http://arma.sourceforge.net</a></li>
</ol>
<h2>To run code </h2>
<p>After running cmake ., add the -lconfig++ and -larmadillo tags into the CMakeCache.txt file :</p>
<p>Flags used by the compiler during all build types. CMAKE_CXX_FLAGS:STRING=-lconfig++ -larmadillo</p>
<p>Then, run the executable with one argument, which is the config file :</p>
<p>&gt;&gt;src/ceres config/sample_CeresFE_config.cfg</p>
<p><a class="anchor" id="ann-src/ceres.cc"></a> </p><h1>Annotated version of src/ceres.cc</h1>
<div class="fragment"><div class="line">/ *</div><div class="line">Viscoelastoplastic relaxation of Ceres</div><div class="line">Author: Roger R. Fu</div><div class="line">Adapted from Fu et al. 2014 Icarus 240, 133-145 starting Oct. 19, 2014</div><div class="line"> * /</div><div class="line"></div><div class="line">/ *</div><div class="line">Summary of output files:</div><div class="line"></div><div class="line">One per run:</div><div class="line"></div><div class="line">- initial_mesh.eps                                        :  Visualization of initially imported mesh</div><div class="line">- physical_times.txt                                :  Columns are (1) step number corresponding to other files, (2) physical times at the time when each calculation is run in sec, (3) number of the final plasticity iteration in each timestep.  Written in do_elastic_steps() for elastic steps and do_flow_step() for viscous steps</div><div class="line"></div><div class="line">One per time step:</div><div class="line"></div><div class="line">- timeXX_elastic_displacements.txt        :  Vtk-readable file with columns (1) x, (2) y, (3) u_x, (4) u_y, (5) P.  Written in output_results() function, which is run immediately after solve().</div><div class="line">- timeXX_baseviscosities.txt                :  Columns (1) cell x, (2) cell y, (3) base viscosity in Pa s.  Written in solution_stresses().</div><div class="line">- timeXX_surface.txt                                :  Surface (defined as where P=0 boundary condition is applied) vertices at the beginning of timestep, except for the final timestep.  Written in write_vertices() function, which is called immediately after setup_dofs() except for the final iteration, when it is called after move_mesh()</div><div class="line"></div><div class="line">One per plasticity step:</div><div class="line"></div><div class="line">- timeXX_flowYY.txt                                        :  Same as timeXX_elastic_displacements.txt above</div><div class="line">- timeXX_principalstressesYY.txt        :  Columns with sigma1 and sigma3 at each cell.  Same order as timeXX_baseviscosities.txt.  Written in solution_stresses().</div><div class="line">- timeXX_stresstensorYY.txt                        :  Columns with components 11, 22, 33, and 13 of stress tensor at each cell.  Written in solution_stresses().</div><div class="line">- timeXX_failurelocationsYY.txt                :  Gives x,y coordinates of all cells where failure occurred.  Written in solution_stresses().</div><div class="line">- timeXX_viscositiesregYY.txt                :  Gives smoothed and regularized (i.e., floor and ceiling-filtered) effective viscosities.  Written at end of solution_stresses().</div><div class="line"></div><div class="line">* /</div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/derivative_approximation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/fe_field_function.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_ilu.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;time.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;armadillo&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;../support_code/ellipsoid_grav.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../support_code/ellipsoid_fit.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../support_code/config_in.h&quot;</span></div></div><!-- fragment --><p>As in all programs, the namespace dealii is included:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step22 {</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"><span class="keyword">using namespace </span>arma;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;2&gt; {</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct </span>InnerPreconditioner&lt;3&gt; {</div><div class="line">        <span class="keyword">typedef</span> <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> type;</div><div class="line">};</div></div><!-- fragment --><p>Auxiliary functions</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>AuxFunctions {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;2, 2&gt;</a> get_rotation_matrix(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> &gt; &amp;grad_u);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2, 2&gt;</a> AuxFunctions&lt;dim&gt;::get_rotation_matrix(</div><div class="line">                <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, 2&gt;</a> &gt; &amp;grad_u) {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> curl = (grad_u[1][0] - grad_u[0][1]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> angle = std::atan(curl);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> t[2][2] = { { cos(angle), sin(angle) }, { -sin(angle), cos(</div><div class="line">                        angle) } };</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;2, 2&gt;</a>(t);</div><div class="line">}</div></div><!-- fragment --><p>Class for remembering material state/properties at each quadrature point</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>PointHistory {</div><div class="line">        <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> old_stress;</div><div class="line">        <span class="keywordtype">double</span> old_phiphi_stress;</div><div class="line">        <span class="keywordtype">double</span> first_eta;</div><div class="line">        <span class="keywordtype">double</span> new_eta;</div><div class="line">        <span class="keywordtype">double</span> G;</div><div class="line">};</div></div><!-- fragment --><p>Primary class of this problem</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StokesProblem {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">        <span class="keywordtype">void</span> run();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="keywordtype">void</span> setup_dofs();</div><div class="line">        <span class="keywordtype">void</span> assemble_system();</div><div class="line">        <span class="keywordtype">void</span> solve();</div><div class="line">        <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line">        <span class="keywordtype">void</span> refine_mesh();</div><div class="line">        <span class="keywordtype">void</span> solution_stesses();</div><div class="line">        <span class="keywordtype">void</span> smooth_eta_field(std::vector&lt;bool&gt; failing_cells);</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> setup_initial_mesh();</div><div class="line">        <span class="keywordtype">void</span> do_elastic_steps();</div><div class="line">        <span class="keywordtype">void</span> do_flow_step();</div><div class="line">        <span class="keywordtype">void</span> update_time_interval();</div><div class="line">        <span class="keywordtype">void</span> initialize_eta_and_G();</div><div class="line">        <span class="keywordtype">void</span> move_mesh();</div><div class="line">        <span class="keywordtype">void</span> do_ellipse_fits();</div><div class="line">        <span class="keywordtype">void</span> append_physical_times(<span class="keywordtype">int</span> max_plastic);</div><div class="line">        <span class="keywordtype">void</span> write_vertices(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>);</div><div class="line">        <span class="keywordtype">void</span> write_mesh();</div><div class="line">        <span class="keywordtype">void</span> setup_quadrature_point_history();</div><div class="line">        <span class="keywordtype">void</span> update_quadrature_point_history();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">        <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> triangulation;</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line">        <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> fe;</div><div class="line">        <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = 0, n_p = 0;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plastic_iteration = 0;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_max_plasticity = 0;</div><div class="line"></div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula;</div><div class="line">        std::vector&lt; std::vector &lt;Vector&lt;double&gt; &gt; &gt; quad_viscosities; <span class="comment">// Indices for this object are [cell][q][q coords, eta]</span></div><div class="line">        std::vector&lt;double&gt; cell_viscosities; <span class="comment">// This vector is only used for output, not FE computations</span></div><div class="line">        std::vector&lt;PointHistory&lt;dim&gt; &gt; quadrature_point_history;</div><div class="line"></div><div class="line">        <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div><div class="line"></div><div class="line">        <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> sparsity_pattern;</div><div class="line">        <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">        <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">        <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">        std_cxx1x::shared_ptr&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; A_preconditioner;</div><div class="line"></div><div class="line">        ellipsoid_fit&lt;dim&gt;   ellipsoid;</div><div class="line">};</div></div><!-- fragment --><p>Class for boundary conditions and rhs</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValuesP: <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        BoundaryValuesP() :</div><div class="line">                        <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1) {</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;value) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValuesP&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const </span>{</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(p[0] &gt;= -10, <a class="code" href="group__Exceptions.html#ga2cbabab84299dbba998aaf083721defa">ExcLowerRange</a> (p[0], 0)); <span class="comment">//value of -10 is to permit some small numerical error moving nodes left of x=0; a &lt;&lt; value is in fact sufficient</span></div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValuesP&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#aa568b98591fc2bda09b28539789aef7d">n_components</a>; ++c)</div><div class="line">                values(c) = BoundaryValuesP&lt;dim&gt;::value(p, c);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide: <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1) {}</div><div class="line"></div><div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component,</div><div class="line">                        A_Grav_namespace::AnalyticGravity&lt;dim&gt; *aGrav) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;value,</div><div class="line">                        A_Grav_namespace::AnalyticGravity&lt;dim&gt; *aGrav) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                        std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt; &amp;values,</div><div class="line">                        A_Grav_namespace::AnalyticGravity&lt;dim&gt; *aGrav) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component,</div><div class="line">                A_Grav_namespace::AnalyticGravity&lt;dim&gt; *aGrav)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">        std::vector&lt;double&gt; temp_vector(2);</div><div class="line">        aGrav-&gt;get_gravity(p, temp_vector);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (component == 0) {</div><div class="line">                <span class="keywordflow">return</span> temp_vector[0] + system_parameters::omegasquared * p[0];        <span class="comment">// * 1.2805;</span></div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">                <span class="keywordflow">if</span> (component == 1)</div><div class="line">                        <span class="keywordflow">return</span> temp_vector[1];</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                        <span class="keywordflow">return</span> 0;</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values,</div><div class="line">                A_Grav_namespace::AnalyticGravity&lt;dim&gt; *aGrav)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">                values(c) = RightHandSide&lt;dim&gt;::value(p, c, aGrav);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::vector_value_list(</div><div class="line">                <span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt; &amp;values,</div><div class="line">                A_Grav_namespace::AnalyticGravity&lt;dim&gt; *aGrav)<span class="keyword"> const </span>{</div></div><!-- fragment --><p>check whether component is in the valid range is up to the derived class</p>
<div class="fragment"><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == points.size(),</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), points.size()));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">                this-&gt;vector_value(points[i], values[i], aGrav);</div><div class="line">}</div></div><!-- fragment --><p>Class for linear solvers and preconditioners</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Matrix, <span class="keyword">class</span> Preconditioner&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix: <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        InverseMatrix(<span class="keyword">const</span> Matrix &amp;m, <span class="keyword">const</span> Preconditioner &amp;preconditioner);</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Matrix&gt;</a> matrix;</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Preconditioner&gt;</a> preconditioner;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Matrix, <span class="keyword">class</span> Preconditioner&gt;</div><div class="line">InverseMatrix&lt;Matrix, Preconditioner&gt;::InverseMatrix(<span class="keyword">const</span> Matrix &amp;m,</div><div class="line">                <span class="keyword">const</span> Preconditioner &amp;preconditioner) :</div><div class="line">                matrix(&amp;m), preconditioner(&amp;preconditioner) {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Matrix, <span class="keyword">class</span> Preconditioner&gt;</div><div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;Matrix, Preconditioner&gt;::vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const </span>{</div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000 * src.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), 1e-9 * src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line"></div><div class="line">        <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">        dst = 0;</div><div class="line"></div><div class="line">        cg.solve(*matrix, dst, src, *preconditioner);</div><div class="line">}</div></div><!-- fragment --><p>Class for the SchurComplement</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Preconditioner&gt;</div><div class="line"><span class="keyword">class </span>SchurComplement: <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a> {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        SchurComplement(<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">                        <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, Preconditioner&gt; &amp;A_inverse);</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a>, Preconditioner&gt; &gt; A_inverse;</div><div class="line"></div><div class="line">        <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Preconditioner&gt;</div><div class="line">SchurComplement&lt;Preconditioner&gt;::SchurComplement(</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;system_matrix,</div><div class="line">                <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>, Preconditioner&gt; &amp;A_inverse) :</div><div class="line">                system_matrix(&amp;system_matrix), A_inverse(&amp;A_inverse), tmp1(</div><div class="line">                                system_matrix.block(0, 0).m()), tmp2(</div><div class="line">                                system_matrix.block(0, 0).m()) {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Preconditioner&gt;</div><div class="line"><span class="keywordtype">void</span> SchurComplement&lt;Preconditioner&gt;::vmult(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const </span>{</div><div class="line">        system_matrix-&gt;<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(0, 1).vmult(tmp1, src);</div><div class="line">        A_inverse-&gt;vmult(tmp2, tmp1);</div><div class="line">        system_matrix-&gt;block(1, 0).vmult(dst, tmp2);</div><div class="line">}</div></div><!-- fragment --><p>StokesProblem::StokesProblem</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesProblem&lt;dim&gt;::StokesProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree) :</div><div class="line">                degree(degree),</div><div class="line">                mapping(),</div><div class="line">                triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing),</div><div class="line">                fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree), 1),</div><div class="line">                dof_handler(triangulation),</div><div class="line">                quadrature_formula(degree + 2),</div><div class="line">                ellipsoid(&amp;triangulation)</div><div class="line">                                {}</div></div><!-- fragment --><p>Set up dofs</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_dofs() {</div><div class="line">        A_preconditioner.reset();</div><div class="line">        system_matrix.<a class="code" href="classSparseLUDecomposition.html#a0e90db1baf968e804126651a988b7c07">clear</a>();</div><div class="line"></div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        <a class="code" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">        std::vector&lt;unsigned int&gt; block_component(dim + 1, 0);</div><div class="line">        block_component[dim] = 1;</div><div class="line">        <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler, block_component);</div></div><!-- fragment --><p>========================================Apply <a class="el" href="classBoundary.html">Boundary</a> Conditions=====================================</p>
<div class="fragment"><div class="line">        {</div><div class="line">                constraints.clear();</div><div class="line">                std::vector&lt;bool&gt; component_maskP(dim + 1, <span class="keyword">false</span>);</div><div class="line">                component_maskP[dim] = <span class="keyword">true</span>;</div><div class="line">                <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">                <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler, 1,</div><div class="line">                                BoundaryValuesP&lt;dim&gt;(), constraints, component_maskP);</div><div class="line">        }</div><div class="line">        {</div><div class="line">                std::set&lt;unsigned char&gt; no_normal_flux_boundaries;</div><div class="line">                no_normal_flux_boundaries.insert(99);</div><div class="line">                <a class="code" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">VectorTools::compute_no_normal_flux_constraints</a>(dof_handler, 0,</div><div class="line">                                no_normal_flux_boundaries, constraints);</div><div class="line">        }</div><div class="line"></div><div class="line">        constraints.close();</div><div class="line"></div><div class="line">        std::vector&lt;unsigned int&gt; dofs_per_block(2);</div><div class="line">        <a class="code" href="namespaceDoFTools.html#abfd9796e22113e13b5802e384e56af4f">DoFTools::count_dofs_per_block</a>(dof_handler, dofs_per_block,</div><div class="line">                        block_component);</div><div class="line">        n_u = dofs_per_block[0];</div><div class="line">        n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">                        &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">                        &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span></div><div class="line">                        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">                BlockCompressedSimpleSparsityPattern csp(2, 2);</div><div class="line"></div><div class="line">                csp.block(0, 0).reinit(n_u, n_u);</div><div class="line">                csp.block(1, 0).reinit(n_p, n_u);</div><div class="line">                csp.block(0, 1).reinit(n_u, n_p);</div><div class="line">                csp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">                csp.collect_sizes();</div><div class="line"></div><div class="line">                <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler, csp, constraints, <span class="keyword">false</span>);</div><div class="line">                sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(csp);</div><div class="line">        }</div><div class="line"></div><div class="line">        system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">        solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(2);</div><div class="line">        solution.block(0).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(n_u);</div><div class="line">        solution.block(1).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(n_p);</div><div class="line">        solution.collect_sizes();</div><div class="line"></div><div class="line">        system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(2);</div><div class="line">        system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0).reinit(n_u);</div><div class="line">        system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).reinit(n_p);</div><div class="line">        system_rhs.<a class="code" href="classBlockVectorBase.html#a6a27b2a48e5b5780cd0a6640b928d794">collect_sizes</a>();</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Viscosity and Shear modulus functions</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Rheology {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        <span class="keywordtype">double</span> get_eta(<span class="keywordtype">double</span> &amp;r, <span class="keywordtype">double</span> &amp;z);</div><div class="line">        <span class="keywordtype">double</span> get_G(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mat_id);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">        std::vector&lt;double&gt; get_manual_eta_profile();</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;double&gt; Rheology&lt;dim&gt;::get_manual_eta_profile()</div><div class="line">{</div><div class="line">        vector&lt;double&gt; etas;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; system_parameters::sizeof_depths_eta; i++)</div><div class="line">        {</div><div class="line">                etas.push_back(system_parameters::depths_eta[i]);</div><div class="line">                etas.push_back(system_parameters::eta_kinks[i]);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> etas;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Rheology&lt;dim&gt;::get_eta(<span class="keywordtype">double</span> &amp;r, <span class="keywordtype">double</span> &amp;z)</div><div class="line">{</div></div><!-- fragment --><p>compute local depth</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> ecc = system_parameters::q_axes[0] / system_parameters::p_axes[0];</div><div class="line"><span class="keywordtype">double</span> Rminusr = system_parameters::q_axes[0] - system_parameters::p_axes[0];</div><div class="line"><span class="keywordtype">double</span> approx_a = std::sqrt(r * r + z * z * ecc * ecc);</div><div class="line"><span class="keywordtype">double</span> approx_b = approx_a / ecc;</div><div class="line"><span class="keywordtype">double</span> group1 = r * r + z * z - Rminusr * Rminusr;</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> a0 = approx_a;</div><div class="line">        <span class="keywordtype">double</span> error = 10000;</div></div><!-- fragment --><p>While loop finds the a axis of the "isodepth" ellipse for which the input point is on the surface. An "isodepth" ellipse is defined as one whose axes a,b are related to the global axes A, B by: A-h = B-h</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((r &gt; system_parameters::q_axes[0] - system_parameters::depths_eta.back()) ||</div><div class="line">    (z &gt; system_parameters::p_axes[0] - system_parameters::depths_eta.back()))</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acf35b7afd6a85044d32320355fbaabfe">eps</a> = 10.0;</div><div class="line">    <span class="keywordflow">while</span> (error &gt;= eps)</div><div class="line">    {</div><div class="line">            <span class="keywordtype">double</span> a02 = a0 * a0;</div><div class="line">            <span class="keywordtype">double</span> a03 = a0 * a02;</div><div class="line">            <span class="keywordtype">double</span> a04 = a0 * a03;</div><div class="line">            <span class="keywordtype">double</span> fofa = a04 - (2 * Rminusr * a03) - (group1 * a02)</div><div class="line">                            + (2 * r * r * Rminusr * a0) - (r * r * Rminusr * Rminusr);</div><div class="line">            <span class="keywordtype">double</span> fprimeofa = 4 * a03 - (6 * Rminusr * a02) - (2 * group1 * a0)</div><div class="line">                                + (2 * r * r * Rminusr);</div><div class="line">            <span class="keywordtype">double</span> deltaa = -fofa / fprimeofa;</div><div class="line">            a0 += deltaa;</div><div class="line">            error = std::abs(deltaa);</div></div><!-- fragment --><p>cout &lt;&lt; "error = " &lt;&lt; error &lt;&lt; endl;</p>
<div class="fragment"><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">        a0 = 0.0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> local_depth = system_parameters::q_axes[0] - a0;</div><div class="line"><span class="keywordflow">if</span> (local_depth &lt; 0)</div><div class="line">        local_depth = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (local_depth &gt; system_parameters::depths_eta.back())</div><div class="line">{</div><div class="line">        <span class="keywordflow">if</span> (system_parameters::eta_kinks.back() &lt; system_parameters::eta_floor)</div><div class="line">            <span class="keywordflow">return</span> system_parameters::eta_floor;</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (system_parameters::eta_kinks.back() &gt; system_parameters::eta_ceiling)</div><div class="line">            <span class="keywordflow">return</span> system_parameters::eta_ceiling;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">                <span class="keywordflow">return</span> system_parameters::eta_kinks.back();</div><div class="line">}</div><div class="line"></div><div class="line">std::vector&lt;double&gt; viscosity_function = get_manual_eta_profile();</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_visc_kinks = viscosity_function.size() / 2;</div></div><!-- fragment --><p>find the correct interval to do the interpolation in</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> n_minus_one = -1;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 1; n &lt;= n_visc_kinks; n++) {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ndeep = 2 * n - 2;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nshallow = 2 * n;</div><div class="line">        <span class="keywordflow">if</span> (local_depth &gt;= viscosity_function[ndeep] &amp;&amp; local_depth &lt;= viscosity_function[nshallow])</div><div class="line">                n_minus_one = ndeep;</div><div class="line">}</div></div><!-- fragment --><p>find the viscosity interpolation</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (n_minus_one == -1)</div><div class="line">        <span class="keywordflow">return</span> system_parameters::eta_ceiling;</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">        <span class="keywordtype">double</span> visc_exponent =</div><div class="line">                        (viscosity_function[n_minus_one]</div><div class="line">                                        - local_depth)</div><div class="line">                                        / (viscosity_function[n_minus_one]</div><div class="line">                                                        - viscosity_function[n_minus_one + 2]);</div><div class="line">        <span class="keywordtype">double</span> visc_base = viscosity_function[n_minus_one + 3]</div><div class="line">                        / viscosity_function[n_minus_one + 1];</div></div><!-- fragment --><p>This is the true viscosity given the thermal profile</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> true_eta = viscosity_function[n_minus_one + 1] * std::pow(visc_base, visc_exponent);</div></div><!-- fragment --><p>Implement latitude-dependence viscosity</p>
<div class="fragment"><div class="line">                        <span class="keywordflow">if</span>(system_parameters::lat_dependence)</div><div class="line">                        {</div><div class="line">                                <span class="keywordtype">double</span> lat = 180 / PI * std::atan(z / r);</div><div class="line">                                <span class="keywordflow">if</span>(lat &gt; 80)</div><div class="line">                                        lat = 80;</div><div class="line">                                <span class="keywordtype">double</span> T_eq = 155;</div><div class="line">                                <span class="keywordtype">double</span> T_surf = T_eq * std::sqrt( std::sqrt( std::cos( PI / 180 * lat ) ) );</div><div class="line">                                <span class="keywordtype">double</span> taper_depth = 40000;</div><div class="line">                                <span class="keywordtype">double</span> surface_taper = (taper_depth - local_depth) / taper_depth;</div><div class="line">                                <span class="keywordflow">if</span>(surface_taper &lt; 0)</div><div class="line">                                        surface_taper = 0;</div><div class="line">                                <span class="keywordtype">double</span> log_eta_contrast = surface_taper * system_parameters::eta_Ea * 52.5365 * (T_eq - T_surf) / T_eq / T_surf;</div><div class="line">                                true_eta *= std::pow(10, log_eta_contrast);</div><div class="line">                        }</div><div class="line"></div><div class="line">                        <span class="keywordflow">if</span>(true_eta &gt; system_parameters::eta_ceiling)</div><div class="line">                                <span class="keywordflow">return</span> system_parameters::eta_ceiling;</div><div class="line">                        <span class="keywordflow">else</span></div><div class="line">                                <span class="keywordflow">if</span>(true_eta &lt; system_parameters::eta_floor)</div><div class="line">                                        <span class="keywordflow">return</span> system_parameters::eta_floor;</div><div class="line">                                <span class="keywordflow">else</span></div><div class="line">                                        <span class="keywordflow">return</span> true_eta;</div><div class="line">                }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Rheology&lt;dim&gt;::get_G(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mat_id)</div><div class="line">{</div><div class="line">                <span class="keywordflow">return</span> system_parameters::G[mat_id];</div><div class="line">}</div></div><!-- fragment --><p>Initialize the eta and G parts of the quadrature_point_history object</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::initialize_eta_and_G() {</div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">        Rheology&lt;dim&gt; rheology;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(); cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell) {</div><div class="line">                PointHistory&lt;dim&gt; *local_quadrature_points_history =</div><div class="line">                                <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">                                local_quadrature_points_history &gt;= &amp;quadrature_point_history.front(),</div><div class="line">                                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">                                local_quadrature_points_history &lt; &amp;quadrature_point_history.back(),</div><div class="line">                                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q) {</div><div class="line"></div><div class="line">                        <span class="keywordtype">double</span> r_value = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q)[0];</div><div class="line">                        <span class="keywordtype">double</span> z_value = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q)[1];</div></div><!-- fragment --><p>defines local viscosity</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> local_viscosity = 0;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_id = cell-&gt;material_id();</div><div class="line"></div><div class="line">local_viscosity = rheology.get_eta(r_value, z_value);</div><div class="line"></div><div class="line">local_quadrature_points_history[q].first_eta = local_viscosity;</div><div class="line">local_quadrature_points_history[q].new_eta = local_viscosity;</div></div><!-- fragment --><p>defines local shear modulus</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> local_G = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mat_id = cell-&gt;material_id();</div><div class="line"></div><div class="line">local_G = rheology.get_G(mat_id);</div><div class="line">local_quadrature_points_history[q].G = local_G;</div></div><!-- fragment --><p>initializes the phi-phi stress</p>
<div class="fragment"><div class="line">                        local_quadrature_points_history[q].old_phiphi_stress = 0;</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>====================== ASSEMBLE THE SYSTEM ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::assemble_system() {</div><div class="line">        system_matrix = 0;</div><div class="line">        system_rhs = 0;</div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="line">                                        | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">        std::vector&lt;unsigned int&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>runs the gravity script function</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line"></div><div class="line">A_Grav_namespace::AnalyticGravity&lt;dim&gt; * aGrav =</div><div class="line">                <span class="keyword">new</span> A_Grav_namespace::AnalyticGravity&lt;dim&gt;;</div><div class="line">std::vector&lt;double&gt; grav_parameters;</div><div class="line">grav_parameters.push_back(system_parameters::q_axes[system_parameters::present_timestep * 2 + 0]);</div><div class="line">grav_parameters.push_back(system_parameters::p_axes[system_parameters::present_timestep * 2 + 0]);</div><div class="line">grav_parameters.push_back(system_parameters::q_axes[system_parameters::present_timestep * 2 + 1]);</div><div class="line">grav_parameters.push_back(system_parameters::p_axes[system_parameters::present_timestep * 2 + 1]);</div><div class="line">grav_parameters.push_back(system_parameters::rho[0]);</div><div class="line">grav_parameters.push_back(system_parameters::rho[1]);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Body parameters are: &quot;</span> ;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;6; i++)</div><div class="line">        std::cout &lt;&lt; grav_parameters[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">std::cout &lt;&lt; endl;</div><div class="line"></div><div class="line">aGrav-&gt;setup_vars(grav_parameters);</div><div class="line"></div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; rhs_values(n_q_points,</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; phi_grads_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt; div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt; &gt; phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt; phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), first_cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell) {</div><div class="line">        PointHistory&lt;dim&gt; *local_quadrature_points_history =</div><div class="line">                        <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">                        local_quadrature_points_history &gt;= &amp;quadrature_point_history.front(),</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">                        local_quadrature_points_history &lt; &amp;quadrature_point_history.back(),</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        </div><div class="line">        <span class="keywordtype">double</span> cell_area = cell-&gt;measure();</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span>(cell_area&lt;0)</div><div class="line">                append_physical_times(-1); <span class="comment">// This writes final line to physical_times.txt if step terminates prematurely</span></div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(cell_area &gt; 0</div><div class="line">                ,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_id = cell-&gt;material_id();</div></div><!-- fragment --><p>initializes the rhs vector to the correct g values</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line">right_hand_side.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                rhs_values, aGrav);</div><div class="line"></div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; new_viscosities(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(), <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div></div><!-- fragment --><p>Finds vertices where the radius is zero DIM</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_singular = <span class="keyword">false</span>;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> singular_vertex_id = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++f) {</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;center()[0] == 0) {</div><div class="line">                is_singular = <span class="keyword">true</span>;</div><div class="line">                singular_vertex_id = f;</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (is_singular == <span class="keyword">false</span> || system_parameters::cylindrical == <span class="keyword">false</span>) {</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs = 0;</div></div><!-- fragment --><p>===== outputs the local gravity</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;dim&gt; &gt; quad_points_list(n_q_points);</div><div class="line">quad_points_list = fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (plastic_iteration</div><div class="line">                == (system_parameters::max_plastic_iterations - 1)) {</div><div class="line">        <span class="keywordflow">if</span> (cell != first_cell) {</div><div class="line">                std::ofstream fout(<span class="stringliteral">&quot;gravity_field.txt&quot;</span>, std::ios::app);</div><div class="line">                fout &lt;&lt; quad_points_list[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rhs_values[0];</div><div class="line">                fout.close();</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">                std::ofstream fout(<span class="stringliteral">&quot;gravity_field.txt&quot;</span>);</div><div class="line">                fout &lt;&lt; quad_points_list[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rhs_values[0];</div><div class="line">                fout.close();</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q) {</div><div class="line">         <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;old_stress =</div><div class="line">                        local_quadrature_points_history[q].old_stress;</div><div class="line">        <span class="keywordtype">double</span> &amp;local_old_phiphi_stress =</div><div class="line">                        local_quadrature_points_history[q].old_phiphi_stress;</div><div class="line">        <span class="keywordtype">double</span> r_value = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q)[0];</div><div class="line">        <span class="keywordtype">double</span> z_value = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q)[1];</div></div><!-- fragment --><p>get local density based on mat id</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> local_density = system_parameters::rho[m_id];</div></div><!-- fragment --><p>defines local viscosities</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> local_viscosity = 0;</div><div class="line"><span class="keywordflow">if</span> (plastic_iteration == 0)</div><div class="line">        local_viscosity = local_quadrature_points_history[q].first_eta;</div><div class="line"><span class="keywordflow">else</span></div><div class="line">        local_viscosity = local_quadrature_points_history[q].new_eta;</div></div><!-- fragment --><p>Define the local viscoelastic constants</p>
<div class="fragment"><div class="line">                <span class="keywordtype">double</span> local_eta_ve = 2</div><div class="line">                                / ((1 / local_viscosity)</div><div class="line">                                                + (1 / local_quadrature_points_history[q].G</div><div class="line">                                                                / system_parameters::current_time_interval));</div><div class="line">                <span class="keywordtype">double</span> local_chi_ve = 1</div><div class="line">                                / (1</div><div class="line">                                                + (local_quadrature_points_history[q].G</div><div class="line">                                                                * system_parameters::current_time_interval</div><div class="line">                                                                / local_viscosity));</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k) {</div><div class="line">                        phi_grads_u[k] = fe_values[velocities].symmetric_gradient(k,</div><div class="line">                                        q);</div><div class="line">                        div_phi_u[k] = (fe_values[velocities].divergence(k, q));</div><div class="line">                        phi_u[k] = (fe_values[velocities].value(k, q));</div><div class="line">                        <span class="keywordflow">if</span> (system_parameters::cylindrical == <span class="keyword">true</span>) {</div><div class="line">                                div_phi_u[k] *= (r_value);</div><div class="line">                                div_phi_u[k] += (phi_u[k][0]);</div><div class="line">                        }</div><div class="line">                        phi_p[k] = fe_values[pressure].value(k, q);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) {</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j) {</div><div class="line">                                <span class="keywordflow">if</span> (system_parameters::cylindrical == <span class="keyword">true</span>) {</div><div class="line">                                        local_matrix(i, j) += (phi_grads_u[i]</div><div class="line">                                                        * phi_grads_u[j] * 2 * local_eta_ve</div><div class="line">                                                        * r_value</div><div class="line">                                                        + 2 * phi_u[i][0] * phi_u[j][0]</div><div class="line">                                                                        * local_eta_ve / r_value</div><div class="line">                                                        - div_phi_u[i] * phi_p[j]</div><div class="line">                                                                        * system_parameters::pressure_scale</div><div class="line">                                                        - phi_p[i] * div_phi_u[j]</div><div class="line">                                                                        * system_parameters::pressure_scale</div><div class="line">                                                        + phi_p[i] * phi_p[j] * r_value</div><div class="line">                                                                        * system_parameters::pressure_scale)</div><div class="line">                                                        * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                                } <span class="keywordflow">else</span> {</div><div class="line">                                        local_matrix(i, j) += (phi_grads_u[i]</div><div class="line">                                                        * phi_grads_u[j] * 2 * local_eta_ve</div><div class="line">                                                        - div_phi_u[i] * phi_p[j]</div><div class="line">                                                                        * system_parameters::pressure_scale</div><div class="line">                                                        - phi_p[i] * div_phi_u[j]</div><div class="line">                                                                        * system_parameters::pressure_scale</div><div class="line">                                                        + phi_p[i] * phi_p[j]) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">                        <span class="keywordflow">if</span> (system_parameters::cylindrical == <span class="keyword">true</span>) {</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                                                fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                                local_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)</div><div class="line">                                                * rhs_values[q](component_i) * r_value</div><div class="line">                                                * local_density</div><div class="line">                                                - local_chi_ve * phi_grads_u[i] * old_stress</div><div class="line">                                                                * r_value</div><div class="line">                                                - local_chi_ve * phi_u[i][0]</div><div class="line">                                                                * local_old_phiphi_stress)</div><div class="line">                                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                        } <span class="keywordflow">else</span> {</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                                                fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                                local_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)</div><div class="line">                                                * rhs_values[q](component_i) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q)</div><div class="line">                                                * local_density;</div><div class="line">                        }</div><div class="line">                }</div><div class="line">        }</div><div class="line">} <span class="comment">// end of non-singular</span></div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs = 0;</div></div><!-- fragment --><p>===== outputs the local gravity</p>
<div class="fragment"><div class="line">        std::vector&lt;Point&lt;dim&gt; &gt; quad_points_list(n_q_points);</div><div class="line">        quad_points_list = fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q) {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;old_stress =</div><div class="line">                                local_quadrature_points_history[q].old_stress;</div><div class="line">                <span class="keywordtype">double</span> &amp;local_old_phiphi_stress =</div><div class="line">                                local_quadrature_points_history[q].old_phiphi_stress;</div><div class="line">                <span class="keywordtype">double</span> r_value = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q)[0];</div><div class="line">                <span class="keywordtype">double</span> z_value = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q)[1];</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> local_density = system_parameters::rho[m_id];</div></div><!-- fragment --><p>defines local viscosities</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> local_viscosity = 0;</div><div class="line"><span class="keywordflow">if</span> (plastic_iteration == 0)</div><div class="line">{</div><div class="line">        local_viscosity = local_quadrature_points_history[q].first_eta;</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">        local_viscosity = local_quadrature_points_history[q].new_eta;</div></div><!-- fragment --><p>Define the local viscoelastic constants</p>
<div class="fragment"><div class="line">                                <span class="keywordtype">double</span> local_eta_ve = 2</div><div class="line">                                                / ((1 / local_viscosity)</div><div class="line">                                                                + (1 / local_quadrature_points_history[q].G</div><div class="line">                                                                                / system_parameters::current_time_interval));</div><div class="line">                                <span class="keywordtype">double</span> local_chi_ve = 1</div><div class="line">                                                / (1</div><div class="line">                                                                + (local_quadrature_points_history[q].G</div><div class="line">                                                                                * system_parameters::current_time_interval</div><div class="line">                                                                                / local_viscosity));</div><div class="line"></div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k) {</div><div class="line">                                        phi_grads_u[k] = fe_values[velocities].symmetric_gradient(k,</div><div class="line">                                                        q);</div><div class="line">                                        div_phi_u[k] = (fe_values[velocities].divergence(k, q));</div><div class="line">                                        phi_u[k] = (fe_values[velocities].value(k, q));</div><div class="line">                                        <span class="keywordflow">if</span> (system_parameters::cylindrical == <span class="keyword">true</span>) {</div><div class="line">                                                div_phi_u[k] *= (r_value);</div><div class="line">                                                div_phi_u[k] += (phi_u[k][0]);</div><div class="line">                                        }</div><div class="line">                                        phi_p[k] = fe_values[pressure].value(k, q);</div><div class="line">                                }</div><div class="line"></div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) {</div><div class="line">                                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j) {</div><div class="line">                                                <span class="keywordflow">if</span> (system_parameters::cylindrical == <span class="keyword">true</span>) {</div><div class="line">                                                        local_matrix(i, j) += (phi_grads_u[i]</div><div class="line">                                                                        * phi_grads_u[j] * 2 * local_eta_ve</div><div class="line">                                                                        * r_value</div><div class="line">                                                                        + 2 * phi_u[i][0] * phi_u[j][0]</div><div class="line">                                                                                        * local_eta_ve / r_value</div><div class="line">                                                                        - div_phi_u[i] * phi_p[j]</div><div class="line">                                                                                        * system_parameters::pressure_scale</div><div class="line">                                                                        - phi_p[i] * div_phi_u[j]</div><div class="line">                                                                                        * system_parameters::pressure_scale</div><div class="line">                                                                        + phi_p[i] * phi_p[j] * r_value</div><div class="line">                                                                                        * system_parameters::pressure_scale)</div><div class="line">                                                                        * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                                                } <span class="keywordflow">else</span> {</div><div class="line">                                                        local_matrix(i, j) += (phi_grads_u[i]</div><div class="line">                                                                        * phi_grads_u[j] * 2 * local_eta_ve</div><div class="line">                                                                        - div_phi_u[i] * phi_p[j]</div><div class="line">                                                                                        * system_parameters::pressure_scale</div><div class="line">                                                                        - phi_p[i] * div_phi_u[j]</div><div class="line">                                                                                        * system_parameters::pressure_scale</div><div class="line">                                                                        + phi_p[i] * phi_p[j]) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                                                }</div><div class="line">                                        }</div><div class="line">                                        <span class="keywordflow">if</span> (system_parameters::cylindrical == <span class="keyword">true</span>) {</div><div class="line">                                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                                                                fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                                                local_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)</div><div class="line">                                                                * rhs_values[q](component_i) * r_value</div><div class="line">                                                                * local_density</div><div class="line">                                                                - local_chi_ve * phi_grads_u[i] * old_stress</div><div class="line">                                                                                * r_value</div><div class="line">                                                                - local_chi_ve * phi_u[i][0]</div><div class="line">                                                                                * local_old_phiphi_stress)</div><div class="line">                                                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                                        } <span class="keywordflow">else</span> {</div><div class="line">                                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                                                                fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                                                local_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)</div><div class="line">                                                                * rhs_values[q](component_i) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q)</div><div class="line">                                                                * local_density;</div><div class="line">                                        }</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">                } <span class="comment">// end of singular</span></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">                                local_matrix(i, j) = local_matrix(j, i);</div><div class="line"></div><div class="line">                cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">                constraints.distribute_local_to_global(local_matrix, local_rhs,</div><div class="line">                                local_dof_indices, system_matrix, system_rhs);</div><div class="line">        }</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Computing preconditioner...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line"></div><div class="line">        A_preconditioner = std_cxx1x::shared_ptr&lt;</div><div class="line">                        <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt;(</div><div class="line">                        <span class="keyword">new</span> <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type());</div><div class="line">        A_preconditioner-&gt;<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(system_matrix.block(0, 0),</div><div class="line">                        <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type::AdditionalData());</div><div class="line"></div><div class="line">        <span class="keyword">delete</span> aGrav;</div><div class="line">}</div></div><!-- fragment --><p>====================== SOLVER ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solve() {</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                        <span class="keyword">typename</span> InnerPreconditioner&lt;dim&gt;::type&gt; A_inverse(</div><div class="line">                        system_matrix.block(0, 0), *A_preconditioner);</div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(solution.block(0).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line"></div><div class="line">        {</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs(solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line">                A_inverse.vmult(tmp, system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">                system_matrix.block(1, 0).vmult(schur_rhs, tmp);</div><div class="line">                schur_rhs -= system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1);</div><div class="line"></div><div class="line">                SchurComplement&lt;typename InnerPreconditioner&lt;dim&gt;::type&gt; <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(</div><div class="line">                                system_matrix, A_inverse);</div><div class="line"></div><div class="line">                <span class="keywordtype">int</span> n_iterations = system_parameters::iteration_coefficient</div><div class="line">                                * solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>();</div><div class="line">                <span class="keywordtype">double</span> tolerance_goal = system_parameters::tolerance_coefficient</div><div class="line">                                * schur_rhs.l2_norm();</div><div class="line"></div><div class="line">                <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(n_iterations, tolerance_goal);</div><div class="line">                <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;\nMax iterations and tolerance are:  &quot;</span> &lt;&lt; n_iterations</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; and &quot;</span> &lt;&lt; tolerance_goal &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> preconditioner;</div><div class="line">                preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(system_matrix.block(1, 1),</div><div class="line">                                <a class="code" href="classSparseILU.html#a17b8686142d5fdbab572f75a9e3e42c2">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">                InverseMatrix&lt;SparseMatrix&lt;double&gt;, <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> &gt; m_inverse(</div><div class="line">                                system_matrix.block(1, 1), preconditioner);</div><div class="line"></div><div class="line">                cg.solve(<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs, m_inverse);</div><div class="line"></div><div class="line">                constraints.distribute(solution);</div><div class="line"></div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; outer CG Schur complement iterations for pressure&quot;</span></div><div class="line">                                &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        {</div><div class="line">                system_matrix.block(0, 1).<a class="code" href="classSparseILU.html#aa16a8a95ca9429c04a4af95d57078f74">vmult</a>(tmp, solution.block(1));</div><div class="line">                tmp *= -1;</div><div class="line">                tmp += system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0);</div><div class="line"></div><div class="line">                A_inverse.vmult(solution.block(0), tmp);</div><div class="line">                constraints.distribute(solution);</div><div class="line">                solution.block(1) *= (system_parameters::pressure_scale);</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>====================== OUTPUT RESULTS ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::output_results()<span class="keyword"> const </span>{</div><div class="line">        std::vector &lt; std::string &gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">        solution_names.push_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">        std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt; data_component_interpretation(</div><div class="line">                        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">        data_component_interpretation.push_back(</div><div class="line">                        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">        <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">        data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler);</div><div class="line">        data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution, solution_names,</div><div class="line">                        <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>, data_component_interpretation);</div><div class="line">        data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>();</div><div class="line"></div><div class="line">        std::ostringstream filename;</div><div class="line">        <span class="keywordflow">if</span> (system_parameters::present_timestep &lt; system_parameters::initial_elastic_iterations)</div><div class="line">        {</div><div class="line">                filename &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/time&quot;</span></div><div class="line">                                                &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(system_parameters::present_timestep, 2)</div><div class="line">                                                &lt;&lt; <span class="stringliteral">&quot;_elastic_displacements&quot;</span> &lt;&lt; <span class="stringliteral">&quot;.txt&quot;</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">                filename &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/time&quot;</span></div><div class="line">                                &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(system_parameters::present_timestep, 2)</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;_flow&quot;</span> &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(plastic_iteration, 2) &lt;&lt; <span class="stringliteral">&quot;.txt&quot;</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        std::ofstream output(filename.str().c_str());</div><div class="line">        data_out.<a class="code" href="classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f">write_gnuplot</a>(output);</div><div class="line">}</div></div><!-- fragment --><p>====================== FIND AND WRITE TO FILE THE STRESS TENSOR; IMPLEMENT PLASTICITY ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::solution_stesses() {</div></div><!-- fragment --><p>note most of this section only works with dim=2</p>
<p>name the output text files</p>
<div class="fragment"><div class="line">std::ostringstream stress_output;</div><div class="line">stress_output &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/time&quot;</span></div><div class="line">                &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(system_parameters::present_timestep, 2)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;_principalstresses&quot;</span> &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(plastic_iteration, 2)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;.txt&quot;</span>;</div><div class="line">std::ofstream fout_snew(stress_output.str().c_str());</div><div class="line">fout_snew.close();</div><div class="line"></div><div class="line">std::ostringstream stresstensor_output;</div><div class="line">stresstensor_output &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/time&quot;</span></div><div class="line">                &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(system_parameters::present_timestep, 2)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;_stresstensor&quot;</span> &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(plastic_iteration, 2)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;.txt&quot;</span>;</div><div class="line">std::ofstream fout_sfull(stresstensor_output.str().c_str());</div><div class="line">fout_sfull.close();</div><div class="line"></div><div class="line">std::ostringstream failed_cells_output;</div><div class="line">failed_cells_output &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/time&quot;</span></div><div class="line">                &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(system_parameters::present_timestep, 2)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;_failurelocations&quot;</span> &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(plastic_iteration, 2)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;.txt&quot;</span>;</div><div class="line">std::ofstream fout_failed_cells(failed_cells_output.str().c_str());</div><div class="line">fout_failed_cells.close();</div><div class="line"></div><div class="line">std::ostringstream plastic_eta_output;</div><div class="line">plastic_eta_output &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/time&quot;</span></div><div class="line">                &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(system_parameters::present_timestep, 2)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;_viscositiesreg&quot;</span> &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(plastic_iteration, 2)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;.txt&quot;</span>;</div><div class="line">std::ofstream fout_vrnew(plastic_eta_output.str().c_str());</div><div class="line">fout_vrnew.close();</div><div class="line"></div><div class="line">std::ostringstream initial_eta_output;</div><div class="line"><span class="keywordflow">if</span> (plastic_iteration == 0)</div><div class="line">{</div><div class="line">        initial_eta_output &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/time&quot;</span></div><div class="line">                &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(system_parameters::present_timestep, 2)</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;_baseviscosities.txt&quot;</span>;</div><div class="line">        std::ofstream fout_baseeta(initial_eta_output.str().c_str());</div><div class="line">        fout_baseeta.close();</div><div class="line">}</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Running stress calculations for plasticity iteration &quot;</span></div><div class="line">                &lt;&lt; plastic_iteration &lt;&lt; <span class="stringliteral">&quot;...\n&quot;</span>;</div></div><!-- fragment --><p>This makes the set of points at which the stress tensor is calculated</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;dim&gt; &gt; points_list(0);</div><div class="line">std::vector&lt;unsigned int&gt; material_list(0);</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div></div><!-- fragment --><p>This loop gets the gradients of the velocity field and saves it in the tensor_gradient_? objects DIM</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell) {</div><div class="line">        points_list.push_back(cell-&gt;center());</div><div class="line">        material_list.push_back(cell-&gt;material_id());</div><div class="line">}</div></div><!-- fragment --><p>Make the <a class="el" href="classFEValues.html">FEValues</a> object to evaluate values and derivatives at quadrature points</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula,</div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>Make the object that will hold the velocities and velocity gradients at the quadrature points</p>
<div class="fragment"><div class="line">std::vector &lt; std::vector&lt;Tensor&lt;1, dim&gt; &gt;&gt; velocity_grads(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(),</div><div class="line">                std::vector &lt; Tensor&lt;1, dim&gt; &gt; (dim + 1));</div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; velocities(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(),</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div></div><!-- fragment --><p>Make the object to find rheology</p>
<div class="fragment"><div class="line">Rheology&lt;dim&gt; rheology;</div></div><!-- fragment --><p>Write the solution flow velocity and derivative for each cell</p>
<div class="fragment"><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; vector_values(0);</div><div class="line">std::vector &lt; std::vector&lt;Tensor&lt;1, dim&gt; &gt; &gt; gradient_values(0);</div><div class="line">std::vector&lt;bool&gt; failing_cells;</div></div><!-- fragment --><p>Write the stresses from the previous step into vectors</p>
<div class="fragment"><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_stress;</div><div class="line">std::vector&lt;double&gt; old_phiphi_stress;</div><div class="line">std::vector&lt;double&gt; cell_Gs;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(); cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">{</div></div><!-- fragment --><p>Makes pointer to data in quadrature_point_history</p>
<div class="fragment"><div class="line">PointHistory&lt;dim&gt; *local_quadrature_points_history =</div><div class="line">                <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"></div><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">get_function_gradients</a>(solution, velocity_grads);</div><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, velocities);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> current_cell_velocity(dim+1);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; current_cell_grads(dim+1);</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> current_cell_old_stress;</div><div class="line">current_cell_old_stress = 0;</div><div class="line"><span class="keywordtype">double</span> current_cell_old_phiphi_stress = 0;</div><div class="line"><span class="keywordtype">double</span> cell_area = 0;</div></div><!-- fragment --><p>Averages across each cell to find mean velocities, gradients, and old stresses</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">{</div><div class="line">        cell_area += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        velocities[q] *= fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        current_cell_velocity += velocities[q];</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (dim+1); i++)</div><div class="line">        {</div><div class="line">                velocity_grads[q][i] *= fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                current_cell_grads[i] += velocity_grads[q][i];</div><div class="line">        }</div><div class="line">        current_cell_old_stress += local_quadrature_points_history[q].old_stress * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        current_cell_old_phiphi_stress += local_quadrature_points_history[q].old_phiphi_stress * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">}</div><div class="line">current_cell_velocity /= cell_area;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (dim+1); i++)</div><div class="line">        current_cell_grads[i] /= cell_area;</div><div class="line">current_cell_old_stress /= cell_area;</div><div class="line">current_cell_old_phiphi_stress /= cell_area;</div><div class="line"></div><div class="line">vector_values.push_back(current_cell_velocity);</div><div class="line">gradient_values.push_back(current_cell_grads);</div><div class="line">old_stress.push_back(current_cell_old_stress);</div><div class="line">old_phiphi_stress.push_back(current_cell_old_phiphi_stress);</div></div><!-- fragment --><p>Get cell shear modulus: assumes it's constant for the cell</p>
<div class="fragment"><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mat_id = cell-&gt;material_id();</div><div class="line">        <span class="keywordtype">double</span> local_G = rheology.get_G(mat_id);</div><div class="line">        cell_Gs.push_back(local_G);</div><div class="line">}</div></div><!-- fragment --><p>tracks where failure occurred</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; reduction_factor;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_fails = 0;</div><div class="line"><span class="keywordflow">if</span> (plastic_iteration == 0)</div><div class="line">        cell_viscosities.resize(0);</div></div><!-- fragment --><p>loop across all the cells to find and adjust eta of failing cells</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>(); i++)</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> current_cell_viscosity = 0;</div></div><!-- fragment --><p>Fill viscosities vector, analytically if plastic_iteration == 0 and from previous viscosities for later iteration</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (plastic_iteration == 0)</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> local_viscosity;</div><div class="line">    local_viscosity = rheology.get_eta(points_list[i][0], points_list[i][1]);</div><div class="line">        current_cell_viscosity = local_viscosity;</div><div class="line">        cell_viscosities.push_back(current_cell_viscosity);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">        current_cell_viscosity = cell_viscosities[i];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> cell_eta_ve = 2</div><div class="line">                / ((1 / current_cell_viscosity)</div><div class="line">                                + (1 / cell_Gs[i]</div><div class="line">                                                / system_parameters::current_time_interval));</div><div class="line"><span class="keywordtype">double</span> cell_chi_ve = 1</div><div class="line">                / (1</div><div class="line">                                + (cell_Gs[i]</div><div class="line">                                                * system_parameters::current_time_interval</div><div class="line">                                                / current_cell_viscosity));</div></div><!-- fragment --><p>find local pressure</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> cell_p = vector_values[i].operator()(2);</div></div><!-- fragment --><p>find stresses tensor makes non-diagonalized local matrix A</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sigma13 = 0.5</div><div class="line">                * (gradient_values[i][0][1] + gradient_values[i][1][0]);</div><div class="line">mat A;</div><div class="line">A &lt;&lt; gradient_values[i][0][0] &lt;&lt; 0 &lt;&lt; sigma13 &lt;&lt; endr</div><div class="line">  &lt;&lt; 0 &lt;&lt; vector_values[i].operator()(0) / points_list[i].<span class="keyword">operator</span>()(0)&lt;&lt; 0 &lt;&lt; endr</div><div class="line">  &lt;&lt; sigma13 &lt;&lt; 0 &lt;&lt; gradient_values[i][1][1] &lt;&lt; endr;</div><div class="line">mat olddevstress;</div><div class="line">olddevstress &lt;&lt; old_stress[i][0][0] &lt;&lt; 0 &lt;&lt; old_stress[i][0][1] &lt;&lt; endr</div><div class="line">                         &lt;&lt; 0 &lt;&lt; old_phiphi_stress[i] &lt;&lt; 0 &lt;&lt; endr</div><div class="line">                         &lt;&lt; old_stress[i][0][1] &lt;&lt; 0 &lt;&lt; old_stress[i][1][1] &lt;&lt; endr;</div><div class="line">vec P;</div><div class="line">P &lt;&lt; cell_p &lt;&lt; cell_p &lt;&lt; cell_p;</div><div class="line">mat Pmat = diagmat(P);</div><div class="line">mat B;</div><div class="line">B = (cell_eta_ve * A + cell_chi_ve * olddevstress) - Pmat;</div></div><!-- fragment --><p>finds principal stresses</p>
<div class="fragment"><div class="line">vec eigval;</div><div class="line">mat eigvec;</div><div class="line">eig_sym(eigval, eigvec, B);</div><div class="line"><span class="keywordtype">double</span> sigma1 = -<a class="code" href="classVectorizedArray.html#ab345d9068414034226b038afde315a37">min</a>(eigval);</div><div class="line"><span class="keywordtype">double</span> sigma3 = -<a class="code" href="classVectorizedArray.html#a4a85a2d940158066e2de933cb6587889">max</a>(eigval);</div></div><!-- fragment --><p>Writes text files for principal stresses, full stress tensor, base viscosities</p>
<div class="fragment"><div class="line">std::ofstream fout_snew(stress_output.str().c_str(), std::ios::app);</div><div class="line">fout_snew &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sigma1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sigma3 &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">fout_snew.close();</div><div class="line"></div><div class="line">std::ofstream fout_sfull(stresstensor_output.str().c_str(), std::ios::app);</div><div class="line">fout_sfull &lt;&lt; A(0,0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; A(1,1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; A(2,2) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; A(0,2) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">fout_sfull.close();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (plastic_iteration == 0)</div><div class="line">{</div><div class="line">        std::ofstream fout_baseeta(initial_eta_output.str().c_str(), std::ios::app);</div><div class="line">        fout_baseeta &lt;&lt; points_list[i]&lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; current_cell_viscosity &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        fout_baseeta.close();</div><div class="line">}</div></div><!-- fragment --><p>Finds adjusted effective viscosity</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> cell_effective_viscosity = 0;</div><div class="line"><span class="keywordflow">if</span> (system_parameters::plasticity_on)</div><div class="line">{</div><div class="line">        <span class="keywordflow">if</span>(system_parameters::failure_criterion == 0) <span class="comment">//Apply Byerlee&#39;s rule</span></div><div class="line">        {</div><div class="line">                <span class="keywordflow">if</span> (sigma1 &gt;= 5 * sigma3) <span class="comment">// this guarantees that viscosities only go down, never up</span></div><div class="line">                        {</div><div class="line">                        failing_cells.push_back(<span class="keyword">true</span>);</div><div class="line">                        <span class="keywordtype">double</span> temp_reductionfactor = 1;</div><div class="line">                        <span class="keywordflow">if</span> (sigma3 &lt; 0)</div><div class="line">                                temp_reductionfactor = 100;</div><div class="line">                        <span class="keywordflow">else</span></div><div class="line">                                temp_reductionfactor = 1.9 * sigma1 / 5 / sigma3;</div><div class="line"></div><div class="line">                        reduction_factor.push_back(temp_reductionfactor);</div><div class="line">                        total_fails++;</div></div><!-- fragment --><p>Text file of all failure locations</p>
<div class="fragment"><div class="line">                std::ofstream fout_failed_cells(failed_cells_output.str().c_str(), std::ios::app);</div><div class="line">                fout_failed_cells &lt;&lt; points_list[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                fout_failed_cells.close();</div><div class="line">                }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">                reduction_factor.push_back(1);</div><div class="line">                failing_cells.push_back(<span class="keyword">false</span>);</div><div class="line">        }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">        <span class="keywordflow">if</span>(system_parameters::failure_criterion == 1) <span class="comment">//Apply Schultz criterion for frozen sand, RMR=45</span></div><div class="line">        {</div><div class="line">                <span class="keywordtype">double</span> temp_reductionfactor = 1;</div><div class="line">                <span class="keywordflow">if</span>(sigma3 &lt; -114037)</div><div class="line">                {</div></div><!-- fragment --><p>std::cout &lt;&lt; " ext ";</p>
<div class="fragment"><div class="line">failing_cells.push_back(<span class="keyword">true</span>);</div><div class="line">temp_reductionfactor = 10;</div><div class="line">reduction_factor.push_back(temp_reductionfactor);</div><div class="line">total_fails++;</div></div><!-- fragment --><p>Text file of all failure locations</p>
<div class="fragment"><div class="line">        std::ofstream fout_failed_cells(failed_cells_output.str().c_str(), std::ios::app);</div><div class="line">        fout_failed_cells &lt;&lt; points_list[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        fout_failed_cells.close();</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> sigma_c = 160e6; <span class="comment">//Unconfined compressive strength</span></div><div class="line">        <span class="keywordtype">double</span> yield_sigma1 = sigma3 + std::sqrt( (3.086 * sigma_c * sigma3) + (0.002 * sigma3 * sigma3) );</div><div class="line">        <span class="keywordflow">if</span> (sigma1 &gt;= yield_sigma1)</div><div class="line">        {</div></div><!-- fragment --><p>std::cout &lt;&lt; " comp ";</p>
<div class="fragment"><div class="line">failing_cells.push_back(<span class="keyword">true</span>);</div><div class="line">temp_reductionfactor = 1.0 * sigma1 / 5 / sigma3;</div><div class="line"></div><div class="line">reduction_factor.push_back(temp_reductionfactor);</div><div class="line">total_fails++;</div></div><!-- fragment --><p>Text file of all failure locations</p>
<div class="fragment"><div class="line">                                                std::ofstream fout_failed_cells(failed_cells_output.str().c_str(), std::ios::app);</div><div class="line">                                                fout_failed_cells &lt;&lt; points_list[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                                                fout_failed_cells.close();</div><div class="line">                                        }</div><div class="line">                                        <span class="keywordflow">else</span></div><div class="line">                                        {</div><div class="line">                                                reduction_factor.push_back(1);</div><div class="line">                                                failing_cells.push_back(<span class="keyword">false</span>);</div><div class="line">                                        }</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">                        <span class="keywordflow">else</span></div><div class="line">                        {</div><div class="line">                                std::cout &lt;&lt; <span class="stringliteral">&quot;Specified failure criterion not found\n&quot;</span>;</div><div class="line">                        }</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">                reduction_factor.push_back(1);</div><div class="line">}</div></div><!-- fragment --><p>If there are enough failed cells, update eta at all quadrature points and perform smoothing</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of failing cells: &quot;</span> &lt;&lt; total_fails &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><span class="keywordtype">double</span> last_max_plasticity_double = last_max_plasticity;</div><div class="line"><span class="keywordtype">double</span> total_fails_double = total_fails;</div><div class="line"><span class="keywordtype">double</span> decrease_in_plasticity = ((last_max_plasticity_double - total_fails_double) / last_max_plasticity_double);</div><div class="line"><span class="keywordflow">if</span>(plastic_iteration == 0)</div><div class="line">        decrease_in_plasticity = 1;</div><div class="line">last_max_plasticity = total_fails;</div><div class="line"><span class="keywordflow">if</span> (total_fails &lt;= 100 || decrease_in_plasticity &lt;= 0.2)</div><div class="line">{</div><div class="line">        system_parameters::continue_plastic_iterations = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>(); j++)</div><div class="line">        {</div></div><!-- fragment --><p>Writes to file the undisturbed cell viscosities</p>
<div class="fragment"><div class="line">                std::ofstream fout_vrnew(plastic_eta_output.str().c_str(), std::ios::app);</div><div class="line">                fout_vrnew &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; cell_viscosities[j] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                fout_vrnew.close();</div><div class="line">        }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span>{</div><div class="line">        quad_viscosities.resize(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>Decrease the eta at quadrature points in failing cells</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(); cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">{</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div></div><!-- fragment --><p>Make local_quadrature_points_history pointer to the cell data</p>
<div class="fragment"><div class="line">PointHistory&lt;dim&gt; *local_quadrature_points_history =</div><div class="line">                <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">                local_quadrature_points_history &gt;= &amp;quadrature_point_history.front(),</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">                local_quadrature_points_history &lt; &amp;quadrature_point_history.back(),</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">quad_viscosities[cell_no].resize(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">{</div><div class="line">        <span class="keywordflow">if</span> (plastic_iteration == 0)</div><div class="line">                local_quadrature_points_history[q].new_eta = local_quadrature_points_history[q].first_eta;</div><div class="line">        local_quadrature_points_history[q].new_eta /= reduction_factor[cell_no];</div></div><!-- fragment --><p>Prevents viscosities from dropping below the floor necessary for numerical stability</p>
<div class="fragment"><div class="line">                <span class="keywordflow">if</span> (local_quadrature_points_history[q].new_eta &lt; system_parameters::eta_floor)</div><div class="line">                        local_quadrature_points_history[q].new_eta = system_parameters::eta_floor;</div><div class="line"></div><div class="line">                quad_viscosities[cell_no][q].reinit(dim+1);</div><div class="line">                <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=0; ii&lt;dim; ii++)</div><div class="line">                        quad_viscosities[cell_no][q](ii) = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q)[ii];</div><div class="line">                quad_viscosities[cell_no][q](dim) = local_quadrature_points_history[q].new_eta;</div><div class="line">        }</div><div class="line">        cell_no++;</div><div class="line">}</div><div class="line">smooth_eta_field(failing_cells);</div></div><!-- fragment --><p>Writes to file the smoothed eta field (which is defined at each quadrature point) for each cell</p>
<div class="fragment"><div class="line">cell_no = 0;</div></div><!-- fragment --><p>cell_viscosities.resize(triangulation.n_active_cells(), 0);</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(); cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">{</div><div class="line">        <span class="keywordflow">if</span>(failing_cells[cell_no])</div><div class="line">        {</div><div class="line">                fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div></div><!-- fragment --><p>Averages across each cell to find mean eta</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> cell_area = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">{</div><div class="line">        cell_area += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        cell_viscosities[cell_no] += quad_viscosities[cell_no][q][dim] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">}</div><div class="line">cell_viscosities[cell_no] /= cell_area;</div></div><!-- fragment --><p>Writes to file</p>
<div class="fragment"><div class="line">                                std::ofstream fout_vrnew(plastic_eta_output.str().c_str(), std::ios::app);</div><div class="line">                                fout_vrnew &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; cell_viscosities[cell_no] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                                fout_vrnew.close();</div><div class="line">                        }</div><div class="line">                        <span class="keywordflow">else</span></div><div class="line">                        {</div><div class="line">                                std::ofstream fout_vrnew(plastic_eta_output.str().c_str(), std::ios::app);</div><div class="line">                                fout_vrnew &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; cell_viscosities[cell_no] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                                fout_vrnew.close();</div><div class="line">                        }</div><div class="line">                        cell_no++;</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>====================== SMOOTHES THE VISCOSITY FIELD AT ALL QUADRATURE POINTS ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::smooth_eta_field(std::vector&lt;bool&gt; failing_cells)</div><div class="line">{</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Smoothing viscosity field...\n&quot;</span>;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(); cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">        {</div><div class="line">                <span class="keywordflow">if</span>(failing_cells[cell_no])</div><div class="line">                {</div><div class="line">                        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">                        PointHistory&lt;dim&gt; *local_quadrature_points_history =</div><div class="line">                                        <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div></div><!-- fragment --><p>Currently this algorithm does not permit refinement. To permit refinement, daughter cells of neighbors must be identified Find pointers and indices of all cells within certain radius</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> find_more_cells = <span class="keyword">true</span>;</div><div class="line">std::vector&lt;bool&gt; cell_touched(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>(), <span class="keyword">false</span>);</div><div class="line">std::vector&lt; TriaIterator&lt; CellAccessor&lt;dim&gt; &gt; &gt; neighbor_cells;</div><div class="line">std::vector&lt;int&gt; neighbor_indices;</div><div class="line"><span class="keywordtype">int</span> start_cell = 0; <span class="comment">// Which cell in the neighbor_cells vector to start from</span></div><div class="line"><span class="keywordtype">int</span> new_cells_found = 0;</div><div class="line">neighbor_cells.push_back(cell);</div><div class="line">neighbor_indices.push_back(cell_no);</div><div class="line">cell_touched[cell_no] = <span class="keyword">true</span>;</div><div class="line"><span class="keywordflow">while</span>(find_more_cells)</div><div class="line">{</div><div class="line">        new_cells_found = 0;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = start_cell; i&lt;neighbor_cells.size(); i++)</div><div class="line">        {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">                {</div><div class="line">                        <span class="keywordflow">if</span> (!neighbor_cells[i]-&gt;face(f)-&gt;at_boundary())</div><div class="line">                        {</div><div class="line">                                <span class="keywordtype">int</span> test_cell_no = neighbor_cells[i]-&gt;neighbor_index(f);</div><div class="line">                                <span class="keywordflow">if</span>(!cell_touched[test_cell_no])</div><div class="line">                                        <span class="keywordflow">if</span>(cell-&gt;center().distance(neighbor_cells[i]-&gt;neighbor(f)-&gt;center()) &lt; 2 * system_parameters::smoothing_radius)</div><div class="line">                                        {</div></div><!-- fragment --><p>What to do if another nearby cell is found that hasn't been found before</p>
<div class="fragment"><div class="line">                                                neighbor_cells.push_back(neighbor_cells[i]-&gt;neighbor(f));</div><div class="line">                                                neighbor_indices.push_back(test_cell_no);</div><div class="line">                                                cell_touched[test_cell_no] = <span class="keyword">true</span>;</div><div class="line">                                                start_cell++;</div><div class="line">                                                new_cells_found++;</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (new_cells_found == 0){</div><div class="line">                find_more_cells = <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">                start_cell = neighbor_cells.size() - new_cells_found;</div><div class="line">}</div><div class="line"></div><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div></div><!-- fragment --><p>Collect the viscosities at nearby quadrature points</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q)</div><div class="line">{</div><div class="line">        std::vector&lt;double&gt; nearby_etas_q;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;neighbor_indices.size(); i++)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); j++)</div><div class="line">                {</div><div class="line">                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> test_q;</div><div class="line">                        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; d++)</div><div class="line">                                test_q(d) = quad_viscosities[neighbor_indices[i]][j][d];</div><div class="line">                        <span class="keywordtype">double</span> qq_distance = fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q).<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(test_q);</div><div class="line">                        <span class="keywordflow">if</span>(qq_distance &lt; system_parameters::smoothing_radius)</div><div class="line">                                nearby_etas_q.push_back(quad_viscosities[neighbor_indices[i]][j][dim]);</div><div class="line">                }</div></div><!-- fragment --><p>Write smoothed viscosities to quadrature_points_history; simple boxcar function is the smoothing kernel</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mean_eta = 0;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;nearby_etas_q.size(); <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>++)</div><div class="line">{</div><div class="line">        mean_eta += nearby_etas_q[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>];</div><div class="line">}</div><div class="line">mean_eta /= nearby_etas_q.size();</div><div class="line">local_quadrature_points_history[q].new_eta = mean_eta;</div></div><!-- fragment --><p>std::cout &lt;&lt; local_quadrature_points_history[q].new_eta &lt;&lt; " ";</p>
<div class="fragment"><div class="line">                        }</div><div class="line">                }</div><div class="line">                cell_no++;</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>====================== SAVE STRESS TENSOR AT QUADRATURE POINTS ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::update_quadrature_point_history() {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Updating stress field...&quot;</span>;</div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe, quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div></div><!-- fragment --><p>Make the object that will hold the velocity gradients</p>
<div class="fragment"><div class="line">std::vector &lt; std::vector&lt;Tensor&lt;1, dim&gt; &gt;&gt; velocity_grads(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(),</div><div class="line">                std::vector &lt; Tensor&lt;1, dim&gt; &gt; (dim + 1));</div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; velocities(quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(),</div><div class="line">                <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(); cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell) {</div><div class="line">        PointHistory&lt;dim&gt; *local_quadrature_points_history =</div><div class="line">                        <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">                        local_quadrature_points_history &gt;= &amp;quadrature_point_history.front(),</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(</div><div class="line">                        local_quadrature_points_history &lt; &amp;quadrature_point_history.back(),</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">get_function_gradients</a>(solution, velocity_grads);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, velocities);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); ++q) {</div></div><!-- fragment --><p>Define the local viscoelastic constants</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> local_eta_ve = 2</div><div class="line">                / ((1 / local_quadrature_points_history[q].new_eta)</div><div class="line">                                + (1 / local_quadrature_points_history[q].G</div><div class="line">                                                / system_parameters::current_time_interval));</div><div class="line"><span class="keywordtype">double</span> local_chi_ve =</div><div class="line">                1</div><div class="line">                                / (1</div><div class="line">                                                + (local_quadrature_points_history[q].G</div><div class="line">                                                                * system_parameters::current_time_interval</div><div class="line">                                                                / local_quadrature_points_history[q].new_eta));</div></div><!-- fragment --><p>Compute new stress at each quadrature point</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> new_stress;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        new_stress[i][i] =</div><div class="line">                        local_eta_ve * velocity_grads[q][i][i]</div><div class="line">                                        + local_chi_ve</div><div class="line">                                                        * local_quadrature_points_history[q].old_stress[i][i];</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dim; ++j)</div><div class="line">                new_stress[i][j] =</div><div class="line">                                local_eta_ve</div><div class="line">                                                * (velocity_grads[q][i][j]</div><div class="line">                                                                + velocity_grads[q][j][i]) / 2</div><div class="line">                                                + local_chi_ve</div><div class="line">                                                                * local_quadrature_points_history[q].old_stress[i][j];</div></div><!-- fragment --><p>Rotate new stress</p>
<div class="fragment"><div class="line">AuxFunctions&lt;dim&gt; rotation_object;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> rotation = rotation_object.get_rotation_matrix(</div><div class="line">                velocity_grads[q]);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> rotated_new_stress = <a class="code" href="classSymmetricTensor.html#a4acdda923e9b04d2d70308f3c095e12f">symmetrize</a>(</div><div class="line">                <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(rotation)</div><div class="line">                                * <span class="keyword">static_cast&lt;</span><a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> <span class="keyword">&gt;</span>(new_stress)</div><div class="line">                                * rotation);</div><div class="line">local_quadrature_points_history[q].old_stress = rotated_new_stress;</div></div><!-- fragment --><p>For axisymmetric case, make the phi-phi element of stress tensor</p>
<div class="fragment"><div class="line">                        local_quadrature_points_history[q].old_phiphi_stress =</div><div class="line">                                        (2 * local_eta_ve * velocities[q](0)</div><div class="line">                                                        / fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q)[0]</div><div class="line">                                                        + local_chi_ve</div><div class="line">                                                                        * local_quadrature_points_history[q].old_phiphi_stress);</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>====================== REDEFINE THE TIME INTERVAL FOR THE VISCOUS STEPS ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::update_time_interval()</div><div class="line">{</div><div class="line">        <span class="keywordtype">double</span> move_goal_per_step = system_parameters::initial_disp_target;</div><div class="line">        <span class="keywordflow">if</span>(system_parameters::present_timestep &gt; system_parameters::initial_elastic_iterations)</div><div class="line">        {</div><div class="line">                move_goal_per_step = system_parameters::initial_disp_target -</div><div class="line">                        ((system_parameters::initial_disp_target - system_parameters::final_disp_target) /</div><div class="line">                        system_parameters::total_viscous_steps *</div><div class="line">                        (system_parameters::present_timestep - system_parameters::initial_elastic_iterations));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> zero_tolerance = 1e-3;</div><div class="line">        <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                                dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(); cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)<span class="comment">// loop over all cells</span></div><div class="line">        {</div><div class="line">                <span class="keywordflow">if</span>(cell-&gt;at_boundary())</div><div class="line">                {</div><div class="line">                        <span class="keywordtype">int</span> zero_faces = 0;</div><div class="line">                        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; f++)</div><div class="line">                                <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">                                        <span class="keywordflow">if</span> (fabs(cell-&gt;face(f)-&gt;center()[i]) &lt; zero_tolerance)</div><div class="line">                                                zero_faces++;</div><div class="line">                        <span class="keywordflow">if</span> (zero_faces==0)</div><div class="line">                        {</div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">                                {</div><div class="line">                                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_velocity;</div><div class="line">                                        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_position;</div><div class="line">                                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++d)</div><div class="line">                                        {</div><div class="line">                                                vertex_velocity[d] = solution(cell-&gt;vertex_dof_index(v, d));</div><div class="line">                                                vertex_position[d] = cell-&gt;vertex(v)[d];</div><div class="line">                                        }</div></div><!-- fragment --><p>velocity to be evaluated is the radial component of a surface vertex</p>
<div class="fragment"><div class="line">                                <span class="keywordtype">double</span> local_velocity = 0;</div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++d)</div><div class="line">                                {</div><div class="line">                                        local_velocity += vertex_velocity[d] * vertex_position [d];</div><div class="line">                                }</div><div class="line">                                local_velocity /= std::sqrt( vertex_position.square() );</div><div class="line">                                <span class="keywordflow">if</span>(local_velocity &lt; 0)</div><div class="line">                                        local_velocity *= -1;</div><div class="line">                                <span class="keywordflow">if</span>(local_velocity &gt; max_velocity)</div><div class="line">                                {</div><div class="line">                                        max_velocity = local_velocity;</div><div class="line">                                                                        }</div><div class="line">                        }</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>NOTE: It is possible for this time interval to be very different from that used in the viscoelasticity calculation.</p>
<div class="fragment"><div class="line">        system_parameters::current_time_interval = move_goal_per_step / max_velocity;</div><div class="line">        <span class="keywordtype">double</span> step_time_yr = system_parameters::current_time_interval / SECSINYEAR;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep interval changed to: &quot;</span></div><div class="line">                        &lt;&lt; step_time_yr</div><div class="line">                        &lt;&lt; <span class="stringliteral">&quot; years\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p>====================== MOVE MESH ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::move_mesh() {</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;   Moving mesh...\n&quot;</span>;</div><div class="line">        std::vector&lt;bool&gt; vertex_touched(triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(); cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">                        <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>) {</div><div class="line">                                vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++d)</div><div class="line">                                        vertex_displacement[d] = solution(</div><div class="line">                                                        cell-&gt;vertex_dof_index(v, d));</div><div class="line">                                cell-&gt;vertex(v) += vertex_displacement</div><div class="line">                                                * system_parameters::current_time_interval;</div><div class="line">                        }</div><div class="line">}</div></div><!-- fragment --><p>====================== WRITE MESH TO FILE ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::write_mesh()</div><div class="line">{</div></div><!-- fragment --><p>output mesh in ucd</p>
<div class="fragment"><div class="line">        std::ostringstream initial_mesh_file;</div><div class="line">        initial_mesh_file &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/time&quot;</span> &lt;&lt;</div><div class="line">    <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(system_parameters::present_timestep, 2) &lt;&lt;</div><div class="line">        <span class="stringliteral">&quot;_mesh.inp&quot;</span>;</div><div class="line">        std::ofstream out_ucd (initial_mesh_file.str().c_str());</div><div class="line">        <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">        grid_out.<a class="code" href="classGridOut.html#ac2644adf53415185e3886a1248911bd4">write_ucd</a> (triangulation, out_ucd);</div><div class="line">}</div></div><!-- fragment --><p>====================== FIT ELLIPSE TO SURFACE AND WRITE RADII TO FILE ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::do_ellipse_fits()</div><div class="line">{</div><div class="line">        std::ostringstream ellipses_filename;</div><div class="line">        ellipses_filename &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/ellipse_fits.txt&quot;</span>;</div></div><!-- fragment --><p>Find ellipsoidal axes for all layers</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; ellipse_axes(0);</div></div><!-- fragment --><p>compute fit to boundary 0, 1, 2 ...</p>
<div class="fragment"><div class="line">        std::cout &lt;&lt; endl;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;system_parameters::sizeof_material_id;i++)</div><div class="line">        {</div><div class="line">                ellipsoid.compute_fit(ellipse_axes, system_parameters::material_id[i]);</div><div class="line">                system_parameters::q_axes.push_back(ellipse_axes[0]);</div><div class="line">                system_parameters::p_axes.push_back(ellipse_axes[1]);</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;a_&quot;</span>&lt;&lt; system_parameters::material_id[i] &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt; ellipse_axes[0]</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <span class="stringliteral">&quot; c_&quot;</span>&lt;&lt; system_parameters::material_id[i] &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt; ellipse_axes[1] &lt;&lt; std::endl;</div><div class="line">                ellipse_axes.clear();</div><div class="line"></div><div class="line">                std::ofstream fout_ellipses(ellipses_filename.str().c_str(), std::ios::app);</div><div class="line">                fout_ellipses &lt;&lt; system_parameters::present_timestep &lt;&lt; <span class="stringliteral">&quot; a_&quot;</span>&lt;&lt; system_parameters::material_id[i] &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt; ellipse_axes[0]</div><div class="line">                                                &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <span class="stringliteral">&quot; c_&quot;</span>&lt;&lt; system_parameters::material_id[i] &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt; ellipse_axes[1] &lt;&lt; endl;</div><div class="line">                fout_ellipses.close();</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>====================== APPEND LINE TO PHYSICAL_TIMES.TXT FILE WITH STEP NUMBER, PHYSICAL TIME, AND # PLASTIC ITERATIONS ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::append_physical_times(<span class="keywordtype">int</span> max_plastic)</div><div class="line">{</div><div class="line">        std::ostringstream times_filename;</div><div class="line">        times_filename &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/physical_times.txt&quot;</span>;</div><div class="line">        std::ofstream fout_times(times_filename.str().c_str(), std::ios::app);</div><div class="line">        fout_times &lt;&lt; system_parameters::present_timestep &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">                                                                &lt;&lt; system_parameters::present_time/SECSINYEAR &lt;&lt; <span class="stringliteral">&quot; &quot;</span> </div><div class="line">                                                                        &lt;&lt; max_plastic &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div></div><!-- fragment --><p>&lt;&lt; system_parameters::q_axes[0] &lt;&lt; " " &lt;&lt; system_parameters::p_axes[0] &lt;&lt; " " &lt;&lt; system_parameters::q_axes[1] &lt;&lt; " " &lt;&lt; system_parameters::p_axes[1] &lt;&lt; "\n";</p>
<div class="fragment"><div class="line">        fout_times.close();</div><div class="line">}</div></div><!-- fragment --><p>====================== WRITE VERTICES TO FILE ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::write_vertices(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> boundary_that_we_need) {</div><div class="line">        std::ostringstream vertices_output;</div><div class="line">        vertices_output &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/time&quot;</span> &lt;&lt;</div><div class="line">                   <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(system_parameters::present_timestep, 2) &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt;</div><div class="line">                   <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(boundary_that_we_need, 2) &lt;&lt;</div><div class="line">                   <span class="stringliteral">&quot;_surface.txt&quot;</span>;</div><div class="line">        std::ofstream fout_final_vertices(vertices_output.str().c_str());</div><div class="line">        fout_final_vertices.close();</div><div class="line"></div><div class="line">        std::vector&lt;bool&gt; vertex_touched(triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (boundary_that_we_need == 0)</div><div class="line">        {</div></div><!-- fragment --><p>Figure out if the vertex is on the boundary of the domain</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">        {</div><div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> boundary_ids = cell-&gt;face(f)-&gt;boundary_indicator();</div><div class="line">                <span class="keywordflow">if</span>(boundary_ids == boundary_that_we_need)</div><div class="line">                        {</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;GeometryInfo&lt;dim&gt;::vertices_per_face; ++v)</div><div class="line">                                <span class="keywordflow">if</span> (vertex_touched[cell-&gt;face(f)-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">                                        {</div><div class="line">                                                vertex_touched[cell-&gt;face(f)-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line">                                                std::ofstream fout_final_vertices(vertices_output.str().c_str(), std::ios::app);</div><div class="line">                                                fout_final_vertices &lt;&lt; cell-&gt;face(f)-&gt;vertex(v) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                                                fout_final_vertices.close();</div><div class="line">                                        }</div><div class="line">                        }</div><div class="line">        }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{                </div></div><!-- fragment --><p>Figure out if the vertex is on an internal boundary</p>
<div class="fragment"><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                                triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">                        {</div><div class="line">                                <span class="keywordflow">if</span> (cell-&gt;neighbor(f) != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>()) {</div><div class="line">                                        <span class="keywordflow">if</span> (cell-&gt;material_id() != cell-&gt;neighbor(f)-&gt;material_id()) <span class="comment">//finds face is at internal boundary</span></div><div class="line">                                                        {</div><div class="line">                                                <span class="keywordtype">int</span> high_mat_id = std::max(cell-&gt;material_id(),</div><div class="line">                                                                cell-&gt;neighbor(f)-&gt;material_id());</div><div class="line">                                                <span class="keywordflow">if</span> (high_mat_id == boundary_that_we_need) <span class="comment">//finds faces at the correct internal boundary</span></div><div class="line">                                                                {</div><div class="line">                                                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0;</div><div class="line">                                                                        v &lt; GeometryInfo&lt;dim&gt;::vertices_per_face;</div><div class="line">                                                                        ++v)</div><div class="line">                                                                <span class="keywordflow">if</span> (vertex_touched[cell-&gt;face(f)-&gt;vertex_index(</div><div class="line">                                                                                v)] == <span class="keyword">false</span>) {</div><div class="line">                                                                        vertex_touched[cell-&gt;face(f)-&gt;vertex_index(</div><div class="line">                                                                                        v)] = <span class="keyword">true</span>;</div><div class="line">                                                                        std::ofstream fout_final_vertices(vertices_output.str().c_str(), std::ios::app);</div><div class="line">                                                                        fout_final_vertices &lt;&lt; cell-&gt;face(f)-&gt;vertex(v) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                                                                        fout_final_vertices.close();</div><div class="line">                                                                }</div><div class="line">                                                }</div><div class="line">                                        }</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">                }</div><div class="line">}</div></div><!-- fragment --><p>====================== SETUP INITIAL MESH ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_initial_mesh() {</div><div class="line">        <a class="code" href="classGridIn.html">GridIn&lt;dim&gt;</a> grid_in;</div><div class="line">        grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(triangulation);</div><div class="line">        std::ifstream mesh_stream(system_parameters::mesh_filename,</div><div class="line">                        std::ifstream::in);</div><div class="line">        grid_in.<a class="code" href="classGridIn.html#abbb16aa0aa53bfa9231b69278d397616">read_ucd</a>(mesh_stream);</div></div><!-- fragment --><p>output initial mesh in eps</p>
<div class="fragment"><div class="line">std::ostringstream initial_mesh_file;</div><div class="line">initial_mesh_file &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/initial_mesh.eps&quot;</span>;</div><div class="line">std::ofstream out_eps (initial_mesh_file.str().c_str());</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">grid_out.<a class="code" href="classGridOut.html#a7e31485bb55254bfa5cd3ab55f8d1748">write_eps</a> (triangulation, out_eps);</div><div class="line">out_eps.close();</div></div><!-- fragment --><p>set boundary ids boundary indicator 0 is outer free surface; 1, 2, 3 ... is boundary between layers, 99 is flat boundaries</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">                      cell=triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(), endc=triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> how_many; <span class="comment">// how many components away from cardinal planes</span></div><div class="line"></div><div class="line">    std::ostringstream boundaries_file;</div><div class="line">    boundaries_file &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/boundaries.txt&quot;</span>;</div><div class="line">    std::ofstream fout_boundaries(boundaries_file.str().c_str());</div><div class="line">    fout_boundaries.close();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> zero_tolerance = 1e-3;</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell) <span class="comment">// loop over all cells</span></div><div class="line">    {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++f) <span class="comment">// loop over all vertices</span></div><div class="line">            {</div><div class="line">                    <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">                    {</div></div><!-- fragment --><p>print boundary</p>
<div class="fragment"><div class="line">                    std::ofstream fout_boundaries(boundaries_file.str().c_str(), std::ios::app);</div><div class="line">                    fout_boundaries &lt;&lt; cell-&gt;face(f)-&gt;center()[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; cell-&gt;face(f)-&gt;center()[1]&lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                    fout_boundaries.close();</div><div class="line"></div><div class="line">                        how_many = 0;</div><div class="line">                        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">                                        <span class="keywordflow">if</span> (fabs(cell-&gt;face(f)-&gt;center()[i]) &gt; zero_tolerance)</div><div class="line">                                    how_many++;</div><div class="line">                        <span class="keywordflow">if</span> (how_many==dim)</div><div class="line">                                cell-&gt;face(f)-&gt;set_all_boundary_indicators(0); <span class="comment">// if face center coordinates &gt; zero_tol, set bnry indicators to 0</span></div><div class="line">                        <span class="keywordflow">else</span></div><div class="line">                            cell-&gt;face(f)-&gt;set_all_boundary_indicators(99);</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line">std::ostringstream ellipses_filename;</div><div class="line">ellipses_filename &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/ellipse_fits.txt&quot;</span>;</div><div class="line">std::ofstream fout_ellipses(ellipses_filename.str().c_str());</div><div class="line">fout_ellipses.close();</div></div><!-- fragment --><p>Find ellipsoidal axes for all layers</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; ellipse_axes(0);</div></div><!-- fragment --><p>compute fit to boundary 0, 1, 2 ...</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; endl;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;system_parameters::sizeof_material_id;i++)</div><div class="line">{</div><div class="line">        ellipsoid.compute_fit(ellipse_axes, system_parameters::material_id[i]);</div><div class="line">        system_parameters::q_axes.push_back(ellipse_axes[0]);</div><div class="line">        system_parameters::p_axes.push_back(ellipse_axes[1]);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;a_&quot;</span>&lt;&lt; system_parameters::material_id[i] &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt; ellipse_axes[0]</div><div class="line">                        &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <span class="stringliteral">&quot; c_&quot;</span>&lt;&lt; system_parameters::material_id[i] &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt; ellipse_axes[1] &lt;&lt; std::endl;</div><div class="line">        ellipse_axes.clear();</div><div class="line"></div><div class="line">        std::ofstream fout_ellipses(ellipses_filename.str().c_str(), std::ios::app);</div><div class="line">        fout_ellipses &lt;&lt; system_parameters::present_timestep &lt;&lt; <span class="stringliteral">&quot; a_&quot;</span>&lt;&lt; system_parameters::material_id[i] &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt; ellipse_axes[0]</div><div class="line">                                        &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <span class="stringliteral">&quot; c_&quot;</span>&lt;&lt; system_parameters::material_id[i] &lt;&lt;<span class="stringliteral">&quot; = &quot;</span> &lt;&lt; ellipse_axes[1] &lt;&lt; endl;</div><div class="line">        fout_ellipses.close();</div><div class="line">}</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(system_parameters::global_refinement);</div></div><!-- fragment --><p>refines crustal region</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (system_parameters::crustal_refinement != 0) {</div><div class="line">        <span class="keywordtype">double</span> a = system_parameters::q_axes[0] - system_parameters::crust_refine_region;</div><div class="line">        <span class="keywordtype">double</span> b = system_parameters::p_axes[0] - system_parameters::crust_refine_region;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0;</div><div class="line">                        step &lt; system_parameters::crustal_refinement; ++step) {</div><div class="line">                typename ::Triangulation&lt;dim&gt;::active_cell_iterator cell =</div><div class="line">                                triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(), endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">                <span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0;</div><div class="line">                                        v &lt; GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v) {</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> current_vertex = cell-&gt;vertex(v);</div><div class="line"></div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span> x_coord = current_vertex.operator()(0);</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span> y_coord = current_vertex.operator()(1);</div><div class="line">                                <span class="keywordtype">double</span> expected_z = -1;</div><div class="line"></div><div class="line">                                <span class="keywordflow">if</span> ((x_coord - a) &lt; -1e-10)</div><div class="line">                                        expected_z = b</div><div class="line">                                                        * std::sqrt(1 - (x_coord * x_coord / a / a));</div><div class="line"></div><div class="line">                                <span class="keywordflow">if</span> (y_coord &gt;= expected_z) {</div><div class="line">                                        cell-&gt;set_refine_flag();</div><div class="line">                                        <span class="keywordflow">break</span>;</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">                triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>output initial mesh in eps</p>
<div class="fragment"><div class="line">        std::ostringstream refined_mesh_file;</div><div class="line">        refined_mesh_file &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/refined_mesh.eps&quot;</span>;</div><div class="line">        std::ofstream out_eps_refined (refined_mesh_file.str().c_str());</div><div class="line">        <a class="code" href="classGridOut.html">GridOut</a> grid_out_refined;</div><div class="line">        grid_out_refined.<a class="code" href="classGridOut.html#a7e31485bb55254bfa5cd3ab55f8d1748">write_eps</a> (triangulation, out_eps_refined);</div><div class="line">        out_eps_refined.close();</div><div class="line">        write_vertices(0);</div><div class="line">        write_vertices(1);</div><div class="line">        write_mesh();</div><div class="line">}</div></div><!-- fragment --><p>====================== REFINE MESH ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::refine_mesh() {</div><div class="line">        <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">        std::vector&lt;bool&gt; component_mask(dim + 1, <span class="keyword">false</span>);</div><div class="line">        component_mask[dim] = <span class="keyword">true</span>;</div><div class="line">        <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a>(dof_handler, <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 1),</div><div class="line">                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(), solution,</div><div class="line">                        estimated_error_per_cell, component_mask);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                        estimated_error_per_cell, 0.3, 0.0);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p>====================== SET UP THE DATA STRUCTURES TO REMEMBER STRESS FIELD ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::setup_quadrature_point_history() {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> our_cells = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                        triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">                ++our_cells;</div><div class="line"></div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a>();</div><div class="line"></div><div class="line">        quadrature_point_history.resize(our_cells * quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>());</div><div class="line"></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> history_index = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">                        triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell) {</div><div class="line">                cell-&gt;set_user_pointer(&amp;quadrature_point_history[history_index]);</div><div class="line">                history_index += quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(history_index == quadrature_point_history.size(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">}</div></div><!-- fragment --><p>====================== DOES ELASTIC STEPS ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::do_elastic_steps()</div><div class="line">{</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elastic_iteration = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">while</span> (elastic_iteration &lt; system_parameters::initial_elastic_iterations)</div><div class="line">        {</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;\n\nElastic iteration &quot;</span> &lt;&lt; elastic_iteration</div><div class="line">                                                        &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                setup_dofs();</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (system_parameters::present_timestep == 0)</div><div class="line">                        initialize_eta_and_G();</div><div class="line">                </div><div class="line">                <span class="keywordflow">if</span>(elastic_iteration == 0)</div><div class="line">                        system_parameters::current_time_interval =</div><div class="line">                                system_parameters::viscous_time; <span class="comment">//This is the time interval needed in assembling the problem</span></div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line">                assemble_system();</div><div class="line"></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div><div class="line">                solve();</div><div class="line"></div><div class="line">                output_results();</div><div class="line">                update_quadrature_point_history();</div><div class="line"></div><div class="line">                append_physical_times(0);</div><div class="line">                elastic_iteration++;</div><div class="line">                system_parameters::present_timestep++;</div><div class="line">                do_ellipse_fits();</div><div class="line">                write_vertices(0);</div><div class="line">            write_vertices(1);</div><div class="line">                write_mesh();</div><div class="line">                update_time_interval();</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>====================== DO A SINGLE VISCOELASTOPLASTIC TIMESTEP ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::do_flow_step() {</div><div class="line">        plastic_iteration = 0;</div><div class="line">        <span class="keywordflow">while</span> (plastic_iteration &lt; system_parameters::max_plastic_iterations) {</div><div class="line">                <span class="keywordflow">if</span> (system_parameters::continue_plastic_iterations == <span class="keyword">true</span>) {</div><div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;Plasticity iteration &quot;</span> &lt;&lt; plastic_iteration &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">                        setup_dofs();</div><div class="line"></div><div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::flush;</div><div class="line">                        assemble_system();</div><div class="line"></div><div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::flush;</div><div class="line">                        solve();</div><div class="line"></div><div class="line">                        output_results();</div><div class="line">                        solution_stesses();</div><div class="line"></div><div class="line">                        <span class="keywordflow">if</span> (system_parameters::continue_plastic_iterations == <span class="keyword">false</span>) </div><div class="line">                                <span class="keywordflow">break</span>;</div><div class="line">                        </div><div class="line">                        plastic_iteration++;</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>====================== RUN ======================</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesProblem&lt;dim&gt;::run()</div><div class="line">{</div></div><!-- fragment --><p>Sets up mesh and data structure for viscosity and stress at quadrature points</p>
<div class="fragment"><div class="line">setup_initial_mesh();</div><div class="line">setup_quadrature_point_history();</div></div><!-- fragment --><p>Makes the physical_times.txt file</p>
<div class="fragment"><div class="line">std::ostringstream times_filename;</div><div class="line">times_filename &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/physical_times.txt&quot;</span>;</div><div class="line">std::ofstream fout_times(times_filename.str().c_str());</div><div class="line">fout_times.close();</div></div><!-- fragment --><p>Computes elastic timesteps</p>
<div class="fragment"><div class="line">do_elastic_steps();</div></div><!-- fragment --><p>Computes viscous timesteps</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> VEPstep = 0;</div><div class="line"><span class="keywordflow">while</span> (system_parameters::present_timestep</div><div class="line">                &lt; (system_parameters::initial_elastic_iterations</div><div class="line">                                + system_parameters::total_viscous_steps)) {</div><div class="line">                                        </div><div class="line">        <span class="keywordflow">if</span> (system_parameters::continue_plastic_iterations == <span class="keyword">false</span>)</div><div class="line">                system_parameters::continue_plastic_iterations = <span class="keyword">true</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\n\nViscoelastoplastic iteration &quot;</span> &lt;&lt; VEPstep &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div></div><!-- fragment --><p>Computes plasticity</p>
<div class="fragment"><div class="line">                do_flow_step();</div><div class="line">                update_quadrature_point_history();</div><div class="line">                move_mesh();</div><div class="line">                append_physical_times(plastic_iteration);</div><div class="line">                system_parameters::present_timestep++;</div><div class="line">                system_parameters::present_time = system_parameters::present_time + system_parameters::current_time_interval;</div><div class="line">                do_ellipse_fits();</div><div class="line">                write_vertices(0);</div><div class="line">                write_vertices(1);</div><div class="line">                write_mesh();</div><div class="line">                VEPstep++;</div><div class="line">        }</div><div class="line">                append_physical_times(-1);</div><div class="line"> }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>====================== MAIN ======================</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div></div><!-- fragment --><p>output program name</p>
<div class="fragment"><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Running: &quot;</span> &lt;&lt; argv[0] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordtype">char</span>* cfg_filename = <span class="keyword">new</span> <span class="keywordtype">char</span>[120];</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (argc == 1) <span class="comment">// if no input parameters (as if launched from eclipse)</span></div><div class="line">        {</div><div class="line">                std::strcpy(cfg_filename,<span class="stringliteral">&quot;config/ConfigurationV2.cfg&quot;</span>);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">                std::strcpy(cfg_filename,argv[1]);</div><div class="line"></div><div class="line">        <span class="keywordflow">try</span> {</div><div class="line">                <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">                <span class="keyword">using namespace </span>Step22;</div><div class="line">                config_in cfg(cfg_filename);</div><div class="line"></div><div class="line">                std::clock_t t1;</div><div class="line">                std::clock_t t2;</div><div class="line">                t1 = std::clock();</div><div class="line"></div><div class="line">                deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(0);</div><div class="line"></div><div class="line">                StokesProblem&lt;2&gt; flow_problem(1);</div><div class="line">        flow_problem.run();</div><div class="line"></div><div class="line">                std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;\a&quot;</span>;</div><div class="line"></div><div class="line">                t2 = std::clock();</div><div class="line">                <span class="keywordtype">float</span> diff (((<span class="keywordtype">float</span>)t2 - (<span class="keywordtype">float</span>)t1) / (<span class="keywordtype">float</span>)CLOCKS_PER_SEC);</div><div class="line">                std::cout  &lt;&lt; <span class="stringliteral">&quot;\n Program run in: &quot;</span> &lt;&lt; diff &lt;&lt; <span class="stringliteral">&quot; seconds&quot;</span> &lt;&lt; endl;</div><div class="line">        } <span class="keywordflow">catch</span> (std::exception &amp;exc) {</div><div class="line">                std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                                &lt;&lt; std::endl;</div><div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl &lt;&lt; exc.what()</div><div class="line">                                &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span> 1;</div><div class="line">        } <span class="keywordflow">catch</span> (...) {</div><div class="line">                std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                                &lt;&lt; std::endl;</div><div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span></div><div class="line">                                &lt;&lt; std::endl</div><div class="line">                                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                                &lt;&lt; std::endl;</div><div class="line">                <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-support_code/config_in.h"></a> </p><h1>Annotated version of support_code/config_in.h</h1>
<div class="fragment"><div class="line">/ *</div><div class="line"> * config_in.h</div><div class="line"> *</div><div class="line"> *  Created on: Aug 17, 2015</div><div class="line"> *      Author: antonermakov</div><div class="line"> * /</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;libconfig.h++&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;local_math.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span>libconfig;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step22 {</div><div class="line"><span class="keyword">namespace </span>system_parameters {</div></div><!-- fragment --><p>Mesh file name</p>
<div class="fragment"><div class="line"><span class="keywordtype">string</span> mesh_filename;</div><div class="line"><span class="keywordtype">string</span> output_folder;</div></div><!-- fragment --><p>Body parameters</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> r_mean;</div><div class="line"><span class="keywordtype">double</span> period;</div><div class="line"><span class="keywordtype">double</span> omegasquared;</div><div class="line"><span class="keywordtype">double</span> beta;</div><div class="line"><span class="keywordtype">double</span> intercept;</div></div><!-- fragment --><p>Rheology parameters</p>
<div class="fragment"><div class="line">vector&lt;double&gt; depths_eta;</div><div class="line">vector&lt;double&gt; eta_kinks;</div><div class="line">vector&lt;double&gt; depths_rho;</div><div class="line">vector&lt;double&gt; rho;</div><div class="line">vector&lt;int&gt; material_id;</div><div class="line">vector&lt;double&gt; G;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> eta_ceiling;</div><div class="line"><span class="keywordtype">double</span> eta_floor;</div><div class="line"><span class="keywordtype">double</span> eta_Ea;</div><div class="line"><span class="keywordtype">bool</span> lat_dependence;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_depths_eta;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_depths_rho;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_rho;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_eta_kinks;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_material_id;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_G;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> pressure_scale;</div><div class="line"><span class="keywordtype">double</span> q;</div><div class="line"><span class="keywordtype">bool</span> cylindrical;</div><div class="line"><span class="keywordtype">bool</span> continue_plastic_iterations;</div></div><!-- fragment --><p>plasticity variables</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> plasticity_on;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> failure_criterion;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_plastic_iterations;</div><div class="line"><span class="keywordtype">double</span> smoothing_radius;</div></div><!-- fragment --><p>viscoelasticity variables</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_elastic_iterations;</div><div class="line"><span class="keywordtype">double</span> elastic_time;</div><div class="line"><span class="keywordtype">double</span> viscous_time;</div><div class="line"><span class="keywordtype">double</span> initial_disp_target;</div><div class="line"><span class="keywordtype">double</span> final_disp_target;</div><div class="line"><span class="keywordtype">double</span> current_time_interval;</div></div><!-- fragment --><p>mesh refinement variables</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> global_refinement;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> small_r_refinement;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> crustal_refinement;</div><div class="line"><span class="keywordtype">double</span> crust_refine_region;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> surface_refinement;</div></div><!-- fragment --><p>solver variables</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> iteration_coefficient;</div><div class="line"><span class="keywordtype">double</span> tolerance_coefficient;</div></div><!-- fragment --><p>time step variables</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> present_time;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> present_timestep;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total_viscous_steps;</div></div><!-- fragment --><p>ellipse axes</p>
<div class="fragment"><div class="line">vector&lt;double&gt; q_axes;</div><div class="line">vector&lt;double&gt; p_axes;</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class </span>config_in</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        config_in(<span class="keywordtype">char</span>*);</div><div class="line">        </div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="keywordtype">void</span> write_config();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> config_in::write_config()</div><div class="line">{</div><div class="line">        std::ostringstream config_parameters;</div><div class="line">        config_parameters &lt;&lt; system_parameters::output_folder &lt;&lt; <span class="stringliteral">&quot;/run_parameters.txt&quot;</span>;</div><div class="line">        std::ofstream fout_config(config_parameters.str().c_str());</div></div><!-- fragment --><p>mesh filename</p>
<div class="fragment"><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;mesh filename: &quot;</span> &lt;&lt; system_parameters::mesh_filename &lt;&lt; endl &lt;&lt; endl;</div></div><!-- fragment --><p>body parameters</p>
<div class="fragment"><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;r_mean = &quot;</span> &lt;&lt; system_parameters::r_mean &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;period = &quot;</span> &lt;&lt; system_parameters::period &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;omegasquared = &quot;</span> &lt;&lt; system_parameters::omegasquared &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;beta = &quot;</span> &lt;&lt; system_parameters::beta &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;intercept = &quot;</span> &lt;&lt; system_parameters::intercept &lt;&lt; endl;</div></div><!-- fragment --><p>rheology parameters</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;system_parameters::sizeof_depths_eta; i++)</div><div class="line">    fout_config &lt;&lt; <span class="stringliteral">&quot;depths_eta[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::depths_eta[i] &lt;&lt; endl;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;system_parameters::sizeof_eta_kinks; i++)</div><div class="line">    fout_config &lt;&lt; <span class="stringliteral">&quot;eta_kinks[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::eta_kinks[i] &lt;&lt; endl;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;system_parameters::sizeof_depths_rho; i++)</div><div class="line">    fout_config &lt;&lt; <span class="stringliteral">&quot;depths_rho[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::depths_rho[i] &lt;&lt; endl;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;system_parameters::sizeof_rho; i++)</div><div class="line">    fout_config &lt;&lt; <span class="stringliteral">&quot;rho[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::rho[i] &lt;&lt; endl;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;system_parameters::sizeof_material_id; i++)</div><div class="line">    fout_config &lt;&lt; <span class="stringliteral">&quot;material_id[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::material_id[i] &lt;&lt; endl;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;system_parameters::sizeof_G; i++)</div><div class="line">    fout_config &lt;&lt; <span class="stringliteral">&quot;G[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::G[i] &lt;&lt; endl;</div><div class="line"></div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;eta_ceiling = &quot;</span> &lt;&lt; system_parameters::eta_ceiling &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;eta_floor = &quot;</span> &lt;&lt; system_parameters::eta_floor &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;eta_Ea = &quot;</span> &lt;&lt; system_parameters::eta_Ea &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;lat_dependence = &quot;</span> &lt;&lt; system_parameters::lat_dependence &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;pressure_scale = &quot;</span> &lt;&lt; system_parameters::pressure_scale &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;q = &quot;</span> &lt;&lt; system_parameters::q &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;cylindrical = &quot;</span> &lt;&lt; system_parameters::cylindrical &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;continue_plastic_iterations = &quot;</span> &lt;&lt; system_parameters::continue_plastic_iterations &lt;&lt; endl;</div></div><!-- fragment --><p>Plasticity parameters</p>
<div class="fragment"><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;plasticity_on = &quot;</span> &lt;&lt; system_parameters::plasticity_on &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;failure_criterion = &quot;</span> &lt;&lt; system_parameters::failure_criterion &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;max_plastic_iterations = &quot;</span> &lt;&lt; system_parameters::max_plastic_iterations &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;smoothing_radius = &quot;</span> &lt;&lt; system_parameters::smoothing_radius &lt;&lt; endl;</div></div><!-- fragment --><p>Viscoelasticity parameters</p>
<div class="fragment"><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;initial_elastic_iterations = &quot;</span> &lt;&lt; system_parameters::initial_elastic_iterations &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;elastic_time = &quot;</span> &lt;&lt; system_parameters::elastic_time &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;viscous_time = &quot;</span> &lt;&lt; system_parameters::viscous_time &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;initial_disp_target = &quot;</span> &lt;&lt; system_parameters::initial_disp_target &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;final_disp_target = &quot;</span> &lt;&lt; system_parameters::final_disp_target &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;current_time_interval = &quot;</span> &lt;&lt; system_parameters::current_time_interval &lt;&lt; endl;</div></div><!-- fragment --><p>Mesh refinement parameters</p>
<div class="fragment"><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;global_refinement = &quot;</span> &lt;&lt; system_parameters::global_refinement &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;small_r_refinement = &quot;</span> &lt;&lt; system_parameters::small_r_refinement &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;crustal_refinement = &quot;</span> &lt;&lt; system_parameters::crustal_refinement &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;crust_refine_region = &quot;</span> &lt;&lt; system_parameters::crust_refine_region &lt;&lt; endl;</div><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;surface_refinement = &quot;</span> &lt;&lt; system_parameters::surface_refinement &lt;&lt; endl;</div></div><!-- fragment --><p><a class="el" href="classSolver.html">Solver</a> parameters</p>
<div class="fragment"><div class="line">fout_config &lt;&lt; <span class="stringliteral">&quot;iteration_coefficient = &quot;</span> &lt;&lt; system_parameters::iteration_coefficient &lt;&lt; endl;</div><div class="line">    fout_config &lt;&lt; <span class="stringliteral">&quot;tolerance_coefficient = &quot;</span> &lt;&lt; system_parameters::tolerance_coefficient &lt;&lt; endl;</div></div><!-- fragment --><p>Time step parameters</p>
<div class="fragment"><div class="line">        fout_config &lt;&lt; <span class="stringliteral">&quot;present_time = &quot;</span> &lt;&lt; system_parameters::present_time &lt;&lt; endl;</div><div class="line">        fout_config &lt;&lt; <span class="stringliteral">&quot;present_timestep = &quot;</span> &lt;&lt; system_parameters::present_timestep &lt;&lt; endl;</div><div class="line">        fout_config &lt;&lt; <span class="stringliteral">&quot;total_viscous_steps = &quot;</span> &lt;&lt; system_parameters::total_viscous_steps &lt;&lt; endl;</div><div class="line">        </div><div class="line">        fout_config.close();</div><div class="line">}</div><div class="line"></div><div class="line">config_in::config_in(<span class="keywordtype">char</span>* filename)</div><div class="line">{</div></div><!-- fragment --><p>This example reads the configuration file 'example.cfg' and displays some of its contents.</p>
<div class="fragment"><div class="line">Config cfg;</div></div><!-- fragment --><p>Read the file. If there is an error, report it and exit.</p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line">  cfg.readFile(filename);</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> FileIOException &amp;fioex)</div><div class="line">{</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;I/O error while reading file:&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> ParseException &amp;pex)</div><div class="line">{</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Parse error at &quot;</span> &lt;&lt; pex.getFile() &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; pex.getLine()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; pex.getError() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Get mesh name.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">try</span></div><div class="line">  {</div><div class="line"><span class="keywordtype">string</span> msh = cfg.lookup(<span class="stringliteral">&quot;mesh_filename&quot;</span>);</div><div class="line">    system_parameters::mesh_filename = msh;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">catch</span>(<span class="keyword">const</span> SettingNotFoundException &amp;nfex)</div><div class="line">  {</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">&quot;No &#39;mesh_filename&#39; setting in configuration file.&quot;</span> &lt;&lt; endl;</div><div class="line">  }</div></div><!-- fragment --><p>get output folder</p>
<div class="fragment"><div class="line">  <span class="keywordflow">try</span></div><div class="line">  {</div><div class="line"><span class="keywordtype">string</span> output = cfg.lookup(<span class="stringliteral">&quot;output_folder&quot;</span>);</div><div class="line">    system_parameters::output_folder = output;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Writing to folder: &quot;</span> &lt;&lt; output &lt;&lt; endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">catch</span>(<span class="keyword">const</span> SettingNotFoundException &amp;nfex)</div><div class="line">  {</div><div class="line">    cerr &lt;&lt; <span class="stringliteral">&quot;No &#39;output_folder&#39; setting in configuration file.&quot;</span> &lt;&lt; endl;</div><div class="line">  }</div></div><!-- fragment --><p>get radii</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Setting&amp; root = cfg.getRoot();</div></div><!-- fragment --><p>get body parameters</p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Setting&amp; body_parameters = root[<span class="stringliteral">&quot;body_parameters&quot;</span>];</div><div class="line"></div><div class="line">  body_parameters.lookupValue(<span class="stringliteral">&quot;period&quot;</span>, system_parameters::period);</div><div class="line">  system_parameters::omegasquared = <a class="code" href="classVectorizedArray.html#aa69d9a4deaee06ae957a25c7877d4daa">pow</a>(TWOPI / 3600.0 / system_parameters::period, 2.0);</div><div class="line">  body_parameters.lookupValue(<span class="stringliteral">&quot;r_mean&quot;</span>, system_parameters::r_mean);</div><div class="line">  body_parameters.lookupValue(<span class="stringliteral">&quot;beta&quot;</span>, system_parameters::beta);</div><div class="line">  body_parameters.lookupValue(<span class="stringliteral">&quot;intercept&quot;</span>, system_parameters::intercept);</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> SettingNotFoundException &amp;nfex)</div><div class="line">{</div><div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;We&#39;ve got a problem in the body parameters block&quot;</span> &lt;&lt; endl;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Rheology parameters</p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div></div><!-- fragment --><p>get depths_eta ------------------&mdash;</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Setting&amp; set_depths_eta = cfg.lookup(<span class="stringliteral">&quot;rheology_parameters.depths_eta&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ndepths_eta = set_depths_eta.getLength();</div><div class="line">    system_parameters::sizeof_depths_eta = ndepths_eta;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;ndepths_eta; i++)</div><div class="line">    {</div><div class="line">        system_parameters::depths_eta.push_back(set_depths_eta[i]);</div><div class="line">              cout &lt;&lt; <span class="stringliteral">&quot;depth_eta[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::depths_eta[i] &lt;&lt; endl;</div><div class="line">    }</div></div><!-- fragment --><p>get eta_kinks ----------------------&mdash;</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Setting&amp; set_eta_kinks = cfg.lookup(<span class="stringliteral">&quot;rheology_parameters.eta_kinks&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> neta_kinks = set_eta_kinks.getLength();</div><div class="line">    system_parameters::sizeof_eta_kinks = neta_kinks;</div></div><!-- fragment --><p>cout &lt;&lt; "Number of depth = " &lt;&lt; ndepths &lt;&lt; endl;</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;neta_kinks; i++)</div><div class="line">{</div><div class="line">    system_parameters::eta_kinks.push_back(set_eta_kinks[i]);</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;eta_kinks[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::eta_kinks[i] &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>get depths_rho ----------------------&mdash;</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Setting&amp; set_depths_rho = cfg.lookup(<span class="stringliteral">&quot;rheology_parameters.depths_rho&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ndepths_rho = set_depths_rho.getLength();</div><div class="line">    system_parameters::sizeof_depths_rho = ndepths_rho;</div></div><!-- fragment --><p>cout &lt;&lt; "Number of depth = " &lt;&lt; ndepths &lt;&lt; endl;</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;ndepths_rho; i++)</div><div class="line">{</div><div class="line">    system_parameters::depths_rho.push_back(set_depths_rho[i]);</div><div class="line">   cout &lt;&lt; <span class="stringliteral">&quot;depths_rho[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::depths_rho[i] &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>get rho ----------------------&mdash;</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Setting&amp; set_rho = cfg.lookup(<span class="stringliteral">&quot;rheology_parameters.rho&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nrho = set_rho.getLength();</div><div class="line">    system_parameters::sizeof_rho = nrho;</div></div><!-- fragment --><p>cout &lt;&lt; "Number of depth = " &lt;&lt; ndepths &lt;&lt; endl;</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nrho; i++)</div><div class="line">{</div><div class="line">    system_parameters::rho.push_back(set_rho[i]);</div><div class="line">       cout &lt;&lt; <span class="stringliteral">&quot;rho[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::rho[i] &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>get material_id ----------------------&mdash;</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Setting&amp; set_material_id = cfg.lookup(<span class="stringliteral">&quot;rheology_parameters.material_id&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nmaterial_id = set_material_id.getLength();</div><div class="line">    system_parameters::sizeof_material_id = nmaterial_id;</div></div><!-- fragment --><p>cout &lt;&lt; "Number of depth = " &lt;&lt; ndepths &lt;&lt; endl;</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nmaterial_id; i++)</div><div class="line">{</div><div class="line">    system_parameters::material_id.push_back(set_material_id[i]);</div><div class="line">       cout &lt;&lt; <span class="stringliteral">&quot;material_id[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::material_id[i] &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>get G ----------------------&mdash;</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Setting&amp; set_G = cfg.lookup(<span class="stringliteral">&quot;rheology_parameters.G&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nG = set_G.getLength();</div><div class="line">    system_parameters::sizeof_G = nG;</div></div><!-- fragment --><p>cout &lt;&lt; "Number of depth = " &lt;&lt; ndepths &lt;&lt; endl;</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nG; i++)</div><div class="line">        {</div><div class="line">            system_parameters::G.push_back(set_G[i]);</div><div class="line">                  cout &lt;&lt; <span class="stringliteral">&quot;G[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; system_parameters::G[i] &lt;&lt; endl;</div><div class="line">        }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Setting&amp; rheology_parameters = root[<span class="stringliteral">&quot;rheology_parameters&quot;</span>];</div><div class="line">  rheology_parameters.lookupValue(<span class="stringliteral">&quot;eta_ceiling&quot;</span>, system_parameters::eta_ceiling);</div><div class="line">  rheology_parameters.lookupValue(<span class="stringliteral">&quot;eta_floor&quot;</span>, system_parameters::eta_floor);</div><div class="line">  rheology_parameters.lookupValue(<span class="stringliteral">&quot;eta_Ea&quot;</span>, system_parameters::eta_Ea);</div><div class="line">  rheology_parameters.lookupValue(<span class="stringliteral">&quot;lat_dependence&quot;</span>, system_parameters::lat_dependence);</div><div class="line">  rheology_parameters.lookupValue(<span class="stringliteral">&quot;pressure_scale&quot;</span>, system_parameters::pressure_scale);</div><div class="line">  rheology_parameters.lookupValue(<span class="stringliteral">&quot;q&quot;</span>, system_parameters::q);</div><div class="line">  rheology_parameters.lookupValue(<span class="stringliteral">&quot;cylindrical&quot;</span>, system_parameters::cylindrical);</div><div class="line">  rheology_parameters.lookupValue(<span class="stringliteral">&quot;continue_plastic_iterations&quot;</span>, system_parameters::continue_plastic_iterations);</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> SettingNotFoundException &amp;nfex)</div><div class="line">{</div><div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;We&#39;ve got a problem in the rheology parameters block&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>Plasticity parameters</p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Setting&amp; plasticity_parameters = root[<span class="stringliteral">&quot;plasticity_parameters&quot;</span>];</div><div class="line">  plasticity_parameters.lookupValue(<span class="stringliteral">&quot;plasticity_on&quot;</span>, system_parameters::plasticity_on);</div><div class="line">  plasticity_parameters.lookupValue(<span class="stringliteral">&quot;failure_criterion&quot;</span>, system_parameters::failure_criterion);</div><div class="line">  plasticity_parameters.lookupValue(<span class="stringliteral">&quot;max_plastic_iterations&quot;</span>, system_parameters::max_plastic_iterations);</div><div class="line">  plasticity_parameters.lookupValue(<span class="stringliteral">&quot;smoothing_radius&quot;</span>, system_parameters::smoothing_radius);</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> SettingNotFoundException &amp;nfex)</div><div class="line">{</div><div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;We&#39;ve got a problem in the plasticity parameters block&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>Viscoelasticity parameters</p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Setting&amp; viscoelasticity_parameters = root[<span class="stringliteral">&quot;viscoelasticity_parameters&quot;</span>];</div><div class="line">  viscoelasticity_parameters.lookupValue(<span class="stringliteral">&quot;initial_elastic_iterations&quot;</span>, system_parameters::initial_elastic_iterations);</div><div class="line">  viscoelasticity_parameters.lookupValue(<span class="stringliteral">&quot;elastic_time&quot;</span>, system_parameters::elastic_time);</div><div class="line">  viscoelasticity_parameters.lookupValue(<span class="stringliteral">&quot;viscous_time&quot;</span>, system_parameters::viscous_time);</div><div class="line">  viscoelasticity_parameters.lookupValue(<span class="stringliteral">&quot;initial_disp_target&quot;</span>, system_parameters::initial_disp_target);</div><div class="line">  viscoelasticity_parameters.lookupValue(<span class="stringliteral">&quot;final_disp_target&quot;</span>, system_parameters::final_disp_target);</div><div class="line">  viscoelasticity_parameters.lookupValue(<span class="stringliteral">&quot;current_time_interval&quot;</span>, system_parameters::current_time_interval);</div><div class="line"></div><div class="line">  system_parameters::viscous_time *= SECSINYEAR;</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> SettingNotFoundException &amp;nfex)</div><div class="line">{</div><div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;We&#39;ve got a problem in the viscoelasticity parameters block&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>Mesh refinement parameters</p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Setting&amp; mesh_refinement_parameters = root[<span class="stringliteral">&quot;mesh_refinement_parameters&quot;</span>];</div><div class="line">  mesh_refinement_parameters.lookupValue(<span class="stringliteral">&quot;global_refinement&quot;</span>, system_parameters::global_refinement);</div><div class="line">  mesh_refinement_parameters.lookupValue(<span class="stringliteral">&quot;small_r_refinement&quot;</span>, system_parameters::small_r_refinement);</div><div class="line">  mesh_refinement_parameters.lookupValue(<span class="stringliteral">&quot;crustal_refinement&quot;</span>, system_parameters::crustal_refinement);</div><div class="line">  mesh_refinement_parameters.lookupValue(<span class="stringliteral">&quot;crust_refine_region&quot;</span>, system_parameters::crust_refine_region);</div><div class="line">  mesh_refinement_parameters.lookupValue(<span class="stringliteral">&quot;surface_refinement&quot;</span>, system_parameters::surface_refinement);</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> SettingNotFoundException &amp;nfex)</div><div class="line">{</div><div class="line">       cerr &lt;&lt; <span class="stringliteral">&quot;We&#39;ve got a problem in the mesh refinement parameters block&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="classSolver.html">Solver</a> parameters</p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Setting&amp; solve_parameters = root[<span class="stringliteral">&quot;solve_parameters&quot;</span>];</div><div class="line">  solve_parameters.lookupValue(<span class="stringliteral">&quot;iteration_coefficient&quot;</span>, system_parameters::iteration_coefficient);</div><div class="line">  solve_parameters.lookupValue(<span class="stringliteral">&quot;tolerance_coefficient&quot;</span>, system_parameters::tolerance_coefficient);</div><div class="line"></div><div class="line"></div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> SettingNotFoundException &amp;nfex)</div><div class="line">{</div><div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;We&#39;ve got a problem in the solver parameters block&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>Time step parameters</p>
<div class="fragment"><div class="line">          <span class="keywordflow">try</span></div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> Setting&amp; time_step_parameters = root[<span class="stringliteral">&quot;time_step_parameters&quot;</span>];</div><div class="line">            time_step_parameters.lookupValue(<span class="stringliteral">&quot;present_time&quot;</span>, system_parameters::present_time);</div><div class="line">            time_step_parameters.lookupValue(<span class="stringliteral">&quot;present_timestep&quot;</span>, system_parameters::present_timestep);</div><div class="line">            time_step_parameters.lookupValue(<span class="stringliteral">&quot;total_viscous_steps&quot;</span>, system_parameters::total_viscous_steps);</div><div class="line">          }</div><div class="line">          <span class="keywordflow">catch</span>(<span class="keyword">const</span> SettingNotFoundException &amp;nfex)</div><div class="line">          {</div><div class="line">                  cerr &lt;&lt; <span class="stringliteral">&quot;We&#39;ve got a problem in the time step parameters block&quot;</span> &lt;&lt; endl;</div><div class="line">          }</div><div class="line"></div><div class="line">          write_config();</div><div class="line">}</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-support_code/ellipsoid_fit.h"></a> </p><h1>Annotated version of support_code/ellipsoid_fit.h</h1>
<div class="fragment"><div class="line">/ *</div><div class="line"> * ellipsoid_fit.h</div><div class="line"> *</div><div class="line"> *  Created on: Jul 24, 2015</div><div class="line"> *      Author: antonermakov</div><div class="line"> * /</div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/point.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;local_math.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ellipsoid_fit</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">       <span class="keyword">inline</span> ellipsoid_fit (<a class="code" href="classTriangulation.html">Triangulation&lt;dim,dim&gt;</a>* pi)</div><div class="line">       {</div><div class="line">               p_triangulation = pi;</div><div class="line">       };</div><div class="line">       <span class="keywordtype">void</span> compute_fit(std::vector&lt;double&gt; &amp;ell, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bndry);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim,dim&gt;</a>*   p_triangulation;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>This function computes ellipsoid fit to a set of vertices that lie on the boundary_that_we_need</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ellipsoid_fit&lt;dim&gt;::compute_fit(std::vector&lt;double&gt; &amp;ell, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> boundary_that_we_need)</div><div class="line">{</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell = p_triangulation-&gt;<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> endc = p_triangulation-&gt;<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> A(p_triangulation-&gt;n_vertices(),dim);</div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     x(dim);</div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     b(p_triangulation-&gt;n_vertices());</div><div class="line"></div><div class="line">        std::vector&lt;bool&gt; vertex_touched (p_triangulation-&gt;n_vertices(),</div><div class="line">                                                             <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> boundary_ids;</div><div class="line">    std::vector&lt;unsigned int&gt; ind_bnry_row;</div><div class="line">    std::vector&lt;unsigned int&gt; ind_bnry_col;</div></div><!-- fragment --><p>assemble the sensitivity matrix and r.h.s.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> zero_tolerance = 1e-3;</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell) {</div><div class="line">            <span class="keywordflow">if</span> (boundary_that_we_need != 0)</div><div class="line">                    cell-&gt;set_manifold_id(cell-&gt;material_id());</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f = 0; f &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++f) {</div><div class="line">                    <span class="keywordflow">if</span> (boundary_that_we_need == 0) <span class="comment">//if this is the outer surface, then look for boundary ID 0; otherwise look for material ID change.</span></div><div class="line">                                    {</div><div class="line">                            boundary_ids = cell-&gt;face(f)-&gt;boundary_indicator();</div><div class="line">                            <span class="keywordflow">if</span> (boundary_ids == boundary_that_we_need) {</div><div class="line">                                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0;</div><div class="line">                                                    v &lt; GeometryInfo&lt;dim&gt;::vertices_per_face; ++v)</div><div class="line">                                            <span class="keywordflow">if</span> (vertex_touched[cell-&gt;face(f)-&gt;vertex_index(v)]</div><div class="line">                                                            == <span class="keyword">false</span>) {</div><div class="line">                                                    vertex_touched[cell-&gt;face(f)-&gt;vertex_index(v)] =</div><div class="line">                                                                    <span class="keyword">true</span>;</div><div class="line">                                                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i) {</div></div><!-- fragment --><p>stiffness matrix entry</p>
<div class="fragment"><div class="line">A(j, i) = <a class="code" href="classVectorizedArray.html#aa69d9a4deaee06ae957a25c7877d4daa">pow</a>(cell-&gt;face(f)-&gt;vertex(v)[i], 2);</div></div><!-- fragment --><p>r.h.s. entry</p>
<div class="fragment"><div class="line">b[j] = 1.0;</div></div><!-- fragment --><p>if mesh if not full: set the indicator</p>
<div class="fragment"><div class="line">                                }</div><div class="line">                                ind_bnry_row.push_back(j);</div><div class="line">                                j++;</div><div class="line">                        }</div><div class="line">        }</div><div class="line">} <span class="keywordflow">else</span> { <span class="comment">//find the faces that are at the boundary between materials, get the vertices, and write them into the stiffness matrix</span></div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;neighbor(f) != endc) {</div><div class="line">                <span class="keywordflow">if</span> (cell-&gt;material_id() != cell-&gt;neighbor(f)-&gt;material_id()) <span class="comment">//finds face is at internal boundary</span></div><div class="line">                                {</div><div class="line">                        <span class="keywordtype">int</span> high_mat_id = std::max(cell-&gt;material_id(),</div><div class="line">                                        cell-&gt;neighbor(f)-&gt;material_id());</div><div class="line">                        <span class="keywordflow">if</span> (high_mat_id == boundary_that_we_need) <span class="comment">//finds faces at the correct internal boundary</span></div><div class="line">                                        {</div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0;</div><div class="line">                                                v &lt; GeometryInfo&lt;dim&gt;::vertices_per_face;</div><div class="line">                                                ++v)</div><div class="line">                                        <span class="keywordflow">if</span> (vertex_touched[cell-&gt;face(f)-&gt;vertex_index(</div><div class="line">                                                        v)] == <span class="keyword">false</span>) {</div><div class="line">                                                vertex_touched[cell-&gt;face(f)-&gt;vertex_index(</div><div class="line">                                                                v)] = <span class="keyword">true</span>;</div><div class="line">                                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i) {</div></div><!-- fragment --><p>stiffness matrix entry</p>
<div class="fragment"><div class="line">A(j, i) = <a class="code" href="classVectorizedArray.html#aa69d9a4deaee06ae957a25c7877d4daa">pow</a>(</div><div class="line">                cell-&gt;face(f)-&gt;vertex(v)[i], 2);</div></div><!-- fragment --><p>r.h.s. entry</p>
<div class="fragment"><div class="line">b[j] = 1.0;</div></div><!-- fragment --><p>if mesh if not full: set the indicator</p>
<div class="fragment"><div class="line">                                                                }</div><div class="line">                                                                ind_bnry_row.push_back(j);</div><div class="line">                                                                j++;</div><div class="line">                                                        }</div><div class="line">                                        }</div><div class="line">                                }</div><div class="line">                        }</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div><div class="line"><span class="keywordflow">if</span> (ind_bnry_row.size()&gt;0)</div><div class="line">{</div></div><!-- fragment --><p>maxtrix A'*A and vector A'*b; A'*A*x = A'*b &ndash; normal system of equations</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> AtA(dim,dim);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     Atb(dim);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> A_out(ind_bnry_row.size(),dim);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     b_out(ind_bnry_row.size());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;dim;i++)</div><div class="line">            ind_bnry_col.push_back(i);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;ind_bnry_row.size();i++)</div><div class="line">        b_out(i) = 1;</div><div class="line"></div><div class="line">A_out.extract_submatrix_from(A, ind_bnry_row, ind_bnry_col);</div><div class="line">A_out.Tmmult(AtA,A_out,<span class="keyword">true</span>);</div><div class="line">A_out.Tvmult(Atb,b_out,<span class="keyword">true</span>);</div></div><!-- fragment --><p>solve normal system of equations</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              solver (solver_control);</div><div class="line">solver.solve (AtA, x, Atb, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div></div><!-- fragment --><p>find ellipsoidal axes</p>
<div class="fragment"><div class="line">         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; i++)</div><div class="line">         ell.push_back(<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(1.0/x[i]));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;fit_ellipsoid: no points to fit&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-support_code/ellipsoid_grav.h"></a> </p><h1>Annotated version of support_code/ellipsoid_grav.h</h1>
<div class="fragment"><div class="line">/ *</div><div class="line"> Started 10/8/2012, R. R. Fu</div><div class="line"> </div><div class="line"> Reference Pohanka 2011, Contrib. Geophys. Geodes.</div><div class="line"> </div><div class="line"> * /</div><div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/point.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>A_Grav_namespace</div><div class="line">{</div><div class="line">        <span class="keyword">namespace </span>system_parameters {</div><div class="line">                <span class="keywordtype">double</span> mantle_rho;</div><div class="line">                <span class="keywordtype">double</span> core_rho;</div><div class="line">                <span class="keywordtype">double</span> excess_rho;</div><div class="line">                <span class="keywordtype">double</span> r_eq;</div><div class="line">                <span class="keywordtype">double</span> r_polar;</div><div class="line">                </div><div class="line">                <span class="keywordtype">double</span> r_core_eq; </div><div class="line">                <span class="keywordtype">double</span> r_core_polar;</div><div class="line">        }</div><div class="line">        </div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>AnalyticGravity </div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_vars (std::vector&lt;double&gt; v);</div><div class="line">        <span class="keywordtype">void</span> get_gravity (const ::Point&lt;dim&gt; &amp;p, std::vector&lt;double&gt; &amp;g);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:        </div><div class="line">        <span class="keywordtype">double</span> ecc;</div><div class="line">        <span class="keywordtype">double</span> eV;</div><div class="line">        <span class="keywordtype">double</span> ke;</div><div class="line">        <span class="keywordtype">double</span> r00;</div><div class="line">        <span class="keywordtype">double</span> r01;</div><div class="line">        <span class="keywordtype">double</span> r11;</div><div class="line">        <span class="keywordtype">double</span> ecc_c;</div><div class="line">        <span class="keywordtype">double</span> eV_c;</div><div class="line">        <span class="keywordtype">double</span> ke_c;</div><div class="line">        <span class="keywordtype">double</span> r00_c;</div><div class="line">        <span class="keywordtype">double</span> r01_c;</div><div class="line">        <span class="keywordtype">double</span> r11_c;</div><div class="line">        <span class="keywordtype">double</span> g_coeff;</div><div class="line">        <span class="keywordtype">double</span> g_coeff_c;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AnalyticGravity&lt;dim&gt;::get_gravity (const ::Point&lt;dim&gt; &amp;p, std::vector&lt;double&gt; &amp;g)</div><div class="line">        {</div><div class="line">                <span class="keywordtype">double</span> rsph = std::sqrt(p[0] * p[0] + p[1] * p[1]);</div><div class="line">                <span class="keywordtype">double</span> thetasph = std::atan2(p[0], p[1]);</div><div class="line">                <span class="keywordtype">double</span> costhetasph = std::cos(thetasph);</div></div><!-- fragment --><p>convert to elliptical coordinates for silicates</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> stemp = std::sqrt((rsph * rsph - eV * eV + std::sqrt((rsph * rsph - eV * eV) * (rsph * rsph - eV * eV)</div><div class="line">                                                  + 4 * eV * eV * rsph * rsph * costhetasph *costhetasph)) / 2);</div><div class="line"><span class="keywordtype">double</span> vout = stemp / system_parameters::r_eq / std::sqrt(1 - ecc * ecc);</div><div class="line"><span class="keywordtype">double</span> eout = std::acos(rsph * costhetasph / stemp);</div></div><!-- fragment --><p>convert to elliptical coordinates for core correction</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> stemp_c = std::sqrt((rsph * rsph - eV_c * eV_c + std::sqrt((rsph * rsph - eV_c * eV_c) * (rsph * rsph - eV_c * eV_c)</div><div class="line">                                                                                                                        + 4 * eV_c * eV_c * rsph * rsph * costhetasph *costhetasph)) / 2);</div><div class="line"><span class="keywordtype">double</span> vout_c = stemp_c / system_parameters::r_core_eq / std::sqrt(1 - ecc_c * ecc_c);</div><div class="line"><span class="keywordtype">double</span> eout_c = std::acos(rsph * costhetasph / stemp_c);</div></div><!-- fragment --><p>shell contribution</p>
<div class="fragment"><div class="line">g[0] = g_coeff * r11 * std::sqrt((1 - ecc * ecc) * vout * vout + ecc * ecc) * std::sin(eout);</div><div class="line">g[1] = g_coeff * r01 * vout * std::cos(eout) / std::sqrt(1 - ecc * ecc);</div></div><!-- fragment --><p>core contribution</p>
<div class="fragment"><div class="line">                <span class="keywordtype">double</span> expected_y = system_parameters::r_core_polar * std::sqrt(1 - </div><div class="line">                                                        (p[0] * p[0] / system_parameters::r_core_eq / system_parameters::r_core_eq));</div><div class="line"></div><div class="line">                </div><div class="line">                <span class="keywordflow">if</span>(p[1] &lt;= expected_y)</div><div class="line">                {</div><div class="line">                        g[0] += g_coeff_c * r11_c * std::sqrt((1 - ecc_c * ecc_c) * vout_c * vout_c + ecc_c * ecc_c) * std::sin(eout_c);</div><div class="line">                        g[1] += g_coeff_c * r01_c * vout_c * std::cos(eout_c) / std::sqrt(1 - ecc_c * ecc_c);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                        <span class="keywordtype">double</span> g_coeff_co = - 2.795007963255562e-10 * system_parameters::excess_rho * system_parameters::r_core_eq</div><div class="line">                        / vout_c / vout_c;</div><div class="line">                        <span class="keywordtype">double</span> r00_co = 0;</div><div class="line">                        <span class="keywordtype">double</span> r01_co = 0;</div><div class="line">                        <span class="keywordtype">double</span> r11_co = 0;</div><div class="line">                        </div><div class="line">                        <span class="keywordflow">if</span>(system_parameters::r_core_polar == system_parameters::r_core_eq)</div><div class="line">                        {</div><div class="line">                                r00_co = 1;</div><div class="line">                                r01_co = 1;</div><div class="line">                                r11_co = 1;</div><div class="line">                        }</div><div class="line">                        <span class="keywordflow">else</span></div><div class="line">                        {</div><div class="line">                                r00_co = ke_c * vout_c * std::atan2(1, ke_c * vout_c);</div><div class="line">                                <span class="keywordtype">double</span> ke_co2 = ke_c * ke_c * vout_c * vout_c;</div><div class="line">                                r01_co = 3 * ke_co2 * (1 - r00_co);</div><div class="line">                                r11_co = 3 * ((ke_co2 + 1) * r00_co - ke_co2) / 2;</div><div class="line">                        }</div><div class="line">                        g[0] += g_coeff_co * vout_c * r11_co / std::sqrt((1 - ecc_c* ecc_c) * vout_c * vout_c + ecc_c * ecc_c) * std::sin(eout_c);</div><div class="line">                        g[1] += g_coeff_co * r01_co * std::cos(eout_c) / std::sqrt(1 - ecc_c * ecc_c);</div><div class="line">                }</div><div class="line">        }</div><div class="line">        </div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AnalyticGravity&lt;dim&gt;::setup_vars (std::vector&lt;double&gt; v) </div><div class="line">{</div><div class="line">        system_parameters::r_eq = v[0];</div><div class="line">        system_parameters::r_polar = v[1];</div><div class="line">        system_parameters::r_core_eq = v[2]; </div><div class="line">        system_parameters::r_core_polar = v[3];</div><div class="line">        system_parameters::mantle_rho = v[4];</div><div class="line">        system_parameters::core_rho = v[5];</div><div class="line">        system_parameters::excess_rho = system_parameters::core_rho - system_parameters::mantle_rho;</div></div><!-- fragment --><p>Shell</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (system_parameters::r_polar &gt; system_parameters::r_eq)</div><div class="line">{</div></div><!-- fragment --><p>This makes the gravity field nearly that of a sphere in case the body becomes prolate</p>
<div class="fragment"><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\nWarning: The model body has become prolate. \n&quot;</span>;</div><div class="line">        ecc = 0.001;</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">        ecc = std::sqrt(1 - (system_parameters::r_polar * system_parameters::r_polar / system_parameters::r_eq / system_parameters::r_eq));</div><div class="line">}</div><div class="line"></div><div class="line">eV = ecc * system_parameters::r_eq;</div><div class="line">ke = std::sqrt(1 - (ecc * ecc)) / ecc;</div><div class="line">r00 = ke * std::atan2(1, ke);</div><div class="line"><span class="keywordtype">double</span> ke2 = ke * ke;</div><div class="line">r01 = 3 * ke2 * (1 - r00);</div><div class="line">r11 = 3 * ((ke2 + 1) * r00 - ke2) / 2;</div><div class="line">g_coeff = - 2.795007963255562e-10 * system_parameters::mantle_rho * system_parameters::r_eq;</div></div><!-- fragment --><p>Core</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (system_parameters::r_core_polar &gt; system_parameters::r_core_eq)</div><div class="line">{</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\nWarning: The model core has become prolate. \n&quot;</span>;</div><div class="line">        ecc_c = 0.001;</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">        ecc_c = std::sqrt(1 - (system_parameters::r_core_polar * system_parameters::r_core_polar / system_parameters::r_core_eq / system_parameters::r_core_eq));</div><div class="line">}</div><div class="line">eV_c = ecc_c * system_parameters::r_core_eq;</div><div class="line"><span class="keywordflow">if</span>(system_parameters::r_core_polar == system_parameters::r_core_eq)</div><div class="line">{</div><div class="line">        ke_c = 1;</div><div class="line">        r00_c = 1;</div><div class="line">        r01_c = 1;</div><div class="line">        r11_c = 1;</div><div class="line">        g_coeff_c = - 2.795007963255562e-10 * system_parameters::excess_rho * system_parameters::r_core_eq;</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">        ke_c = std::sqrt(1 - (ecc_c * ecc_c)) / ecc_c;</div><div class="line">        r00_c = ke_c * std::atan2(1, ke_c);</div><div class="line">        <span class="keywordtype">double</span> ke2_c = ke_c * ke_c;</div><div class="line">        r01_c = 3 * ke2_c * (1 - r00_c);</div><div class="line">        r11_c = 3 * ((ke2_c + 1) * r00_c - ke2_c) / 2;</div><div class="line">        g_coeff_c = - 2.795007963255562e-10 * system_parameters::excess_rho * system_parameters::r_core_eq;</div><div class="line">}</div></div><!-- fragment --><p>std::cout &lt;&lt; "Loaded variables: ecc = " &lt;&lt; ecc_c &lt;&lt; " ke = " &lt;&lt; ke_c &lt;&lt; " r00 = " &lt;&lt; r00_c &lt;&lt; " r01 = " &lt;&lt; r01_c &lt;&lt; " r11 = " &lt;&lt; r11_c &lt;&lt; "\n";</p>
<div class="fragment"><div class="line">}</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ann-support_code/local_math.h"></a> </p><h1>Annotated version of support_code/local_math.h</h1>
<div class="fragment"><div class="line">/ *</div><div class="line"> * File:   localmath.h</div><div class="line"> * Author: antonermakov</div><div class="line"> *</div><div class="line"> * Created on September 21, 2013, 7:14 PM</div><div class="line"> * /</div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef LOCAL_MATH_</span></div><div class="line"><span class="preprocessor">#define LOCAL_MATH_</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define PI 3.14159265358979323846</span></div><div class="line"><span class="preprocessor">#define TWOPI 6.283185307179586476925287</span></div><div class="line"><span class="preprocessor">#define SECSINYEAR 3.155692608e+07</span></div><div class="line"><span class="preprocessor">#define MAX(x,y) ((x) &gt; (y)) ? (x) : (y)</span></div><div class="line"><span class="preprocessor">#define MIN(x,y) ((x) &lt; (y)) ? (x) : (y)</span></div></div><!-- fragment --><p>#define ABS(a) ((a) &lt; 0 ? -(a) : (a))</p>
<p>double factorial(int n) { if(n == 0) { return(1.); } else if(n == 1) { return(1.); } else if(n == 2) { return(2.); } else if(n == 3) { return(6.); } else if(n == 4) { return(24.); } else { exit(-1); } }</p>
<p>double fudge(int m) { if(m == 0) { return(1.0); } else { return(2.0); } }</p>
<p>double sign(double x) { if(x &gt; 0) { return(1.0); } else if(x &lt; 0.0) { return(-1.0); } else { return(0.0); } }</p>
<p>double pv0(double x) { double ans;</p>
<p>ans = x - TWOPI*floor(x/TWOPI); if(ans &gt; TWOPI/2.0) { ans = ans - TWOPI; }</p>
<p>return(ans); }</p>
<div class="fragment"><div class="line">/ * assumes <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>=2 * /</div></div><!-- fragment --><p>double System::Plm(int m, double x) { if(m == 0) { return(1.5*x*x - 0.5); } else if(m == 1) { return(3.0*x*sqrt(1.0 - x*x)); } else if(m == 2) { return(3.0 - 3.0*x*x); } else { exit(-1); } }</p>
<p>double System::DP(int m, double x) { if(m == 0) { return(3.0*x); } else if(m == 1) { return((3.0 - 6.0*x*x)/sqrt(1.0 - x*x)); } else if(m == 2) { return(- 6.0*x); } else { exit(-1); } }</p>
<div class="fragment"><div class="line"><span class="preprocessor">#endif        / * LOCALMATH_H * /</span></div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
