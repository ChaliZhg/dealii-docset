<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Vector&lt; Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Vector&lt; Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="vector_8h_source.html">deal.II/lac/vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Vector&lt; Number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classVector__inherit__graph.svg" width="914" height="198"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a74fcd04fb9b545c818ec5d451b8b0bcf"><td class="memItemLeft" align="right" valign="top">typedef Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a74fcd04fb9b545c818ec5d451b8b0bcf">value_type</a></td></tr>
<tr class="separator:a74fcd04fb9b545c818ec5d451b8b0bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d46c24827f5ac7ee25d91e897f6fe4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a></td></tr>
<tr class="separator:a07d46c24827f5ac7ee25d91e897f6fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic object handling</div></td></tr>
<tr class="memitem:a5424155269bd22011e9ff796e0c77e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5424155269bd22011e9ff796e0c77e69">Vector</a> ()</td></tr>
<tr class="separator:a5424155269bd22011e9ff796e0c77e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a55f3a1869eafb7680e44c3fe5c0f6d39">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4b48670b3f65d20c95a7528447f464"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8d4b48670b3f65d20c95a7528447f464">Vector</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v)</td></tr>
<tr class="separator:a8d4b48670b3f65d20c95a7528447f464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a9b9f407c4064e4d83796c5f5149aa1c0">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b274d95f514cbf3d4a934d5f5e7bef3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a6b274d95f514cbf3d4a934d5f5e7bef3">Vector</a> (const <a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> &amp;v)</td></tr>
<tr class="separator:a6b274d95f514cbf3d4a934d5f5e7bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dbb7642901ec9bb2eeb85ff99ba89c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aa5dbb7642901ec9bb2eeb85ff99ba89c">Vector</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:aa5dbb7642901ec9bb2eeb85ff99ba89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb6efe58ff7587ec88b542fe705bba6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a1bb6efe58ff7587ec88b542fe705bba6">Vector</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:a1bb6efe58ff7587ec88b542fe705bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80ce3a2f53c8eeba527e97266639826"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#af80ce3a2f53c8eeba527e97266639826">Vector</a> (const <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> &amp;v)</td></tr>
<tr class="separator:af80ce3a2f53c8eeba527e97266639826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de475367d8e8440fc32564a9178216f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2de475367d8e8440fc32564a9178216f">Vector</a> (const size_type n)</td></tr>
<tr class="separator:a2de475367d8e8440fc32564a9178216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441b2c23134f8e6e08c833f918888a2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:af441b2c23134f8e6e08c833f918888a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#af441b2c23134f8e6e08c833f918888a2">Vector</a> (const InputIterator first, const InputIterator last)</td></tr>
<tr class="separator:af441b2c23134f8e6e08c833f918888a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff98f0b79cf49711fad567855321592"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4ff98f0b79cf49711fad567855321592">~Vector</a> ()</td></tr>
<tr class="separator:a4ff98f0b79cf49711fad567855321592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8740c5534b6dbc31f4f1503a5e2a10a3">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6">VectorOperation::unknown</a>) const</td></tr>
<tr class="separator:a8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (const size_type N, const bool omit_zeroing_entries=false)</td></tr>
<tr class="separator:ac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4724e0d85120bda42159be96c493a702"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a4724e0d85120bda42159be96c493a702"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a4724e0d85120bda42159be96c493a702">reinit</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V, const bool omit_zeroing_entries=false)</td></tr>
<tr class="separator:a4724e0d85120bda42159be96c493a702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9818314bd7dc4e66849559f429e06151"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9818314bd7dc4e66849559f429e06151">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a9818314bd7dc4e66849559f429e06151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e835da7c35928e87f425f41ba30c2f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9e835da7c35928e87f425f41ba30c2f1">operator=</a> (const Number s)</td></tr>
<tr class="separator:a9e835da7c35928e87f425f41ba30c2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd12a193b97aa945190a9ce19a81e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5cd12a193b97aa945190a9ce19a81e18">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a5cd12a193b97aa945190a9ce19a81e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e4b7e0c68447743917278de469086f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a20e4b7e0c68447743917278de469086f">operator=</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v)</td></tr>
<tr class="separator:a20e4b7e0c68447743917278de469086f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#aa40c43480e8d2c50d0bb0a13421b7264">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v)</td></tr>
<tr class="separator:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b25ae266b150f897762592e56e5e649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5b25ae266b150f897762592e56e5e649">operator=</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a5b25ae266b150f897762592e56e5e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de6d056db5f16012dbf6f049645e15e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4de6d056db5f16012dbf6f049645e15e">operator=</a> (const <a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a> &amp;v)</td></tr>
<tr class="separator:a4de6d056db5f16012dbf6f049645e15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bce4b9a35a996ce804b9de6aee34d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a99bce4b9a35a996ce804b9de6aee34d6">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:a99bce4b9a35a996ce804b9de6aee34d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21d0e4ddcd2e645180487745e56692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d21d0e4ddcd2e645180487745e56692">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:a4d21d0e4ddcd2e645180487745e56692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5102b6d405b73ab5f3af4bd0c87c355e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5102b6d405b73ab5f3af4bd0c87c355e">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a> &amp;v)</td></tr>
<tr class="separator:a5102b6d405b73ab5f3af4bd0c87c355e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a226204eb09ef133f124ad2137c17f4"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a7a226204eb09ef133f124ad2137c17f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a7a226204eb09ef133f124ad2137c17f4">operator==</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a7a226204eb09ef133f124ad2137c17f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ee1076dfadf9933073247e56e80c7"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a082ee1076dfadf9933073247e56e80c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a082ee1076dfadf9933073247e56e80c7">operator!=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a082ee1076dfadf9933073247e56e80c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scalar products, norms and related operations</div></td></tr>
<tr class="memitem:a2371854d97a2f717da3170b72e2a58e8"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a2371854d97a2f717da3170b72e2a58e8"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a2371854d97a2f717da3170b72e2a58e8">operator*</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V) const</td></tr>
<tr class="separator:a2371854d97a2f717da3170b72e2a58e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5a995087a003f81fa5b74513e13677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aad5a995087a003f81fa5b74513e13677">norm_sqr</a> () const</td></tr>
<tr class="separator:aad5a995087a003f81fa5b74513e13677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d47f6cd8a2b9ec62f133e7d303b745"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a33d47f6cd8a2b9ec62f133e7d303b745">mean_value</a> () const</td></tr>
<tr class="separator:a33d47f6cd8a2b9ec62f133e7d303b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aeaa8fc05dd5a8a8f9560a5de096ebb4e">l1_norm</a> () const</td></tr>
<tr class="separator:aeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a> () const</td></tr>
<tr class="separator:a8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708e76373444e3b1d12dbee72f5d32b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a708e76373444e3b1d12dbee72f5d32b9">lp_norm</a> (const <a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a> p) const</td></tr>
<tr class="separator:a708e76373444e3b1d12dbee72f5d32b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">linfty_norm</a> () const</td></tr>
<tr class="separator:a9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3659971dfc5e53759da2be27d702d078"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a3659971dfc5e53759da2be27d702d078">add_and_dot</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:a3659971dfc5e53759da2be27d702d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access</div></td></tr>
<tr class="memitem:af34b888fe493ef2ed188179de69ad7ed"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#af34b888fe493ef2ed188179de69ad7ed">begin</a> ()</td></tr>
<tr class="separator:af34b888fe493ef2ed188179de69ad7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710df6df8902b609158fa277f216d146"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a710df6df8902b609158fa277f216d146">begin</a> () const</td></tr>
<tr class="separator:a710df6df8902b609158fa277f216d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">end</a> ()</td></tr>
<tr class="separator:a7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#abc9d45917e1f6cd2ba60dc4aef430ce9">end</a> () const</td></tr>
<tr class="separator:abc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3af32d65459fad49b43d41ec7e848c3"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad3af32d65459fad49b43d41ec7e848c3">operator()</a> (const size_type i) const</td></tr>
<tr class="separator:ad3af32d65459fad49b43d41ec7e848c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1268a6b336ee46bd8b2ac746cbe82643"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a1268a6b336ee46bd8b2ac746cbe82643">operator()</a> (const size_type i)</td></tr>
<tr class="separator:a1268a6b336ee46bd8b2ac746cbe82643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5c137f6bd56f1fad54a13a8cc46f5b12">operator[]</a> (const size_type i) const</td></tr>
<tr class="separator:a5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7bafc88c457dbc2e7db6a533d35391"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d7bafc88c457dbc2e7db6a533d35391">operator[]</a> (const size_type i)</td></tr>
<tr class="separator:a4d7bafc88c457dbc2e7db6a533d35391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#ae406cc28ed782932504a186ba1c5f9e8">extract_subvector_to</a> (const std::vector&lt; size_type &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;values) const</td></tr>
<tr class="separator:ae406cc28ed782932504a186ba1c5f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ae7a1b9cf454549e0925103208cc5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a079ae7a1b9cf454549e0925103208cc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a079ae7a1b9cf454549e0925103208cc5">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:a079ae7a1b9cf454549e0925103208cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification of vectors</div></td></tr>
<tr class="memitem:a0b2abb4f2a3a722b30165373ea982a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0b2abb4f2a3a722b30165373ea982a50">operator+=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a0b2abb4f2a3a722b30165373ea982a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603f91549c76b084a88e47d8824997ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a603f91549c76b084a88e47d8824997ab">operator-=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a603f91549c76b084a88e47d8824997ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b0336c485e36c7b4b105dd2a926002"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a10b0336c485e36c7b4b105dd2a926002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a> (const std::vector&lt; size_type &gt; &amp;indices, const std::vector&lt; OtherNumber &gt; &amp;values)</td></tr>
<tr class="separator:a10b0336c485e36c7b4b105dd2a926002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a1e611de68e9631791cebf3736c86"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:aeb5a1e611de68e9631791cebf3736c86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#aeb5a1e611de68e9631791cebf3736c86">add</a> (const std::vector&lt; size_type &gt; &amp;indices, const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;values)</td></tr>
<tr class="separator:aeb5a1e611de68e9631791cebf3736c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1770cabeceaf722763742cdc1e10ba"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:acd1770cabeceaf722763742cdc1e10ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#acd1770cabeceaf722763742cdc1e10ba">add</a> (const size_type n_elements, const size_type *indices, const OtherNumber *values)</td></tr>
<tr class="separator:acd1770cabeceaf722763742cdc1e10ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b264924f2c8dc130e0be826f40e0da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2b264924f2c8dc130e0be826f40e0da0">add</a> (const Number s)</td></tr>
<tr class="separator:a2b264924f2c8dc130e0be826f40e0da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f573343d5a9777514210f8775d3f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a86f573343d5a9777514210f8775d3f49">add</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V) 1</td></tr>
<tr class="separator:a86f573343d5a9777514210f8775d3f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141369afc3169fc80597a7d70fa7b7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a141369afc3169fc80597a7d70fa7b7a6">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:a141369afc3169fc80597a7d70fa7b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0643f15938ef8dc4727d90405cf83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aae0643f15938ef8dc4727d90405cf83f">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:aae0643f15938ef8dc4727d90405cf83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7126299241702719e409f59c0ec07d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a7126299241702719e409f59c0ec07d51">sadd</a> (const Number s, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a7126299241702719e409f59c0ec07d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2bb04de50473779d407149dec7be9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2d2bb04de50473779d407149dec7be9f">sadd</a> (const Number s, const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a2d2bb04de50473779d407149dec7be9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4267a96046e472e11e7e8e040c10721d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4267a96046e472e11e7e8e040c10721d">sadd</a> (const Number s, const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W) 1</td></tr>
<tr class="separator:a4267a96046e472e11e7e8e040c10721d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01847573e1ed4665ff29c81c0f8afb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aa01847573e1ed4665ff29c81c0f8afb6">sadd</a> (const Number s, const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W, const Number c, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;X) 1</td></tr>
<tr class="separator:aa01847573e1ed4665ff29c81c0f8afb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3e7e9460e7395dd67b95e61dd87d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4f3e7e9460e7395dd67b95e61dd87d37">operator*=</a> (const Number factor)</td></tr>
<tr class="separator:a4f3e7e9460e7395dd67b95e61dd87d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4263fde23b0a636562ca9751d51b5e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4263fde23b0a636562ca9751d51b5e4a">operator/=</a> (const Number factor)</td></tr>
<tr class="separator:a4263fde23b0a636562ca9751d51b5e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956ed8a13546e788464672e88057b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aa956ed8a13546e788464672e88057b65">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:aa956ed8a13546e788464672e88057b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a0a3d0f3f7fb1a7d6196a0def1bacf371">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feedb1e66657dcc91855748c936879a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5feedb1e66657dcc91855748c936879a">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u)</td></tr>
<tr class="separator:a5feedb1e66657dcc91855748c936879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#ab59511c3b4ce9b3fe8454c8657234a25">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;u)</td></tr>
<tr class="separator:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0765d1e862499ab56035bf4ae5b19de4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0765d1e862499ab56035bf4ae5b19de4">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v) 1</td></tr>
<tr class="separator:a0765d1e862499ab56035bf4ae5b19de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab365f187325669a78b6add77e45a5860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ab365f187325669a78b6add77e45a5860">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v, const Number c, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;w) 1</td></tr>
<tr class="separator:ab365f187325669a78b6add77e45a5860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac194da670d449ccf2084163013e08a5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ac194da670d449ccf2084163013e08a5e">ratio</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;b) 1</td></tr>
<tr class="separator:ac194da670d449ccf2084163013e08a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50dd04b204d8ebf6be467c3ebe2234f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae50dd04b204d8ebf6be467c3ebe2234f">update_ghost_values</a> () const</td></tr>
<tr class="separator:ae50dd04b204d8ebf6be467c3ebe2234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input and output</div></td></tr>
<tr class="memitem:a0286df9826dc7754ecff86ea651d8178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0286df9826dc7754ecff86ea651d8178">print</a> (const char *format=nullptr) const 1</td></tr>
<tr class="separator:a0286df9826dc7754ecff86ea651d8178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d43302d459c7cb6ae4b5bad13d31507">print</a> (std::ostream &amp;out, const unsigned int precision=3, const bool scientific=true, const bool across=true) const</td></tr>
<tr class="separator:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6df3b5d4bf9184688950ce7fcb3194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#acc6df3b5d4bf9184688950ce7fcb3194">print</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out, const unsigned int width=6, const bool across=true) const 1</td></tr>
<tr class="separator:acc6df3b5d4bf9184688950ce7fcb3194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f18ed7d00d429247dc3127ba496e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a31f18ed7d00d429247dc3127ba496e42">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a31f18ed7d00d429247dc3127ba496e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d77409b8591a13d5ee10c2e705593a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a57d77409b8591a13d5ee10c2e705593a">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a57d77409b8591a13d5ee10c2e705593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a9c9b9333d11630bf0fc82a7957e0d1c1">save</a> (Archive &amp;ar, const unsigned int version) const</td></tr>
<tr class="separator:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a3b7a75b54cfee3d921a467f2ca126b54">load</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about the object</div></td></tr>
<tr class="memitem:a21bdbe031534857b865272b4e986b830"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a21bdbe031534857b865272b4e986b830">in_local_range</a> (const size_type global_index) const</td></tr>
<tr class="separator:a21bdbe031534857b865272b4e986b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6b216c32fbf2cddb2466a8033ad3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aac6b216c32fbf2cddb2466a8033ad3e6">locally_owned_elements</a> () const</td></tr>
<tr class="separator:aac6b216c32fbf2cddb2466a8033ad3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8005bf1ec399c608c3755c1d22960add"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a> () const</td></tr>
<tr class="separator:a8005bf1ec399c608c3755c1d22960add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae72a04de37cc5ba8f0263809a59ec99e">all_zero</a> () const</td></tr>
<tr class="separator:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e23a22888630c9874cbddf8bcccdf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad8e23a22888630c9874cbddf8bcccdf5">is_non_negative</a> () const</td></tr>
<tr class="separator:ad8e23a22888630c9874cbddf8bcccdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea73d2cb54e87b69a9b7cdb17ed274df"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aea73d2cb54e87b69a9b7cdb17ed274df">memory_consumption</a> () const</td></tr>
<tr class="separator:aea73d2cb54e87b69a9b7cdb17ed274df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2e99f8753b7634734243e9f66e307b86"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2e99f8753b7634734243e9f66e307b86">supports_distributed_data</a> = false</td></tr>
<tr class="separator:a2e99f8753b7634734243e9f66e307b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a25df23a5447341690518d92427f4c389"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a25df23a5447341690518d92427f4c389">vec_size</a></td></tr>
<tr class="separator:a25df23a5447341690518d92427f4c389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ae4028baa6c4debf53c36ff7768dcb"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae1ae4028baa6c4debf53c36ff7768dcb">max_vec_size</a></td></tr>
<tr class="separator:ae1ae4028baa6c4debf53c36ff7768dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4ec94ca7ad6d391900a1ea38cabbec"><td class="memItemLeft" align="right" valign="top">Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aca4ec94ca7ad6d391900a1ea38cabbec">val</a></td></tr>
<tr class="separator:aca4ec94ca7ad6d391900a1ea38cabbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566a66df753d0a75121aa84fa4164d56"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; parallel::internal::TBBPartitioner &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a566a66df753d0a75121aa84fa4164d56">thread_loop_partitioner</a></td></tr>
<tr class="separator:a566a66df753d0a75121aa84fa4164d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3c212d060a7cd84141fc3190ad6c5fb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a3c212d060a7cd84141fc3190ad6c5fb5">allocate</a> ()</td></tr>
<tr class="separator:a3c212d060a7cd84141fc3190ad6c5fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f62f9dc4899c0bd70be4c56e78b56fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8f62f9dc4899c0bd70be4c56e78b56fd">deallocate</a> ()</td></tr>
<tr class="separator:a8f62f9dc4899c0bd70be4c56e78b56fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a879f896329da9659f538e8dc9d386087"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a879f896329da9659f538e8dc9d386087"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a879f896329da9659f538e8dc9d386087">Vector</a></td></tr>
<tr class="separator:a879f896329da9659f538e8dc9d386087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380a36584c7594936d68501e914bc28c"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a380a36584c7594936d68501e914bc28c"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a380a36584c7594936d68501e914bc28c">LAPACKFullMatrix</a></td></tr>
<tr class="separator:a380a36584c7594936d68501e914bc28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bdd8777c5d982b4907118a22bd540a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad1bdd8777c5d982b4907118a22bd540a">VectorView&lt; Number &gt;</a></td></tr>
<tr class="separator:ad1bdd8777c5d982b4907118a22bd540a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4042ae66239bc28379e93c53dea344b8"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a4042ae66239bc28379e93c53dea344b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a4042ae66239bc28379e93c53dea344b8">swap</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &amp;u, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a4042ae66239bc28379e93c53dea344b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52ed1088f622c49c50dc4bf9638863"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a2e52ed1088f622c49c50dc4bf9638863"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a2e52ed1088f622c49c50dc4bf9638863">swap</a> (<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;u, <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a2e52ed1088f622c49c50dc4bf9638863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga77cffd135b29b32a9d77a1bcdef4b95a">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u, <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Number&gt;<br />
class Vector&lt; Number &gt;</h3>

<p>Numerical vector of data. For this class there are different types of functions available. The first type of function initializes the vector, changes its size, or computes the norm of the vector in order to measure its length in a suitable norm. The second type helps us to manipulate the components of the vector. The third type defines the algebraic operations for vectors, while the last type defines a few input and output functions. As opposed to the array of the C++ standard library called <code>vector</code> (with a lowercase "v"), this class implements an element of a vector space suitable for numerical computations.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt;, &lt;double&gt;, &lt;std::complex&lt;float&gt;&gt;, &lt;std::complex&lt;double&gt;&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Guido Kanschat, Franz-Theo Suttmeier, Wolfgang Bangerth </dd></dl>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00034">34</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a74fcd04fb9b545c818ec5d451b8b0bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fcd04fb9b545c818ec5d451b8b0bcf">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a74fcd04fb9b545c818ec5d451b8b0bcf">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare standard types used in all containers. These types parallel those in the <code>C++</code> standard libraries <code>vector&lt;...&gt;</code> class. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00137">137</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a07d46c24827f5ac7ee25d91e897f6fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d46c24827f5ac7ee25d91e897f6fe4">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a type that has holds real-valued numbers with the same precision as the template argument to this class. If the template argument of this class is a real data type, then real_type equals the template argument. If the template argument is a std::complex type then real_type equals the type underlying the complex numbers.</p>
<p>This typedef is used to represent the return type of norms. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00155">155</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5424155269bd22011e9ff796e0c77e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5424155269bd22011e9ff796e0c77e69">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create a vector of dimension zero. </p>

</div>
</div>
<a id="a55f3a1869eafb7680e44c3fe5c0f6d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f3a1869eafb7680e44c3fe5c0f6d39">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Sets the dimension to that of the given vector, and copies all elements.</p>
<p>We would like to make this constructor explicit, but standard containers insist on using it implicitly. </p>

</div>
</div>
<a id="a8d4b48670b3f65d20c95a7528447f464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4b48670b3f65d20c95a7528447f464">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor. Creates a new vector by stealing the internal data of the vector <code>v</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is only available if deal.II is configured with C++11 support. </dd></dl>

</div>
</div>
<a id="a9b9f407c4064e4d83796c5f5149aa1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9f407c4064e4d83796c5f5149aa1c0">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking a vector of another data type. This will fail if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. Note that you may lose accuracy when copying to a vector with data elements with less accuracy.</p>
<p>Older versions of gcc did not honor the <code>explicit</code> keyword on template constructors. In such cases, it is easy to accidentally write code that can be very inefficient, since the compiler starts performing hidden conversions. To avoid this, this function is disabled if we have detected a broken compiler during configuration. </p>

</div>
</div>
<a id="a6b274d95f514cbf3d4a934d5f5e7bef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b274d95f514cbf3d4a934d5f5e7bef3">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a sequential PETSc wrapper vector class. This copy constructor is only available if PETSc was detected during configuration time. </p>

</div>
</div>
<a id="aa5dbb7642901ec9bb2eeb85ff99ba89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5dbb7642901ec9bb2eeb85ff99ba89c">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a parallel PETSc wrapper vector class. This copy constructor is only available if PETSc was detected during configuration time.</p>
<p>Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time. I.e., it is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="a1bb6efe58ff7587ec88b542fe705bba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb6efe58ff7587ec88b542fe705bba6">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a Trilinos wrapper vector. This copy constructor is only available if Trilinos was detected during configuration time.</p>
<p>Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time. This means that it is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. This call will rather result in a copy of the vector on all processors. </p>

</div>
</div>
<a id="af80ce3a2f53c8eeba527e97266639826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80ce3a2f53c8eeba527e97266639826">&#9670;&nbsp;</a></span>Vector() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a localized Trilinos wrapper vector. This copy constructor is only available if Trilinos was detected during configuration time. </p>

</div>
</div>
<a id="a2de475367d8e8440fc32564a9178216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de475367d8e8440fc32564a9178216f">&#9670;&nbsp;</a></span>Vector() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Set dimension to <code>n</code> and initialize all elements with zero.</p>
<p>The constructor is made explicit to avoid accidents like this: <code>v=0;</code>. Presumably, the user wants to set every element of the vector to zero, but instead, what happens is this call: <code>v=<a class="el" href="classVector.html">Vector</a>&lt;number&gt;(0);</code>, i.e. the vector is replaced by one of length zero. </p>

</div>
</div>
<a id="af441b2c23134f8e6e08c833f918888a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441b2c23134f8e6e08c833f918888a2">&#9670;&nbsp;</a></span>Vector() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the vector with a given range of values pointed to by the iterators. This function is there in analogy to the <code>std::vector</code> class. </p>

</div>
</div>
<a id="a4ff98f0b79cf49711fad567855321592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff98f0b79cf49711fad567855321592">&#9670;&nbsp;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::~<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor, deallocates memory. Made virtual to allow for derived classes to behave properly. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8740c5534b6dbc31f4f1503a5e2a10a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8740c5534b6dbc31f4f1503a5e2a10a3">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em> = <code>::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6">VectorOperation::unknown</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but is there for compatibility with the <code><a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a></code> class.</p>
<p>For the PETSc vector wrapper class, this function compresses the underlying representation of the PETSc object, i.e. flushes the buffers of the vector object if it has any. This function is necessary after writing into a vector element-by-element and before anything else can be done on it.</p>
<p>However, for the implementation of this class, it is immaterial and thus an empty function. </p>

</div>
</div>
<a id="ac4a4dbef7dd65ef8ad35ae56b57d7c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a4dbef7dd65ef8ad35ae56b57d7c05">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension of the vector to <code>N</code>. The reserved memory for this vector remains unchanged if possible, to make things faster; this may waste some memory, so keep this in mind. However, if <code>N==0</code> all memory is freed, i.e. if you want to resize the vector and release the memory not needed, you have to first call <code>reinit(0)</code> and then <code>reinit(N)</code>. This cited behaviour is analogous to that of the standard library containers.</p>
<p>If <code>omit_zeroing_entries</code> is false, the vector is filled by zeros. Otherwise, the elements are left an unspecified state.</p>
<p>This function is virtual in order to allow for derived classes to handle memory separately. </p>

<p>Reimplemented in <a class="el" href="classVectorView.html#a8979291c6adbe5522b0154135508cdcd">VectorView&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a4724e0d85120bda42159be96c493a702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4724e0d85120bda42159be96c493a702">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector <code>V</code>. The same applies as for the other <code>reinit</code> function.</p>
<p>The elements of <code>V</code> are not copied, i.e. this function is the same as calling <code>reinit (V.size(), omit_zeroing_entries)</code>. </p>

</div>
</div>
<a id="a9818314bd7dc4e66849559f429e06151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9818314bd7dc4e66849559f429e06151">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions.</p>
<p>This function is virtual in order to allow for derived classes to handle memory separately. </p>

<p>Reimplemented in <a class="el" href="classVectorView.html#a6ac3b929084512c78f876f88607e2f1f">VectorView&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a9e835da7c35928e87f425f41ba30c2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e835da7c35928e87f425f41ba30c2f1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all components of the vector to the given number <code>s</code>. Simply pass this down to the individual block objects, but we still need to declare this function to make the example given in the discussion about making the constructor explicit work.</p>
<p>Since the semantics of assigning a scalar to a vector are not immediately clear, this operator should really only be used if you want to set the entire vector to zero. This allows the intuitive notation <code>v=0</code>. Assigning other values is deprecated and may be disallowed in the future.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a5cd12a193b97aa945190a9ce19a81e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd12a193b97aa945190a9ce19a81e18">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a20e4b7e0c68447743917278de469086f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e4b7e0c68447743917278de469086f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move the given vector. This operator replaces the present vector with the internal data of the vector <code>v</code> and resets <code>v</code> to the state it would have after being newly default-constructed.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is only available if deal.II is configured with C++11 support. </dd></dl>

</div>
</div>
<a id="aa40c43480e8d2c50d0bb0a13421b7264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40c43480e8d2c50d0bb0a13421b7264">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a5b25ae266b150f897762592e56e5e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b25ae266b150f897762592e56e5e649">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for assigning a block vector to a regular vector. </p>

</div>
</div>
<a id="a4de6d056db5f16012dbf6f049645e15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de6d056db5f16012dbf6f049645e15e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a sequential PETSc wrapper vector class. This operator is only available if PETSc was detected during configuration time. </p>

</div>
</div>
<a id="a99bce4b9a35a996ce804b9de6aee34d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bce4b9a35a996ce804b9de6aee34d6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a parallel PETSc wrapper vector class. This operator is only available if PETSc was detected during configuration time.</p>
<p>Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time. I.e., it is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="a4d21d0e4ddcd2e645180487745e56692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d21d0e4ddcd2e645180487745e56692">&#9670;&nbsp;</a></span>operator=() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a (sequential or parallel, depending on the underlying compiler) Trilinos wrapper vector class. This operator is only available if Trilinos was detected during configuration time.</p>
<p>Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time. I.e., it is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="a5102b6d405b73ab5f3af4bd0c87c355e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5102b6d405b73ab5f3af4bd0c87c355e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a> &amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1Vector.html">TrilinosWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a sequential Trilinos wrapper vector class. This operator is only available if Trilinos was detected during configuration time. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00580">580</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a7a226204eb09ef133f124ad2137c17f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a226204eb09ef133f124ad2137c17f4">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="a082ee1076dfadf9933073247e56e80c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082ee1076dfadf9933073247e56e80c7">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for inequality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="a2371854d97a2f717da3170b72e2a58e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2371854d97a2f717da3170b72e2a58e8">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. The return type is the underlying type of <code>this</code> vector, so the return type and the accuracy with which it the result is computed depend on the order of the arguments of this vector.</p>
<p>For complex vectors, the scalar product is implemented as <img class="formulaInl" alt="$\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}$" src="form_1132.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="aad5a995087a003f81fa5b74513e13677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5a995087a003f81fa5b74513e13677">&#9670;&nbsp;</a></span>norm_sqr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return square of the <img class="formulaInl" alt="$l_2$" src="form_111.png"/>-norm.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a33d47f6cd8a2b9ec62f133e7d303b745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d47f6cd8a2b9ec62f133e7d303b745">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean value of the elements of this vector.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="aeaa8fc05dd5a8a8f9560a5de096ebb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa8fc05dd5a8a8f9560a5de096ebb4e">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><img class="formulaInl" alt="$l_1$" src="form_488.png"/>-norm of the vector. The sum of the absolute values.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a8ee1b8309a7a9ecf109c8a7116733ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee1b8309a7a9ecf109c8a7116733ef8">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><img class="formulaInl" alt="$l_2$" src="form_111.png"/>-norm of the vector. The square root of the sum of the squares of the elements.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a708e76373444e3b1d12dbee72f5d32b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708e76373444e3b1d12dbee72f5d32b9">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><img class="formulaInl" alt="$l_p$" src="form_1038.png"/>-norm of the vector. The pth root of the sum of the pth powers of the absolute values of the elements.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a9f6b7f7afb05aaff7e1ab8f9942b6dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6b7f7afb05aaff7e1ab8f9942b6dae">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a07d46c24827f5ac7ee25d91e897f6fe4">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum absolute value of the elements. </p>

</div>
</div>
<a id="a3659971dfc5e53759da2be27d702d078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3659971dfc5e53759da2be27d702d078">&#9670;&nbsp;</a></span>add_and_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(a, V);</div><div class="line">return_value = *<span class="keyword">this</span> * W;</div></div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="af34b888fe493ef2ed188179de69ad7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34b888fe493ef2ed188179de69ad7ed">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <code><a class="el" href="classVector.html">Vector</a></code> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the elements of this vector. </p>

</div>
</div>
<a id="a710df6df8902b609158fa277f216d146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710df6df8902b609158fa277f216d146">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the vectors. </p>

</div>
</div>
<a id="a7a2a770cb19d3e5b0b69b08ffc88184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2a770cb19d3e5b0b69b08ffc88184f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="abc9d45917e1f6cd2ba60dc4aef430ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9d45917e1f6cd2ba60dc4aef430ce9">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="ad3af32d65459fad49b43d41ec7e848c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3af32d65459fad49b43d41ec7e848c3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component. </p>

</div>
</div>
<a id="a1268a6b336ee46bd8b2ac746cbe82643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1268a6b336ee46bd8b2ac746cbe82643">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference. </p>

</div>
</div>
<a id="a5c137f6bd56f1fad54a13a8cc46f5b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c137f6bd56f1fad54a13a8cc46f5b12">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="a4d7bafc88c457dbc2e7db6a533d35391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7bafc88c457dbc2e7db6a533d35391">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="ae406cc28ed782932504a186ba1c5f9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae406cc28ed782932504a186ba1c5f9e8">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collective get operation: instead of getting individual elements of a vector, this function allows to get a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second. </p>

</div>
</div>
<a id="a079ae7a1b9cf454549e0925103208cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ae7a1b9cf454549e0925103208cc5">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Just as the above, but with pointers. Useful in minimizing copying of data around. </p>

</div>
</div>
<a id="a0b2abb4f2a3a722b30165373ea982a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2abb4f2a3a722b30165373ea982a50">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given vector to the present one.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a603f91549c76b084a88e47d8824997ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603f91549c76b084a88e47d8824997ab">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract the given vector from the present one.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a10b0336c485e36c7b4b105dd2a926002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b0336c485e36c7b4b105dd2a926002">&#9670;&nbsp;</a></span>add() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="aeb5a1e611de68e9631791cebf3736c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5a1e611de68e9631791cebf3736c86">&#9670;&nbsp;</a></span>add() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a second collective add operation. As a difference, this function takes a deal.II vector of values. </p>

</div>
</div>
<a id="acd1770cabeceaf722763742cdc1e10ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1770cabeceaf722763742cdc1e10ba">&#9670;&nbsp;</a></span>add() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where <code>n_elements</code> are stored contiguously and add them into the vector. Handles all cases which are not covered by the other two <code><a class="el" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add()</a></code> functions above. </p>

</div>
</div>
<a id="a2b264924f2c8dc130e0be826f40e0da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b264924f2c8dc130e0be826f40e0da0">&#9670;&nbsp;</a></span>add() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of <code>s</code> to all components. Note that <code>s</code> is a scalar and not a vector.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a86f573343d5a9777514210f8775d3f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f573343d5a9777514210f8775d3f49">&#9670;&nbsp;</a></span>add() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple vector addition, equal to the <code>operator +=</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000097">Deprecated:</a></b></dt><dd>Use the <code>operator +=</code> instead.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a141369afc3169fc80597a7d70fa7b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141369afc3169fc80597a7d70fa7b7a6">&#9670;&nbsp;</a></span>add() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aae0643f15938ef8dc4727d90405cf83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0643f15938ef8dc4727d90405cf83f">&#9670;&nbsp;</a></span>add() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a7126299241702719e409f59c0ec07d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7126299241702719e409f59c0ec07d51">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code>*this = s*(*this)+V</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a2d2bb04de50473779d407149dec7be9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2bb04de50473779d407149dec7be9f">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple addition, i.e. <code>*this = s*(*this)+a*V</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a4267a96046e472e11e7e8e040c10721d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4267a96046e472e11e7e8e040c10721d">&#9670;&nbsp;</a></span>sadd() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and multiple addition.</p>
<p>This function is deprecated.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aa01847573e1ed4665ff29c81c0f8afb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01847573e1ed4665ff29c81c0f8afb6">&#9670;&nbsp;</a></span>sadd() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and multiple addition. <code>*this = s*(*this)+a*V + b*W + c*X</code>.</p>
<p>This function is deprecated.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a4f3e7e9460e7395dd67b95e61dd87d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3e7e9460e7395dd67b95e61dd87d37">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by a constant value.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a4263fde23b0a636562ca9751d51b5e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4263fde23b0a636562ca9751d51b5e4a">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by the inverse of the given value.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aa956ed8a13546e788464672e88057b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa956ed8a13546e788464672e88057b65">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a0a3d0f3f7fb1a7d6196a0def1bacf371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3d0f3f7fb1a7d6196a0def1bacf371">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

</div>
</div>
<a id="a5feedb1e66657dcc91855748c936879a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5feedb1e66657dcc91855748c936879a">&#9670;&nbsp;</a></span>equ() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ab59511c3b4ce9b3fe8454c8657234a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59511c3b4ce9b3fe8454c8657234a25">&#9670;&nbsp;</a></span>equ() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>. </p>

</div>
</div>
<a id="a0765d1e862499ab56035bf4ae5b19de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0765d1e862499ab56035bf4ae5b19de4">&#9670;&nbsp;</a></span>equ() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u + b*v</code>.</p>
<p>This function is deprecated.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ab365f187325669a78b6add77e45a5860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab365f187325669a78b6add77e45a5860">&#9670;&nbsp;</a></span>equ() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u + b*v + b*w</code>.</p>
<p>This function is deprecated.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ac194da670d449ccf2084163013e08a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac194da670d449ccf2084163013e08a5e">&#9670;&nbsp;</a></span>ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::ratio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the elementwise ratio of the two given vectors, that is let <code>this[i] = a[i]/b[i]</code>. This is useful for example if you want to compute the cellwise ratio of true to estimated error.</p>
<p>This vector is appropriately scaled to hold the result.</p>
<p>If any of the <code>b[i]</code> is zero, the result is undefined. No attempt is made to catch such situations.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ae50dd04b204d8ebf6be467c3ebe2234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50dd04b204d8ebf6be467c3ebe2234f">&#9670;&nbsp;</a></span>update_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but is there for compatibility with the <code><a class="el" href="classPETScWrappers_1_1Vector.html">PETScWrappers::Vector</a></code> class.</p>
<p>For the PETSc vector wrapper class, this function updates the ghost values of the PETSc vector. This is necessary after any modification before reading ghost values.</p>
<p>However, for the implementation of this class, it is immaterial and thus an empty function. </p>

</div>
</div>
<a id="a0286df9826dc7754ecff86ea651d8178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0286df9826dc7754ecff86ea651d8178">&#9670;&nbsp;</a></span>print() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output of vector in user-defined format. For complex-valued vectors, the format should include specifiers for both the real and imaginary parts.</p>
<p>This function is deprecated. </p>

</div>
</div>
<a id="a4d43302d459c7cb6ae4b5bad13d31507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d43302d459c7cb6ae4b5bad13d31507">&#9670;&nbsp;</a></span>print() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to a stream. <code>precision</code> denotes the desired precision with which values shall be printed, <code>scientific</code> whether scientific notation shall be used. If <code>across</code> is <code>true</code> then the vector is printed in a line, while if <code>false</code> then the elements are printed on a separate line each. </p>

</div>
</div>
<a id="acc6df3b5d4bf9184688950ce7fcb3194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6df3b5d4bf9184688950ce7fcb3194">&#9670;&nbsp;</a></span>print() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>width</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to a <a class="el" href="classLogStream.html">LogStream</a>. <code>width</code> is used as argument to the std::setw manipulator, if printing across. If <code>across</code> is <code>true</code> then the vector is printed in a line, while if <code>false</code> then the elements are printed on a separate line each.</p>
<p>This function is deprecated. </p>

</div>
</div>
<a id="a31f18ed7d00d429247dc3127ba496e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f18ed7d00d429247dc3127ba496e42">&#9670;&nbsp;</a></span>block_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the vector en bloc to a file. This is done in a binary mode, so the output is neither readable by humans nor (probably) by other computers using a different operating system or number format. </p>

</div>
</div>
<a id="a57d77409b8591a13d5ee10c2e705593a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d77409b8591a13d5ee10c2e705593a">&#9670;&nbsp;</a></span>block_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a vector en block from a file. This is done using the inverse operations to the above function, so it is reasonably fast because the bitstream is not interpreted.</p>
<p>The vector is resized if necessary.</p>
<p>A primitive form of error checking is performed which will recognize the bluntest attempts to interpret some data as a vector stored bitwise to a file, but not more. </p>

</div>
</div>
<a id="a9c9b9333d11630bf0fc82a7957e0d1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9b9333d11630bf0fc82a7957e0d1c1">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization. </p>

</div>
</div>
<a id="a3b7a75b54cfee3d921a467f2ca126b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a75b54cfee3d921a467f2ca126b54">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization. </p>

</div>
</div>
<a id="a21bdbe031534857b865272b4e986b830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bdbe031534857b865272b4e986b830">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given global index is in the local range of this processor. Since this is not a distributed vector the method always returns true. </p>

</div>
</div>
<a id="aac6b216c32fbf2cddb2466a8033ad3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6b216c32fbf2cddb2466a8033ad3e6">&#9670;&nbsp;</a></span>locally_owned_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. Note that this index set does not include elements this vector may store locally as ghost elements but that are in fact owned by another processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == complete_index_set (vec.size())</div></div><!-- fragment --><p>Since the current data type does not support parallel data storage across different processors, the returned index set is the complete index set. </p>

</div>
</div>
<a id="a8005bf1ec399c608c3755c1d22960add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8005bf1ec399c608c3755c1d22960add">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return dimension of the vector. </p>

</div>
</div>
<a id="ae72a04de37cc5ba8f0263809a59ec99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72a04de37cc5ba8f0263809a59ec99e">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. This function is mainly for internal consistency checks and should seldom be used when not in debug mode since it uses quite some time. </p>

</div>
</div>
<a id="ad8e23a22888630c9874cbddf8bcccdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e23a22888630c9874cbddf8bcccdf5">&#9670;&nbsp;</a></span>is_non_negative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::is_non_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vector has no negative entries, i.e. all entries are zero or positive. This function is used, for example, to check whether refinement indicators are really all positive (or zero).</p>
<p>The function obviously only makes sense if the template argument of this class is a real type. If it is a complex type, then an exception is thrown. </p>

</div>
</div>
<a id="aea73d2cb54e87b69a9b7cdb17ed274df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea73d2cb54e87b69a9b7cdb17ed274df">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a3c212d060a7cd84141fc3190ad6c5fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c212d060a7cd84141fc3190ad6c5fb5">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate and align <code>val</code> along 64-byte boundaries. The size of the allocated memory is determined by <code>max_vec_size</code> . </p>

</div>
</div>
<a id="a8f62f9dc4899c0bd70be4c56e78b56fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f62f9dc4899c0bd70be4c56e78b56fd">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocate <code>val</code>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a879f896329da9659f538e8dc9d386087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879f896329da9659f538e8dc9d386087">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classVector.html">Vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make all other vector types friends.</p>
<p>Make all other ReadWriteVector types friends.</p>
<p>Typedef for the vector type used. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01021">1021</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a380a36584c7594936d68501e914bc28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380a36584c7594936d68501e914bc28c">&#9670;&nbsp;</a></span>LAPACKFullMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLAPACKFullMatrix.html">LAPACKFullMatrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LAPACK matrices need access to the data. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01026">1026</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ad1bdd8777c5d982b4907118a22bd540a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bdd8777c5d982b4907118a22bd540a">&#9670;&nbsp;</a></span>VectorView< Number ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classVectorView.html">VectorView</a>&lt; Number &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVectorView.html">VectorView</a> will access the pointer. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01031">1031</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a4042ae66239bc28379e93c53dea344b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4042ae66239bc28379e93c53dea344b8">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors.</p>
<dl class="section author"><dt>Author</dt><dd>Katharina Kormann, Martin Kronbichler, 2011 </dd></dl>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01473">1473</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a2e52ed1088f622c49c50dc4bf9638863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e52ed1088f622c49c50dc4bf9638863">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l00923">923</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2e99f8753b7634734243e9f66e307b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e99f8753b7634734243e9f66e307b86">&#9670;&nbsp;</a></span>supports_distributed_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::supports_distributed_data = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A variable that indicates whether this vector supports distributed data storage. If true, then this vector also needs an appropriate <a class="el" href="classVector.html#a8740c5534b6dbc31f4f1503a5e2a10a3">compress()</a> function that allows communicating recent set or add operations to individual elements to be communicated to other processors.</p>
<p>For the current class, the variable equals false, since it does not support parallel data storage.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000096">Deprecated:</a></b></dt><dd>instead of using this variable, please use the type trait value <code>is_serial_vector&lt; VectorType &gt;::value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00169">169</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a25df23a5447341690518d92427f4c389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25df23a5447341690518d92427f4c389">&#9670;&nbsp;</a></span>vec_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::vec_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension. Actual number of components contained in the vector. Get this number by calling <code><a class="el" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l00997">997</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="ae1ae4028baa6c4debf53c36ff7768dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ae4028baa6c4debf53c36ff7768dcb">&#9670;&nbsp;</a></span>max_vec_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::max_vec_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Amount of memory actually reserved for this vector. This number may be greater than <code>vec_size</code> if a <code>reinit</code> was called with less memory requirements than the vector needed last time. At present <code>reinit</code> does not free memory when the number of needed elements is reduced. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01005">1005</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="aca4ec94ca7ad6d391900a1ea38cabbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4ec94ca7ad6d391900a1ea38cabbec">&#9670;&nbsp;</a></span>val</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number* <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::val</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the array of elements of this vector. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01010">1010</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a566a66df753d0a75121aa84fa4164d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566a66df753d0a75121aa84fa4164d56">&#9670;&nbsp;</a></span>thread_loop_partitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;parallel::internal::TBBPartitioner&gt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::thread_loop_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For parallel loops with TBB, this member variable stores the affinity information of loops. </p>

<p class="definition">Definition at line <a class="el" href="vector_8h_source.html#l01016">1016</a> of file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/base/<a class="el" href="function_8h_source.html">function.h</a></li>
<li>deal.II/lac/<a class="el" href="vector_8h_source.html">vector.h</a></li>
<li>deal.II/lac/<a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a></li>
<li>deal.II/lac/<a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/lac/<a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
