<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataOutBase Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DataOutBase Namespace Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutFilterFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">Deal_II_IntermediateFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1DXFlags.html">DXFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1GmvFlags.html">GmvFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1GnuplotFlags.html">GnuplotFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1OutputFlagsBase.html">OutputFlagsBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1Patch.html">Patch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1PovrayFlags.html">PovrayFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1UcdFlags.html">UcdFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa3cbced9f1d4ae661f13018f4c980aa1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a> { <br />
&#160;&#160;<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">default_format</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">none</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1af54db6e70b60a249b36f803d0657b39e">dx</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a1a420a2edb82acdd6e8e214f2ed97721">ucd</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a74aee841ac4d429a660bbd1bfee6f298">povray</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acf35b7afd6a85044d32320355fbaabfe">eps</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a958eea3b2724c76d1c1ff20d69f7da4e">gmv</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a8c187cd13581e59b34d71645276a550c">tecplot</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a9b83a7bdbd793467207e0a8f151e15e0">tecplot_binary</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1ac41fd26a6a54c90d0d2062d859b8facf">vtk</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1ad512d1f704c4b56b7bf99e3f81ebc06f">svg</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1ab9c7fdc67b488efaf1b27b02985a40fb">deal_II_intermediate</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1af7b5982bac28c91f885940695ca47542">hdf5</a>
<br />
 }</td></tr>
<tr class="separator:aa3cbced9f1d4ae661f13018f4c980aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a979e6be37cc683fe6ac959d435d1d3a4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a979e6be37cc683fe6ac959d435d1d3a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a979e6be37cc683fe6ac959d435d1d3a4">write_dx</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1DXFlags.html">DXFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a979e6be37cc683fe6ac959d435d1d3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac990dc4545b9c911d3700ffcf014a7"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a8ac990dc4545b9c911d3700ffcf014a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a8ac990dc4545b9c911d3700ffcf014a7">write_eps</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; 2, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a8ac990dc4545b9c911d3700ffcf014a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfee5a42e39f19cc4de48d2c1c944c08"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acfee5a42e39f19cc4de48d2c1c944c08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#acfee5a42e39f19cc4de48d2c1c944c08">write_eps</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:acfee5a42e39f19cc4de48d2c1c944c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b84ae14cf8b1e823ac5abad3858418"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa8b84ae14cf8b1e823ac5abad3858418"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#aa8b84ae14cf8b1e823ac5abad3858418">write_gmv</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1GmvFlags.html">GmvFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:aa8b84ae14cf8b1e823ac5abad3858418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c788bb66ca5ad815c7279aa33ce084"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a70c788bb66ca5ad815c7279aa33ce084"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a70c788bb66ca5ad815c7279aa33ce084">write_gnuplot</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1GnuplotFlags.html">GnuplotFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a70c788bb66ca5ad815c7279aa33ce084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88526658316b2999c9531a95a7e3a988"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a88526658316b2999c9531a95a7e3a988"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a88526658316b2999c9531a95a7e3a988">write_povray</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1PovrayFlags.html">PovrayFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a88526658316b2999c9531a95a7e3a988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98102cc4b5c323e0d90b195d5337353b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a98102cc4b5c323e0d90b195d5337353b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a98102cc4b5c323e0d90b195d5337353b">write_tecplot</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a98102cc4b5c323e0d90b195d5337353b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9522df7cfd1a94ac4e952bc5a608b5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2b9522df7cfd1a94ac4e952bc5a608b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a2b9522df7cfd1a94ac4e952bc5a608b5">write_tecplot_binary</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a2b9522df7cfd1a94ac4e952bc5a608b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4abfd2f2d061fd7a7d9f041aac160c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7d4abfd2f2d061fd7a7d9f041aac160c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a7d4abfd2f2d061fd7a7d9f041aac160c">write_ucd</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1UcdFlags.html">UcdFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a7d4abfd2f2d061fd7a7d9f041aac160c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b27325af6e59e2449593730bfaa6b0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a80b27325af6e59e2449593730bfaa6b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a80b27325af6e59e2449593730bfaa6b0">write_vtk</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a80b27325af6e59e2449593730bfaa6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266522fd4890ddeb146bf077d69ecb6b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a266522fd4890ddeb146bf077d69ecb6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a266522fd4890ddeb146bf077d69ecb6b">write_vtu</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a266522fd4890ddeb146bf077d69ecb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb8c60785a483ffaf2644ab93508da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a6cb8c60785a483ffaf2644ab93508da9">write_vtu_header</a> (std::ostream &amp;out, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags)</td></tr>
<tr class="separator:a6cb8c60785a483ffaf2644ab93508da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8709fac9a9e37c808518888630b4e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#aa8709fac9a9e37c808518888630b4e04">write_vtu_footer</a> (std::ostream &amp;out)</td></tr>
<tr class="separator:aa8709fac9a9e37c808518888630b4e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8b0425b6651eb1b8ca29a45bceb4c2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a6b8b0425b6651eb1b8ca29a45bceb4c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a6b8b0425b6651eb1b8ca29a45bceb4c2">write_vtu_main</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a6b8b0425b6651eb1b8ca29a45bceb4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc4eefa3b1e1d858789ac8ce921b501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a2fc4eefa3b1e1d858789ac8ce921b501">write_pvtu_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges)</td></tr>
<tr class="separator:a2fc4eefa3b1e1d858789ac8ce921b501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcaee76160be3f2cee5c15ca7976a26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a9bcaee76160be3f2cee5c15ca7976a26">write_pvd_record</a> (std::ostream &amp;out, const std::vector&lt; std::pair&lt; double, std::string &gt; &gt; &amp;times_and_names)</td></tr>
<tr class="separator:a9bcaee76160be3f2cee5c15ca7976a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c65120d0661fe57597ff0d13a296c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">write_visit_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names)</td></tr>
<tr class="separator:ae4c65120d0661fe57597ff0d13a296c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6441687a28d4ed1d33ba46fb6ff091a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a6441687a28d4ed1d33ba46fb6ff091a9">write_visit_record</a> (std::ostream &amp;out, const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;piece_names)</td></tr>
<tr class="separator:a6441687a28d4ed1d33ba46fb6ff091a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e8edf69620ff3c9d9d034cff4fd7e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a46e8edf69620ff3c9d9d034cff4fd7e1">write_visit_record</a> (std::ostream &amp;out, const std::vector&lt; std::pair&lt; double, std::vector&lt; std::string &gt; &gt; &gt; &amp;times_and_piece_names)</td></tr>
<tr class="separator:a46e8edf69620ff3c9d9d034cff4fd7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9340336189fdd96465b9d39118071254"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a9340336189fdd96465b9d39118071254"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a9340336189fdd96465b9d39118071254">write_svg</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; 2, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a9340336189fdd96465b9d39118071254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af0146cbaa187e83f91abd5efa6b360"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0af0146cbaa187e83f91abd5efa6b360"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a0af0146cbaa187e83f91abd5efa6b360">write_deal_II_intermediate</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, const <a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">Deal_II_IntermediateFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a0af0146cbaa187e83f91abd5efa6b360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b0569f80776b0ebab7fb910c04b564"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab5b0569f80776b0ebab7fb910c04b564"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ab5b0569f80776b0ebab7fb910c04b564">write_hdf5_parallel</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;data_filter, const std::string &amp;filename, MPI_Comm comm)</td></tr>
<tr class="separator:ab5b0569f80776b0ebab7fb910c04b564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af639e570d8d6dc551eac82e0bdee4b3d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af639e570d8d6dc551eac82e0bdee4b3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#af639e570d8d6dc551eac82e0bdee4b3d">write_hdf5_parallel</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;data_filter, const bool write_mesh_file, const std::string &amp;mesh_filename, const std::string &amp;solution_filename, MPI_Comm comm)</td></tr>
<tr class="separator:af639e570d8d6dc551eac82e0bdee4b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfc3c034ac53dbfa77b418328c4df28"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aecfc3c034ac53dbfa77b418328c4df28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#aecfc3c034ac53dbfa77b418328c4df28">write_filtered_data</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;vector_data_ranges, <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;filtered_data)</td></tr>
<tr class="separator:aecfc3c034ac53dbfa77b418328c4df28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e601aef19bd7d10884a1d25f07f3f8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a14e601aef19bd7d10884a1d25f07f3f8">determine_intermediate_format_dimensions</a> (std::istream &amp;input)</td></tr>
<tr class="separator:a14e601aef19bd7d10884a1d25f07f3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf6308a89986d2081638ef3117699a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#abbf6308a89986d2081638ef3117699a9">parse_output_format</a> (const std::string &amp;format_name)</td></tr>
<tr class="separator:abbf6308a89986d2081638ef3117699a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add43d8f47ccf7052f0178e710ad4ca02"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#add43d8f47ccf7052f0178e710ad4ca02">get_output_format_names</a> ()</td></tr>
<tr class="separator:add43d8f47ccf7052f0178e710ad4ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed25a6ddf928a6904fd1ac942125ec86"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#aed25a6ddf928a6904fd1ac942125ec86">default_suffix</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a> output_format)</td></tr>
<tr class="separator:aed25a6ddf928a6904fd1ac942125ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee90f94d79a99d58013199c0acf6034"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7ee90f94d79a99d58013199c0acf6034">ExcInvalidDatasetSize</a> (int arg1, int arg2)</td></tr>
<tr class="separator:ga7ee90f94d79a99d58013199c0acf6034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad06f77234d13c7c6d63d8fc54b524b3f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad06f77234d13c7c6d63d8fc54b524b3f">ExcNoPatches</a> ()</td></tr>
<tr class="separator:gad06f77234d13c7c6d63d8fc54b524b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5fe1fc60077930909828fa4344a9aa2"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa5fe1fc60077930909828fa4344a9aa2">ExcTecplotAPIError</a> ()</td></tr>
<tr class="separator:gaa5fe1fc60077930909828fa4344a9aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ecb35cb7c9815777fa989f17cfa3846"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1ecb35cb7c9815777fa989f17cfa3846">ExcErrorOpeningTecplotFile</a> (char *arg1)</td></tr>
<tr class="separator:ga1ecb35cb7c9815777fa989f17cfa3846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b471b212de843a0e7d1de8d6d631fea"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1b471b212de843a0e7d1de8d6d631fea"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a1b471b212de843a0e7d1de8d6d631fea">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &amp;patch)</td></tr>
<tr class="separator:a1b471b212de843a0e7d1de8d6d631fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f1da20fc706db32c3355d79fa819ae"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad5f1da20fc706db32c3355d79fa819ae"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ad5f1da20fc706db32c3355d79fa819ae">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &amp;patch)</td></tr>
<tr class="separator:ad5f1da20fc706db32c3355d79fa819ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a base class for output of data on meshes of very general form. Output data is expected as a set of <code>patches</code> and written to the output stream in the format expected by the visualization tool. For a list of output formats, check the enumeration <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a>. For each format listed there, this class contains a function <code>write_format</code>, writing the output. Refer to the documentation of those functions for details on a certain format.</p>
<h3>Structure of the output data</h3>
<p>Data is not written with the deal.II mesh structure. Instead, it relies on a set of <code>patches</code> created by a derived class (for example the <a class="el" href="classDataOut.html">DataOut</a>, <a class="el" href="classDataOutStack.html">DataOutStack</a>, <a class="el" href="classDataOutFaces.html">DataOutFaces</a>, <a class="el" href="classDataOutRotation.html">DataOutRotation</a>, or <a class="el" href="classMatrixOut.html">MatrixOut</a> classes). Each <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a> describes a single logical cell of a mesh, possibly subdivided a number of times to represent higher order polynomials defined on this cell. To this end, a patch consists of a <code>dim</code>-dimensional regular grid with the same number of grid points in each direction. In the simplest case it may consist of the corner points of a single mesh cell. For each point of this local grid, the <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a> contains an arbitrary number of data values, though the number of data sets must be the same for each point on each patch.</p>
<p>By offering this interface to the different output formats, it is simple to extend this class to new formats without depending on such things as actual triangulations and handling of data vectors. These things shall be provided by derived class which have a user callable interface then.</p>
<p>Inside each patch, the data is organized in the usual lexicographical order, <em>x</em> running fastest, then <em>y</em> and <em>z</em>. Nodes are stored in this order and cells as well. Each cell in 3D is stored such that the front face is in the <em>xz</em>-plane. In order to enhance intelligibility of this concept, the following two sections are kept from a previous version of this documentation.</p>
<h4>Patches</h4>
<p>Grids can be thought of as a collection of cells; if you want to write out data on such a grid, you can do so by writing them one cell at a time. The functions in this class therefore take a list of objects describing the data on one cell each. This data for each cell usually consists of a list of vertices for this cell, and a list of data values (for example solution data, error information, etc) at each of these vertices.</p>
<p>In some cases, this interface to a cell is too restricted, however. For example, you may have higher order elements and printing the values at the vertices only is not enough. For this reason, we not only provide writing the data on the vertices only, but the data is organizes as a tensor product grid on each cell. The parameter <code>n_subdivisions</code>, which is given for each patch separately, denotes how often the cell is to be divided for output; for example, <code>n_subdivisions==1</code> yields no subdivision of the cell, <code>n_subdivisions==2</code> will produce a grid of 3 times 3 points in two spatial dimensions and 3 times 3 times 3 points in three dimensions, <code>n_subdivisions==3</code> will yield 4 times 4 (times 4) points, etc. The actual location of these points on the patch will be computed by a multilinear transformation from the vertices given for this patch. For cells at the boundary, a mapping might be used to calculate the position of the inner points. In that case the coordinates are stored inside the <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>, as they cannot be easily recovered otherwise.</p>
<p>Given these comments, the actual data to be printed on this patch of points consists of several data sets each of which has a value at each of the patch points. For example with <code>n_subdivisions==2</code> in two space dimensions, each data set has to provide nine values, and since the patch is to be printed as a tensor product (or its transformation to the real space cell), its values are to be ordered like <em>(x0,y0) (x0,y1) (x0,y2) (x1,y0) (x1,y1) (x1,y2) (x2,y0) (x2,y1) (x2,y2)</em>, i.e. the z-coordinate runs fastest, then the y-coordinate, then x (if there are that many space directions).</p>
<h4>Generalized patches</h4>
<p>In general, the patches as explained above might be too restricted. For example, one might want to draw only the outer faces of a domain in a three-dimensional computation, if one is not interested in what happens inside. Then, the objects that should be drawn are two-dimensional in a three-dimensional world. The <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a> class and associated output functions handle these cases. The <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a> class therefore takes two template parameters, the first, named <code>dim</code> denoting the dimension of the object (in the above example, this would be two), while the second, named <code>spacedim</code>, denotes the dimension of the embedding space (this would be three). The corner points of a patch have the dimension of the space, while their number is determined by the dimension of the patch. By default, the second template parameter has the same value as the first, which would correspond to outputting a cell, rather than a face or something else.</p>
<h3>DataOutBaseInterface</h3>
<p>The members of this namespace are not usually called from user code directly. Rather, classes that use the functions declared here are typically derived from <a class="el" href="classDataOutInterface.html">DataOutInterface</a>.</p>
<p>The interface of this class basically consists of the declaration of a data type describing a patch and a bunch of functions taking a list of patches and writing them in one format or other to the stream. It is in the responsibility of the derived classes to provide this list of patches. In addition to the list of patches, a name for each data set may be given.</p>
<h3>Querying interface</h3>
<p>This class also provides a few functions (<a class="el" href="namespaceDataOutBase.html#abbf6308a89986d2081638ef3117699a9">parse_output_format()</a>, <a class="el" href="namespaceDataOutBase.html#add43d8f47ccf7052f0178e710ad4ca02">get_output_format_names()</a>, <a class="el" href="namespaceDataOutBase.html#aed25a6ddf928a6904fd1ac942125ec86">default_suffix()</a>) that can be used to query which output formats this class supports. The provide a list of names for all the formats we can output, parse a string and return an enum indicating each format, and provide a way to convert a value of this enum into the usual suffix used for files of that name. Using these functions, one can entirely free applications from knowledge which formats the library presently allows to output; several of the example programs show how to do this.</p>
<h3>Output parameters</h3>
<p>All functions take a parameter which is a structure of type <code>XFlags</code>, where <code>X</code> is the name of the output format. To find out what flags are presently supported, read the documentation of the different structures.</p>
<p>Note that usually the output formats used for scientific visualization programs have no or very few parameters (apart from some compatibility flags) because there the actual appearance of output is determined using the visualization program and the files produced by this class store more or less only raw data.</p>
<p>The direct output formats, like Postscript or Povray need to be given a lot more parameters, though, since there the output file has to contain all details of the viewpoint, light source, etc.</p>
<h3>Writing backends</h3>
<p>An abstraction layer has been introduced to facilitate coding backends for additional visualization tools. It is applicable for data formats separating the information into a field of vertices, a field of connection information for the grid cells and data fields.</p>
<p>For each of these fields, output functions are implemented, namely write_nodes(), write_cells() and write_data(). In order to use these functions, a format specific output stream must be written, following the examples of DXStream, GmvStream, VtkStream and so on, implemented in the .cc file.</p>
<p>In this framework, the implementation of a new output format is reduced to writing the section headers and the new output stream class for writing a single mesh object.</p>
<h3>Credits</h3>
<ul>
<li>
<p class="startli">EPS output based on an earlier implementation by Stefan Nauber for the old <a class="el" href="classDataOut.html">DataOut</a> class</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Povray output by Thomas Richter</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Tecplot output by Benjamin Shelton Kirk</p>
<p class="endli"></p>
</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Guido Kanschat 1999, 2000, 2001, 2002, 2005, 2006. </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa3cbced9f1d4ae661f13018f4c980aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cbced9f1d4ae661f13018f4c980aa1">&#9670;&nbsp;</a></span>OutputFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide a data type specifying the presently supported output formats. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07"></a>default_format&#160;</td><td class="fielddoc"><p>Use the format already stored in the object. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1"></a>none&#160;</td><td class="fielddoc"><p>Do not write any output. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1af54db6e70b60a249b36f803d0657b39e"></a>dx&#160;</td><td class="fielddoc"><p>Output for OpenDX. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a1a420a2edb82acdd6e8e214f2ed97721"></a>ucd&#160;</td><td class="fielddoc"><p>Output in the UCD format for AVS. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1"></a>gnuplot&#160;</td><td class="fielddoc"><p>Output for the Gnuplot tool. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a74aee841ac4d429a660bbd1bfee6f298"></a>povray&#160;</td><td class="fielddoc"><p>Output for the Povray raytracer. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1acf35b7afd6a85044d32320355fbaabfe"></a>eps&#160;</td><td class="fielddoc"><p>Output in encapsulated PostScript. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a958eea3b2724c76d1c1ff20d69f7da4e"></a>gmv&#160;</td><td class="fielddoc"><p>Output for GMV. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a8c187cd13581e59b34d71645276a550c"></a>tecplot&#160;</td><td class="fielddoc"><p>Output for Tecplot in text format. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a9b83a7bdbd793467207e0a8f151e15e0"></a>tecplot_binary&#160;</td><td class="fielddoc"><p>Output for Tecplot in binary format. Faster and smaller than text format. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1ac41fd26a6a54c90d0d2062d859b8facf"></a>vtk&#160;</td><td class="fielddoc"><p>Output in VTK format. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e"></a>vtu&#160;</td><td class="fielddoc"><p>Output in VTK format. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1ad512d1f704c4b56b7bf99e3f81ebc06f"></a>svg&#160;</td><td class="fielddoc"><p>Output in SVG format. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1ab9c7fdc67b488efaf1b27b02985a40fb"></a>deal_II_intermediate&#160;</td><td class="fielddoc"><p>Output in deal.II intermediate format. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1af7b5982bac28c91f885940695ca47542"></a>hdf5&#160;</td><td class="fielddoc"><p>Output in HDF5 format. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l01307">1307</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a979e6be37cc683fe6ac959d435d1d3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979e6be37cc683fe6ac959d435d1d3a4">&#9670;&nbsp;</a></span>write_dx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_dx </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1DXFlags.html">DXFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in OpenDX format. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02652">2652</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a8ac990dc4545b9c911d3700ffcf014a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac990dc4545b9c911d3700ffcf014a7">&#9670;&nbsp;</a></span>write_eps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_eps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; 2, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in eps format.</p>
<p>Output in this format circumvents the use of auxiliary graphic programs converting some output format into a graphics format. This has the advantage that output is easy and fast, and the disadvantage that you have to give a whole bunch of parameters which determine the direction of sight, the mode of colorization, the scaling of the height axis, etc. (Of course, all these parameters have reasonable default values, which you may want to change.)</p>
<p>This function only supports output for two-dimensional domains (i.e., with dim==2), with values in the vertical direction taken from a data vector.</p>
<p>Basically, output consists of the mesh and the cells in between them. You can draw either of these, or both, or none if you are really interested in an empty picture. If written, the mesh uses black lines. The cells in between the mesh are either not printed (this will result in a loss of hidden line removal, i.e. you can "see through" the cells to lines behind), printed in white (which does nothing apart from the hidden line removal), or colorized using one of the data vectors (which need not be the same as the one used for computing the height information) and a customizable color function. The default color functions chooses the color between black, blue, green, red and white, with growing values of the data field chosen for colorization. At present, cells are displayed with one color per cell only, which is taken from the value of the data field at the center of the cell; bilinear interpolation of the color on a cell is not used.</p>
<p>By default, the viewpoint is chosen like the default viewpoint in GNUPLOT, i.e. with an angle of 60 degrees with respect to the positive z-axis and rotated 30 degrees in positive sense (as seen from above) away from the negative y-axis. Of course you can change these settings.</p>
<p>EPS output is written without a border around the picture, i.e. the bounding box is close to the output on all four sides. Coordinates are written using at most five digits, to keep picture size at a reasonable size.</p>
<p>All parameters along with their default values are listed in the documentation of the <code><a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a></code> member class of this class. See there for more and detailed information. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l03526">3526</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="acfee5a42e39f19cc4de48d2c1c944c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee5a42e39f19cc4de48d2c1c944c08">&#9670;&nbsp;</a></span>write_eps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_eps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the same function as above except for domains that are not two- dimensional. This function is not implemented (and will throw an error if called) but is declared to allow for dimension-independent programs. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l03514">3514</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aa8b84ae14cf8b1e823ac5abad3858418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b84ae14cf8b1e823ac5abad3858418">&#9670;&nbsp;</a></span>write_gmv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_gmv </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1GmvFlags.html">GmvFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in GMV format.</p>
<p>Data is written in the following format: nodes are considered the points of the patches. In spatial dimensions less than three, zeroes are inserted for the missing coordinates. The data vectors are written as node or cell data, where for the first the data space is interpolated to (bi-,tri-)linear elements. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l03895">3895</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a70c788bb66ca5ad815c7279aa33ce084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c788bb66ca5ad815c7279aa33ce084">&#9670;&nbsp;</a></span>write_gnuplot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_gnuplot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1GnuplotFlags.html">GnuplotFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in gnuplot format. Visualization of two-dimensional data can then be achieved by starting <code>gnuplot</code> and entering the commands</p>
<pre class="fragment">* set data style lines
* splot "filename" using 1:2:n
* </pre><p> This example assumes that the number of the data vector displayed is <b>n-2</b>.</p>
<p>The GNUPLOT format is not able to handle data on unstructured grids directly. Directly would mean that you only give the vertices and the solution values thereon and the program constructs its own grid to represent the data. This is only possible for a structured tensor product grid in two dimensions. However, it is possible to give several such patches within one file, which is exactly what the respective function of this class does: writing each cell's data as a patch of data, at least if the patches as passed from derived classes represent cells. Note that the functions on patches need not be continuous at interfaces between patches, so this method also works for discontinuous elements. Note also, that GNUPLOT can do hidden line removal for patched data.</p>
<p>While this discussion applies to two spatial dimensions, it is more complicated in 3d. The reason is that we could still use patches, but it is difficult when trying to visualize them, since if we use a cut through the data (by, for example, using x- and z-coordinates, a fixed y-value and plot function values in z-direction, then the patched data is not a patch in the sense GNUPLOT wants it any more. Therefore, we use another approach, namely writing the data on the 3d grid as a sequence of lines, i.e. two points each associated with one or more data sets. There are therefore 12 lines for each subcells of a patch.</p>
<p>Given the lines as described above, a cut through this data in Gnuplot can then be achieved like this (&amp; stands for the dollar sign in the following): </p><pre class="fragment">*   set data style lines
*   splot [:][:][0:] "T" using 1:2:(&amp;3==.5 ? &amp;4 : -1)
* </pre><p>This command plots data in x- and y-direction unbounded, but in z-direction only those data points which are above the x-y-plane (we assume here a positive solution, if it has negative values, you might want to decrease the lower bound). Furthermore, it only takes the data points with z-values (<code>&amp;3</code>) equal to 0.5, i.e. a cut through the domain at <code>z=0.5</code>. For the data points on this plane, the data values of the first data set (<code>&amp;4</code>) are raised in z-direction above the x-y-plane; all other points are denoted the value <code>-1</code> instead of the value of the data vector and are not plotted due to the lower bound in z plotting direction, given in the third pair of brackets.</p>
<p>More complex cuts are possible, including nonlinear ones. Note however, that only those points which are actually on the cut-surface are plotted. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02943">2943</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a88526658316b2999c9531a95a7e3a988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88526658316b2999c9531a95a7e3a988">&#9670;&nbsp;</a></span>write_povray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_povray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1PovrayFlags.html">PovrayFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream for the Povray raytracer.</p>
<p>Output in this format creates a povray source file, include standard camera and light source definition for rendering with povray 3.1 At present, this format only supports output for two-dimensional data, with values in the third direction taken from a data vector.</p>
<p>The output uses two different povray-objects:</p>
<ul>
<li>
<p class="startli"><code>BICUBIC_PATCH</code> A <code>bicubic_patch</code> is a 3-dimensional Bezier patch. It consists of 16 Points describing the surface. The 4 corner points are touched by the object, while the other 12 points pull and stretch the patch into shape. One <code>bicubic_patch</code> is generated on each patch. Therefor the number of subdivisions has to be 3 to provide the patch with 16 points. A bicubic patch is not exact but generates very smooth images.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>MESH</code> The mesh object is used to store large number of triangles. Every square of the patch data is split into one upper-left and one lower-right triangle. If the number of subdivisions is three, 32 triangle are generated for every patch.</p>
<p class="endli">Using the smooth flag povray interpolates the normals on the triangles, imitating a curved surface </p>
</li>
</ul>
<p>All objects get one texture definition called Tex. This texture has to be declared somewhere before the object data. This may be in an external data file or at the beginning of the output file. Setting the <code>external_data</code> flag to false, an standard camera, light and texture (scaled to fit the scene) is added to the output file. Set to true an include file "data.inc" is included. This file is not generated by deal and has to include camera, light and the texture definition Tex.</p>
<p>You need povray (&gt;=3.0) to render the scene. The minimum options for povray are: </p><pre class="fragment">*   povray +I&lt;inputfile&gt; +W&lt;horiz. size&gt; +H&lt;ver. size&gt; +L&lt;include path&gt;
* </pre><p> If the external file "data.inc" is used, the path to this file has to be included in the povray options. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l03157">3157</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a98102cc4b5c323e0d90b195d5337353b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98102cc4b5c323e0d90b195d5337353b">&#9670;&nbsp;</a></span>write_tecplot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_tecplot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in Tecplot ASCII format (FEBLOCK).</p>
<p>For more information consult the Tecplot Users and Reference manuals. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04050">4050</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a2b9522df7cfd1a94ac4e952bc5a608b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9522df7cfd1a94ac4e952bc5a608b5">&#9670;&nbsp;</a></span>write_tecplot_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_tecplot_binary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in Tecplot binary format.</p>
<p>For this to work properly <code>./configure</code> checks for the Tecplot API at build time. To write Tecplot binary files directly make sure that the TECHOME environment variable points to the Tecplot installation directory, and that the files $TECHOME/include/TECIO.h and $TECHOME/lib/tecio.a are readable. If these files are not available (or in the case of 1D) this function will simply call <a class="el" href="namespaceDataOutBase.html#a98102cc4b5c323e0d90b195d5337353b">write_tecplot()</a> and thus larger ASCII data files will be produced rather than more efficient Tecplot binary files.</p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="structDataOutBase_1_1TecplotFlags.html#a125c9de7b09e8fe7606da42e3ac61127">TecplotFlags::tecplot_binary_file_name</a> indicates the name of the file to be written. If the file name is not set ASCII output is produced.</dd></dl>
<p>For more information consult the Tecplot Users and Reference manuals. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04293">4293</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a7d4abfd2f2d061fd7a7d9f041aac160c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4abfd2f2d061fd7a7d9f041aac160c">&#9670;&nbsp;</a></span>write_ucd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_ucd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1UcdFlags.html">UcdFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in UCD format described in the AVS developer's guide (now AVS). Due to limitations in the present format, only node based data can be output, which in one reason why we invented the patch concept. In order to write higher order elements, you may split them up into several subdivisions of each cell. These subcells will then, however, also appear as different cells by programs which understand the UCD format.</p>
<p>No use is made of the possibility to give model data since these are not supported by all UCD aware programs. You may give cell data in derived classes by setting all values of a given data set on a patch to the same value. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02561">2561</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a80b27325af6e59e2449593730bfaa6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b27325af6e59e2449593730bfaa6b0">&#9670;&nbsp;</a></span>write_vtk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtk </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in VTK format. The data is written in the traditional VTK format as opposed to the XML-based format that <a class="el" href="namespaceDataOutBase.html#a266522fd4890ddeb146bf077d69ecb6b">write_vtu()</a> produces.</p>
<p>The vector_data_ranges argument denotes ranges of components in the output that are considered a vector, rather than simply a collection of scalar fields. The VTK output format has special provisions that allow these components to be output by a single name rather than having to group several scalar fields into a vector later on in the visualization program.</p>
<dl class="section note"><dt>Note</dt><dd>VTK is a legacy format and has largely been supplanted by the VTU format (an XML-structured version of VTK). In particular, VTU allows for the compression of data and consequently leads to much smaller file sizes that equivalent VTK files for large files. Since all visualization programs that support VTK also support VTU, you should consider using the latter file format instead, by using the <a class="el" href="namespaceDataOutBase.html#a266522fd4890ddeb146bf077d69ecb6b">write_vtu()</a> function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04639">4639</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a266522fd4890ddeb146bf077d69ecb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266522fd4890ddeb146bf077d69ecb6b">&#9670;&nbsp;</a></span>write_vtu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtu </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in VTU format. The data is written in the XML-based VTK format as opposed to the traditional format that <a class="el" href="namespaceDataOutBase.html#a80b27325af6e59e2449593730bfaa6b0">write_vtk()</a> produces.</p>
<p>The vector_data_ranges argument denotes ranges of components in the output that are considered a vector, rather than simply a collection of scalar fields. The VTK output format has special provisions that allow these components to be output by a single name rather than having to group several scalar fields into a vector later on in the visualization program.</p>
<p>Some visualization programs, such as ParaView, can read several separate VTU files to parallelize visualization. In that case, you need a <code>.pvtu</code> file that describes which VTU files form a group. The <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a> function can generate such a master record. Likewise, <a class="el" href="classDataOutInterface.html#acfdbd7ee8c3fe029d318426b28c61670">DataOutInterface::write_visit_record()</a> does the same for VisIt (although VisIt can also read <code>pvtu</code> records since version 2.5.1). Finally, for time dependent problems, you may also want to look at <a class="el" href="classDataOutInterface.html#a7d6eca4f63127dd89806cd7591fdedf3">DataOutInterface::write_pvd_record()</a></p>
<p>The use of this function is explained in <a class="el" href="step_40.html">step-40</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04949">4949</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a6cb8c60785a483ffaf2644ab93508da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb8c60785a483ffaf2644ab93508da9">&#9670;&nbsp;</a></span>write_vtu_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtu_header </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This writes the header for the xml based vtu file format. This routine is used internally together with DataOutInterface::write_vtu_footer() and DataOutInterface::write_vtu_main() by <a class="el" href="namespaceDataOutBase.html#a266522fd4890ddeb146bf077d69ecb6b">DataOutBase::write_vtu()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04904">4904</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aa8709fac9a9e37c808518888630b4e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8709fac9a9e37c808518888630b4e04">&#9670;&nbsp;</a></span>write_vtu_footer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtu_footer </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes the footer for the xml based vtu file format. This routine is used internally together with DataOutInterface::write_vtu_header() and DataOutInterface::write_vtu_main() by <a class="el" href="namespaceDataOutBase.html#a266522fd4890ddeb146bf077d69ecb6b">DataOutBase::write_vtu()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04938">4938</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a6b8b0425b6651eb1b8ca29a45bceb4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8b0425b6651eb1b8ca29a45bceb4c2">&#9670;&nbsp;</a></span>write_vtu_main()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtu_main </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes the main part for the xml based vtu file format. This routine is used internally together with DataOutInterface::write_vtu_header() and DataOutInterface::write_vtu_footer() by <a class="el" href="namespaceDataOutBase.html#a266522fd4890ddeb146bf077d69ecb6b">DataOutBase::write_vtu()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04964">4964</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a2fc4eefa3b1e1d858789ac8ce921b501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc4eefa3b1e1d858789ac8ce921b501">&#9670;&nbsp;</a></span>write_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Some visualization programs, such as ParaView, can read several separate VTU files that all form part of the same simulation, in order to parallelize visualization. In that case, you need a <code>.pvtu</code> file that describes which VTU files (written, for example, through the <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> function) form a group. The current function can generate such a master record.</p>
<p>This function is typically not called by itself from user space, but you may want to call it through <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a> since the <a class="el" href="classDataOutInterface.html">DataOutInterface</a> class has access to information that you would have to provide to the current function by hand.</p>
<p>In any case, whether this function is called directly or via <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a>, the master record file so written contains a list of (scalar or vector) fields that describes which fields can actually be found in the individual files that comprise the set of parallel VTU files along with the names of these files. This function gets the names and types of fields through the third and fourth argument; you can determine these by hand, but in practice, this function is most easily called by calling DataOutInterfaces::write_pvtu_record(), which determines the last two arguments by calling <a class="el" href="classDataOutInterface.html#a128e5dec286cc1a429b94e29dd55ab81">DataOutInterface::get_dataset_names()</a> and <a class="el" href="classDataOutInterface.html#abefd43594be7d8835829ef706a53d560">DataOutInterface::get_vector_data_ranges()</a> functions. The second argument to this function specifies the names of the files that form the parallel set.</p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="namespaceDataOutBase.html#a266522fd4890ddeb146bf077d69ecb6b">DataOutBase::write_vtu()</a> and <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> for writing each piece. Also note that only one parallel process needs to call the current function, listing the names of the files written by all parallel processes.</dd>
<dd>
In order to tell Paraview to group together multiple <code>pvtu</code> files that each describe one time step of a time dependent simulation, see the <a class="el" href="namespaceDataOutBase.html#a9bcaee76160be3f2cee5c15ca7976a26">DataOutBase::write_pvd_record()</a> function.</dd>
<dd>
Older versions of VisIt (before 2.5.1), can not read <code>pvtu</code> records. However, it can read visit records as written by the <a class="el" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">write_visit_record()</a> function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05333">5333</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a9bcaee76160be3f2cee5c15ca7976a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcaee76160be3f2cee5c15ca7976a26">&#9670;&nbsp;</a></span>write_pvd_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_pvd_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>times_and_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In ParaView it is possible to visualize time-dependent data tagged with the current integration time of a time dependent simulation. To use this feature you need a <code>.pvd</code> file that describes which VTU or PVTU file belongs to which timestep. This function writes a file that provides this mapping, i.e., it takes a list of pairs each of which indicates a particular time instant and the corresponding file that contains the graphical data for this time instant.</p>
<p>A typical use case, in program that computes a time dependent solution, would be the following (<code>time</code> and <code>time_step</code> are member variables of the class with types <code>double</code> and <code>unsigned int</code>, respectively; the variable <code>times_and_names</code> is of type <code>std::vector&lt;std::pair&lt;double,std::string&gt; &gt;</code>):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MyEquation&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (timestep_number, 3) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output (filename.c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line"></div><div class="line">  times_and_names.emplace_back (time, filename);</div><div class="line">  std::ofstream pvd_output (<span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a9bcaee76160be3f2cee5c15ca7976a26">DataOutBase::write_pvd_record</a> (pvd_output, times_and_names);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>See <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu</a>, <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record</a>, and <a class="el" href="classDataOutInterface.html#accd0043b7fe5e6f9d3ad76228c5008a2">DataOutInterface::write_vtu_in_parallel</a> for writing solutions at each timestep.</dd>
<dd>
The second element of each pair, i.e., the file in which the graphical data for each time is stored, may itself be again a file that references other files. For example, it could be the name for a <code>.pvtu</code> file that references multiple parts of a parallel computation.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Marco Engelhard, 2012 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05428">5428</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ae4c65120d0661fe57597ff0d13a296c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c65120d0661fe57597ff0d13a296c1">&#9670;&nbsp;</a></span>write_visit_record() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_visit_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the exact equivalent of the <a class="el" href="namespaceDataOutBase.html#a2fc4eefa3b1e1d858789ac8ce921b501">write_pvtu_record()</a> function but for older versions of the VisIt visualization program and for one visualization graph (or one time step only). See there for the purpose of this function.</p>
<p>This function is documented in the "Creating a master file for parallel" section (section 5.7) of the "Getting data into VisIt" report that can be found here: <a href="https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf">https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf</a> </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05464">5464</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a6441687a28d4ed1d33ba46fb6ff091a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6441687a28d4ed1d33ba46fb6ff091a9">&#9670;&nbsp;</a></span>write_visit_record() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_visit_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is equivalent to the <a class="el" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">write_visit_record()</a> above but for multiple time steps. Here is an example of how the function would be used: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 3;</div><div class="line">std::vector&lt;std::vector&lt;std::string &gt; &gt; piece_names(number_of_time_steps);</div><div class="line"></div><div class="line">piece_names[0].emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_0.vtk&quot;</span>);</div><div class="line">piece_names[0].emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_0.vtk&quot;</span>);</div><div class="line"></div><div class="line">piece_names[1].emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_1.vtk&quot;</span>);</div><div class="line">piece_names[1].emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_1.vtk&quot;</span>);</div><div class="line"></div><div class="line">piece_names[2].emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_2.vtk&quot;</span>);</div><div class="line">piece_names[2].emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_2.vtk&quot;</span>);</div><div class="line"></div><div class="line">std::ofstream visit_output (<span class="stringliteral">&quot;master_file.visit&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a>(visit_output, piece_names);</div></div><!-- fragment --><p>This function is documented in the "Creating a master file for parallel" section (section 5.7) of the "Getting data into VisIt" report that can be found here: <a href="https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf">https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf</a> </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05477">5477</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a46e8edf69620ff3c9d9d034cff4fd7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e8edf69620ff3c9d9d034cff4fd7e1">&#9670;&nbsp;</a></span>write_visit_record() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_visit_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, std::vector&lt; std::string &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>times_and_piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is equivalent to the <a class="el" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">write_visit_record()</a> above but for multiple time steps and with additional information about the time for each timestep. Here is an example of how the function would be used: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 3;</div><div class="line">std::vector&lt;std::pair&lt;double,std::vector&lt;std::string &gt; &gt; &gt; times_and_piece_names(number_of_time_steps);</div><div class="line"></div><div class="line">times_and_piece_names[0].first = 0.0;</div><div class="line">times_and_piece_names[0].second.emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_0.vtk&quot;</span>);</div><div class="line">times_and_piece_names[0].second.emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_0.vtk&quot;</span>);</div><div class="line"></div><div class="line">times_and_piece_names[1].first = 0.5;</div><div class="line">times_and_piece_names[1].second.emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_1.vtk&quot;</span>);</div><div class="line">times_and_piece_names[1].second.emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_1.vtk&quot;</span>);</div><div class="line"></div><div class="line">times_and_piece_names[2].first = 1.0;</div><div class="line">times_and_piece_names[2].second.emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_2.vtk&quot;</span>);</div><div class="line">times_and_piece_names[2].second.emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_2.vtk&quot;</span>);</div><div class="line"></div><div class="line">std::ofstream visit_output (<span class="stringliteral">&quot;master_file.visit&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a>(visit_output, times_and_piece_names);</div></div><!-- fragment --><p>This function is documented in the "Creating a master file for parallel" section (section 5.7) of the "Getting data into VisIt" report that can be found here: <a href="https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf">https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf</a> </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05502">5502</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a9340336189fdd96465b9d39118071254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9340336189fdd96465b9d39118071254">&#9670;&nbsp;</a></span>write_svg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_svg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; 2, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in SVG format.</p>
<p>SVG (Scalable <a class="el" href="classVector.html">Vector</a> Graphics) is an XML-based vector image format developed and maintained by the World Wide Web Consortium (W3C). This function conforms to the latest specification SVG 1.1, released on August 16, 2011. Controlling the graphic output is possible by setting or clearing the respective flags (see the <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> struct). At present, this format only supports output for two-dimensional data, with values in the third direction taken from a data vector.</p>
<p>For the output, each patch is subdivided into four triangles which are then written as polygons and filled with a linear color gradient. The arising coloring of the patches visualizes the data values at the vertices taken from the specified data vector. A colorbar can be drawn to encode the coloring.</p>
<dl class="section note"><dt>Note</dt><dd>This function is so far only implemented for two dimensions with an additional dimension reserved for data information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05542">5542</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0af0146cbaa187e83f91abd5efa6b360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af0146cbaa187e83f91abd5efa6b360">&#9670;&nbsp;</a></span>write_deal_II_intermediate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_deal_II_intermediate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">Deal_II_IntermediateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the given list of patches to the output stream in deal.II intermediate format. This is not a format understood by any other graphics program, but is rather a direct dump of the intermediate internal format used by deal.II. This internal format is generated by the various classes that can generate output using the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> class, for example from a finite element solution, and is then converted in the present class to the final graphics format.</p>
<p>Note that the intermediate format is what its name suggests: a direct representation of internal data. It isn't standardized and will change whenever we change our internal representation. You can only expect to process files written in this format using the same version of deal.II that was used for writing.</p>
<p>The reason why we offer to write out this intermediate format is that it can be read back into a deal.II program using the <a class="el" href="classDataOutReader.html">DataOutReader</a> class, which is helpful in at least two contexts: First, this can be used to later generate graphical output in any other graphics format presently understood; this way, it is not necessary to know at run-time which output format is requested, or if multiple output files in different formats are needed. Secondly, in contrast to almost all other graphics formats, it is possible to merge several files that contain intermediate format data, and generate a single output file from it, which may be again in intermediate format or any of the final formats. This latter option is most helpful for parallel programs: as demonstrated in the <a class="el" href="step_17.html">step-17</a> example program, it is possible to let only one processor generate the graphical output for the entire parallel program, but this can become vastly inefficient if many processors are involved, because the load is no longer balanced. The way out is to let each processor generate intermediate graphical output for its chunk of the domain, and the later merge the different files into one, which is an operation that is much cheaper than the generation of the intermediate data.</p>
<p>Intermediate format deal.II data is usually stored in files with the ending <code>.d2</code>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06181">6181</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ab5b0569f80776b0ebab7fb910c04b564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b0569f80776b0ebab7fb910c04b564">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data in data_filter to a single HDF5 file containing both the mesh and solution values. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06791">6791</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="af639e570d8d6dc551eac82e0bdee4b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af639e570d8d6dc551eac82e0bdee4b3d">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>write_mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data in data_filter to HDF5 file(s). If write_mesh_file is false, the mesh data will not be written and the solution file will contain only the solution values. If write_mesh_file is true and the filenames are the same, the resulting file will contain both mesh data and solution values. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06802">6802</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aecfc3c034ac53dbfa77b418328c4df28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfc3c034ac53dbfa77b418328c4df28">&#9670;&nbsp;</a></span>write_filtered_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_filtered_data </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned int, unsigned int, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filtered_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> is an intermediate data format that reduces the amount of data that will be written to files. The object filled by this function can then later be used again to write data in a concrete file format; see, for example, <a class="el" href="namespaceDataOutBase.html#ab5b0569f80776b0ebab7fb910c04b564">DataOutBase::write_hdf5_parallel()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06673">6673</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a14e601aef19bd7d10884a1d25f07f3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e601aef19bd7d10884a1d25f07f3f8">&#9670;&nbsp;</a></span>determine_intermediate_format_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, unsigned int &gt; DataOutBase::determine_intermediate_format_dimensions </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an input stream that contains data written by <a class="el" href="namespaceDataOutBase.html#a0af0146cbaa187e83f91abd5efa6b360">write_deal_II_intermediate()</a>, determine the <code>dim</code> and <code>spacedim</code> template parameters with which that function was called, and return them as a pair of values.</p>
<p>Note that this function eats a number of elements at the present position of the stream, and therefore alters it. In order to read from it using, for example, the <a class="el" href="classDataOutReader.html">DataOutReader</a> class, you may wish to either reset the stream to its previous position, or close and reopen it. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06224">6224</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="abbf6308a89986d2081638ef3117699a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf6308a89986d2081638ef3117699a9">&#9670;&nbsp;</a></span>parse_output_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a> DataOutBase::parse_output_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the OutputFormat value corresponding to the given string. If the string does not match any known format, an exception is thrown.</p>
<p>The main purpose of this function is to allow a program to use any implemented output format without the need to extend the program's parser each time a new format is implemented.</p>
<p>To get a list of presently available format names, e.g. to give it to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class, use the function <a class="el" href="namespaceDataOutBase.html#add43d8f47ccf7052f0178e710ad4ca02">get_output_format_names()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02063">2063</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="add43d8f47ccf7052f0178e710ad4ca02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add43d8f47ccf7052f0178e710ad4ca02">&#9670;&nbsp;</a></span>get_output_format_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DataOutBase::get_output_format_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of implemented output formats. The different names are separated by vertical bar signs (<code>`|'</code>) as used by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> classes. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02115">2115</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aed25a6ddf928a6904fd1ac942125ec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed25a6ddf928a6904fd1ac942125ec86">&#9670;&nbsp;</a></span>default_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DataOutBase::default_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide a function which tells us which suffix a file with a given output format usually has. At present the following formats are defined: </p><ul>
<li>
<code>dx</code>: <code>.dx</code> </li>
<li>
<code>ucd</code>: <code>.inp</code> </li>
<li>
<code>gnuplot</code>: <code>.gnuplot</code> </li>
<li>
<code>povray</code>: <code>.pov</code> </li>
<li>
<code>eps</code>: <code>.eps</code> </li>
<li>
<code>gmv</code>: <code>.gmv</code> </li>
<li>
<code>tecplot</code>: <code>.dat</code> </li>
<li>
<code>tecplot_binary</code>: <code>.plt</code> </li>
<li>
<code>vtk</code>: <code>.vtk</code> </li>
<li>
<code>vtu</code>: <code>.vtu</code> </li>
<li>
<code>svg</code>: <code>.svg</code> </li>
<li>
<code>deal_II_intermediate</code>: <code>.d2</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02123">2123</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1b471b212de843a0e7d1de8d6d631fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b471b212de843a0e7d1de8d6d631fea">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DataOutBase::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output operator for an object of type <code><a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a></code>. This operator dumps the intermediate graphics format represented by the patch data structure. It may later be converted into regular formats for a number of graphics programs.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07592">7592</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ad5f1da20fc706db32c3355d79fa819ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f1da20fc706db32c3355d79fa819ae">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; DataOutBase::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Input operator for an object of type <code><a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a></code>. This operator reads the intermediate graphics format represented by the patch data structure, using the format in which it was written using the operator&lt;&lt;.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2005 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07627">7627</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
