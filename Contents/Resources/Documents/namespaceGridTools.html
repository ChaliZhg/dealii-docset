<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GridTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">GridTools Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about meshes and cells</div></td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:acd5ccc543d561cfb086b571d1f7818cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff265d387af7b430f5aec7005faace6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4ff265d387af7b430f5aec7005faace6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">volume</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim, spacedim &gt;::mapping))</td></tr>
<tr class="separator:a4ff265d387af7b430f5aec7005faace6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89deda30a32b232dbe9c95e14896df5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac89deda30a32b232dbe9c95e14896df5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac89deda30a32b232dbe9c95e14896df5">minimal_cell_diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:ac89deda30a32b232dbe9c95e14896df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfcfbf4a51832d5994de2c185183101"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acbfcfbf4a51832d5994de2c185183101"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acbfcfbf4a51832d5994de2c185183101">maximal_cell_diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:acbfcfbf4a51832d5994de2c185183101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ca8be2ba8a96aa8c5c4dcb51b55a73"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a51ca8be2ba8a96aa8c5c4dcb51b55a73"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a51ca8be2ba8a96aa8c5c4dcb51b55a73">cell_measure</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;all_vertices, const unsigned int(&amp;vertex_indices)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell])</td></tr>
<tr class="separator:a51ca8be2ba8a96aa8c5c4dcb51b55a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441c41c7ddccbf28eef748b271190705"><td class="memTemplParams" colspan="2">template&lt;int dim, typename T &gt; </td></tr>
<tr class="memitem:a441c41c7ddccbf28eef748b271190705"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a441c41c7ddccbf28eef748b271190705">cell_measure</a> (const T &amp;,...)</td></tr>
<tr class="separator:a441c41c7ddccbf28eef748b271190705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions supporting the creation of meshes</div></td></tr>
<tr class="memitem:a0606069313c01837a47c9fd4bc1e11f1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0606069313c01837a47c9fd4bc1e11f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0606069313c01837a47c9fd4bc1e11f1">delete_unused_vertices</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;vertices, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;cells, <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:a0606069313c01837a47c9fd4bc1e11f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79820d66b08b06e94541817ba78d6213"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a79820d66b08b06e94541817ba78d6213"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a79820d66b08b06e94541817ba78d6213">delete_duplicated_vertices</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;all_vertices, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;cells, <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata, std::vector&lt; unsigned int &gt; &amp;considered_vertices, const double tol=1e-12)</td></tr>
<tr class="separator:a79820d66b08b06e94541817ba78d6213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rotating, stretching and otherwise transforming meshes</div></td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Transformation , int spacedim&gt; </td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform</a> (const Transformation &amp;transformation, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b953611883979e3f920f800bd855df3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4b953611883979e3f920f800bd855df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">shift</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;shift_vector, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a4b953611883979e3f920f800bd855df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ea00f2009014a52520c05beadc78b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa7ea00f2009014a52520c05beadc78b6">rotate</a> (const double angle, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;triangulation)</td></tr>
<tr class="separator:aa7ea00f2009014a52520c05beadc78b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a580cbf329f016024a2e6b9d7eb9eed69">rotate</a> (const double angle, const unsigned int axis, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, 3 &gt; &amp;triangulation)</td></tr>
<tr class="separator:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea9a503f365395ed24460cb489d7f0e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6ea9a503f365395ed24460cb489d7f0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a6ea9a503f365395ed24460cb489d7f0e">laplace_transform</a> (const std::map&lt; unsigned int, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;new_points, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; *coefficient=nullptr, const bool solve_for_absolute_positions=false)</td></tr>
<tr class="separator:a6ea9a503f365395ed24460cb489d7f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baa65a240caf7a5033f47b07b17f86f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1baa65a240caf7a5033f47b07b17f86f"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned int, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1baa65a240caf7a5033f47b07b17f86f">get_all_vertices_at_boundary</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:a1baa65a240caf7a5033f47b07b17f86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a> (const double scaling_factor, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a0967563badadd81f77f62622dd8bc2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec039d544c93a6e810427ad45ba0c84f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aec039d544c93a6e810427ad45ba0c84f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aec039d544c93a6e810427ad45ba0c84f">distort_random</a> (const double factor, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const bool keep_boundary=true)</td></tr>
<tr class="separator:aec039d544c93a6e810427ad45ba0c84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b77b07123012706fbadf91d8f022b3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a62b77b07123012706fbadf91d8f022b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a62b77b07123012706fbadf91d8f022b3">remove_hanging_nodes</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const bool isotropic=false, const unsigned int max_iterations=100)</td></tr>
<tr class="separator:a62b77b07123012706fbadf91d8f022b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40336842aa2faac805746dc10c7c604f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a40336842aa2faac805746dc10c7c604f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a40336842aa2faac805746dc10c7c604f">remove_anisotropy</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const double max_ratio=1.6180339887, const unsigned int max_iterations=5)</td></tr>
<tr class="separator:a40336842aa2faac805746dc10c7c604f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finding cells and vertices of a triangulation</div></td></tr>
<tr class="memitem:a3ae72c22852ca1a5b2cd1bd49642f650"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a3ae72c22852ca1a5b2cd1bd49642f650"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a3ae72c22852ca1a5b2cd1bd49642f650">find_closest_vertex</a> (const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:a3ae72c22852ca1a5b2cd1bd49642f650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb822f0e3068e48640ecc981ee6c1e6"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:addb822f0e3068e48640ecc981ee6c1e6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#addb822f0e3068e48640ecc981ee6c1e6">find_cells_adjacent_to_vertex</a> (const MeshType&lt; dim, spacedim &gt; &amp;container, const unsigned int vertex_index)</td></tr>
<tr class="separator:addb822f0e3068e48640ecc981ee6c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57c66000d93c12c70f05995c0c3308f"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:aa57c66000d93c12c70f05995c0c3308f"><td class="memTemplItemLeft" align="right" valign="top">MeshType&lt; dim, spacedim &gt;::active_cell_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa57c66000d93c12c70f05995c0c3308f">find_active_cell_around_point</a> (const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:aa57c66000d93c12c70f05995c0c3308f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffa665e05b53e1476c949de697d6c31"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:aaffa665e05b53e1476c949de697d6c31"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aaffa665e05b53e1476c949de697d6c31">find_active_cell_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:aaffa665e05b53e1476c949de697d6c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225cd212b8c74eef9cd6096ccdcd3317"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a225cd212b8c74eef9cd6096ccdcd3317"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a225cd212b8c74eef9cd6096ccdcd3317">find_active_cell_around_point</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:a225cd212b8c74eef9cd6096ccdcd3317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c182c1901bb0d09046271809f918c6"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:ab5c182c1901bb0d09046271809f918c6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ab5c182c1901bb0d09046271809f918c6">get_active_child_cells</a> (const typename MeshType::cell_iterator &amp;cell)</td></tr>
<tr class="separator:ab5c182c1901bb0d09046271809f918c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a30ccceb7c9216efc44dd4af561e0bea0">get_active_neighbors</a> (const typename MeshType::active_cell_iterator &amp;cell, std::vector&lt; typename MeshType::active_cell_iterator &gt; &amp;active_neighbors)</td></tr>
<tr class="separator:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51acc74a2c56fc9cab517235be235cdc"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a51acc74a2c56fc9cab517235be235cdc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">compute_active_cell_halo_layer</a> (const MeshType &amp;mesh, const std::function&lt; bool(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate)</td></tr>
<tr class="separator:a51acc74a2c56fc9cab517235be235cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e89706e7e925b16d42d288c462e9d8"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a98e89706e7e925b16d42d288c462e9d8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a98e89706e7e925b16d42d288c462e9d8">compute_cell_halo_layer_on_level</a> (const MeshType &amp;mesh, const std::function&lt; bool(const typename MeshType::cell_iterator &amp;)&gt; &amp;predicate, const unsigned int level)</td></tr>
<tr class="separator:a98e89706e7e925b16d42d288c462e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0674004143aed7f492a3ae7bcb2e3d"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a6d0674004143aed7f492a3ae7bcb2e3d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a6d0674004143aed7f492a3ae7bcb2e3d">compute_ghost_cell_halo_layer</a> (const MeshType &amp;mesh)</td></tr>
<tr class="separator:a6d0674004143aed7f492a3ae7bcb2e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7e2ca8ecd26a472e5225ba91a58acb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9b7e2ca8ecd26a472e5225ba91a58acb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">vertex_to_cell_map</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a9b7e2ca8ecd26a472e5225ba91a58acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1ec4049da3c61cb29eb294199e7e53"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:adf1ec4049da3c61cb29eb294199e7e53"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned int, <a class="el" href="namespacetypes.html#a2bee0f76c9f9b2098d3d279bf9f4ab58">types::global_vertex_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#adf1ec4049da3c61cb29eb294199e7e53">compute_local_to_global_vertex_index_map</a> (const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:adf1ec4049da3c61cb29eb294199e7e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed82bbc9838a9123bf567014ae9990dd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aed82bbc9838a9123bf567014ae9990dd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; unsigned int, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aed82bbc9838a9123bf567014ae9990dd">get_longest_direction</a> (typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator cell)</td></tr>
<tr class="separator:aed82bbc9838a9123bf567014ae9990dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Partitions and subdomains of triangulations</div></td></tr>
<tr class="memitem:a002fd376a184234ccbf5eca8f8fd7012"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a002fd376a184234ccbf5eca8f8fd7012"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a002fd376a184234ccbf5eca8f8fd7012">get_face_connectivity_of_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:a002fd376a184234ccbf5eca8f8fd7012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90a4369a93e8684066ad89d4f0898c1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae90a4369a93e8684066ad89d4f0898c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae90a4369a93e8684066ad89d4f0898c1">get_face_connectivity_of_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;connectivity) 1</td></tr>
<tr class="separator:ae90a4369a93e8684066ad89d4f0898c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54e2fb68484ddaedaab56de13323169"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab54e2fb68484ddaedaab56de13323169"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ab54e2fb68484ddaedaab56de13323169">get_vertex_connectivity_of_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:ab54e2fb68484ddaedaab56de13323169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec0e25e2e5b5c9f359516d85ef29950"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acec0e25e2e5b5c9f359516d85ef29950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acec0e25e2e5b5c9f359516d85ef29950">get_vertex_connectivity_of_cells_on_level</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const unsigned int level, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:acec0e25e2e5b5c9f359516d85ef29950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4706b77042db5437cf81fd13e62b20"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5b4706b77042db5437cf81fd13e62b20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a5b4706b77042db5437cf81fd13e62b20">partition_triangulation</a> (const unsigned int n_partitions, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a5b4706b77042db5437cf81fd13e62b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6de68d2a7d5444fd3d2664974a2c5e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7e6de68d2a7d5444fd3d2664974a2c5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a7e6de68d2a7d5444fd3d2664974a2c5e">partition_triangulation</a> (const unsigned int n_partitions, const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;cell_connection_graph, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a7e6de68d2a7d5444fd3d2664974a2c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0e99c7f13956959c99282a33ce0625"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1a0e99c7f13956959c99282a33ce0625"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1a0e99c7f13956959c99282a33ce0625">partition_triangulation_zorder</a> (const unsigned int n_partitions, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a1a0e99c7f13956959c99282a33ce0625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d37431a097d36fb7152c41e0352b5e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a70d37431a097d36fb7152c41e0352b5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a70d37431a097d36fb7152c41e0352b5e">partition_multigrid_levels</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a70d37431a097d36fb7152c41e0352b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae0cb61bdd7e17c6b1589bdd16891e561">get_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, std::vector&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;subdomain)</td></tr>
<tr class="separator:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c212a30784bec20b1ae13fad3fd579c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8c212a30784bec20b1ae13fad3fd579c"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">count_cells_with_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:a8c212a30784bec20b1ae13fad3fd579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b3f1dcc53c868171f1bb0a3793a96e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a33b3f1dcc53c868171f1bb0a3793a96e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a33b3f1dcc53c868171f1bb0a3793a96e">get_locally_owned_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a33b3f1dcc53c868171f1bb0a3793a96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparing different meshes</div></td></tr>
<tr class="memitem:a32a5016c746ad756046ecff264dfa60d"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:a32a5016c746ad756046ecff264dfa60d"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; typename MeshType::cell_iterator, typename MeshType::cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a32a5016c746ad756046ecff264dfa60d">get_finest_common_cells</a> (const MeshType &amp;mesh_1, const MeshType &amp;mesh_2)</td></tr>
<tr class="separator:a32a5016c746ad756046ecff264dfa60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aae387b14cb19f14e3dbd3e0e1a3e3ba2">have_same_coarse_mesh</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh_2)</td></tr>
<tr class="separator:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75c70b1760c88a852413a1a9fae107"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:abb75c70b1760c88a852413a1a9fae107"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#abb75c70b1760c88a852413a1a9fae107">have_same_coarse_mesh</a> (const MeshType &amp;mesh_1, const MeshType &amp;mesh_2)</td></tr>
<tr class="separator:abb75c70b1760c88a852413a1a9fae107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with distorted cells</div></td></tr>
<tr class="memitem:a1c7bb95bc2bbb09d6f02651d7be1527d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1c7bb95bc2bbb09d6f02651d7be1527d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1c7bb95bc2bbb09d6f02651d7be1527d">fix_up_distorted_child_cells</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList &amp;distorted_cells, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a1c7bb95bc2bbb09d6f02651d7be1527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extracting and creating patches of cells surrounding a single cell,</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>and creating triangulation out of them </p>
</div></td></tr>
<tr class="memitem:aaec69b92488f0dd0d61ff66445327f0d"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:aaec69b92488f0dd0d61ff66445327f0d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">get_patch_around_cell</a> (const typename MeshType::active_cell_iterator &amp;cell)</td></tr>
<tr class="separator:aaec69b92488f0dd0d61ff66445327f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb9de754873e0401df4a51bacf0556c"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a1cb9de754873e0401df4a51bacf0556c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Container::cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1cb9de754873e0401df4a51bacf0556c">get_cells_at_coarsest_common_level</a> (const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;patch_cells)</td></tr>
<tr class="separator:a1cb9de754873e0401df4a51bacf0556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3b216d4efc9d4add312c055a5ec95f"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:aca3b216d4efc9d4add312c055a5ec95f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aca3b216d4efc9d4add312c055a5ec95f">build_triangulation_from_patch</a> (const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;patch, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt; &amp;local_triangulation, std::map&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt;::active_cell_iterator, typename Container::active_cell_iterator &gt; &amp;patch_to_global_tria_map)</td></tr>
<tr class="separator:aca3b216d4efc9d4add312c055a5ec95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a90d2b1a061b70a0d28761e3e1316f"><td class="memTemplParams" colspan="2">template&lt;class DoFHandlerType &gt; </td></tr>
<tr class="memitem:ae7a90d2b1a061b70a0d28761e3e1316f"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae7a90d2b1a061b70a0d28761e3e1316f">get_dof_to_support_patch_map</a> (DoFHandlerType &amp;dof_handler)</td></tr>
<tr class="separator:ae7a90d2b1a061b70a0d28761e3e1316f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with periodic domains</div></td></tr>
<tr class="memitem:ac2a1903382c6cff07b33d456a641f6d9"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:ac2a1903382c6cff07b33d456a641f6d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality</a> (std::bitset&lt; 3 &gt; &amp;orientation, const FaceIterator &amp;face1, const FaceIterator &amp;face2, const int direction, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;offset=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt;())</td></tr>
<tr class="separator:ac2a1903382c6cff07b33d456a641f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ea413c4f9405a1515dc9f1af8a6ec3"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:ad9ea413c4f9405a1515dc9f1af8a6ec3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ad9ea413c4f9405a1515dc9f1af8a6ec3">orthogonal_equality</a> (const FaceIterator &amp;face1, const FaceIterator &amp;face2, const int direction, const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, FaceIterator::AccessorType::space_dimension &gt; &amp;offset=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt;())</td></tr>
<tr class="separator:ad9ea413c4f9405a1515dc9f1af8a6ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeadfc0053429f542fbfd48d192b94f0"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:aaeadfc0053429f542fbfd48d192b94f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aaeadfc0053429f542fbfd48d192b94f0">collect_periodic_faces</a> (const MeshType &amp;mesh, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id1, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id2, const int direction, std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt; &gt; &amp;matched_pairs, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;offset=::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt;())</td></tr>
<tr class="separator:aaeadfc0053429f542fbfd48d192b94f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6c6052ecc070b8f6ee1489b55897a7"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:add6c6052ecc070b8f6ee1489b55897a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#add6c6052ecc070b8f6ee1489b55897a7">collect_periodic_faces</a> (const MeshType &amp;mesh, const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id, const int direction, std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt; &gt; &amp;matched_pairs, const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;offset=::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt;())</td></tr>
<tr class="separator:add6c6052ecc070b8f6ee1489b55897a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with boundary and manifold ids</div></td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2ea00d3c65f290a020a268df8fb50c19">copy_boundary_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const bool reset_boundary_ids=false)</td></tr>
<tr class="separator:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga306131b2b48ca10bb9a51e189806193c">copy_material_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const bool compute_face_ids=false)</td></tr>
<tr class="separator:ga306131b2b48ca10bb9a51e189806193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exceptions</div></td></tr>
<tr class="memitem:gab4403672fd04ec4fdaa8af5874f013e4"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab4403672fd04ec4fdaa8af5874f013e4">ExcInvalidNumberOfPartitions</a> (int arg1)</td></tr>
<tr class="separator:gab4403672fd04ec4fdaa8af5874f013e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf085ef6740e34bb2dff96477e7a02a62"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf085ef6740e34bb2dff96477e7a02a62">ExcNonExistentSubdomain</a> (int arg1)</td></tr>
<tr class="separator:gaf085ef6740e34bb2dff96477e7a02a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b439a32ea6b3f89c9267a3706b330fd"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6b439a32ea6b3f89c9267a3706b330fd">ExcTriangulationHasBeenRefined</a> ()</td></tr>
<tr class="separator:ga6b439a32ea6b3f89c9267a3706b330fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2added16caf5d21400c18e294bc110bb"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2added16caf5d21400c18e294bc110bb">ExcScalingFactorNotPositive</a> (double arg1)</td></tr>
<tr class="separator:ga2added16caf5d21400c18e294bc110bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f7952bd8f3fc7acceaee342e30ab4a"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:gac7f7952bd8f3fc7acceaee342e30ab4a"><td class="memTemplItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac7f7952bd8f3fc7acceaee342e30ab4a">ExcPointNotFoundInCoarseGrid</a> (<a class="el" href="classPoint.html">Point</a>&lt; N &gt; arg1)</td></tr>
<tr class="separator:gac7f7952bd8f3fc7acceaee342e30ab4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae2c427cc3c38cfdfe518db77fdcb3a"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:gafae2c427cc3c38cfdfe518db77fdcb3a"><td class="memTemplItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafae2c427cc3c38cfdfe518db77fdcb3a">ExcPointNotFound</a> (<a class="el" href="classPoint.html">Point</a>&lt; N &gt; arg1)</td></tr>
<tr class="separator:gafae2c427cc3c38cfdfe518db77fdcb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e49026ef790fdd5ae987392f445c5c"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga55e49026ef790fdd5ae987392f445c5c">ExcVertexNotUsed</a> (unsigned int arg1)</td></tr>
<tr class="separator:ga55e49026ef790fdd5ae987392f445c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace is a collection of algorithms working on triangulations, such as shifting or rotating triangulations, but also finding a cell that contains a given point. See the descriptions of the individual functions for more information. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acd5ccc543d561cfb086b571d1f7818cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5ccc543d561cfb086b571d1f7818cb">&#9670;&nbsp;</a></span>diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double GridTools::diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the diameter of a triangulation. The diameter is computed using only the vertices, i.e. if the diameter should be larger than the maximal distance between boundary vertices due to a higher order mapping, then this function will not catch this. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00066">66</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a4ff265d387af7b430f5aec7005faace6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff265d387af7b430f5aec7005faace6">&#9670;&nbsp;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double GridTools::volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;dim,spacedim&gt;::mapping)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the volume (i.e. the dim-dimensional measure) of the triangulation. We compute the measure using the integral <img class="formulaInl" alt="$\sum_K \int_K 1 \; dx$" src="form_833.png"/> where <img class="formulaInl" alt="$K$" src="form_57.png"/> are the cells of the given triangulation. The integral is approximated via quadrature for which we need the mapping argument.</p>
<p>If the triangulation is a dim-dimensional one embedded in a higher dimensional space of dimension spacedim, then the value returned is the dim-dimensional measure. For example, for a two-dimensional triangulation in three-dimensional space, the value returned is the area of the surface so described. (This obviously makes sense since the spacedim-dimensional measure of a dim-dimensional triangulation would always be zero if dim &lt; spacedim.</p>
<p>This function also works for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, in which case the function is a collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation. </td></tr>
    <tr><td class="paramname">mapping</td><td>An optional argument used to denote the mapping that should be used when describing whether cells are bounded by straight or curved faces. The default is to use a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> mapping, which corresponds to straight lines bounding the cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dim-dimensional measure of the domain described by the triangulation, as discussed above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00121">121</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ac89deda30a32b232dbe9c95e14896df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89deda30a32b232dbe9c95e14896df5">&#9670;&nbsp;</a></span>minimal_cell_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double GridTools::minimal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the diameter of the smallest active cell of a triangulation. See <a class="el" href="step_24.html">step-24</a> for an example of use of this function. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02553">2553</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="acbfcfbf4a51832d5994de2c185183101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfcfbf4a51832d5994de2c185183101">&#9670;&nbsp;</a></span>maximal_cell_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double GridTools::maximal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the diameter of the largest active cell of a triangulation. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02568">2568</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a51ca8be2ba8a96aa8c5c4dcb51b55a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ca8be2ba8a96aa8c5c4dcb51b55a73">&#9670;&nbsp;</a></span>cell_measure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double GridTools::cell_measure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int(&amp;)&#160;</td>
          <td class="paramname"><em>vertex_indices</em>[GeometryInfo&lt; dim &gt;::vertices_per_cell]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of vertices (typically obtained using <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices</a>) as the first, and a list of vertex indices that characterize a single cell as the second argument, return the measure (area, volume) of this cell. If this is a real cell, then you can get the same result using <code>cell-&gt;measure()</code>, but this function also works for cells that do not exist except that you make it up by naming its vertices from the list. </p>

</div>
</div>
<a id="a441c41c7ddccbf28eef748b271190705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441c41c7ddccbf28eef748b271190705">&#9670;&nbsp;</a></span>cell_measure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double GridTools::cell_measure </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A version of the last function that can accept input for nonzero codimension cases. This function only exists to aid generic programming and calling it will just raise an exception. </p>

</div>
</div>
<a id="a0606069313c01837a47c9fd4bc1e11f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0606069313c01837a47c9fd4bc1e11f1">&#9670;&nbsp;</a></span>delete_unused_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_unused_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove vertices that are not referenced by any of the cells. This function is called by all <code>GridIn::read_*</code> functions to eliminate vertices that are listed in the input files but are not used by the cells in the input file. While these vertices should not be in the input from the beginning, they sometimes are, most often when some cells have been removed by hand without wanting to update the vertex lists, as they might be lengthy.</p>
<p>This function is called by all <code>GridIn::read_*</code> functions as the triangulation class requires them to be called with used vertices only. This is so, since the vertices are copied verbatim by that class, so we have to eliminate unused vertices beforehand.</p>
<p>Not implemented for the codimension one case. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00368">368</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a79820d66b08b06e94541817ba78d6213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79820d66b08b06e94541817ba78d6213">&#9670;&nbsp;</a></span>delete_duplicated_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_duplicated_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>considered_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove vertices that are duplicated, due to the input of a structured grid, for example. If these vertices are not removed, the faces bounded by these vertices become part of the boundary, even if they are in the interior of the mesh.</p>
<p>This function is called by some <code>GridIn::read_*</code> functions. Only the vertices with indices in <code>considered_vertices</code> are tested for equality. This speeds up the algorithm, which is quadratic and thus quite slow to begin with. However, if you wish to consider all vertices, simply pass an empty vector.</p>
<p>Two vertices are considered equal if their difference in each coordinate direction is less than <code>tol</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00464">464</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a212e99cf0d923cebfa04f1d23fa60b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212e99cf0d923cebfa04f1d23fa60b04">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Transformation , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::transform </td>
          <td>(</td>
          <td class="paramtype">const Transformation &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the vertices of the given triangulation by applying the function object provided as first argument to all its vertices.</p>
<p>The transformation given as argument is used to transform each vertex. Its respective type has to offer a function-like syntax, i.e. the predicate is either an object of a type that has an <code>operator()</code>, or it is a pointer to the function. In either case, argument and return value have to be of type <code><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If you are using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you will have hanging nodes in your local <a class="el" href="classTriangulation.html">Triangulation</a> even if your "global" mesh has no hanging nodes. This will cause issues with wrong positioning of hanging nodes in ghost cells if you call the current functions: The vertices of all locally owned cells will be correct, but the vertices of some ghost cells may not. This means that computations like <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> may give wrong answers. A safe approach is to use this function prior to any refinement in parallel, if that is possible, but not after you refine the mesh.</dd></dl>
<p>This function is used in the "Possibilities for extensions" section of <a class="el" href="step_38.html">step-38</a>. It is also used in <a class="el" href="step_49.html">step-49</a> and <a class="el" href="step_53.html">step-53</a>. </p>

</div>
</div>
<a id="a4b953611883979e3f920f800bd855df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b953611883979e3f920f800bd855df3">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift each vertex of the triangulation by the given shift vector. This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00625">625</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aa7ea00f2009014a52520c05beadc78b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ea00f2009014a52520c05beadc78b6">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate all vertices of the given two-dimensional triangulation in counter-clockwise sense around the origin of the coordinate system by the given angle (given in radians, rather than degrees). This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00634">634</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a580cbf329f016024a2e6b9d7eb9eed69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580cbf329f016024a2e6b9d7eb9eed69">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate all vertices of the given <code>triangulation</code> in counter-clockwise direction around the axis with the given index. Otherwise like the function above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>Angle in radians to rotate the <a class="el" href="classTriangulation.html">Triangulation</a> by. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Index of the coordinate axis to rotate around, keeping that coordinate fixed (0=x axis, 1=y axis, 2=z axis). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">triangulation</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object to rotate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for dim=1, 2, and 3. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00642">642</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a6ea9a503f365395ed24460cb489d7f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea9a503f365395ed24460cb489d7f0e">&#9670;&nbsp;</a></span>laplace_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::laplace_transform </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; unsigned int, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, double &gt; *&#160;</td>
          <td class="paramname"><em>coefficient</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>solve_for_absolute_positions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the given triangulation smoothly to a different domain where, typically, each of the vertices at the boundary of the triangulation is mapped to the corresponding points in the <code>new_points</code> map.</p>
<p>The unknown displacement field <img class="formulaInl" alt="$u_d(\mathbf x)$" src="form_834.png"/> in direction <img class="formulaInl" alt="$d$" src="form_301.png"/> is obtained from the minimization problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \min\, \int \frac{1}{2} c(\mathbf x) \mathbf \nabla u_d(\mathbf x) \cdot \mathbf \nabla u_d(\mathbf x) \,\rm d x \]" src="form_835.png"/>
</p>
<p> subject to prescribed constraints. The minimizer is obtained by solving the Laplace equation of the dim components of a displacement field that maps the current domain into one described by <code>new_points</code> . Linear finite elements with four Gaussian quadrature points in each direction are used. The difference between the vertex positions specified in <code>new_points</code> and their current value in <code>tria</code> therefore represents the prescribed values of this displacement field at the boundary of the domain, or more precisely at all of those locations for which <code>new_points</code> provides values (which may be at part of the boundary, or even in the interior of the domain). The function then evaluates this displacement field at each unconstrained vertex and uses it to place the mapped vertex where the displacement field locates it. Because the solution of the Laplace equation is smooth, this guarantees a smooth mapping from the old domain to the new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_points</td><td>The locations where a subset of the existing vertices are to be placed. Typically, this would be a map from the vertex indices of all nodes on the boundary to their new locations, thus completely specifying the geometry of the mapped domain. However, it may also include interior points if necessary and it does not need to include all boundary vertices (although you then lose control over the exact shape of the mapped domain).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object. This object is changed in- place, i.e., the previous locations of vertices are overwritten.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficient</td><td>An optional coefficient for the Laplace problem. Larger values make cells less prone to deformation (effectively increasing their stiffness). The coefficient is evaluated in the coordinate system of the old, undeformed configuration of the triangulation as input, i.e., before the transformation is applied. Should this function be provided, sensible results can only be expected if all coefficients are positive.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solve_for_absolute_positions</td><td>If set to <code>true</code>, the minimization problem is formulated with respect to the final vertex positions as opposed to their displacement. The two formulations are equivalent for the homogeneous problem (default value of <code>coefficient</code>), but they result in very different mesh motion otherwise. Since in most cases one will be using a non-constant coefficient in displacement formulation, the default value of this parameter is <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not currently implemented for the 1d case. </dd></dl>

</div>
</div>
<a id="a1baa65a240caf7a5033f47b07b17f86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1baa65a240caf7a5033f47b07b17f86f">&#9670;&nbsp;</a></span>get_all_vertices_at_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned int, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; GridTools::get_all_vertices_at_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a std::map with all vertices of faces located in the boundary</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00799">799</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a0967563badadd81f77f62622dd8bc2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0967563badadd81f77f62622dd8bc2cd">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::scale </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scaling_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the entire triangulation by the given factor. To preserve the orientation of the triangulation, the factor must be positive.</p>
<p>This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00653">653</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aec039d544c93a6e810427ad45ba0c84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec039d544c93a6e810427ad45ba0c84f">&#9670;&nbsp;</a></span>distort_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::distort_random </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>keep_boundary</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distort the given triangulation by randomly moving around all the vertices of the grid. The direction of movement of each vertex is random, while the length of the shift vector has a value of <code>factor</code> times the minimal length of the active edges adjacent to this vertex. Note that <code>factor</code> should obviously be well below <code>0.5</code>.</p>
<p>If <code>keep_boundary</code> is set to <code>true</code> (which is the default), then boundary vertices are not moved.</p>
<p>Distort a triangulation in some random way. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00831">831</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a62b77b07123012706fbadf91d8f022b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b77b07123012706fbadf91d8f022b3">&#9670;&nbsp;</a></span>remove_hanging_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::remove_hanging_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isotropic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove hanging nodes from a grid. If the <code>isotropic</code> parameter is set to <code>false</code> (default) this function detects cells with hanging nodes and refines the neighbours in the direction that removes hanging nodes. If the <code>isotropic</code> parameter is set to <code>true</code>, the neighbours refinement is made in each directions. In order to remove all hanging nodes this procedure has to be repeated: this could require a large number of iterations. To avoid this a max number (<code>max_iterations</code>) of iteration is provided.</p>
<p>Consider the following grid: </p><div class="image">
<img src="remove_hanging_nodes-hanging.png" alt="remove_hanging_nodes-hanging.png"/>
</div>
<p><code>isotropic</code> == <code>false</code> would return: </p><div class="image">
<img src="remove_hanging_nodes-aniso.png" alt="remove_hanging_nodes-aniso.png"/>
</div>
<p><code>isotropic</code> == <code>true</code> would return: </p><div class="image">
<img src="remove_hanging_nodes-isotro.png" alt="remove_hanging_nodes-isotro.png"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a> to refine.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isotropic</td><td>If true refine cells in each directions, otherwise (default value) refine the cell in the direction that removes hanging node.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iterations</td><td>At each step only closest cells to hanging nodes are refined. The code may require a lot of iterations to remove all hanging nodes. <code>max_iterations</code> is the maximum number of iteration allowed. If <code>max_iterations</code> == <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> this function continues refining until there are no hanging nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In the case of parallel codes, this function should be combined with <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a>.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mauro Bardelloni, Luca Heltai, Andrea Mola, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04161">4161</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a40336842aa2faac805746dc10c7c604f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40336842aa2faac805746dc10c7c604f">&#9670;&nbsp;</a></span>remove_anisotropy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::remove_anisotropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_ratio</em> = <code>1.6180339887</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine a mesh anisotropically such that the resulting mesh is composed by cells with maximum ratio between dimensions less than <code>max_ratio</code>. This procedure requires an algorithm that may not terminate. Consequently, it is possible to set a maximum number of iterations through the <code>max_iterations</code> parameter.</p>
<p>Starting from a cell like this: </p><div class="image">
<img src="remove_anisotropy-coarse.png" alt="remove_anisotropy-coarse.png"/>
</div>
<p>This function would return: </p><div class="image">
<img src="remove_anisotropy-refined.png" alt="remove_anisotropy-refined.png"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a> to refine.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_ratio</td><td>Maximum value allowed among the ratio between the dimensions of each cell.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iterations</td><td>Maximum number of iterations allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In the case of parallel codes, this function should be combined with <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a> and <a class="el" href="namespaceGridTools.html#a62b77b07123012706fbadf91d8f022b3">GridTools::remove_hanging_nodes</a>.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mauro Bardelloni, Luca Heltai, Andrea Mola, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04196">4196</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a3ae72c22852ca1a5b2cd1bd49642f650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae72c22852ca1a5b2cd1bd49642f650">&#9670;&nbsp;</a></span>find_closest_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the number of the used vertex in a given mesh that is located closest to a given point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the closest vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest vertex found.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ralf B. Schulz, 2006 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01053">1053</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="addb822f0e3068e48640ecc981ee6c1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb822f0e3068e48640ecc981ee6c1e6">&#9670;&nbsp;</a></span>find_cells_adjacent_to_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &gt; GridTools::find_cells_adjacent_to_vertex </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>vertex_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return a vector of iterators to active cells that surround a given vertex with index <code>vertex_index</code>.</p>
<p>For locally refined grids, the vertex itself might not be a vertex of all adjacent cells that are returned. However, it will always be either a vertex of a cell or be a hanging node located on a face or an edge of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">vertex_index</td><td>The index of the vertex for which we try to find adjacent cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of cells that lie adjacent to the given vertex.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the point requested does not lie in any of the cells of the mesh given, then this function throws an exception of type <a class="el" href="group__Exceptions.html#gafae2c427cc3c38cfdfe518db77fdcb3a">GridTools::ExcPointNotFound</a>. You can catch this exception and decide what to do in that case.</dd>
<dd>
It isn't entirely clear at this time whether the function does the right thing with anisotropically refined meshes. It needs to be checked for this case. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01100">1100</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aa57c66000d93c12c70f05995c0c3308f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57c66000d93c12c70f05995c0c3308f">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType&lt; dim, spacedim &gt;::active_cell_iterator GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return an iterator to the active cell that surrounds a given point.</p>
<p>This is solely a wrapper function for the function of same name below. A Q1 mapping is used for the boundary, and the iterator to the cell in which the point resides is returned.</p>
<p>It is recommended to use the other version of this function, as it simultaneously delivers the local coordinate of the given point without additional computational cost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the surrounding cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator into the mesh that points to the surrounding cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the point requested does not lie in any of the cells of the mesh given, then this function throws an exception of type <a class="el" href="group__Exceptions.html#gafae2c427cc3c38cfdfe518db77fdcb3a">GridTools::ExcPointNotFound</a>. You can catch this exception and decide what to do in that case.</dd>
<dd>
When applied to a triangulation or DoF handler object based on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, the cell returned may in fact be a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). If so, many of the operations one may want to do on this cell (e.g., evaluating the solution) may not be possible and you will have to decide what to do in that case. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01298">1298</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aaffa665e05b53e1476c949de697d6c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffa665e05b53e1476c949de697d6c31">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return an iterator to the active cell that surrounds a given point <code>p</code>.</p>
<p>The algorithm used in this function proceeds by first looking for vertex located closest to the given point, see <a class="el" href="namespaceGridTools.html#a3ae72c22852ca1a5b2cd1bd49642f650">find_closest_vertex()</a>. Secondly, all adjacent cells to this point are found in the mesh, see <a class="el" href="namespaceGridTools.html#addb822f0e3068e48640ecc981ee6c1e6">find_cells_adjacent_to_vertex()</a>. Lastly, for each of these cells, it is tested whether the point is inside. This check is performed using arbitrary boundary mappings. Still, it is possible that due to roundoff errors, the point cannot be located exactly inside the unit cell. In this case, even points at a very small distance outside the unit cell are allowed.</p>
<p>If a point lies on the boundary of two or more cells, then the algorithm tries to identify the cell that is of highest refinement level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>The mapping used to determine whether the given point is inside a given cell. </td></tr>
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the surrounding cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An pair of an iterators into the mesh that points to the surrounding cell, and of the coordinates of that point inside the cell in the reference coordinates of that cell. This local position might be located slightly outside an actual unit cell, due to numerical roundoff. Therefore, the point returned by this function should be projected onto the unit cell, using <a class="el" href="structGeometryInfo.html#a0a57cad4fd84b5e758fd7a0ffefc0077">GeometryInfo::project_to_unit_cell()</a>. This is not automatically performed by the algorithm.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the point requested does not lie in any of the cells of the mesh given, then this function throws an exception of type <a class="el" href="group__Exceptions.html#gafae2c427cc3c38cfdfe518db77fdcb3a">GridTools::ExcPointNotFound</a>. You can catch this exception and decide what to do in that case.</dd>
<dd>
When applied to a triangulation or DoF handler object based on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, the cell returned may in fact be a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). If so, many of the operations one may want to do on this cell (e.g., evaluating the solution) may not be possible and you will have to decide what to do in that case. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01314">1314</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a225cd212b8c74eef9cd6096ccdcd3317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225cd212b8c74eef9cd6096ccdcd3317">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A version of the previous function where we use that mapping on a given cell that corresponds to the active finite element index of that cell. This is obviously only useful for hp problems, since the active finite element index for all other DoF handlers is always zero.</p>
<dl class="section note"><dt>Note</dt><dd>If the point requested does not lie in any of the cells of the mesh given, then this function throws an exception of type <a class="el" href="group__Exceptions.html#gafae2c427cc3c38cfdfe518db77fdcb3a">GridTools::ExcPointNotFound</a>. You can catch this exception and decide what to do in that case.</dd>
<dd>
When applied to a triangulation or DoF handler object based on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, the cell returned may in fact be a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). If so, many of the operations one may want to do on this cell (e.g., evaluating the solution) may not be possible and you will have to decide what to do in that case. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01426">1426</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ab5c182c1901bb0d09046271809f918c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c182c1901bb0d09046271809f918c6">&#9670;&nbsp;</a></span>get_active_child_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType::active_cell_iterator&gt; GridTools::get_active_child_cells </td>
          <td>(</td>
          <td class="paramtype">const typename MeshType::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of all descendants of the given cell that are active. For example, if the current cell is once refined but none of its children are any further refined, then the returned list will contain all its children.</p>
<p>If the current cell is already active, then the returned list is empty (because the cell has no children that may be active).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active descendants of the given cell</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since in C++ the MeshType template argument can not be deduced from a function call, you will have to specify it after the function name, as for example in <div class="fragment"><div class="line">GridTools::get_active_child_cells&lt;DoFHandler&lt;dim&gt; &gt; (cell)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a30ccceb7c9216efc44dd4af561e0bea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ccceb7c9216efc44dd4af561e0bea0">&#9670;&nbsp;</a></span>get_active_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_active_neighbors </td>
          <td>(</td>
          <td class="paramtype">const typename MeshType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename MeshType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the active cells around a given cell <code>cell</code> and return them in the vector <code>active_neighbors</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">active_neighbors</td><td>A list of active descendants of the given cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51acc74a2c56fc9cab517235be235cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51acc74a2c56fc9cab517235be235cdc">&#9670;&nbsp;</a></span>compute_active_cell_halo_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_active_cell_halo_layer </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return the active cell layer around a subdomain (set of active cells) in the <code>mesh</code> (i.e. those that share a common set of vertices with the subdomain but are not a part of it). Here, the "subdomain" consists of exactly all of those cells for which the <code>predicate</code> returns <code>true</code>.</p>
<p>An example of a custom predicate is one that checks for a given material id </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span></div><div class="line">pred_mat_id(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> &amp; cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> cell-&gt;material_id() ==  1;</div><div class="line">}</div></div><!-- fragment --><p> and we can then extract the layer of cells around this material with the following call: </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(tria, pred_mat_id&lt;dim&gt;);</div></div><!-- fragment --><p>Predicates that are frequently useful can be found in namespace <a class="el" href="namespaceIteratorFilters.html">IteratorFilters</a>. For example, it is possible to extracting a layer based on material id </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(tria,</div><div class="line">                                          <a class="code" href="classIteratorFilters_1_1MaterialIdEqualTo.html">IteratorFilters::MaterialIdEqualTo</a>(1, <span class="keyword">true</span>));</div></div><!-- fragment --><p> or based on a set of active FE indices for an <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(hp_dof_handler,</div><div class="line">                                          <a class="code" href="classIteratorFilters_1_1ActiveFEIndexEqualTo.html">IteratorFilters::ActiveFEIndexEqualTo</a>({1,2}, <span class="keyword">true</span>));</div></div><!-- fragment --><p> Note that in the last two examples we ensure that the predicate returns true only for locally owned cells. This means that the halo layer will not contain any artificial cells.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predicate</td><td>A function (or object of a type with an operator()) defining the subdomain around which the halo layer is to be extracted. It is a function that takes in an active cell and returns a boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells sharing at least one common vertex with the predicated subdomain.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jean-Paul Pelteret, Denis Davydov, Wolfgang Bangerth, 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01583">1583</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a98e89706e7e925b16d42d288c462e9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e89706e7e925b16d42d288c462e9d8">&#9670;&nbsp;</a></span>compute_cell_halo_layer_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::cell_iterator &gt; GridTools::compute_cell_halo_layer_on_level </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const typename MeshType::cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return the cell layer around a subdomain (set of cells) on a specified level of the <code>mesh</code> (i.e. those cells on that level that share a common set of vertices with the subdomain but are not a part of it). Here, the "subdomain" consists of exactly all of those cells for which the <code>predicate</code> returns <code>true</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01622">1622</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a6d0674004143aed7f492a3ae7bcb2e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0674004143aed7f492a3ae7bcb2e3d">&#9670;&nbsp;</a></span>compute_ghost_cell_halo_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_ghost_cell_halo_layer </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return ghost cells which are the active cell layer around all locally owned cells. This is most relevant for <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> where it will return a subset of all ghost cells on a processor, but for <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this will return all the ghost cells.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of ghost cells</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jean-Paul Pelteret, Denis Davydov, Wolfgang Bangerth, 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01661">1661</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a9b7e2ca8ecd26a472e5225ba91a58acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7e2ca8ecd26a472e5225ba91a58acb">&#9670;&nbsp;</a></span>vertex_to_cell_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &gt; GridTools::vertex_to_cell_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the adjacent cells of all the vertices. If a vertex is also a hanging node, the associated coarse cell is also returned. The vertices are ordered by the vertex index. This is the number returned by the function <code>cell-&gt;vertex_index()</code>. Notice that only the indices marked in the array returned by <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation&lt;dim,spacedim&gt;::get_used_vertices()</a> are used. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01683">1683</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="adf1ec4049da3c61cb29eb294199e7e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1ec4049da3c61cb29eb294199e7e53">&#9670;&nbsp;</a></span>compute_local_to_global_vertex_index_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned int, <a class="el" href="namespacetypes.html#a2bee0f76c9f9b2098d3d279bf9f4ab58">types::global_vertex_index</a> &gt; GridTools::compute_local_to_global_vertex_index_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a globally unique index for each vertex and hanging node associated with a locally owned active cell. The vertices of a ghost cell that are hanging nodes of a locally owned cells have a global index. However, the other vertices of the cells that do not <em>touch</em> an active cell do not have a global index on this processor.</p>
<p>The key of the map is the local index of the vertex and the value is the global index. The indices need to be recomputed after refinement or coarsening and may be different. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01727">1727</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aed82bbc9838a9123bf567014ae9990dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed82bbc9838a9123bf567014ae9990dd">&#9670;&nbsp;</a></span>get_longest_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, double &gt; GridTools::get_longest_direction </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the highest value among ratios between extents in each of the coordinate directions of a <code>cell</code>. Moreover, return the dimension relative to the highest elongation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>an iterator pointing to the cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair&lt;unsigned int, double&gt; such that the <code>first</code> value is the dimension of the highest elongation and the <code>second</code> value is the ratio among the dimensions of the <code>cell</code>.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mauro Bardelloni, Luca Heltai, Andrea Mola, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04131">4131</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a002fd376a184234ccbf5eca8f8fd7012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002fd376a184234ccbf5eca8f8fd7012">&#9670;&nbsp;</a></span>get_face_connectivity_of_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_face_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern in which nonzero entries indicate that two cells are connected via a common face. The diagonal entries of the sparsity pattern are also set.</p>
<p>The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02009">2009</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae90a4369a93e8684066ad89d4f0898c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90a4369a93e8684066ad89d4f0898c1">&#9670;&nbsp;</a></span>get_face_connectivity_of_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_face_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As above, but filling a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object instead.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02056">2056</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ab54e2fb68484ddaedaab56de13323169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54e2fb68484ddaedaab56de13323169">&#9670;&nbsp;</a></span>get_vertex_connectivity_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_vertex_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern in which nonzero entries indicate that two cells are connected via a common vertex. The diagonal entries of the sparsity pattern are also set.</p>
<p>The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02068">2068</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="acec0e25e2e5b5c9f359516d85ef29950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec0e25e2e5b5c9f359516d85ef29950">&#9670;&nbsp;</a></span>get_vertex_connectivity_of_cells_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_vertex_connectivity_of_cells_on_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern for a given level mesh in which nonzero entries indicate that two cells are connected via a common vertex. The diagonal entries of the sparsity pattern are also set.</p>
<p>The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02093">2093</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a5b4706b77042db5437cf81fd13e62b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4706b77042db5437cf81fd13e62b20">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the METIS partitioner to generate a partitioning of the active cells making up the entire domain. After calling this function, the subdomain ids of all active cells will have values between zero and <code>n_partitions-1</code>. You can access the subdomain id of a cell by using <code>cell-&gt;subdomain_id()</code>.</p>
<p>This function will generate an error if METIS is not installed unless <code>n_partitions</code> is one. I.e., you can write a program so that it runs in the single-processor single-partition case without METIS installed, and only requires METIS when multiple partitions are required. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02120">2120</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a7e6de68d2a7d5444fd3d2664974a2c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6de68d2a7d5444fd3d2664974a2c5e">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_connection_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the previous one, i.e. it partitions a triangulation using METIS into a number of subdomains identified by the <code>cell-&gt;subdomain_id()</code> flag.</p>
<p>The difference to the previous function is the second argument, a sparsity pattern that represents the connectivity pattern between cells.</p>
<p>While the function above builds it directly from the triangulation by considering which cells neighbor each other, this function can take a more refined connectivity graph. The sparsity pattern needs to be of size <img class="formulaInl" alt="$N\times N$" src="form_707.png"/>, where <img class="formulaInl" alt="$N$" src="form_104.png"/> is the number of active cells in the triangulation. If the sparsity pattern contains an entry at position <img class="formulaInl" alt="$(i,j)$" src="form_739.png"/>, then this means that cells <img class="formulaInl" alt="$i$" src="form_90.png"/> and <img class="formulaInl" alt="$j$" src="form_513.png"/> (in the order in which they are traversed by active cell iterators) are to be considered connected; METIS will then try to partition the domain in such a way that (i) the subdomains are of roughly equal size, and (ii) a minimal number of connections are broken.</p>
<p>This function is mainly useful in cases where connections between cells exist that are not present in the triangulation alone (otherwise the previous function would be the simpler one to use). Such connections may include that certain parts of the boundary of a domain are coupled through symmetric boundary conditions or integrals (e.g. friction contact between the two sides of a crack in the domain), or if a numerical scheme is used that not only connects immediate neighbors but a larger neighborhood of cells (e.g. when solving integral equations).</p>
<p>In addition, this function may be useful in cases where the default sparsity pattern is not entirely sufficient. This can happen because the default is to just consider face neighbors, not neighboring cells that are connected by edges or vertices. While the latter couple when using continuous finite elements, they are typically still closely connected in the neighborship graph, and METIS will not usually cut important connections in this case. However, if there are vertices in the mesh where many cells (many more than the common 4 or 6 in 2d and 3d, respectively) come together, then there will be a significant number of cells that are connected across a vertex, but several degrees removed in the connectivity graph built only using face neighbors. In a case like this, METIS may sometimes make bad decisions and you may want to build your own connectivity graph. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02159">2159</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a1a0e99c7f13956959c99282a33ce0625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0e99c7f13956959c99282a33ce0625">&#9670;&nbsp;</a></span>partition_triangulation_zorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation_zorder </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a partitioning of the active cells making up the entire domain using the same partitioning scheme as in the p4est library. After calling this function, the subdomain ids of all active cells will have values between zero and <code>n_partitions-1</code>. You can access the subdomain id of a cell by using <code>cell-&gt;subdomain_id()</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02234">2234</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a70d37431a097d36fb7152c41e0352b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d37431a097d36fb7152c41e0352b5e">&#9670;&nbsp;</a></span>partition_multigrid_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_multigrid_levels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partitions the cells of a multigrid hierarchy by assigning level subdomain ids using the "youngest child" rule, that is, each cell in the hierarchy is owned by the processor who owns its left most child in the forest, and active cells have the same subdomain id and level subdomain id. You can access the level subdomain id of a cell by using <code>cell-&gt;level_subdomain_id()</code>.</p>
<p>Note: This function assumes that the active cells have already been partitioned. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02333">2333</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae0cb61bdd7e17c6b1589bdd16891e561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cb61bdd7e17c6b1589bdd16891e561">&#9670;&nbsp;</a></span>get_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each active cell, return in the output array to which subdomain (as given by the <code>cell-&gt;subdomain_id()</code> function) it belongs. The output array is supposed to have the right size already when calling this function.</p>
<p>This function returns the association of each cell with one subdomain. If you are looking for the association of each <em>DoF</em> with a subdomain, use the <code><a class="el" href="namespaceDoFTools.html#aafdaa16476cd2bec333a7197ab06bff9">DoFTools::get_subdomain_association</a></code> function. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02358">2358</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a8c212a30784bec20b1ae13fad3fd579c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c212a30784bec20b1ae13fad3fd579c">&#9670;&nbsp;</a></span>count_cells_with_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GridTools::count_cells_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many cells are uniquely associated with the given <code>subdomain</code> index.</p>
<p>This function may return zero if there are no cells with the given <code>subdomain</code> index. This can happen, for example, if you try to partition a coarse mesh into more partitions (one for each processor) than there are cells in the mesh.</p>
<p>This function returns the number of cells associated with one subdomain. If you are looking for the association of <em>DoFs</em> with this subdomain, use the <code><a class="el" href="namespaceDoFTools.html#a2dde9ded6d7cbc9962547356f37e5f72">DoFTools::count_dofs_with_subdomain_association</a></code> function. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02373">2373</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a33b3f1dcc53c868171f1bb0a3793a96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b3f1dcc53c868171f1bb0a3793a96e">&#9670;&nbsp;</a></span>get_locally_owned_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; GridTools::get_locally_owned_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a triangulation, return a mask that represents which of its vertices are "owned" by the current process in the same way as we talk about locally owned cells or degrees of freedom (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a> and <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">GlossLocallyOwnedDof</a>). For the purpose of this function, we define a locally owned vertex as follows: a vertex is owned by that processor with the smallest subdomain id (which equals the MPI rank of that processor) among all owners of cells adjacent to this vertex. In other words, vertices that are in the interior of a partition of the triangulation are owned by the owner of this partition; for vertices that lie on the boundary between two or more partitions, the owner is the processor with the least subdomain_id among all adjacent subdomains.</p>
<p>For sequential triangulations (as opposed to, for example, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>), every user vertex is of course owned by the current processor, i.e., the function returns <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation::get_used_vertices()</a>. For parallel triangulations, the returned mask is a subset of what <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation::get_used_vertices()</a> returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>The triangulation of which the function evaluates which vertices are locally owned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The subset of vertices, as described above. The length of the returned array equals <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation.n_vertices()</a> and may, consequently, be larger than <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02390">2390</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a32a5016c746ad756046ecff264dfa60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a5016c746ad756046ecff264dfa60d">&#9670;&nbsp;</a></span>get_finest_common_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; std::pair&lt; typename MeshType::cell_iterator, typename MeshType::cell_iterator &gt; &gt; GridTools::get_finest_common_cells </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two meshes (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>) that are based on the same coarse mesh, this function figures out a set of cells that are matched between the two meshes and where at most one of the meshes is more refined on this cell. In other words, it finds the smallest cells that are common to both meshes, and that together completely cover the domain.</p>
<p>This function is useful, for example, in time-dependent or nonlinear application, where one has to integrate a solution defined on one mesh (e.g., the one from the previous time step or nonlinear iteration) against the shape functions of another mesh (the next time step, the next nonlinear iteration). If, for example, the new mesh is finer, then one has to obtain the solution on the coarse mesh (mesh_1) and interpolate it to the children of the corresponding cell of mesh_2. Conversely, if the new mesh is coarser, one has to express the coarse cell shape function by a linear combination of fine cell shape functions. In either case, one needs to loop over the finest cells that are common to both triangulations. This function returns a list of pairs of matching iterators to cells in the two meshes that can be used to this end.</p>
<p>Note that the list of these iterators is not necessarily ordered, and does also not necessarily coincide with the order in which cells are traversed in one, or both, of the meshes given as arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02420">2420</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aae387b14cb19f14e3dbd3e0e1a3e3ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae387b14cb19f14e3dbd3e0e1a3e3ba2">&#9670;&nbsp;</a></span>have_same_coarse_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the two triangulations are based on the same coarse mesh. This is determined by checking whether they have the same number of cells on the coarsest level, and then checking that they have the same vertices.</p>
<p>The two meshes may have different refinement histories beyond the coarse mesh. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02511">2511</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="abb75c70b1760c88a852413a1a9fae107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb75c70b1760c88a852413a1a9fae107">&#9670;&nbsp;</a></span>have_same_coarse_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same function as above, but working on arguments of type <a class="el" href="classDoFHandler.html">DoFHandler</a>, or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. This function is provided to allow calling have_same_coarse_mesh for all types of containers representing triangulations or the classes built on triangulations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02542">2542</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a1c7bb95bc2bbb09d6f02651d7be1527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7bb95bc2bbb09d6f02651d7be1527d">&#9670;&nbsp;</a></span>fix_up_distorted_child_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList GridTools::fix_up_distorted_child_cells </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList &amp;&#160;</td>
          <td class="paramname"><em>distorted_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a triangulation and a list of cells whose children have become distorted as a result of mesh refinement, try to fix these cells up by moving the center node around.</p>
<p>The function returns a list of cells with distorted children that couldn't be fixed up for whatever reason. The returned list is therefore a subset of the input argument.</p>
<p>For a definition of the concept of distorted cells, see the <a class="el" href="DEALGlossary.html#GlossDistorted">glossary entry</a>. The first argument passed to the current function is typically the exception thrown by the <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement</a> function. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03112">3112</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aaec69b92488f0dd0d61ff66445327f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec69b92488f0dd0d61ff66445327f0d">&#9670;&nbsp;</a></span>get_patch_around_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::active_cell_iterator &gt; GridTools::get_patch_around_cell </td>
          <td>(</td>
          <td class="paramtype">const typename MeshType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a list of all the active neighbor cells of the given, active cell. Here, a neighbor is defined as one having at least part of a face in common with the given cell, but not edge (in 3d) or vertex neighbors (in 2d and 3d).</p>
<p>The first element of the returned list is the cell provided as argument. The remaining ones are neighbors: The function loops over all faces of that given cell and checks if that face is not on the boundary of the domain. Then, if the neighbor cell does not have any children (i.e., it is either at the same refinement level as the current cell, or coarser) then this neighbor cell is added to the list of cells. Otherwise, if the neighbor cell is refined and therefore has children, then this function loops over all subfaces of current face adds the neighbors behind these sub-faces to the list to be returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. In C++, the compiler can not determine <code>MeshType</code> from the function call. You need to specify it as an explicit template argument following the function name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells that form the patch around the given cell</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. This also requires manipulating the degrees of freedom associated with the cells of a patch. To this end, there are further functions working on patches in namespace <a class="el" href="namespaceDoFTools.html">DoFTools</a>.</dd>
<dd>
In the context of a parallel distributed computation, it only makes sense to call this function on locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Arezou Ghesmati, Wolfgang Bangerth, 2014 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03149">3149</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a1cb9de754873e0401df4a51bacf0556c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb9de754873e0401df4a51bacf0556c">&#9670;&nbsp;</a></span>get_cells_at_coarsest_common_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename Container::cell_iterator &gt; GridTools::get_cells_at_coarsest_common_level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes a vector of active cells (hereafter named <code>patch_cells</code>) as input argument, and returns a vector of their parent cells with the coarsest common level of refinement. In other words, find that set of cells living at the same refinement level so that all cells in the input vector are children of the cells in the set, or are in the set itself.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>In C++, the compiler can not determine the type of <code>Container</code> from the function call. You need to specify it as an explicit template argument following the function name. This type has to satisfy the requirements of a mesh container (see <a class="el" href="group__Concepts.html#ConceptMeshType">ConceptMeshType</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch_cells</td><td>A vector of active cells for which this function finds the parents at the coarsest common level. This vector of cells typically results from calling the function <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of cells with the coarsest common level of refinement of the input cells.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Arezou Ghesmati, Wolfgang Bangerth, 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03192">3192</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aca3b216d4efc9d4add312c055a5ec95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3b216d4efc9d4add312c055a5ec95f">&#9670;&nbsp;</a></span>build_triangulation_from_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::build_triangulation_from_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt;::active_cell_iterator, typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_to_global_tria_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function constructs a <a class="el" href="classTriangulation.html">Triangulation</a> (named <code>local_triangulation</code>) from a given vector of active cells. This vector (which we think of the cells corresponding to a "patch") contains active cells that are part of an existing global <a class="el" href="classTriangulation.html">Triangulation</a>. The goal of this function is to build a local <a class="el" href="classTriangulation.html">Triangulation</a> that contains only the active cells given in <code>patch</code> (and potentially a minimum number of additional cells required to form a valid <a class="el" href="classTriangulation.html">Triangulation</a>). The function also returns a map that allows to identify the cells in the output <a class="el" href="classTriangulation.html">Triangulation</a> and corresponding cells in the input list.</p>
<p>The function copies the location of vertices of cells from the cells of the source triangulation to the triangulation that is built from the list of patch cells. This adds support for triangulations which have been perturbed or smoothed in some manner which makes the triangulation deviate from the standard deal.ii refinement strategy of placing new vertices at midpoints of faces or edges.</p>
<p>The operation implemented by this function is frequently used in the definition of error estimators that need to solve "local" problems on each cell and its neighbors. A similar construction is necessary in the definition of the Clement interpolation operator in which one needs to solve a local problem on all cells within the support of a shape function. This function then builds a complete <a class="el" href="classTriangulation.html">Triangulation</a> from a list of cells that make up such a patch; one can then later attach a <a class="el" href="classDoFHandler.html">DoFHandler</a> to such a <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>If the list of input cells contains only cells at the same refinement level, then the output <a class="el" href="classTriangulation.html">Triangulation</a> simply consists of a <a class="el" href="classTriangulation.html">Triangulation</a> containing only exactly these patch cells. On the other hand, if the input cells live on different refinement levels, i.e., the <a class="el" href="classTriangulation.html">Triangulation</a> of which they are part is adaptively refined, then the construction of the output <a class="el" href="classTriangulation.html">Triangulation</a> is not so simple because the coarsest level of a <a class="el" href="classTriangulation.html">Triangulation</a> can not contain hanging nodes. Rather, we first have to find the common refinement level of all input cells, along with their common parents (see <a class="el" href="namespaceGridTools.html#a1cb9de754873e0401df4a51bacf0556c">GridTools::get_cells_at_coarsest_common_level()</a>), build a <a class="el" href="classTriangulation.html">Triangulation</a> from those, and then adaptively refine it so that the input cells all also exist in the output <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>A consequence of this procedure is that that output <a class="el" href="classTriangulation.html">Triangulation</a> may contain more active cells than the ones that exist in the input vector. On the other hand, one typically wants to solve the local problem not on the entire output <a class="el" href="classTriangulation.html">Triangulation</a>, but only on those cells of it that correspond to cells in the input list. In this case, a user typically wants to assign degrees of freedom only on cells that are part of the "patch", and somehow ignore those excessive cells. The current function supports this common requirement by setting the user flag for the cells in the output <a class="el" href="classTriangulation.html">Triangulation</a> that match with cells in the input list. Cells which are not part of the original patch will not have their <code>user_flag</code> set; we can then avoid assigning degrees of freedom using the <a class="el" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a> element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>In C++, the compiler can not determine the type of <code>Container</code> from the function call. You need to specify it as an explicit template argument following the function name. This type that satisfies the requirements of a mesh container (see <a class="el" href="group__Concepts.html#ConceptMeshType">ConceptMeshType</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A vector of active cells from a common triangulation. These cells may or may not all be at the same refinement level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_triangulation</td><td>A triangulation whose active cells correspond to the given vector of active cells in <code>patch</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">patch_to_global_tria_map</td><td>A map between the local triangulation which is built as explained above, and the cell iterators in the input list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Arezou Ghesmati, Wolfgang Bangerth, 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03231">3231</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae7a90d2b1a061b70a0d28761e3e1316f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a90d2b1a061b70a0d28761e3e1316f">&#9670;&nbsp;</a></span>get_dof_to_support_patch_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>, std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &gt; GridTools::get_dof_to_support_patch_map </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function runs through the degrees of freedom defined by the DoFHandlerType and for each dof constructs a vector of active_cell_iterators representing the cells of support of the associated basis element at that degree of freedom. This function was originally designed for the implementation of local projections, for instance the Clement interpolant, in conjunction with other local patch functions like <a class="el" href="namespaceGridTools.html#aca3b216d4efc9d4add312c055a5ec95f">GridTools::build_triangulation_from_patch</a>.</p>
<p>DoFHandlerType's built on top of <a class="el" href="classTriangulation.html">Triangulation</a> or parallel:distributed::<a class="el" href="classTriangulation.html">Triangulation</a> are supported and handled appropriately.</p>
<p>The result is the patch of cells representing the support of the basis element associated to the degree of freedom. For instance using an <a class="el" href="classFE__Q.html">FE_Q</a> finite element, we obtain the standard patch of cells touching the degree of freedom and then add other cells that take care of possible hanging node constraints. Using a <a class="el" href="classFE__DGQ.html">FE_DGQ</a> finite element, the degrees of freedom are logically considered to be "interior" to the cells so the patch would consist exclusively of the single cell on which the degree of freedom is located.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DoFHandlerType</td><td>The DoFHandlerType should be a <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The DoFHandlerType which could be built on a <a class="el" href="classTriangulation.html">Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> with a finite element that has degrees of freedom that are logically associated to a vertex, line, quad, or hex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from the global_dof_index of degrees of freedom on locally relevant cells to vectors containing DoFHandlerType::active_cell_iterators of cells in the support of the basis function at that degree of freedom.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Spencer Patty, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03411">3411</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ac2a1903382c6cff07b33d456a641f6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a1903382c6cff07b33d456a641f6d9">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,FaceIterator::AccessorType::space_dimension&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;double&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An orthogonal equality test for faces.</p>
<p><code>face1</code> and <code>face2</code> are considered equal, if a one to one matching between its vertices can be achieved via an orthogonal equality relation.</p>
<p>Here, two vertices <code>v_1</code> and <code>v_2</code> are considered equal, if <img class="formulaInl" alt="$M\cdot v_1 + offset - v_2$" src="form_836.png"/> is parallel to the unit vector in unit direction <code>direction</code>. If the parameter <code>matrix</code> is a reference to a spacedim x spacedim matrix, <img class="formulaInl" alt="$M$" src="form_64.png"/> is set to <code>matrix</code>, otherwise <img class="formulaInl" alt="$M$" src="form_64.png"/> is the identity matrix.</p>
<p>If the matching was successful, the <em>relative</em> orientation of <code>face1</code> with respect to <code>face2</code> is returned in the bitset <code>orientation</code>, where </p><div class="fragment"><div class="line">orientation[0] -&gt; face_orientation</div><div class="line">orientation[1] -&gt; face_flip</div><div class="line">orientation[2] -&gt; face_rotation</div></div><!-- fragment --><p>In 2D <code>face_orientation</code> is always <code>true</code>, <code>face_rotation</code> is always <code>false</code>, and face_flip has the meaning of <code>line_flip</code>. More precisely in 3d:</p>
<p><code>face_orientation</code>: <code>true</code> if <code>face1</code> and <code>face2</code> have the same orientation. Otherwise, the vertex indices of <code>face1</code> match the vertex indices of <code>face2</code> in the following manner:</p>
<div class="fragment"><div class="line">face1:           face2:</div><div class="line"></div><div class="line">1 - 3            2 - 3</div><div class="line">|   |    &lt;--&gt;    |   |</div><div class="line">0 - 2            0 - 1</div></div><!-- fragment --><p><code>face_flip</code>: <code>true</code> if the matched vertices are rotated by 180 degrees:</p>
<div class="fragment"><div class="line">face1:           face2:</div><div class="line"></div><div class="line">1 - 0            2 - 3</div><div class="line">|   |    &lt;--&gt;    |   |</div><div class="line">3 - 2            0 - 1</div></div><!-- fragment --><p><code>face_rotation</code>: <code>true</code> if the matched vertices are rotated by 90 degrees counterclockwise:</p>
<div class="fragment"><div class="line">face1:           face2:</div><div class="line"></div><div class="line">0 - 2            2 - 3</div><div class="line">|   |    &lt;--&gt;    |   |</div><div class="line">1 - 3            0 - 1</div></div><!-- fragment --><p>and any combination of that... More information on the topic can be found in the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article.</p>
<dl class="section author"><dt>Author</dt><dd>Matthias Maier, 2012 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03795">3795</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ad9ea413c4f9405a1515dc9f1af8a6ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ea413c4f9405a1515dc9f1af8a6ec3">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;&#160;1,&#160;FaceIterator::AccessorType::space_dimension&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;&#160;double&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but doesn't return the actual orientation </p>

</div>
</div>
<a id="aaeadfc0053429f542fbfd48d192b94f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeadfc0053429f542fbfd48d192b94f0">&#9670;&nbsp;</a></span>collect_periodic_faces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>::<a class="el" href="classTensor.html">Tensor</a>&lt;1,MeshType::space_dimension&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;double&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will collect periodic face pairs on the coarsest mesh level of the given <code>mesh</code> (a <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>) and add them to the vector <code>matched_pairs</code> leaving the original contents intact.</p>
<p>Define a 'first' boundary as all boundary faces having boundary_id <code>b_id1</code> and a 'second' boundary consisting of all faces belonging to <code>b_id2</code>.</p>
<p>This function tries to match all faces belonging to the first boundary with faces belonging to the second boundary with the help of <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a>.</p>
<p>The bitset that is returned inside of <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a> encodes the <em>relative</em> orientation of the first face with respect to the second face, see the documentation of <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a> for further details.</p>
<p>The <code>direction</code> refers to the space direction in which periodicity is enforced. When maching periodic faces this vector component is ignored.</p>
<p>The <code>offset</code> is a vector tangential to the faces that is added to the location of vertices of the 'first' boundary when attempting to match them to the corresponding vertices of the 'second' boundary. This can be used to implement conditions such as <img class="formulaInl" alt="$u(0,y)=u(1,y+1)$" src="form_837.png"/>.</p>
<p>Optionally, a <img class="formulaInl" alt="$dim\times dim$" src="form_838.png"/> rotation <code>matrix</code> can be specified that describes how vector valued DoFs of the first face should be modified prior to constraining to the DoFs of the second face. The <code>matrix</code> is used in two places. First, <code>matrix</code> will be supplied to <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a> and used for matching faces: Two vertices <img class="formulaInl" alt="$v_1$" src="form_839.png"/> and <img class="formulaInl" alt="$v_2$" src="form_840.png"/> match if <img class="formulaInl" alt="$\text{matrix}\cdot v_1 + \text{offset} - v_2$" src="form_841.png"/> is parallel to the unit vector in unit direction <code>direction</code>. (For more details see <a class="el" href="namespaceDoFTools.html#ab1028908d67f767237a12fce8e761c16">DoFTools::make_periodicity_constraints()</a>, the glossary <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">glossary entry on periodic conditions</a> and <a class="el" href="step_45.html">step-45</a>). Second, <code>matrix</code> will be stored in the <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a> collection <code>matched_pairs</code> for further use.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The created std::vector can be used in <a class="el" href="namespaceDoFTools.html#ab1028908d67f767237a12fce8e761c16">DoFTools::make_periodicity_constraints()</a> and in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9539cda687eeb08c602bceac11807987">parallel::distributed::Triangulation::add_periodicity()</a> to enforce periodicity algebraically.</dd>
<dd>
Because elements will be added to <code>matched_pairs</code> (and existing entries will be preserved), it is possible to call this function several times with different boundary ids to generate a vector with all periodic pairs.</dd>
<dd>
Since the periodic face pairs are found on the coarsest mesh level, it is necessary to ensure that the coarsest level faces have the correct boundary indicators set. In general, this means that one must first set all boundary indicators on the coarse grid before performing any global or local grid refinement.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Daniel Arndt, Matthias Maier, 2013 - 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03925">3925</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="add6c6052ecc070b8f6ee1489b55897a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6c6052ecc070b8f6ee1489b55897a7">&#9670;&nbsp;</a></span>collect_periodic_faces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>::<a class="el" href="classTensor.html">Tensor</a>&lt;&#160;1,&#160;MeshType::space_dimension&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;&#160;double&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This compatibility version of <a class="el" href="namespaceGridTools.html#aaeadfc0053429f542fbfd48d192b94f0">collect_periodic_faces()</a> only works on grids with cells in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</p>
<p>Instead of defining a 'first' and 'second' boundary with the help of two boundary_ids this function defines a 'left' boundary as all faces with local face index <code>2*dimension</code> and boundary indicator <code>b_id</code> and, similarly, a 'right' boundary consisting of all face with local face index <code>2*dimension+1</code> and boundary indicator <code>b_id</code>.</p>
<p>This function will collect periodic face pairs on the coarsest mesh level and add them to <code>matched_pairs</code> leaving the original contents intact.</p>
<p>See above function for further details.</p>
<dl class="section note"><dt>Note</dt><dd>This version of <a class="el" href="namespaceGridTools.html#aaeadfc0053429f542fbfd48d192b94f0">collect_periodic_faces()</a> will not work on meshes with cells not in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Daniel Arndt, Matthias Maier, 2013 - 2015 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
