<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-21 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-21 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetwophaseflowproblem">The two phase flow problem</a>
        <li><a href="#Timediscretization">Time discretization</a>
        <li><a href="#Spacediscretization">Space discretization</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Choosingatimestep">Choosing a time step</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeTwoPhaseFlowProblemcodeclass">The <code>TwoPhaseFlowProblem</code> class</a>
        <li><a href="#Equationdata">Equation data</a>
      <ul>
        <li><a href="#Pressurerighthandside">Pressure right hand side</a>
        <li><a href="#Pressureboundaryvalues">Pressure boundary values</a>
        <li><a href="#Saturationboundaryvalues">Saturation boundary values</a>
        <li><a href="#Initialdata">Initial data</a>
      </ul>
        <li><a href="#Theinversepermeabilitytensor">The inverse permeability tensor</a>
      <ul>
        <li><a href="#Singlecurvingcrackpermeability">Single curving crack permeability</a>
        <li><a href="#Randommediumpermeability">Random medium permeability</a>
      </ul>
        <li><a href="#Theinversemobilityandsaturationfunctions">The inverse mobility and saturation functions</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
        <li><a href="#codeTwoPhaseFlowProblemcodeclassimplementation"><code>TwoPhaseFlowProblem</code> class implementation</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemTwoPhaseFlowProblem">TwoPhaseFlowProblem::TwoPhaseFlowProblem</a>
        <li><a href="#TwoPhaseFlowProblemmake_grid_and_dofs">TwoPhaseFlowProblem::make_grid_and_dofs</a>
        <li><a href="#TwoPhaseFlowProblemassemble_system">TwoPhaseFlowProblem::assemble_system</a>
        <li><a href="#TwoPhaseFlowProblemassemble_rhs_S">TwoPhaseFlowProblem::assemble_rhs_S</a>
        <li><a href="#TwoPhaseFlowProblemsolve">TwoPhaseFlowProblem::solve</a>
        <li><a href="#TwoPhaseFlowProblemoutput_results">TwoPhaseFlowProblem::output_results</a>
        <li><a href="#TwoPhaseFlowProblemproject_back_saturation">TwoPhaseFlowProblem::project_back_saturation</a>
        <li><a href="#TwoPhaseFlowProblemget_maximal_velocity">TwoPhaseFlowProblem::get_maximal_velocity</a>
        <li><a href="#TwoPhaseFlowProblemrun">TwoPhaseFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Solvers">Solvers</a>
        <li><a href="#Timestepping">Time stepping</a>
        <li><a href="#Adaptivity">Adaptivity</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Introduction"></a><a class="anchor" id="Intro"></a> </p><h1>Introduction</h1>
<p>This program grew out of a student project by Yan Li at Texas A&amp;M University. Most of the work for this program is by her.</p>
<p>In this project, we propose a numerical simulation for two phase flow problems in porous media. This problem includes one elliptic equation and one nonlinear, time dependent transport equation. This is therefore also the first time-dependent tutorial program (besides the somewhat strange time-dependence of <a class="el" href="step_18.html">step-18</a>).</p>
<p>The equations covered here are an extension of the material already covered in <a class="el" href="step_20.html">step-20</a>. In particular, they fall into the class of vector-valued problems. A toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Thetwophaseflowproblem"></a></p><h3>The two phase flow problem</h3>
<p>Modeling of two phase flow in porous media is important for both environmental remediation and the management of petroleum and groundwater reservoirs. Practical situations involving two phase flow include the dispersal of a nonaqueous phase liquid in an aquifer, or the joint movement of a mixture of fluids such as oil and water in a reservoir. Simulation models, if they are to provide realistic predictions, must accurately account for these effects.</p>
<p>To derive the governing equations, consider two phase flow in a reservoir <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> under the assumption that the movement of fluids is dominated by viscous effects; i.e. we neglect the effects of gravity, compressibility, and capillary pressure. Porosity will be considered to be constant. We will denote variables referring to either of the two phases using subscripts <img class="formulaInl" alt="$w$" src="form_859.png"/> and <img class="formulaInl" alt="$o$" src="form_354.png"/>, short for water and oil. The derivation of the equations holds for other pairs of fluids as well, however.</p>
<p>The velocity with which molecules of each of the two phases move is determined by Darcy's law that states that the velocity is proportional to the pressure gradient: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \mathbf{u}_{j} = -\frac{k_{rj}(S)}{\mu_{j}} \mathbf{K} \cdot \nabla p \end{eqnarray*}" src="form_1726.png"/>
</p>
<p> where <img class="formulaInl" alt="$\mathbf{u}_{j}$" src="form_1727.png"/> is the velocity of phase <img class="formulaInl" alt="$j=o,w$" src="form_1728.png"/>, <img class="formulaInl" alt="$K$" src="form_57.png"/> is the permeability tensor, <img class="formulaInl" alt="$k_{rj}$" src="form_1729.png"/> is the relative permeability of phase <img class="formulaInl" alt="$j$" src="form_513.png"/>, <img class="formulaInl" alt="$p$" src="form_202.png"/> is the pressure and <img class="formulaInl" alt="$\mu_{j}$" src="form_1730.png"/> is the viscosity of phase <img class="formulaInl" alt="$j$" src="form_513.png"/>. Finally, <img class="formulaInl" alt="$S$" src="form_731.png"/> is the saturation (volume fraction), i.e. a function with values between 0 and 1 indicating the composition of the mixture of fluids. In general, the coefficients <img class="formulaInl" alt="$K, k_{rj}, \mu$" src="form_1731.png"/> may be spatially dependent variables, and we will always treat them as non-constant functions in the following.</p>
<p>We combine Darcy's law with the statement of conservation of mass for each phase, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \textrm{div}\ \mathbf{u}_{j} = q_j, \]" src="form_1732.png"/>
</p>
<p> with a source term for each phase. By summing over the two phases, we can express the governing equations in terms of the so-called pressure equation: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \nabla \cdot (\mathbf{K}\lambda(S) \nabla p)= q. \end{eqnarray*}" src="form_1733.png"/>
</p>
<p> Here, <img class="formulaInl" alt="$q$" src="form_171.png"/> is the sum source term, and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \lambda(S) = \frac{k_{rw}(S)}{\mu_{w}}+\frac{k_{ro}(S)}{\mu_{o}} \]" src="form_1734.png"/>
</p>
<p> is the total mobility.</p>
<p>So far, this looks like an ordinary stationary, Poisson-like equation that we can solve right away with the techniques of the first few tutorial programs (take a look at <a class="el" href="step_6.html">step-6</a>, for example, for something very similar). However, we have not said anything yet about the saturation, which of course is going to change as the fluids move around.</p>
<p>The second part of the equations is a therefore description of the dynamics of the saturation. We model this as an advected quantity: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} S_{t} + \mathbf{u} \cdot \nabla F(S) = 0, \end{eqnarray*}" src="form_1735.png"/>
</p>
<p> where <img class="formulaInl" alt="$\mathbf u$" src="form_220.png"/> is the total velocity </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{u} = \mathbf{u}_{o} + \mathbf{u}_{w} = -\lambda(S) \mathbf{K}\cdot\nabla p. \]" src="form_1736.png"/>
</p>
<p> In addition, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ F(S) = \frac{k_{rw}(S)/\mu_{w}}{k_{rw}(S)/\mu_{w} + k_{ro}(S)/\mu_{o}} \]" src="form_1737.png"/>
</p>
<p> Note that the advection equation contains the term <img class="formulaInl" alt="$\mathbf{u} \cdot \nabla F(S)$" src="form_1738.png"/> rather than <img class="formulaInl" alt="$\mathbf{u} \cdot \nabla S$" src="form_1739.png"/> to indicate that the saturation is not simply transported along; rather, since the two phases move with different velocities, the saturation can actually change even in the advected coordinate system. To see this, rewrite <img class="formulaInl" alt="$\mathbf{u} \cdot \nabla F(S) = \mathbf{u} F'(S) \cdot \nabla S$" src="form_1740.png"/> to observe that the <em>actual</em> velocity with which the phase with saturation <img class="formulaInl" alt="$S$" src="form_731.png"/> is transported is <img class="formulaInl" alt="$\mathbf u F'(S)$" src="form_1741.png"/> whereas the other phase is transported at velocity <img class="formulaInl" alt="$\mathbf u (1-F'(S))$" src="form_1742.png"/>. <img class="formulaInl" alt="$F(S)$" src="form_1743.png"/> is consequently often referred to as the <em>fractional flow</em>.</p>
<p>In summary, what we get are the following two equations: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \nabla \cdot (\mathbf{K}\lambda(S) \nabla p) &amp;=&amp; q \qquad \textrm{in}\ \Omega\times[0,T], \\ S_{t} + \mathbf{u} \cdot \nabla F(S) &amp;=&amp; 0 \qquad \textrm{in}\ \Omega\times[0,T]. \end{eqnarray*}" src="form_1744.png"/>
</p>
<p> Here, <img class="formulaInl" alt="$p=p(\mathbf x, t), S=S(\mathbf x, t)$" src="form_1745.png"/> are now time dependent functions: while at every time instant the flow field is in equilibrium with the pressure (i.e. we neglect dynamic accelerations), the saturation is transported along with the flow and therefore changes over time, in turn affected the flow field again through the dependence of the first equation on <img class="formulaInl" alt="$S$" src="form_731.png"/>.</p>
<p>This set of equations has a peculiar character: one of the two equations has a time derivative, the other one doesn't. This corresponds to the character that the pressure and velocities are coupled through an instantaneous constraint, whereas the saturation evolves over finite time scales.</p>
<p>Such systems of equations are called Differential Algebraic Equations (DAEs), since one of the equations is a differential equation, the other is not (at least not with respect to the time variable) and is therefore an "algebraic" equation. (The notation comes from the field of ordinary differential equations, where everything that does not have derivatives with respect to the time variable is necessarily an algebraic equation.) This class of equations contains pretty well-known cases: for example, the time dependent Stokes and Navier-Stokes equations (where the algebraic constraint is that the divergence of the flow field, <img class="formulaInl" alt="$\textrm{div}\ \mathbf u$" src="form_1746.png"/>, must be zero) as well as the time dependent Maxwell equations (here, the algebraic constraint is that the divergence of the electric displacement field equals the charge density, <img class="formulaInl" alt="$\textrm{div}\ \mathbf D = \rho$" src="form_1747.png"/> and that the divergence of the magnetic flux density is zero: <img class="formulaInl" alt="$\textrm{div}\ \mathbf B = 0$" src="form_1748.png"/>); even the quasistatic model of <a class="el" href="step_18.html">step-18</a> falls into this category. We will see that the different character of the two equations will inform our discretization strategy for the two equations.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p>In the reservoir simulation community, it is common to solve the equations derived above by going back to the first order, mixed formulation. To this end, we re-introduce the total velocity <img class="formulaInl" alt="$\mathbf u$" src="form_220.png"/> and write the equations in the following form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \mathbf{u}+\mathbf{K}\lambda(S) \nabla p&amp;=&amp;0 \\ \nabla \cdot\mathbf{u} &amp;=&amp; q \\ S_{t} + \mathbf{u} \cdot \nabla F(S) &amp;=&amp; 0. \end{eqnarray*}" src="form_1749.png"/>
</p>
<p> This formulation has the additional benefit that we do not have to express the total velocity <img class="formulaInl" alt="$\mathbf u$" src="form_220.png"/> appearing in the transport equation as a function of the pressure, but can rather take the primary variable for it. Given the saddle point structure of the first two equations and their similarity to the mixed Laplace formulation we have introduced in <a class="el" href="step_20.html">step-20</a>, it will come as no surprise that we will use a mixed discretization again.</p>
<p>But let's postpone this for a moment. The first business we have with these equations is to think about the time discretization. In reservoir simulation, there is a rather standard algorithm that we will use here. It first solves the pressure using an implicit equation, then the saturation using an explicit time stepping scheme. The algorithm is called IMPES for IMplicit Pressure Explicit Saturation and was first proposed a long time ago: by Sheldon et al. in 1959 and Stone and Gardner in 1961 (J. W. Sheldon, B. Zondek and W. T. Cardwell: <em>One-dimensional, incompressible, non-capillary, two-phase fluid flow in a porous medium</em>, Trans. SPE AIME, 216 (1959), pp. 290-296; H. L. Stone and A. O. Gardner Jr: <em>Analysis of gas-cap or dissolved-gas reservoirs</em>, Trans. SPE AIME, 222 (1961), pp. 92-104). In a slightly modified form, this algorithm can be written as follows: for each time step, solve </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \mathbf{u}^{n+1}+\mathbf{K}\lambda(S^n) \nabla p^{n+1}&amp;=&amp;0 \\ \nabla \cdot\mathbf{u}^{n+1} &amp;=&amp; q^{n+1} \\ \frac {S^{n+1}-S^n}{\triangle t} + \mathbf{u}^{n+1} \cdot \nabla F(S^n) &amp;=&amp; 0, \end{eqnarray*}" src="form_1750.png"/>
</p>
<p> where <img class="formulaInl" alt="$\triangle t$" src="form_1751.png"/> is the length of a time step. Note how we solve the implicit pressure-velocity system that only depends on the previously computed saturation <img class="formulaInl" alt="$S^n$" src="form_1752.png"/>, and then do an explicit time step for <img class="formulaInl" alt="$S^{n+1}$" src="form_1753.png"/> that only depends on the previously known <img class="formulaInl" alt="$S^n$" src="form_1752.png"/> and the just computed <img class="formulaInl" alt="$\mathbf{u}^{n+1}$" src="form_1754.png"/>. This way, we never have to iterate for the nonlinearities of the system as we would have if we used a fully implicit method.</p>
<p>We can then state the problem in weak form as follows, by multiplying each equation with test functions <img class="formulaInl" alt="$\mathbf v$" src="form_221.png"/>, <img class="formulaInl" alt="$\phi$" src="form_643.png"/>, and <img class="formulaInl" alt="$\sigma$" src="form_456.png"/> and integrating terms by parts: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left((\mathbf{K}\lambda(S^n))^{-1} \mathbf{u}^{n+1},\mathbf v\right)_\Omega - (p^{n+1}, \nabla\cdot\mathbf v)_\Omega &amp;=&amp; - (p^{n+1}, \mathbf v)_{\partial\Omega} \\ (\nabla \cdot\mathbf{u}^{n+1}, \phi)_\Omega &amp;=&amp; (q^{n+1},\phi)_\Omega \end{eqnarray*}" src="form_1755.png"/>
</p>
<p> Note that in the first term, we have to prescribe the pressure <img class="formulaInl" alt="$p^{n+1}$" src="form_1756.png"/> on the boundary <img class="formulaInl" alt="$\partial\Omega$" src="form_1757.png"/> as boundary values for our problem. <img class="formulaInl" alt="$\mathbf n$" src="form_1758.png"/> denotes the unit outward normal vector to <img class="formulaInl" alt="$\partial K$" src="form_1759.png"/>, as usual.</p>
<p>For the saturation equation, we obtain after integrating by parts </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (S^{n+1}, \sigma)_\Omega - \triangle t \sum_K \left\{ \left(F(S^n), \nabla \cdot (\mathbf{u}^{n+1} \sigma)\right)_K - \left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}, \sigma\right)_{\partial K} \right\} &amp;=&amp; (S^n,\sigma)_\Omega. \end{eqnarray*}" src="form_1760.png"/>
</p>
<p> Using the fact that <img class="formulaInl" alt="$\nabla \cdot \mathbf{u}^{n+1}=q^{n+1}$" src="form_1761.png"/>, we can rewrite the cell term to get an equation as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (S^{n+1}, \sigma)_\Omega - \triangle t \sum_K \left\{ \left(F(S^n) \mathbf{u}^{n+1}, \nabla \sigma\right)_K - \left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}), \sigma\right)_{\partial K} \right\} &amp;=&amp; (S^n,\sigma)_\Omega + \triangle t \sum_K \left(F(S^n) q^{n+1}, \sigma\right)_K. \end{eqnarray*}" src="form_1762.png"/>
</p>
<p><a class="anchor" id="Spacediscretization"></a></p><h3>Space discretization</h3>
<p>In each time step, we then apply the mixed finite method of <a class="el" href="step_20.html">step-20</a> to the velocity and pressure. To be well-posed, we choose Raviart-Thomas spaces <img class="formulaInl" alt="$RT_{k}$" src="form_1763.png"/> for <img class="formulaInl" alt="$\mathbf{u}$" src="form_1365.png"/> and discontinuous elements of class <img class="formulaInl" alt="$DQ_{k}$" src="form_1764.png"/> for <img class="formulaInl" alt="$p$" src="form_202.png"/>. For the saturation, we will also choose <img class="formulaInl" alt="$DQ_{k}$" src="form_1764.png"/> spaces.</p>
<p>Since we have discontinuous spaces, we have to think about how to evaluate terms on the interfaces between cells, since discontinuous functions are not really defined there. In particular, we have to give a meaning to the last term on the left hand side of the saturation equation. To this end, let us define that we want to evaluate it in the following sense: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} &amp;&amp;\left(F(S^n) (\mathbf n \cdot \mathbf{u}^{n+1}), \sigma\right)_{\partial K} \\ &amp;&amp;\qquad = \left(F(S^n_+) (\mathbf n \cdot \mathbf{u}^{n+1}_+), \sigma\right)_{\partial K_+} + \left(F(S^n_-) (\mathbf n \cdot \mathbf{u}^{n+1}_-), \sigma\right)_{\partial K_-}, \end{eqnarray*}" src="form_1765.png"/>
</p>
<p> where <img class="formulaInl" alt="$\partial K_{-}:= \{x\in \partial K, \mathbf{u}(x) \cdot \mathbf{n}&lt;0\}$" src="form_1766.png"/> denotes the inflow boundary and <img class="formulaInl" alt="$\partial K_{+}:= \{\partial K \setminus \partial K_{-}\}$" src="form_1767.png"/> is the outflow part of the boundary. The quantities <img class="formulaInl" alt="$S_+,\mathbf{u}_+$" src="form_1768.png"/> then correspond to the values of these variables on the present cell, whereas <img class="formulaInl" alt="$S_-,\mathbf{u}_-$" src="form_1769.png"/> (needed on the inflow part of the boundary of <img class="formulaInl" alt="$K$" src="form_57.png"/>) are quantities taken from the neighboring cell. Some more context on discontinuous element techniques and evaluation of fluxes can also be found in <a class="el" href="step_12.html">step-12</a>.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h3>Linear solvers</h3>
<p>The linear solvers used in this program are a straightforward extension of the ones used in <a class="el" href="step_20.html">step-20</a>. Essentially, we simply have to extend everything from two to three solution components. If we use the discrete spaces mentioned above and put shape functions into the bilinear forms, we arrive at the following linear system to be solved for time step <img class="formulaInl" alt="$n+1$" src="form_903.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left( \begin{array}{ccc} M^u(S^{n}) &amp; B^{T}&amp; 0\\ B &amp; 0 &amp; 0\\ \triangle t\; H &amp; 0&amp; M^S \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{n+1} \\ P^{n+1} \\ S^{n+1} \end{array} \right) = \left( \begin{array}{c} 0 \\ F_2 \\ F_3 \end{array} \right) \]" src="form_1770.png"/>
</p>
<p> where the individual matrices and vectors are defined as follows using shape functions <img class="formulaInl" alt="$\mathbf v_i$" src="form_1771.png"/> (of type Raviart Thomas <img class="formulaInl" alt="$RT_k$" src="form_1772.png"/>) for velocities and <img class="formulaInl" alt="$\phi_i$" src="form_525.png"/> (of type <img class="formulaInl" alt="$DG_k$" src="form_1773.png"/>) for both pressures and saturations: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M^u(S^n)_{ij} &amp;=&amp; \left((\mathbf{K}\lambda(S^n))^{-1} \mathbf{v}_i,\mathbf v_j\right)_\Omega, \\ B_{ij} &amp;=&amp; -(\nabla \cdot \mathbf v_j, \phi_i)_\Omega, \\ H_{ij} &amp;=&amp; - \sum_K \left\{ \left(F(S^n) \mathbf v_i, \nabla \phi_j)\right)_K - \left(F(S^n_+) (\mathbf n \cdot (\mathbf v_i)_+), \phi_j\right)_{\partial K_+} - \left(F(S^n_-) (\mathbf n \cdot (\mathbf v_i)_-), \phi_j\right)_{\partial K_-}, \right\} \\ M^S_{ij} &amp;=&amp; (\phi_i, \phi_j)_\Omega, \\ (F_2)_i &amp;=&amp; -(q^{n+1},\phi_i)_\Omega, \\ (F_3)_i &amp;=&amp; (S^n,\phi_i)_\Omega +\triangle t \sum_K \left(F(S^n) q^{n+1}, \phi_i\right)_K. \end{eqnarray*}" src="form_1774.png"/>
</p>
<dl class="section note"><dt>Note</dt><dd>Due to historical accidents, the role of matrices <img class="formulaInl" alt="$B$" src="form_65.png"/> and <img class="formulaInl" alt="$B^T$" src="form_66.png"/> has been reverted in this program compared to <a class="el" href="step_20.html">step-20</a>. In other words, here <img class="formulaInl" alt="$B$" src="form_65.png"/> refers to the divergence and <img class="formulaInl" alt="$B^T$" src="form_66.png"/> to the gradient operators when it was the other way around in <a class="el" href="step_20.html">step-20</a>.</dd></dl>
<p>The system above presents a complication: Since the matrix <img class="formulaInl" alt="$H_{ij}$" src="form_1775.png"/> depends on <img class="formulaInl" alt="$\mathbf u^{n+1}$" src="form_1776.png"/> implicitly (the velocities are needed to determine which parts of the boundaries <img class="formulaInl" alt="$\partial K$" src="form_1759.png"/> of cells are influx or outflux parts), we can only assemble this matrix after we have solved for the velocities.</p>
<p>The solution scheme then involves the following steps: </p><ol>
<li>
<p class="startli">Solve for the pressure <img class="formulaInl" alt="$p^{n+1}$" src="form_1756.png"/> using the Schur complement technique introduced in <a class="el" href="step_20.html">step-20</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Solve for the velocity <img class="formulaInl" alt="$\mathbf u^{n+1}$" src="form_1776.png"/> as also discussed in <a class="el" href="step_20.html">step-20</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Compute the term <img class="formulaInl" alt="$F_3-\triangle t\; H \mathbf u^{n+1}$" src="form_1777.png"/>, using the just computed velocities.</p>
<p class="endli"></p>
</li>
<li>
Solve for the saturation <img class="formulaInl" alt="$S^{n+1}$" src="form_1753.png"/>. </li>
</ol>
<p>In this scheme, we never actually build the matrix <img class="formulaInl" alt="$H$" src="form_1778.png"/>, but rather generate the right hand side of the third equation once we are ready to do so.</p>
<p>In the program, we use a variable <code>solution</code> to store the solution of the present time step. At the end of each step, we copy its content, i.e. all three of its block components, into the variable <code>old_solution</code> for use in the next time step.</p>
<p><a class="anchor" id="Choosingatimestep"></a></p><h3>Choosing a time step</h3>
<p>A general rule of thumb in hyperbolic transport equations like the equation we have to solve for the saturation equation is that if we use an explicit time stepping scheme, then we should use a time step such that the distance that a particle can travel within one time step is no larger than the diameter of a single cell. In other words, here, we should choose </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \triangle t_{n+1} \le \frac h{|\mathbf{u}^{n+1}(\mathbf{x})|}. \]" src="form_1779.png"/>
</p>
<p> Fortunately, we are in a position where we can do that: we only need the time step when we want to assemble the right hand side of the saturation equation, which is after we have already solved for <img class="formulaInl" alt="$\mathbf{u}^{n+1}$" src="form_1754.png"/>. All we therefore have to do after solving for the velocity is to loop over all quadrature points in the domain and determine the maximal magnitude of the velocity. We can then set the time step for the saturation equation to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \triangle t_{n+1} = \frac {\min_K h_K}{\max_{\mathbf{x}}|\mathbf{u}^{n+1}(\mathbf{x})|}. \]" src="form_1780.png"/>
</p>
<p>Why is it important to do this? If we don't, then we will end up with lots of places where our saturation is larger than one or less than zero, as can easily be verified. (Remember that the saturation corresponds to something like the water fraction in the fluid mixture, and therefore must physically be between 0 and 1.) On the other hand, if we choose our time step according to the criterion listed above, this only happens very very infrequently &mdash; in fact only once for the entire run of the program. However, to be on the safe side, however, we run a function <code>project_back_saturation</code> at the end of each time step, that simply projects the saturation back onto the interval <img class="formulaInl" alt="$[0,1]$" src="form_364.png"/>, should it have gotten out of the physical range. This is useful since the functions <img class="formulaInl" alt="$\lambda(S)$" src="form_1781.png"/> and <img class="formulaInl" alt="$F(S)$" src="form_1743.png"/> do not represent anything physical outside this range, and we should not expect the program to do anything useful once we have negative saturations or ones larger than one.</p>
<p>Note that we will have similar restrictions on the time step also in <a class="el" href="step_23.html">step-23</a> and <a class="el" href="step_24.html">step-24</a> where we solve the time dependent wave equation, another hyperbolic problem. We will also come back to the issue of time step choice below in the section on <a href="#extensions">possible extensions to this program</a>.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>For simplicity, this program assumes that there is no source, <img class="formulaInl" alt="$q=0$" src="form_1782.png"/>, and that the heterogeneous porous medium is isotropic <img class="formulaInl" alt="$\mathbf{K}(\mathbf{x}) = k(\mathbf{x}) \mathbf{I}$" src="form_1783.png"/>. The first one of these is a realistic assumption in oil reservoirs: apart from injection and production wells, there are usually no mechanisms for fluids to appear or disappear out of the blue. The second one is harder to justify: on a microscopic level, most rocks are isotropic, because they consist of a network of interconnected pores. However, this microscopic scale is out of the range of today's computer simulations, and we have to be content with simulating things on the scale of meters. On that scale, however, fluid transport typically happens through a network of cracks in the rock, rather than through pores. However, cracks often result from external stress fields in the rock layer (for example from tectonic faulting) and the cracks are therefore roughly aligned. This leads to a situation where the permeability is often orders of magnitude larger in the direction parallel to the cracks than perpendicular to the cracks. A problem typically faces in reservoir simulation, however, is that the modeler doesn't know the direction of cracks because oil reservoirs are not accessible to easy inspection. The only solution in that case is to assume an effective, isotropic permeability.</p>
<p>Whatever the matter, both of these restrictions, no sources and isotropy, would be easy to lift with a few lines of code in the program.</p>
<p>Next, for simplicity, our numerical simulation will be done on the unit cell <img class="formulaInl" alt="$\Omega = [0,1]\times [0,1]$" src="form_1784.png"/> for <img class="formulaInl" alt="$t\in [0,T]$" src="form_1785.png"/>. Our initial conditions are <img class="formulaInl" alt="$S(\mathbf{x},0)=0$" src="form_1786.png"/>; in the oil reservoir picture, where <img class="formulaInl" alt="$S$" src="form_731.png"/> would indicate the water saturation, this means that the reservoir contains pure oil at the beginning. Note that we do not need any initial conditions for pressure or velocity, since the equations do not contain time derivatives of these variables. Finally, we impose the following pressure boundary conditions: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ p(\mathbf{x},t)=1-x_1 \qquad \textrm{on}\ \partial\Omega. \]" src="form_1787.png"/>
</p>
<p> Since the pressure and velocity solve a mixed form Poisson equation, the imposed pressure leads to a resulting flow field for the velocity. On the other hand, this flow field determines whether a piece of the boundary is of inflow or outflow type, which is of relevance because we have to impose boundary conditions for the saturation on the inflow part of the boundary, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Gamma_{in}(t) = \{\mathbf{x}\in\partial\Omega: \mathbf{n} \cdot \mathbf{u}(\mathbf{x},t) &lt; 0\}. \]" src="form_1788.png"/>
</p>
<p> On this inflow boundary, we impose the following saturation values: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray} S(\mathbf{x},t) = 1 &amp; \textrm{on}\ \Gamma_{in}\cap\{x_1=0\}, \\ S(\mathbf{x},t) = 0 &amp; \textrm{on}\ \Gamma_{in}\backslash \{x_1=0\}. \end{eqnarray}" src="form_1789.png"/>
</p>
<p> In other words, we have pure water entering the reservoir at the left, whereas the other parts of the boundary are in contact with undisturbed parts of the reservoir and whenever influx occurs on these boundaries, pure oil will enter.</p>
<p>In our simulations, we choose the total mobility as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \lambda (S) = \frac{1.0}{\mu} S^2 +(1-S)^2 \]" src="form_1790.png"/>
</p>
<p> where we use <img class="formulaInl" alt="$\mu=0.2$" src="form_1791.png"/> for the viscosity. In addition, the fractional flow of water is given by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ F(S)=\frac{S^2}{S^2+\mu (1-S)^2} \]" src="form_1792.png"/>
</p>
<dl class="section note"><dt>Note</dt><dd>Coming back to this testcase in <a class="el" href="step_43.html">step-43</a> several years later revealed an oddity in the setup of this testcase. To this end, consider that we can rewrite the advection equation for the saturation as <img class="formulaInl" alt="$S_{t} + (\mathbf{u} F'(S)) \cdot \nabla S = 0$" src="form_1793.png"/>. Now, at the initial time, we have <img class="formulaInl" alt="$S=0$" src="form_1794.png"/>, and with the given choice of function <img class="formulaInl" alt="$F(S)$" src="form_1743.png"/>, we happen to have <img class="formulaInl" alt="$F'(0)=0$" src="form_1795.png"/>. In other words, at <img class="formulaInl" alt="$t=0$" src="form_854.png"/>, the equation reduces to <img class="formulaInl" alt="$S_t=0$" src="form_1796.png"/> for all <img class="formulaInl" alt="$\mathbf x$" src="form_751.png"/>, so the saturation is zero everywhere and it is going to stay zero everywhere! This is despite the fact that <img class="formulaInl" alt="$\mathbf u$" src="form_220.png"/> is not necessarily zero: the combined fluid is moving, but we've chosen our partial flux <img class="formulaInl" alt="$F(S)$" src="form_1743.png"/> in such a way that infinitesimal amounts of wetting fluid also only move at infinitesimal speeds (i.e., they stick to the medium more than the non-wetting phase in which they are embedded). That said, how can we square this with the knowledge that wetting fluid is invading from the left, leading to the flow patterns seen in the <a href="#Results">results section</a>? That's where we get into mathematics: Equations like the transport equation we are considering here have infinitely many solutions, but only one of them is physical: the one that results from the so-called viscosity limit, called the <a href="http://en.wikipedia.org/wiki/Viscosity_solution">viscosity solution</a>. The thing is that with discontinuous elements we arrive at this viscosity limit because using a numerical flux introduces a finite amount of artificial viscosity into the numerical scheme. On the other hand, in <a class="el" href="step_43.html">step-43</a>, we use an artificial viscosity that is proportional to <img class="formulaInl" alt="$\|\mathbf u F'(S)\|$" src="form_1797.png"/> on every cell, which at the initial time is zero. Thus, the saturation there is zero and remains zero; the solution we then get is <em>one</em> solution of the advection equation, but the method does not converge to the viscosity solution without further changes. We will therefore use a different initial condition in that program.</dd></dl>
<p>Finally, to come back to the description of the testcase, we will show results for computations with the two permeability functions introduced at the end of the results section of <a class="el" href="step_20.html">step-20</a>: </p><ul>
<li>
<p class="startli">A function that models a single, winding crack that snakes through the domain. In analogy to <a class="el" href="step_20.html">step-20</a>, but taking care of the slightly different geometry we have here, we describe this by the following function: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ k(\mathbf x) = \max \left\{ e^{-\left(\frac{x_2-\frac 12 - 0.1\sin(10x_1)}{0.1}\right)^2}, 0.01 \right\}. \]" src="form_1798.png"/>
</p>
<p> Taking the maximum is necessary to ensure that the ratio between maximal and minimal permeability remains bounded. If we don't do that, permeabilities will span many orders of magnitude. On the other hand, the ratio between maximal and minimal permeability is a factor in the condition number of the Schur complement matrix, and if too large leads to problems for which our linear solvers will no longer converge properly.</p>
<p class="endli"></p>
</li>
<li>
A function that models a somewhat random medium. Here, we choose <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} k(\mathbf x) &amp;=&amp; \min \left\{ \max \left\{ \sum_{i=1}^N \sigma_i(\mathbf{x}), 0.01 \right\}, 4\right\}, \\ \sigma_i(\mathbf x) &amp;=&amp; e^{-\left(\frac{|\mathbf{x}-\mathbf{x}_i|}{0.05}\right)^2}, \end{eqnarray*}" src="form_1799.png"/>
</p>
 where the centers <img class="formulaInl" alt="$\mathbf{x}_i$" src="form_1800.png"/> are <img class="formulaInl" alt="$N$" src="form_104.png"/> randomly chosen locations inside the domain. This function models a domain in which there are <img class="formulaInl" alt="$N$" src="form_104.png"/> centers of higher permeability (for example where rock has cracked) embedded in a matrix of more pristine, unperturbed background rock. Note that here we have cut off the permeability function both above and below to ensure a bounded condition number. </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>This program is an adaptation of <a class="el" href="step_20.html">step-20</a> and includes some technique of DG methods from <a class="el" href="step_12.html">step-12</a>. A good part of the program is therefore very similar to <a class="el" href="step_20.html">step-20</a> and we will not comment again on these parts. Only the new stuff will be discussed in more detail.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>All of these include files have been used before:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_raviart_thomas.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div></div><!-- fragment --><p>In this program, we use a tensor-valued coefficient. Since it may have a spatial dependence, we consider it a tensor-valued function. The following include file provides the <code><a class="el" href="classTensorFunction.html">TensorFunction</a></code> class that offers such functionality:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor_function.h&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step21</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeTwoPhaseFlowProblemcodeclass"></a> </p><h3>The <code>TwoPhaseFlowProblem</code> class</h3>
<p>This is the main class of the program. It is close to the one of <a class="el" href="step_20.html">step-20</a>, but with a few additional functions:</p>
<ul>
<li>
<p class="startli"><code>assemble_rhs_S</code> assembles the right hand side of the saturation equation. As explained in the introduction, this can't be integrated into <code>assemble_rhs</code> since it depends on the velocity that is computed in the first part of the time step.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>get_maximal_velocity</code> does as its name suggests. This function is used in the computation of the time step size.</p>
<p class="endli"></p>
</li>
<li>
<code>project_back_saturation</code> resets all saturation degrees of freedom with values less than zero to zero, and all those with saturations greater than one to one. </li>
</ul>
<p>The rest of the class should be pretty much obvious. The <code>viscosity</code> variable stores the viscosity <img class="formulaInl" alt="$\mu$" src="form_1643.png"/> that enters several of the formulas in the nonlinear equations.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TwoPhaseFlowProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid_and_dofs ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_rhs_S ();</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity () <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> project_back_saturation ();</div><div class="line">  <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_steps;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> time_step;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">  <span class="keywordtype">double</span> viscosity;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> old_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p><a class="anchor" id="Pressurerighthandside"></a> </p><h4>Pressure right hand side</h4>
<p>At present, the right hand side of the pressure equation is simply the zero function. However, the rest of the program is fully equipped to deal with anything else, if this is desired:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureRightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">PressureRightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;/ *p* /,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> / *component* /)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Pressureboundaryvalues"></a> </p><h4>Pressure boundary values</h4>
<p>The next are pressure boundary values. As mentioned in the introduction, we choose a linear pressure field:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureBoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">PressureBoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> / *component* /)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 1-p[0];</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Saturationboundaryvalues"></a> </p><h4>Saturation boundary values</h4>
<p>Then we also need boundary values on the inflow portions of the boundary. The question whether something is an inflow part is decided when assembling the right hand side, we only have to provide a functional description of the boundary values. This is as explained in the introduction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SaturationBoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">SaturationBoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> / *component* /)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Initialdata"></a> </p><h4>Initial data</h4>
<p>Finally, we need initial data. In reality, we only need initial data for the saturation, but we are lazy, so we will later, before the first time step, simply interpolate the entire solution for the previous time step from a function that contains all vector components.</p>
<p>We therefore simply create a function that returns zero in all components. We do that by simply forward every function to the <a class="el" href="classZeroFunction.html">ZeroFunction</a> class. Why not use that right away in the places of this program where we presently use the <code>InitialValues</code> class? Because this way it is simpler to later go back and choose a different function for initial values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+2) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">InitialValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+2).value (p, component);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">InitialValues&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+2).vector_value (p, values);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Theinversepermeabilitytensor"></a> </p><h3>The inverse permeability tensor</h3>
<p>As announced in the introduction, we implement two different permeability tensor fields. Each of them we put into a namespace of its own, so that it will be easy later to replace use of one by the other in the code.</p>
<p><a class="anchor" id="Singlecurvingcrackpermeability"></a> </p><h4>Single curving crack permeability</h4>
<p>The first function for the permeability was the one that models a single curving crack. It was already used at the end of <a class="el" href="step_20.html">step-20</a>, and its functional form is given in the introduction of the present tutorial program. As in some previous programs, we have to declare a (seemingly unnecessary) default constructor of the KInverse class to avoid warnings from some compilers:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse ()</div><div class="line">      :</div><div class="line">      <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt; ()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  KInverse&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (points.size() == values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (points.size(), values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">      {</div><div class="line">        values[p].clear ();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline</div><div class="line">          = std::fabs(points[p][1]-0.5-0.1*std::sin(10*points[p][0]));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> permeability = std::max(std::exp(-(distance_to_flowline*</div><div class="line">                                                        distance_to_flowline)</div><div class="line">                                                      / (0.1 * 0.1)),</div><div class="line">                                             0.01);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          values[p][d][d] = 1./permeability;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Randommediumpermeability"></a> </p><h4>Random medium permeability</h4>
<p>This function does as announced in the introduction, i.e. it creates an overlay of exponentials at random places. There is one thing worth considering for this class. The issue centers around the problem that the class creates the centers of the exponentials using a random function. If we therefore created the centers each time we create an object of the present type, we would get a different list of centers each time. That's not what we expect from classes of this type: they should reliably represent the same function.</p>
<p>The solution to this problem is to make the list of centers a static member variable of this class, i.e. there exists exactly one such variable for the entire program, rather than for each object of this type. That's exactly what we are going to do.</p>
<p>The next problem, however, is that we need a way to initialize this variable. Since this variable is initialized at the beginning of the program, we can't use a regular member function for that since there may not be an object of this type around at the time. The C++ standard therefore says that only non-member and static member functions can be used to initialize a static variable. We use the latter possibility by defining a function <code>get_centers</code> that computes the list of center points when called.</p>
<p>Note that this class works just fine in both 2d and 3d, with the only difference being that we use more points in 3d: by experimenting we find that we need more exponentials in 3d than in 2d (we have more ground to cover, after all, if we want to keep the distance between centers roughly equal), so we choose 40 in 2d and 100 in 3d. For any other dimension, the function does presently not know what to do so simply throws an exception indicating exactly this.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>RandomMedium</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse ()</div><div class="line">      :</div><div class="line">      <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt; ()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt; &gt; centers;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt; &gt; get_centers ();</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;Point&lt;dim&gt; &gt;</div><div class="line">  KInverse&lt;dim&gt;::centers = KInverse&lt;dim&gt;::get_centers();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;Point&lt;dim&gt; &gt;</div><div class="line">  KInverse&lt;dim&gt;::get_centers ()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = (dim == 2 ?</div><div class="line">                            40 :</div><div class="line">                            (dim == 3 ?</div><div class="line">                             100 :</div><div class="line">                             <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt; &gt; centers_list (N);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;N; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        centers_list[i][d] = static_cast&lt;double&gt;(rand())/RAND_MAX;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> centers_list;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  KInverse&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (points.size() == values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (points.size(), values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">      {</div><div class="line">        values[p].clear ();</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> permeability = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;centers.size(); ++i)</div><div class="line">          permeability += std::exp(-(points[p]-centers[i]).norm_square()</div><div class="line">                                   / (0.05 * 0.05));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability</div><div class="line">          = std::min (std::max(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          values[p][d][d] = 1./normalized_permeability;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Theinversemobilityandsaturationfunctions"></a> </p><h3>The inverse mobility and saturation functions</h3>
<p>There are two more pieces of data that we need to describe, namely the inverse mobility function and the saturation curve. Their form is also given in the introduction:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mobility_inverse (<span class="keyword">const</span> <span class="keywordtype">double</span> S,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> 1.0 / (1.0/viscosity * S * S + (1-S) * (1-S));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> fractional_flow (<span class="keyword">const</span> <span class="keywordtype">double</span> S,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> S*S / (S * S + viscosity * (1-S) * (1-S));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p>The linear solvers we use are also completely analogous to the ones used in <a class="el" href="step_20.html">step-20</a>. The following classes are therefore copied verbatim from there. Note that the classes here are not only copied from <a class="el" href="step_20.html">step-20</a>, but also duplicate classes in deal.II. In a future version of this example, they should be replaced by an efficient method, though. There is a single change: if the size of a linear system is small, i.e. when the mesh is very coarse, then it is sometimes not sufficient to set a maximum of <code>src.size()</code> CG iterations before the solver in the <code>vmult()</code> function converges. (This is, of course, a result of numerical round-off, since we know that on paper, the CG method converges in at most <code>src.size()</code> steps.) As a consequence, we set the maximum number of iterations equal to the maximum of the size of the linear system and 200.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix (<span class="keyword">const</span> MatrixType &amp;m);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> matrix;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">InverseMatrix&lt;MatrixType&gt;::InverseMatrix (<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">  :</div><div class="line">  matrix (&amp;m)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType&gt;::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                                       <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (std::max(src.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span> (200)),</div><div class="line">                                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8*src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div><div class="line"></div><div class="line">  dst = 0;</div><div class="line"></div><div class="line">  cg.solve (*matrix, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A,</div><div class="line">                   <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &gt; &amp;Minv);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a> &gt; &gt; m_inverse;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">SchurComplement::</div><div class="line">SchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A,</div><div class="line">                 <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &gt; &amp;Minv)</div><div class="line">  :</div><div class="line">  system_matrix (&amp;A),</div><div class="line">  m_inverse (&amp;Minv),</div><div class="line">  tmp1 (A.block(0,0).m()),</div><div class="line">  tmp2 (A.block(0,0).m())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> SchurComplement::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  system_matrix-&gt;block(0,1).vmult (tmp1, src);</div><div class="line">  m_inverse-&gt;vmult (tmp2, tmp1);</div><div class="line">  system_matrix-&gt;block(1,0).vmult (dst, tmp2);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ApproximateSchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">ApproximateSchurComplement::</div><div class="line">ApproximateSchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A)</div><div class="line">  :</div><div class="line">  system_matrix (&amp;A),</div><div class="line">  tmp1 (A.block(0,0).m()),</div><div class="line">  tmp2 (A.block(0,0).m())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ApproximateSchurComplement::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  system_matrix-&gt;block(0,1).vmult (tmp1, src);</div><div class="line">  system_matrix-&gt;block(0,0).precondition_Jacobi (tmp2, tmp1);</div><div class="line">  system_matrix-&gt;block(1,0).vmult (dst, tmp2);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeTwoPhaseFlowProblemcodeclassimplementation"></a> </p><h3><code>TwoPhaseFlowProblem</code> class implementation</h3>
<p>Here now the implementation of the main class. Much of it is actually copied from <a class="el" href="step_20.html">step-20</a>, so we won't comment on it in much detail. You should try to get familiar with that program first, then most of what is happening here should be mostly clear.</p>
<p><a class="anchor" id="TwoPhaseFlowProblemTwoPhaseFlowProblem"></a> </p><h4>TwoPhaseFlowProblem::TwoPhaseFlowProblem</h4>
<p>First for the constructor. We use <img class="formulaInl" alt="$RT_k \times DQ_k \times DQ_k$" src="form_1801.png"/> spaces. The time step is set to zero initially, but will be computed before it is needed first, as described in a subsection of the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  :</div><div class="line">  degree (degree),</div><div class="line">  fe (<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree), 1,</div><div class="line">      <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1,</div><div class="line">      <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1),</div><div class="line">  dof_handler (triangulation),</div><div class="line">  n_refinement_steps (5),</div><div class="line">  time_step (0),</div><div class="line">  timestep_number (1),</div><div class="line">  viscosity (0.2)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemmake_grid_and_dofs"></a> </p><h4>TwoPhaseFlowProblem::make_grid_and_dofs</h4>
<p>This next function starts out with well-known functions calls that create and refine a mesh, and then associate degrees of freedom with it. It does all the same things as in <a class="el" href="step_20.html">step-20</a>, just now for three components instead of two.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::make_grid_and_dofs ()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, 0, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (n_refinement_steps);</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> (dof_handler);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; dofs_per_component (dim+2);</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a1a86f6b2291b6bc814a982b85fa64a09">DoFTools::count_dofs_per_component</a> (dof_handler, dofs_per_component);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                     n_p = dofs_per_component[dim],</div><div class="line">                     n_s = dofs_per_component[dim+1];</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span>&lt;&lt; n_s &lt;&lt;<span class="charliteral">&#39;)&#39;</span></div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">  n_couplings = dof_handler.<a class="code" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">max_couplings_between_dofs</a>();</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (3,3);</div><div class="line">  sparsity_pattern.block(0,0).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_u, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(1,0).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_p, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(2,0).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_s, n_u, n_couplings);</div><div class="line">  sparsity_pattern.block(0,1).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_u, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(1,1).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_p, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(2,1).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_s, n_p, n_couplings);</div><div class="line">  sparsity_pattern.block(0,2).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_u, n_s, n_couplings);</div><div class="line">  sparsity_pattern.block(1,2).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_p, n_s, n_couplings);</div><div class="line">  sparsity_pattern.block(2,2).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_s, n_s, n_couplings);</div><div class="line"></div><div class="line">  sparsity_pattern.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (3);</div><div class="line">  solution.block(0).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_u);</div><div class="line">  solution.block(1).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_p);</div><div class="line">  solution.block(2).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_s);</div><div class="line">  solution.collect_sizes ();</div><div class="line"></div><div class="line">  old_solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (3);</div><div class="line">  old_solution.block(0).reinit (n_u);</div><div class="line">  old_solution.block(1).reinit (n_p);</div><div class="line">  old_solution.block(2).reinit (n_s);</div><div class="line">  old_solution.collect_sizes ();</div><div class="line"></div><div class="line">  system_rhs.reinit (3);</div><div class="line">  system_rhs.block(0).reinit (n_u);</div><div class="line">  system_rhs.block(1).reinit (n_p);</div><div class="line">  system_rhs.block(2).reinit (n_s);</div><div class="line">  system_rhs.collect_sizes ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemassemble_system"></a> </p><h4>TwoPhaseFlowProblem::assemble_system</h4>
<p>This is the function that assembles the linear system, or at least everything except the (1,3) block that depends on the still-unknown velocity computed during this time step (we deal with this in <code>assemble_rhs_S</code>). Much of it is again as in <a class="el" href="step_20.html">step-20</a>, but we have to deal with some nonlinearity this time. However, the top of the function is pretty much as usual (note that we set matrix and right hand side to zero at the beginning &mdash; something we didn't have to do for stationary problems since there we use each matrix object only once and it is empty at the beginning anyway).</p>
<p>Note that in its present form, the function uses the permeability implemented in the RandomMedium::KInverse class. Switching to the single curved crack permeability function is as simple as just changing the namespace name.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  system_matrix=0;</div><div class="line">  system_rhs=0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(degree+2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe, face_quadrature_formula,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   local_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       local_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> PressureRightHandSide&lt;dim&gt;  pressure_right_hand_side;</div><div class="line">  <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line">  <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;               pressure_rhs_values (n_q_points);</div><div class="line">  std::vector&lt;double&gt;               boundary_values (n_face_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;2,dim&gt; &gt;       k_inverse_values (n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt;      old_solution_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">  std::vector&lt;std::vector&lt;Tensor&lt;1,dim&gt; &gt; &gt;  old_solution_grads(n_q_points,</div><div class="line">      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; (dim+2));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation (dim+1);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">      local_matrix = 0;</div><div class="line">      local_rhs = 0;</div></div><!-- fragment --><p>Here's the first significant difference: We have to get the values of the saturation function of the previous time step at the quadrature points. To this end, we can use the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> (previously already used in <a class="el" href="step_9.html">step-9</a>, <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_15.html">step-15</a>), a function that takes a solution vector and returns a list of function values at the quadrature points of the present cell. In fact, it returns the complete vector-valued solution at each quadrature point, i.e. not only the saturation but also the velocities and pressure:</p>
<div class="fragment"><div class="line">fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_solution, old_solution_values);</div></div><!-- fragment --><p>Then we also have to get the values of the pressure right hand side and of the inverse permeability tensor at the quadrature points:</p>
<div class="fragment"><div class="line">pressure_right_hand_side.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                     pressure_rhs_values);</div><div class="line">k_inverse.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                      k_inverse_values);</div></div><!-- fragment --><p>With all this, we can now loop over all the quadrature points and shape functions on this cell and assemble those parts of the matrix and right hand side that we deal with in this function. The individual terms in the contributions should be self-explanatory given the explicit form of the bilinear form stated in the introduction:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim+1);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_i_u      = fe_values[velocities].value (i, q);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_i_u  = fe_values[velocities].divergence (i, q);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_i_p      = fe_values[pressure].value (i, q);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_i_s      = fe_values[saturation].value (i, q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_j_u     = fe_values[velocities].value (j, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_j_u = fe_values[velocities].divergence (j, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_j_p     = fe_values[pressure].value (j, q);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_j_s     = fe_values[saturation].value (j, q);</div><div class="line"></div><div class="line">          local_matrix(i,j) += (phi_i_u * k_inverse_values[q] *</div><div class="line">                                mobility_inverse(old_s,viscosity) * phi_j_u</div><div class="line">                                - div_phi_i_u * phi_j_p</div><div class="line">                                - phi_i_p * div_phi_j_u</div><div class="line">                                + phi_i_s * phi_j_s)</div><div class="line">                               * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      local_rhs(i) += (-phi_i_p * pressure_rhs_values[q])*</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    }</div></div><!-- fragment --><p>Next, we also have to deal with the pressure boundary values. This, again is as in <a class="el" href="step_20.html">step-20</a>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0;</div><div class="line">     face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">     ++face_no)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">    {</div><div class="line">      fe_face_values.reinit (cell, face_no);</div><div class="line"></div><div class="line">      pressure_boundary_values</div><div class="line">      .value_list (fe_face_values.get_quadrature_points(),</div><div class="line">                   boundary_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a></div><div class="line">            phi_i_u = fe_face_values[velocities].value (i, q);</div><div class="line"></div><div class="line">            local_rhs(i) += -(phi_i_u *</div><div class="line">                              fe_face_values.normal_vector(q) *</div><div class="line">                              boundary_values[q] *</div><div class="line">                              fe_face_values.JxW(q));</div><div class="line">          }</div><div class="line">    }</div></div><!-- fragment --><p>The final step in the loop over all cells is to transfer local contributions into the global matrix and right hand side vector:</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">          system_matrix.add (local_dof_indices[i],</div><div class="line">                             local_dof_indices[j],</div><div class="line">                             local_matrix(i,j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>So much for assembly of matrix and right hand side. Note that we do not have to interpolate and apply boundary values since they have all been taken care of in the weak form already.</p>
<p><a class="anchor" id="TwoPhaseFlowProblemassemble_rhs_S"></a> </p><h4>TwoPhaseFlowProblem::assemble_rhs_S</h4>
<p>As explained in the introduction, we can only evaluate the right hand side of the saturation equation once the velocity has been computed. We therefore have this separate function to this end.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_rhs_S ()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(degree+2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe, face_quadrature_formula,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_neighbor (fe, face_quadrature_formula,</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       local_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; old_solution_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; old_solution_values_face(n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; old_solution_values_face_neighbor(n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; present_solution_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; present_solution_values_face(n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; neighbor_saturation (n_face_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation (dim+1);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      local_rhs = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_solution, old_solution_values);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (solution, present_solution_values);</div></div><!-- fragment --><p>First for the cell terms. These are, following the formulas in the introduction, <img class="formulaInl" alt="$(S^n,\sigma)-(F(S^n) \mathbf{v}^{n+1},\nabla \sigma)$" src="form_1802.png"/>, where <img class="formulaInl" alt="$\sigma$" src="form_456.png"/> is the saturation component of the test function:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim+1);</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> present_u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        present_u[d] = present_solution_values[q](d);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_i_s      = fe_values[saturation].value (i, q);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> grad_phi_i_s = fe_values[saturation].gradient (i, q);</div><div class="line"></div><div class="line">      local_rhs(i) += (time_step *</div><div class="line">                       fractional_flow(old_s,viscosity) *</div><div class="line">                       present_u *</div><div class="line">                       grad_phi_i_s</div><div class="line">                       +</div><div class="line">                       old_s * phi_i_s)</div><div class="line">                      *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    }</div></div><!-- fragment --><p>Secondly, we have to deal with the flux parts on the face boundaries. This was a bit more involved because we first have to determine which are the influx and outflux parts of the cell boundary. If we have an influx boundary, we need to evaluate the saturation on the other side of the face (or the boundary values, if we are at the boundary of the domain).</p>
<p>All this is a bit tricky, but has been explained in some detail already in <a class="el" href="step_9.html">step-9</a>. Take a look there how this is supposed to work!</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">           ++face_no)</div><div class="line">        {</div><div class="line">          fe_face_values.reinit (cell, face_no);</div><div class="line"></div><div class="line">          fe_face_values.get_function_values (old_solution, old_solution_values_face);</div><div class="line">          fe_face_values.get_function_values (solution, present_solution_values_face);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">            saturation_boundary_values</div><div class="line">            .value_list (fe_face_values.get_quadrature_points(),</div><div class="line">                         neighbor_saturation);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">              neighbor = cell-&gt;neighbor(face_no);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">              neighbor_face = cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">              fe_face_values_neighbor.reinit (neighbor, neighbor_face);</div><div class="line"></div><div class="line">              fe_face_values_neighbor</div><div class="line">              .get_function_values (old_solution,</div><div class="line">                                    old_solution_values_face_neighbor);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">                neighbor_saturation[q] = old_solution_values_face_neighbor[q](dim+1);</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">            {</div><div class="line">              <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> present_u_face;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                present_u_face[d] = present_solution_values_face[q](d);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux = present_u_face *</div><div class="line">                                         fe_face_values.normal_vector(q);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                local_rhs(i) -= time_step *</div><div class="line">                                normal_flux *</div><div class="line">                                fractional_flow((is_outflow_q_point == <span class="keyword">true</span></div><div class="line">                                                 ?</div><div class="line">                                                 old_solution_values_face[q](dim+1)</div><div class="line">                                                 :</div><div class="line">                                                 neighbor_saturation[q]),</div><div class="line">                                                viscosity) *</div><div class="line">                                fe_face_values[saturation].value (i,q) *</div><div class="line">                                fe_face_values.JxW(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemsolve"></a> </p><h4>TwoPhaseFlowProblem::solve</h4>
<p>After all these preparations, we finally solve the linear system for velocity and pressure in the same way as in <a class="el" href="step_20.html">step-20</a>. After that, we have to deal with the saturation equation (see below):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt; &gt;</div><div class="line">  m_inverse (system_matrix.block(0,0));</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (solution.block(0).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp2 (solution.block(2).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div></div><!-- fragment --><p>First the pressure, using the pressure Schur complement of the first two equations:</p>
<div class="fragment"><div class="line">{</div><div class="line">  m_inverse.vmult (tmp, system_rhs.block(0));</div><div class="line">  system_matrix.block(1,0).vmult (schur_rhs, tmp);</div><div class="line">  schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line"></div><div class="line">  SchurComplement</div><div class="line">  <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (system_matrix, m_inverse);</div><div class="line"></div><div class="line">  ApproximateSchurComplement</div><div class="line">  approximate_schur_complement (system_matrix);</div><div class="line"></div><div class="line">  InverseMatrix&lt;ApproximateSchurComplement&gt;</div><div class="line">  preconditioner (approximate_schur_complement);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">                                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12*schur_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div><div class="line"></div><div class="line">  cg.solve (<a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>, solution.block(1), schur_rhs,</div><div class="line">            preconditioner);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations for pressure.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Now the velocity:</p>
<div class="fragment"><div class="line">{</div><div class="line">  system_matrix.block(0,1).vmult (tmp, solution.block(1));</div><div class="line">  tmp *= -1;</div><div class="line">  tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">  m_inverse.vmult (solution.block(0), tmp);</div><div class="line">}</div></div><!-- fragment --><p>Finally, we have to take care of the saturation equation. The first business we have here is to determine the time step using the formula in the introduction. Knowing the shape of our domain and that we created the mesh by regular subdivision of cells, we can compute the diameter of each of our cells quite easily (in fact we use the linear extensions in coordinate directions of the cells, not the diameter). Note that we will learn a more general way to do this in <a class="el" href="step_24.html">step-24</a>, where we use the <a class="el" href="namespaceGridTools.html#ac89deda30a32b232dbe9c95e14896df5">GridTools::minimal_cell_diameter</a> function.</p>
<p>The maximal velocity we compute using a helper function to compute the maximal velocity defined below, and with all this we can evaluate our new time step length:</p>
<div class="fragment"><div class="line">time_step = std::pow(0.5, <span class="keywordtype">double</span>(n_refinement_steps)) /</div><div class="line">            get_maximal_velocity();</div></div><!-- fragment --><p>The next step is to assemble the right hand side, and then to pass everything on for solution. At the end, we project back saturations onto the physically reasonable range:</p>
<div class="fragment"><div class="line">  assemble_rhs_S ();</div><div class="line">  {</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.block(2,2).m(),</div><div class="line">                                  1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8*system_rhs.block(2).l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>   cg (solver_control);</div><div class="line">    cg.solve (system_matrix.block(2,2), solution.block(2), system_rhs.block(2),</div><div class="line">              <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    project_back_saturation ();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">              &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations for saturation.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  old_solution = solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemoutput_results"></a> </p><h4>TwoPhaseFlowProblem::output_results</h4>
<p>There is nothing surprising here. Since the program will do a lot of time steps, we create an output file only every fifth time step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results ()<span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (timestep_number % 5 != 0)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; solution_names;</div><div class="line">  <span class="keywordflow">switch</span> (dim)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> 2:</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;v&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;S&quot;</span>);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">case</span> 3:</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;v&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;w&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;S&quot;</span>);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, solution_names);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> (degree+1);</div><div class="line"></div><div class="line">  std::ostringstream filename;</div><div class="line">  filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div><div class="line">           &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number,4)</div><div class="line">           &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line"></div><div class="line">  std::ofstream output (filename.str().c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemproject_back_saturation"></a> </p><h4>TwoPhaseFlowProblem::project_back_saturation</h4>
<p>In this function, we simply run over all saturation degrees of freedom and make sure that if they should have left the physically reasonable range, that they be reset to the interval <img class="formulaInl" alt="$[0,1]$" src="form_364.png"/>. To do this, we only have to loop over all saturation components of the solution vector; these are stored in the block 2 (block 0 are the velocities, block 1 are the pressures).</p>
<p>It may be instructive to note that this function almost never triggers when the time step is chosen as mentioned in the introduction. However, if we choose the timestep only slightly larger, we get plenty of values outside the proper range. Strictly speaking, the function is therefore unnecessary if we choose the time step small enough. In a sense, the function is therefore only a safety device to avoid situations where our entire solution becomes unphysical because individual degrees of freedom have become unphysical a few time steps earlier.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;solution.block(2).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (solution.block(2)(i) &lt; 0)</div><div class="line">      solution.block(2)(i) = 0;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solution.block(2)(i) &gt; 1)</div><div class="line">      solution.block(2)(i) = 1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemget_maximal_velocity"></a> </p><h4>TwoPhaseFlowProblem::get_maximal_velocity</h4>
<p>The following function is used in determining the maximal allowable time step. What it does is to loop over all quadrature points in the domain and find what the maximal magnitude of the velocity is.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::get_maximal_velocity ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points</div><div class="line">    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Vector&lt;double&gt; &gt; solution_values(n_q_points,</div><div class="line">                                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">  <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (solution, solution_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> velocity;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">            velocity[i] = solution_values[q](i);</div><div class="line"></div><div class="line">          max_velocity = std::max (max_velocity,</div><div class="line">                                   velocity.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemrun"></a> </p><h4>TwoPhaseFlowProblem::run</h4>
<p>This is the final function of our main class. Its brevity speaks for itself. There are only two points worth noting: First, the function projects the initial values onto the finite element space at the beginning; the <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> function doing this requires an argument indicating the hanging node constraints. We have none in this program (we compute on a uniformly refined mesh), but the function requires the argument anyway, of course. So we have to create a constraint object. In its original state, constraint objects are unsorted, and have to be sorted (using the <a class="el" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">ConstraintMatrix::close</a> function) before they can be used. This is what we do here, and which is why we can't simply call the <a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> function with an anonymous temporary object <code><a class="el" href="classConstraintMatrix.html">ConstraintMatrix()</a></code> as the second argument.</p>
<p>The second point worth mentioning is that we only compute the length of the present time step in the middle of solving the linear system corresponding to each time step. We can therefore output the present end time of a time step only at the end of the time step.</p>
<p>The function as it is here does actually not compute the results found on the web page. The reason is, that even on a decent computer it runs more than a day. If you want to reproduce these results, set the final time at the end of the do loop to 250.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> (dof_handler,</div><div class="line">                            constraints,</div><div class="line">                            <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree+2),</div><div class="line">                            InitialValues&lt;dim&gt;(),</div><div class="line">                            old_solution);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line"></div><div class="line">        solve ();</div><div class="line"></div><div class="line">        output_results ();</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Now at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time_step &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= 1.);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>That's it. In the main function, we pass the degree of the finite element space to the constructor of the TwoPhaseFlowProblem object. Here, we use zero-th degree elements, i.e. <img class="formulaInl" alt="$RT_0\times DQ_0 \times DQ_0$" src="form_1803.png"/>. The rest is as in all the other programs.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step21;</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div><div class="line">      two_phase_flow_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>If we run the program, we get the following kind of output: </p><div class="fragment"><div class="line">Number of active cells: 1024</div><div class="line">Number of degrees of freedom: 4160 (2112+1024+1024)</div><div class="line"></div><div class="line">Timestep 1</div><div class="line">   22 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0326742, dt=0.0326742.</div><div class="line"></div><div class="line">Timestep 2</div><div class="line">   17 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0653816, dt=0.0327074.</div><div class="line"></div><div class="line">Timestep 3</div><div class="line">   17 CG Schur complement iterations <span class="keywordflow">for</span> pressure.</div><div class="line">   1 CG iterations <span class="keywordflow">for</span> saturation.</div><div class="line">   Now at t=0.0980651, dt=0.0326836.</div><div class="line"></div><div class="line">...</div></div><!-- fragment --><p> As we can see, the time step is pretty much constant right from the start, which indicates that the velocities in the domain are not strongly dependent on changes in saturation, although they certainly are through the factor <img class="formulaInl" alt="$\lambda(S)$" src="form_1781.png"/> in the pressure equation.</p>
<p>Our second observation is that the number of CG iterations needed to solve the pressure Schur complement equation drops from 22 to 17 between the first and the second time step (in fact, it remains around 17 for the rest of the computations). The reason is actually simple: Before we solve for the pressure during a time step, we don't reset the <code>solution</code> variable to zero. The pressure (and the other variables) therefore have the previous time step's values at the time we get into the CG solver. Since the velocities and pressures don't change very much as computations progress, the previous time step's pressure is actually a good initial guess for this time step's pressure. Consequently, the number of iterations we need once we have computed the pressure once is significantly reduced.</p>
<p>The final observation concerns the number of iterations needed to solve for the saturation, i.e. one. This shouldn't surprise us too much: the matrix we have to solve with is the mass matrix. However, this is the mass matrix for the <img class="formulaInl" alt="$DQ_0$" src="form_1804.png"/> element of piecewise constants where no element couples with the degrees of freedom on neighboring cells. The matrix is therefore a diagonal one, and it is clear that we should be able to invert this matrix in a single CG iteration.</p>
<p>With all this, here are a few movies that show how the saturation progresses over time. First, this is for the single crack model, as implemented in the <code>SingleCurvingCrack::KInverse</code> class:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.centerline.gif"/>
</div>
<p>As can be seen, the water rich fluid snakes its way mostly along the high-permeability zone in the middle of the domain, whereas the rest of the domain is mostly impermeable. This and the next movie are generated using <code>n_refinement_steps=7</code>, leading to a <img class="formulaInl" alt="$128\times 128$" src="form_1805.png"/> mesh with some 16,000 cells and about 66,000 unknowns in total.</p>
<p>The second movie shows the saturation for the random medium model of class <code>RandomMedium::KInverse</code>, where we have randomly distributed centers of high permeability and fluid hops from one of these zones to the next:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.random2d.gif"/>
</div>
<p>Finally, here is the same situation in three space dimensions, on a mesh with <code>n_refinement_steps=5</code>, which produces a mesh of some 32,000 cells and 167,000 degrees of freedom:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-21.random3d.gif"/>
</div>
<p>To repeat these computations, all you have to do is to change the line </p><div class="fragment"><div class="line">TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div></div><!-- fragment --><p> in the main function to </p><div class="fragment"><div class="line">TwoPhaseFlowProblem&lt;3&gt; two_phase_flow_problem(0);</div></div><!-- fragment --><p> The visualization uses a cloud technique, where the saturation is indicated by colored but transparent clouds for each cell. This way, one can also see somewhat what happens deep inside the domain. A different way of visualizing would have been to show isosurfaces of the saturation evolving over time. There are techniques to plot isosurfaces transparently, so that one can see several of them at the same time like the layers of an onion.</p>
<p>So why don't we show such isosurfaces? The problem lies in the way isosurfaces are computed: they require that the field to be visualized is continuous, so that the isosurfaces can be generated by following contours at least across a single cell. However, our saturation field is piecewise constant and discontinuous. If we wanted to plot an isosurface for a saturation <img class="formulaInl" alt="$S=0.5$" src="form_1806.png"/>, chances would be that there is no single point in the domain where that saturation is actually attained. If we had to define isosurfaces in that context at all, we would have to take the interfaces between cells, where one of the two adjacent cells has a saturation greater than and the other cell a saturation less than 0.5. However, it appears that most visualization programs are not equipped to do this kind of transformation.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>There are a number of areas where this program can be improved. Three of them are listed below. All of them are, in fact, addressed in a tutorial program that forms the continuation of the current one: <a class="el" href="step_43.html">step-43</a>.</p>
<p><a class="anchor" id="Solvers"></a></p><h4>Solvers</h4>
<p>At present, the program is not particularly fast: the 2d random medium computation took about a day for the 1,000 or so time steps. The corresponding 3d computation took almost two days for 800 time steps. The reason why it isn't faster than this is twofold. First, we rebuild the entire matrix in every time step, although some parts such as the <img class="formulaInl" alt="$B$" src="form_65.png"/>, <img class="formulaInl" alt="$B^T$" src="form_66.png"/>, and <img class="formulaInl" alt="$M^S$" src="form_1807.png"/> blocks never change.</p>
<p>Second, we could do a lot better with the solver and preconditioners. Presently, we solve the Schur complement <img class="formulaInl" alt="$B^TM^u(S)^{-1}B$" src="form_1808.png"/> with a CG method, using <img class="formulaInl" alt="$[B^T (\textrm{diag}(M^u(S)))^{-1} B]^{-1}$" src="form_1809.png"/> as a preconditioner. Applying this preconditioner is expensive, since it involves solving a linear system each time. This may have been appropriate for <a class="el" href="step_20.html">step-20</a>, where we have to solve the entire problem only once. However, here we have to solve it hundreds of times, and in such cases it is worth considering a preconditioner that is more expensive to set up the first time, but cheaper to apply later on.</p>
<p>One possibility would be to realize that the matrix we use as preconditioner, <img class="formulaInl" alt="$B^T (\textrm{diag}(M^u(S)))^{-1} B$" src="form_1810.png"/> is still sparse, and symmetric on top of that. If one looks at the flow field evolve over time, we also see that while <img class="formulaInl" alt="$S$" src="form_731.png"/> changes significantly over time, the pressure hardly does and consequently <img class="formulaInl" alt="$B^T (\textrm{diag}(M^u(S)))^{-1} B \approx B^T (\textrm{diag}(M^u(S^0)))^{-1} B$" src="form_1811.png"/>. In other words, the matrix for the first time step should be a good preconditioner also for all later time steps. With a bit of back-and-forthing, it isn't hard to actually get a representation of it as a <a class="el" href="classSparseMatrix.html">SparseMatrix</a> object. We could then hand it off to the <a class="el" href="classSparseMIC.html">SparseMIC</a> class to form a sparse incomplete Cholesky decomposition. To form this decomposition is expensive, but we have to do it only once in the first time step, and can then use it as a cheap preconditioner in the future. We could do better even by using the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class that produces not only an incomplete, but a complete decomposition of the matrix, which should yield an even better preconditioner.</p>
<p>Finally, why use the approximation <img class="formulaInl" alt="$B^T (\textrm{diag}(M^u(S)))^{-1} B$" src="form_1810.png"/> to precondition <img class="formulaInl" alt="$B^T M^u(S)^{-1} B$" src="form_1812.png"/>? The latter matrix, after all, is the mixed form of the Laplace operator on the pressure space, for which we use linear elements. We could therefore build a separate matrix <img class="formulaInl" alt="$A^p$" src="form_1813.png"/> on the side that directly corresponds to the non-mixed formulation of the Laplacian, for example using the bilinear form <img class="formulaInl" alt="$(\mathbf{K}\lambda(S^n) \nabla \varphi_i,\nabla\varphi_j)$" src="form_1814.png"/>. We could then form an incomplete or complete decomposition of this non-mixed matrix and use it as a preconditioner of the mixed form.</p>
<p>Using such techniques, it can reasonably be expected that the solution process will be faster by at least an order of magnitude.</p>
<p><a class="anchor" id="Timestepping"></a></p><h4>Time stepping</h4>
<p>In the introduction we have identified the time step restriction </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \triangle t_{n+1} \le \frac h{|\mathbf{u}^{n+1}(\mathbf{x})|} \]" src="form_1815.png"/>
</p>
<p> that has to hold globally, i.e. for all <img class="formulaInl" alt="$\mathbf x$" src="form_751.png"/>. After discretization, we satisfy it by choosing </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \triangle t_{n+1} = \frac {\min_K h_K}{\max_{\mathbf{x}}|\mathbf{u}^{n+1}(\mathbf{x})|}. \]" src="form_1780.png"/>
</p>
<p>This restriction on the time step is somewhat annoying: the finer we make the mesh the smaller the time step; in other words, we get punished twice: each time step is more expensive to solve and we have to do more time steps.</p>
<p>This is particularly annoying since the majority of the additional work is spent solving the implicit part of the equations, i.e. the pressure-velocity system, whereas it is the hyperbolic transport equation for the saturation that imposes the time step restriction.</p>
<p>To avoid this bottleneck, people have invented a number of approaches. For example, they may only re-compute the pressure-velocity field every few time steps (or, if you want, use different time step sizes for the pressure/velocity and saturation equations). This keeps the time step restriction on the cheap explicit part while it makes the solution of the implicit part less frequent. Experiments in this direction are certainly worthwhile; one starting point for such an approach is the paper by Zhangxin Chen, Guanren Huan and Baoyan Li: <em>An improved IMPES method for two-phase flow in porous media</em>, Transport in Porous Media, 54 (2004), pp. 361&mdash;376. There are certainly many other papers on this topic as well, but this one happened to land on our desk a while back.</p>
<p><a class="anchor" id="Adaptivity"></a></p><h4>Adaptivity</h4>
<p>Adaptivity would also clearly help. Looking at the movies, one clearly sees that most of the action is confined to a relatively small part of the domain (this particularly obvious for the saturation, but also holds for the velocities and pressures). Adaptivity can therefore be expected to keep the necessary number of degrees of freedom low, or alternatively increase the accuracy.</p>
<p>On the other hand, adaptivity for time dependent problems is not a trivial thing: we would have to change the mesh every few time steps, and we would have to transport our present solution to the next mesh every time we change it (something that the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class can help with). These are not insurmountable obstacles, but they do require some additional coding and more than we felt comfortable was worth packing into this tutorial program. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2006 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Yan Li, Wolfgang Bangerth, Texas A&amp;M University, 2006</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_raviart_thomas.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor_function.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step21</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TwoPhaseFlowProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid_and_dofs ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_rhs_S ();</div><div class="line">    <span class="keywordtype">double</span> get_maximal_velocity () <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> project_back_saturation ();</div><div class="line">    <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_steps;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line">    <span class="keywordtype">double</span> viscosity;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> old_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureRightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  PressureRightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;<span class="comment">/*p*/</span>,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureBoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  PressureBoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1-p[0];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationBoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  SaturationBoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InitialValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+2) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  InitialValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+2).value (p, component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  InitialValues&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+2).vector_value (p, values);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse ()</div><div class="line">        :</div><div class="line">        <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt; ()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    KInverse&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (points.size() == values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (points.size(), values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear ();</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline</div><div class="line">            = std::fabs(points[p][1]-0.5-0.1*std::sin(10*points[p][0]));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> permeability = std::max(std::exp(-(distance_to_flowline*</div><div class="line">                                                          distance_to_flowline)</div><div class="line">                                                        / (0.1 * 0.1)),</div><div class="line">                                               0.01);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][d][d] = 1./permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>RandomMedium</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse ()</div><div class="line">        :</div><div class="line">        <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2,dim&gt; ()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt; &gt; centers;</div><div class="line"></div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt; &gt; get_centers ();</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    std::vector&lt;Point&lt;dim&gt; &gt;</div><div class="line">    KInverse&lt;dim&gt;::centers = KInverse&lt;dim&gt;::get_centers();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    std::vector&lt;Point&lt;dim&gt; &gt;</div><div class="line">    KInverse&lt;dim&gt;::get_centers ()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N = (dim == 2 ?</div><div class="line">                              40 :</div><div class="line">                              (dim == 3 ?</div><div class="line">                               100 :</div><div class="line">                               <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">      std::vector&lt;Point&lt;dim&gt; &gt; centers_list (N);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;N; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          centers_list[i][d] = static_cast&lt;double&gt;(rand())/RAND_MAX;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> centers_list;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    KInverse&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt;    &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (points.size() == values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (points.size(), values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear ();</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> permeability = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;centers.size(); ++i)</div><div class="line">            permeability += std::exp(-(points[p]-centers[i]).norm_square()</div><div class="line">                                     / (0.05 * 0.05));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability</div><div class="line">            = std::min (std::max(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][d][d] = 1./normalized_permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mobility_inverse (<span class="keyword">const</span> <span class="keywordtype">double</span> S,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> 1.0 / (1.0/viscosity * S * S + (1-S) * (1-S));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow (<span class="keyword">const</span> <span class="keywordtype">double</span> S,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> S*S / (S * S + viscosity * (1-S) * (1-S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix (<span class="keyword">const</span> MatrixType &amp;m);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> matrix;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">  InverseMatrix&lt;MatrixType&gt;::InverseMatrix (<span class="keyword">const</span> MatrixType &amp;m)</div><div class="line">    :</div><div class="line">    matrix (&amp;m)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType&gt;</div><div class="line">  <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType&gt;::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                                         <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (std::max(src.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span> (200)),</div><div class="line">                                  1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8*src.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    cg.solve (*matrix, dst, src, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>SchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A,</div><div class="line">                     <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &gt; &amp;Minv);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const InverseMatrix&lt;SparseMatrix&lt;double&gt;</a> &gt; &gt; m_inverse;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  SchurComplement::</div><div class="line">  SchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A,</div><div class="line">                   <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &gt; &amp;Minv)</div><div class="line">    :</div><div class="line">    system_matrix (&amp;A),</div><div class="line">    m_inverse (&amp;Minv),</div><div class="line">    tmp1 (A.block(0,0).m()),</div><div class="line">    tmp2 (A.block(0,0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> SchurComplement::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                               <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0,1).vmult (tmp1, src);</div><div class="line">    m_inverse-&gt;vmult (tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1,0).vmult (dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>ApproximateSchurComplement : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ApproximateSchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const BlockSparseMatrix&lt;double&gt;</a> &gt; system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp1, tmp2;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  ApproximateSchurComplement::</div><div class="line">  ApproximateSchurComplement (<span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;A)</div><div class="line">    :</div><div class="line">    system_matrix (&amp;A),</div><div class="line">    tmp1 (A.block(0,0).m()),</div><div class="line">    tmp2 (A.block(0,0).m())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> ApproximateSchurComplement::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    system_matrix-&gt;block(0,1).vmult (tmp1, src);</div><div class="line">    system_matrix-&gt;block(0,0).precondition_Jacobi (tmp2, tmp1);</div><div class="line">    system_matrix-&gt;block(1,0).vmult (dst, tmp2);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    :</div><div class="line">    degree (degree),</div><div class="line">    fe (<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas</a>&lt;dim&gt;(degree), 1,</div><div class="line">        <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1,</div><div class="line">        <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1),</div><div class="line">    dof_handler (triangulation),</div><div class="line">    n_refinement_steps (5),</div><div class="line">    time_step (0),</div><div class="line">    timestep_number (1),</div><div class="line">    viscosity (0.2)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::make_grid_and_dofs ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (n_refinement_steps);</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> (dof_handler);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; dofs_per_component (dim+2);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a1a86f6b2291b6bc814a982b85fa64a09">DoFTools::count_dofs_per_component</a> (dof_handler, dofs_per_component);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_component[0],</div><div class="line">                       n_p = dofs_per_component[dim],</div><div class="line">                       n_s = dofs_per_component[dim+1];</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span>&lt;&lt; n_s &lt;&lt;<span class="charliteral">&#39;)&#39;</span></div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    n_couplings = dof_handler.<a class="code" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">max_couplings_between_dofs</a>();</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (3,3);</div><div class="line">    sparsity_pattern.block(0,0).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_u, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(1,0).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_p, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(2,0).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_s, n_u, n_couplings);</div><div class="line">    sparsity_pattern.block(0,1).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_u, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(1,1).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_p, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(2,1).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_s, n_p, n_couplings);</div><div class="line">    sparsity_pattern.block(0,2).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_u, n_s, n_couplings);</div><div class="line">    sparsity_pattern.block(1,2).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_p, n_s, n_couplings);</div><div class="line">    sparsity_pattern.block(2,2).<a class="code" href="classSparsityPattern.html#a9673f06e3314481ac989ff777ab491b9">reinit</a> (n_s, n_s, n_couplings);</div><div class="line"></div><div class="line">    sparsity_pattern.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line"></div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line"></div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (3);</div><div class="line">    solution.block(0).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_u);</div><div class="line">    solution.block(1).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_p);</div><div class="line">    solution.block(2).<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (n_s);</div><div class="line">    solution.collect_sizes ();</div><div class="line"></div><div class="line">    old_solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (3);</div><div class="line">    old_solution.block(0).reinit (n_u);</div><div class="line">    old_solution.block(1).reinit (n_p);</div><div class="line">    old_solution.block(2).reinit (n_s);</div><div class="line">    old_solution.collect_sizes ();</div><div class="line"></div><div class="line">    system_rhs.reinit (3);</div><div class="line">    system_rhs.block(0).reinit (n_u);</div><div class="line">    system_rhs.block(1).reinit (n_p);</div><div class="line">    system_rhs.block(2).reinit (n_s);</div><div class="line">    system_rhs.collect_sizes ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    system_matrix=0;</div><div class="line">    system_rhs=0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(degree+2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe, face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   local_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       local_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> PressureRightHandSide&lt;dim&gt;  pressure_right_hand_side;</div><div class="line">    <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt; pressure_boundary_values;</div><div class="line">    <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;               pressure_rhs_values (n_q_points);</div><div class="line">    std::vector&lt;double&gt;               boundary_values (n_face_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;2,dim&gt; &gt;       k_inverse_values (n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt;      old_solution_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">    std::vector&lt;std::vector&lt;Tensor&lt;1,dim&gt; &gt; &gt;  old_solution_grads(n_q_points,</div><div class="line">        std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; (dim+2));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation (dim+1);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_solution, old_solution_values);</div><div class="line"></div><div class="line">        pressure_right_hand_side.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                             pressure_rhs_values);</div><div class="line">        k_inverse.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                              k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim+1);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_i_u      = fe_values[velocities].value (i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_i_u  = fe_values[velocities].divergence (i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_i_p      = fe_values[pressure].value (i, q);</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_i_s      = fe_values[saturation].value (i, q);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> phi_j_u     = fe_values[velocities].value (j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>        div_phi_j_u = fe_values[velocities].divergence (j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_j_p     = fe_values[pressure].value (j, q);</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_j_s     = fe_values[saturation].value (j, q);</div><div class="line"></div><div class="line">                  local_matrix(i,j) += (phi_i_u * k_inverse_values[q] *</div><div class="line">                                        mobility_inverse(old_s,viscosity) * phi_j_u</div><div class="line">                                        - div_phi_i_u * phi_j_p</div><div class="line">                                        - phi_i_p * div_phi_j_u</div><div class="line">                                        + phi_i_s * phi_j_s)</div><div class="line">                                       * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line"></div><div class="line">              local_rhs(i) += (-phi_i_p * pressure_rhs_values[q])*</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0;</div><div class="line">             face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">             ++face_no)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">            {</div><div class="line">              fe_face_values.reinit (cell, face_no);</div><div class="line"></div><div class="line">              pressure_boundary_values</div><div class="line">              .value_list (fe_face_values.get_quadrature_points(),</div><div class="line">                           boundary_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a></div><div class="line">                    phi_i_u = fe_face_values[velocities].value (i, q);</div><div class="line"></div><div class="line">                    local_rhs(i) += -(phi_i_u *</div><div class="line">                                      fe_face_values.normal_vector(q) *</div><div class="line">                                      boundary_values[q] *</div><div class="line">                                      fe_face_values.JxW(q));</div><div class="line">                  }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            system_matrix.add (local_dof_indices[i],</div><div class="line">                               local_dof_indices[j],</div><div class="line">                               local_matrix(i,j));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_rhs_S ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(degree+2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe, face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_neighbor (fe, face_quadrature_formula,</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       local_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; old_solution_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; old_solution_values_face(n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; old_solution_values_face_neighbor(n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; present_solution_values(n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; present_solution_values_face(n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; neighbor_saturation (n_face_q_points);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> saturation (dim+1);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        local_rhs = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_solution, old_solution_values);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (solution, present_solution_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_solution_values[q](dim+1);</div><div class="line">              <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> present_u;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                present_u[d] = present_solution_values[q](d);</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>        phi_i_s      = fe_values[saturation].value (i, q);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> grad_phi_i_s = fe_values[saturation].gradient (i, q);</div><div class="line"></div><div class="line">              local_rhs(i) += (time_step *</div><div class="line">                               fractional_flow(old_s,viscosity) *</div><div class="line">                               present_u *</div><div class="line">                               grad_phi_i_s</div><div class="line">                               +</div><div class="line">                               old_s * phi_i_s)</div><div class="line">                              *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face_no=0; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">             ++face_no)</div><div class="line">          {</div><div class="line">            fe_face_values.reinit (cell, face_no);</div><div class="line"></div><div class="line">            fe_face_values.get_function_values (old_solution, old_solution_values_face);</div><div class="line">            fe_face_values.get_function_values (solution, present_solution_values_face);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;at_boundary(face_no))</div><div class="line">              saturation_boundary_values</div><div class="line">              .value_list (fe_face_values.get_quadrature_points(),</div><div class="line">                           neighbor_saturation);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">                neighbor = cell-&gt;neighbor(face_no);</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">                neighbor_face = cell-&gt;neighbor_of_neighbor(face_no);</div><div class="line"></div><div class="line">                fe_face_values_neighbor.reinit (neighbor, neighbor_face);</div><div class="line"></div><div class="line">                fe_face_values_neighbor</div><div class="line">                .get_function_values (old_solution,</div><div class="line">                                      old_solution_values_face_neighbor);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">                  neighbor_saturation[q] = old_solution_values_face_neighbor[q](dim+1);</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> present_u_face;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                  present_u_face[d] = present_solution_values_face[q](d);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux = present_u_face *</div><div class="line">                                           fe_face_values.normal_vector(q);</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                  local_rhs(i) -= time_step *</div><div class="line">                                  normal_flux *</div><div class="line">                                  fractional_flow((is_outflow_q_point == <span class="keyword">true</span></div><div class="line">                                                   ?</div><div class="line">                                                   old_solution_values_face[q](dim+1)</div><div class="line">                                                   :</div><div class="line">                                                   neighbor_saturation[q]),</div><div class="line">                                                  viscosity) *</div><div class="line">                                  fe_face_values[saturation].value (i,q) *</div><div class="line">                                  fe_face_values.JxW(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          system_rhs(local_dof_indices[i]) += local_rhs(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;SparseMatrix&lt;double&gt; &gt;</div><div class="line">    m_inverse (system_matrix.block(0,0));</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (solution.block(0).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> schur_rhs (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp2 (solution.block(2).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>());</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      m_inverse.vmult (tmp, system_rhs.block(0));</div><div class="line">      system_matrix.block(1,0).vmult (schur_rhs, tmp);</div><div class="line">      schur_rhs -= system_rhs.block(1);</div><div class="line"></div><div class="line"></div><div class="line">      SchurComplement</div><div class="line">      schur_complement (system_matrix, m_inverse);</div><div class="line"></div><div class="line">      ApproximateSchurComplement</div><div class="line">      approximate_schur_complement (system_matrix);</div><div class="line"></div><div class="line">      InverseMatrix&lt;ApproximateSchurComplement&gt;</div><div class="line">      preconditioner (approximate_schur_complement);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (solution.block(1).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(),</div><div class="line">                                    1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12*schur_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div><div class="line"></div><div class="line">      cg.solve (schur_complement, solution.block(1), schur_rhs,</div><div class="line">                preconditioner);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">                &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG Schur complement iterations for pressure.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      system_matrix.block(0,1).vmult (tmp, solution.block(1));</div><div class="line">      tmp *= -1;</div><div class="line">      tmp += system_rhs.block(0);</div><div class="line"></div><div class="line">      m_inverse.vmult (solution.block(0), tmp);</div><div class="line">    }</div><div class="line"></div><div class="line">    time_step = std::pow(0.5, <span class="keywordtype">double</span>(n_refinement_steps)) /</div><div class="line">                get_maximal_velocity();</div><div class="line"></div><div class="line">    assemble_rhs_S ();</div><div class="line">    {</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.block(2,2).m(),</div><div class="line">                                    1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8*system_rhs.block(2).l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>   cg (solver_control);</div><div class="line">      cg.solve (system_matrix.block(2,2), solution.block(2), system_rhs.block(2),</div><div class="line">                <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">      project_back_saturation ();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">                &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations for saturation.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    old_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results ()<span class="keyword">  const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (timestep_number % 5 != 0)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;v&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;S&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;v&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;w&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">        solution_names.push_back (<span class="stringliteral">&quot;S&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, solution_names);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> (degree+1);</div><div class="line"></div><div class="line">    std::ostringstream filename;</div><div class="line">    filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div><div class="line">             &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number,4)</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line"></div><div class="line">    std::ofstream output (filename.str().c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;solution.block(2).<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (solution.block(2)(i) &lt; 0)</div><div class="line">        solution.block(2)(i) = 0;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solution.block(2)(i) &gt; 1)</div><div class="line">        solution.block(2)(i) = 1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::get_maximal_velocity ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points</div><div class="line">      = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Vector&lt;double&gt; &gt; solution_values(n_q_points,</div><div class="line">                                                 <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim+2));</div><div class="line">    <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (solution, solution_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> velocity;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dim; ++i)</div><div class="line">              velocity[i] = solution_values[q](i);</div><div class="line"></div><div class="line">            max_velocity = std::max (max_velocity,</div><div class="line">                                     velocity.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>());</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> constraints;</div><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a> (dof_handler,</div><div class="line">                            constraints,</div><div class="line">                            <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(degree+2),</div><div class="line">                            InitialValues&lt;dim&gt;(),</div><div class="line">                            old_solution);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line"></div><div class="line">        solve ();</div><div class="line"></div><div class="line">        output_results ();</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Now at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time_step &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div><div class="line">                  &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= 1.);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step21;</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(0);</div><div class="line">      two_phase_flow_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
