<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: WorkStream::internal::Implementation2::IteratorRangeToItemStream&lt; Iterator, ScratchData, CopyData &gt;::ItemType Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceWorkStream.html">WorkStream</a></li><li class="navelem"><b>internal</b></li><li class="navelem"><a class="el" href="namespaceWorkStream_1_1internal_1_1Implementation2.html">Implementation2</a></li><li class="navelem"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">IteratorRangeToItemStream</a></li><li class="navelem"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html">ItemType</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WorkStream::internal::Implementation2::IteratorRangeToItemStream&lt; Iterator, ScratchData, CopyData &gt;::ItemType Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="work__stream_8h_source.html">deal.II/base/work_stream.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType_1_1ScratchDataObject.html">ScratchDataObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2fdcc0eacda3b01a499e19a053b56b7b"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType_1_1ScratchDataObject.html">ScratchDataObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a2fdcc0eacda3b01a499e19a053b56b7b">ScratchDataList</a></td></tr>
<tr class="separator:a2fdcc0eacda3b01a499e19a053b56b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad4ec070fb7a2b7f5e969b57f4bb35335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#ad4ec070fb7a2b7f5e969b57f4bb35335">ItemType</a> ()</td></tr>
<tr class="separator:ad4ec070fb7a2b7f5e969b57f4bb35335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af4ac7667344ca1bd916e1d81468d827a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#af4ac7667344ca1bd916e1d81468d827a">work_items</a></td></tr>
<tr class="separator:af4ac7667344ca1bd916e1d81468d827a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6db9546d4107eec8c2d4bd1e9d8298c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; CopyData &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#ae6db9546d4107eec8c2d4bd1e9d8298c">copy_datas</a></td></tr>
<tr class="separator:ae6db9546d4107eec8c2d4bd1e9d8298c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3361d0e74299b341501c4ce61ea8f02b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a3361d0e74299b341501c4ce61ea8f02b">n_items</a></td></tr>
<tr class="separator:a3361d0e74299b341501c4ce61ea8f02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9861de9593d3f9c9fb62f8c33de5798a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; <a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a2fdcc0eacda3b01a499e19a053b56b7b">ScratchDataList</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a9861de9593d3f9c9fb62f8c33de5798a">scratch_data</a></td></tr>
<tr class="separator:a9861de9593d3f9c9fb62f8c33de5798a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c030078722bb657cba6e1f07dfdac28"><td class="memItemLeft" align="right" valign="top">const ScratchData *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a6c030078722bb657cba6e1f07dfdac28">sample_scratch_data</a></td></tr>
<tr class="separator:a6c030078722bb657cba6e1f07dfdac28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ce22c6b491fc842737ec62f20664d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a80ce22c6b491fc842737ec62f20664d1">currently_in_use</a></td></tr>
<tr class="separator:a80ce22c6b491fc842737ec62f20664d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Iterator, typename ScratchData, typename CopyData&gt;<br />
struct WorkStream::internal::Implementation2::IteratorRangeToItemStream&lt; Iterator, ScratchData, CopyData &gt;::ItemType</h3>

<p>A data type that we use to identify items to be worked on. This is the structure that is passed around between the different parts of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> implementation to identify what needs to be done by the various stages of the pipeline. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00187">187</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2fdcc0eacda3b01a499e19a053b56b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdcc0eacda3b01a499e19a053b56b7b">&#9670;&nbsp;</a></span>ScratchDataList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType_1_1ScratchDataObject.html">ScratchDataObject</a>&gt; <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::<a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a2fdcc0eacda3b01a499e19a053b56b7b">ItemType::ScratchDataList</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef to a list of scratch data objects. The rationale for this list is provided in the variables that use these lists. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00234">234</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad4ec070fb7a2b7f5e969b57f4bb35335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ec070fb7a2b7f5e969b57f4bb35335">&#9670;&nbsp;</a></span>ItemType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::ItemType::ItemType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Initialize everything that doesn't have a default constructor itself. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00306">306</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af4ac7667344ca1bd916e1d81468d827a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ac7667344ca1bd916e1d81468d827a">&#9670;&nbsp;</a></span>work_items</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Iterator&gt; <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::ItemType::work_items</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A list of iterators that need to be worked on. Only the first n_items are relevant. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00240">240</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="ae6db9546d4107eec8c2d4bd1e9d8298c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6db9546d4107eec8c2d4bd1e9d8298c">&#9670;&nbsp;</a></span>copy_datas</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;CopyData&gt; <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::ItemType::copy_datas</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The CopyData objects that the <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1Worker.html">Worker</a> part of the pipeline fills for each work item. Again, only the first n_items elements are what we care about. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00247">247</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a3361d0e74299b341501c4ce61ea8f02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3361d0e74299b341501c4ce61ea8f02b">&#9670;&nbsp;</a></span>n_items</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::ItemType::n_items</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of items identified by the work_items array that the <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1Worker.html">Worker</a> and <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1Copier.html">Copier</a> pipeline stage need to work on. The maximum value of this variable will be chunk_size. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00254">254</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a9861de9593d3f9c9fb62f8c33de5798a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9861de9593d3f9c9fb62f8c33de5798a">&#9670;&nbsp;</a></span>scratch_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt;<a class="el" href="structWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream_1_1ItemType.html#a2fdcc0eacda3b01a499e19a053b56b7b">ScratchDataList</a>&gt;* <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::ItemType::scratch_data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to a thread local variable identifying the scratch data objects this thread will use. The initial implementation of this class using thread local variables provided only a single scratch object per thread. This doesn't work, because the worker functions may start tasks itself and then call <a class="el" href="classThreads_1_1TaskGroup.html#a2917c607a567538f8e560c849fa88ac6">Threads::TaskGroup::join_all()</a> or a similar function, which the TBB scheduler may use to run something else on the current thread &ndash; for example another instance of the worker function. Consequently, there would be two instances of the worker function that use the same scratch object if we only provided a single scratch object per thread. The solution is to provide a list of scratch objects for each thread, together with a flag indicating whether this scratch object is currently used. If a thread needs a scratch object, it walks this list until it finds an unused object, or, if there is none, creates one itself. Note that we need not use synchronization primitives for this process since the lists are thread-local and we are guaranteed that only a single thread accesses them as long as we have no yield point in between the accesses to the list.</p>
<p>The pointers to scratch objects stored in each of these lists must be so that they are deleted on all threads when the thread local object is destroyed. This is achieved by using shared_ptr.</p>
<p>Note that when a worker needs to create a scratch object, it allocates it using sample_scratch_data to copy from. This has the advantage of a first-touch initialization, i.e., the memory for the scratch data object is allocated and initialized by the same thread that will later use it. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00287">287</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a6c030078722bb657cba6e1f07dfdac28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c030078722bb657cba6e1f07dfdac28">&#9670;&nbsp;</a></span>sample_scratch_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ScratchData* <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::ItemType::sample_scratch_data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to a sample scratch data object, to be used to initialize the scratch data objects created for each individual thread. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00293">293</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a80ce22c6b491fc842737ec62f20664d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ce22c6b491fc842737ec62f20664d1">&#9670;&nbsp;</a></span>currently_in_use</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename ScratchData, typename CopyData&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWorkStream_1_1internal_1_1Implementation2_1_1IteratorRangeToItemStream.html">WorkStream::internal::Implementation2::IteratorRangeToItemStream</a>&lt; Iterator, ScratchData, CopyData &gt;::ItemType::currently_in_use</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag is true if the buffer is used and false if the buffer can be used. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l00299">299</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>deal.II/base/<a class="el" href="work__stream_8h_source.html">work_stream.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
