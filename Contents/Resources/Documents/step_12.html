<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-12 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-12 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Overview">Overview</a>
        <li><a href="#Problem">Problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#TheAdvectionProblemclass">The AdvectionProblem class</a>
      <ul>
        <li><a href="#Theassemble_systemfunction">The assemble_system function</a>
        <li><a href="#Thelocalintegrators">The local integrators</a>
      </ul>
        <li><a href="#Alltherest">All the rest</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Whyusediscontinuouselements">Why use discontinuous elements</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="AnexampleoftheMeshWorkerframeworkwithanadvectionproblem"></a></p><h1>An example of the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework with an advection problem</h1>
<p><a class="anchor" id="Overview"></a></p><h3>Overview</h3>
<p>This example is devoted to the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework and the <em>discontinuous Galerkin method</em>, or in short: DG method. It includes the following topics. </p><ol>
<li>
Discretization of the linear advection equation with the DG method. </li>
<li>
Assembling of the system matrix using the <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop()</a>. </li>
</ol>
<p>The particular concern of this program are the loops of DG methods. These turn out to be especially complex, primarily because for the face terms, we have to distinguish the cases of boundary, regular interior faces and interior faces with hanging nodes, respectively. The <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework implements the standard loop over all cells and faces in <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop()</a> and takes care of distinguishing between all the different faces.</p>
<p>There are two things left to do if you use <a class="el" href="namespaceMeshWorker.html">MeshWorker</a>: first, you need to write the local integrators for your problem. Second, you select classes from the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> namespace and combine them to achieve your goal.</p>
<p><a class="anchor" id="Problem"></a></p><h3>Problem</h3>
<p>The model problem solved in this example is the linear advection equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \nabla\cdot \left({\mathbf \beta} u\right)=0 \qquad\mbox{in }\Omega, \]" src="form_1441.png"/>
</p>
<p> subject to the boundary conditions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u=g\quad\mbox{on }\Gamma_-, \]" src="form_1442.png"/>
</p>
<p> on the inflow part <img class="formulaInl" alt="$\Gamma_-$" src="form_1443.png"/> of the boundary <img class="formulaInl" alt="$\Gamma=\partial\Omega$" src="form_1444.png"/> of the domain. Here, <img class="formulaInl" alt="${\mathbf \beta}={\mathbf \beta}({\bf x})$" src="form_1445.png"/> denotes a vector field, <img class="formulaInl" alt="$u$" src="form_256.png"/> the (scalar) solution function, <img class="formulaInl" alt="$g$" src="form_36.png"/> a boundary value function, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Gamma_-:=\{{\bf x}\in\Gamma, {\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})&lt;0\} \]" src="form_1446.png"/>
</p>
<p> the inflow part of the boundary of the domain and <img class="formulaInl" alt="${\bf n}$" src="form_1447.png"/> denotes the unit outward normal to the boundary <img class="formulaInl" alt="$\Gamma$" src="form_1193.png"/>. This equation is the conservative version of the advection equation already considered in <a class="el" href="step_9.html">step-9</a> of this tutorial. In particular, we solve the advection equation on <img class="formulaInl" alt="$\Omega=[0,1]^2$" src="form_1448.png"/> with <img class="formulaInl" alt="${\mathbf \beta}=\frac{1}{|x|}(-x_2, x_1)$" src="form_1449.png"/> representing a circular counterclockwise flow field, and <img class="formulaInl" alt="$g=1$" src="form_1429.png"/> on <img class="formulaInl" alt="${\bf x}\in\Gamma_-^1:=[0,0.5]\times\{0\}$" src="form_1450.png"/> and <img class="formulaInl" alt="$g=0$" src="form_1451.png"/> on <img class="formulaInl" alt="${\bf x}\in \Gamma_-\setminus \Gamma_-^1$" src="form_1452.png"/>.</p>
<p>We apply the well-known upwind discontinuous Galerkin method. To this end, we introduce the mesh dependent bilinear form</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ -\sum_{T\in \mathbb T_h}\bigl(u_h,{\mathbf \beta}\cdot\nabla v_h\bigr)_T +\sum_{F\in\mathbb F_h^i} \bigl&lt;u_h^-, \beta\cdot[v_h\mathbf n]\bigr&gt;_{F} + \bigl&lt;u_h, v_h \beta\cdot \mathbf n\bigr&gt;_{\Gamma_+} =-\bigl&lt;g, v_h \beta\cdot\mathbf n\bigr&gt;_{\Gamma_-}. \]" src="form_1453.png"/>
</p>
<p>Here, <img class="formulaInl" alt="$\mathbb T_h$" src="form_1454.png"/> is the set of all active cells of the triangulation and <img class="formulaInl" alt="$\mathbb F_h^i$" src="form_1455.png"/> is the set of all active interior faces. <img class="formulaInl" alt="$(\cdot, \cdot)_T$" src="form_1456.png"/> and <img class="formulaInl" alt="$\left&lt;\cdot, \cdot\right&gt;_{F}$" src="form_1457.png"/> denote the <em>L<sup>2</sup></em>-inner products on the cell <img class="formulaInl" alt="$T$" src="form_1207.png"/> and a face <img class="formulaInl" alt="$F$" src="form_249.png"/>, respectively. The jump is defined as <img class="formulaInl" alt="$[v\mathbf n] = v^+\mathbf n^+ + v^-\mathbf n^-$" src="form_1458.png"/>, where the superscripts refer to the upwind ('+') and downwind ('-') values at the face.</p>
<p>In order to implement this bilinear form, we need to compute the cell terms <img class="formulaInl" alt="$\bigl(u_h,{\mathbf \beta}\cdot\nabla v_h\bigr)_T$" src="form_1459.png"/>, the internal fluxes <img class="formulaInl" alt="$\bigl&lt;u_h^-, \beta\cdot[v_h\mathbf n]\bigr&gt;_{F}$" src="form_1460.png"/>, and the boundary terms <img class="formulaInl" alt="$\bigl&lt;u_h, v_h \beta\cdot \mathbf n]\bigr&gt;_{\Gamma_+}$" src="form_1461.png"/> and <img class="formulaInl" alt="$\bigl&lt;g, \beta\cdot\mathbf n v_h\bigr&gt;_{\Gamma_-}$" src="form_1462.png"/>. The summation of all those is done by <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">MeshWorker::integration_loop()</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The first few files have already been covered in previous examples and will thus not be further commented on:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q1.h&gt;</span></div></div><!-- fragment --><p>Here the discontinuous finite elements are defined. They are used in the same way as all other finite elements, though &ndash; as you have seen in previous tutorial programs &ndash; there isn't much user interaction with finite element classes at all: they are passed to <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> and <code><a class="el" href="classFEValues.html">FEValues</a></code> objects, and that is about it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div></div><!-- fragment --><p>We are going to use the simplest possible solver, called Richardson iteration, that represents a simple defect correction. This, in combination with a block SSOR preconditioner (defined in <a class="el" href="precondition__block_8h_source.html">precondition_block.h</a>), that uses the special block matrix structure of system matrices arising from DG discretizations.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_richardson.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition_block.h&gt;</span></div></div><!-- fragment --><p>We are going to use gradients as refinement indicator.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/derivative_approximation.h&gt;</span></div></div><!-- fragment --><p>Here come the new include files for using the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework. The first contains the class <a class="el" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo</a>, which provides local integrators with a mapping between local and global degrees of freedom. It stores the results of local integrals as well in its base class Meshworker::LocalResults. In the second of these files, we find an object of type <a class="el" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo</a>, which is mostly a wrapper around a group of <a class="el" href="classFEValues.html">FEValues</a> objects. The file <code><a class="el" href="simple_8h_source.html">meshworker/simple.h</a></code> contains classes assembling locally integrated data into a global system containing only a single matrix. Finally, we will need the file that runs the loop over all mesh cells and faces.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/dof_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/integration_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/simple.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/loop.h&gt;</span></div></div><!-- fragment --><p>Like in all programs, we finish this section by including the needed C++ headers and declaring we want to use objects in the dealii namespace without prefix.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>First, we define a class describing the inhomogeneous boundary data. Since only its values are used, we implement value_list(), but leave all other functions of <a class="el" href="classFunction.html">Function</a> undefined.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues:  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues () {};</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#afc0acd3155a0c854dee816a096d88165">value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                           std::vector&lt;double&gt; &amp;values,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>Given the flow direction, the inflow boundary of the unit square <img class="formulaInl" alt="$[0,1]^2$" src="form_431.png"/> are the right and the lower boundaries. We prescribe discontinuous boundary values 1 and 0 on the x-axis and value 0 on the right boundary. The values of this function on the outflow boundaries will not be used within the DG scheme.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size()==points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(),points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;values.size(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (points[i](0)&lt;0.5)</div><div class="line">        values[i]=1.;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        values[i]=0.;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheAdvectionProblemclass"></a> </p><h3>The AdvectionProblem class</h3>
<p>After this preparations, we proceed with the main class of this program, called AdvectionProblem. It is basically the main class of <a class="el" href="step_6.html">step-6</a>. We do not have a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>, because there are no hanging node constraints in DG discretizations.</p>
<p>Major differences will only come up in the implementation of the assemble functions, since here, we not only need to cover the flux integrals over faces, we also use the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> interface to simplify the loops involved.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>AdvectionProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AdvectionProblem ();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> solve (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution);</div><div class="line">  <span class="keywordtype">void</span> refine_grid ();</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div></div><!-- fragment --><p>Furthermore we want to use DG elements of degree 1 (but this is only specified in the constructor). If you want to use a DG method of a different degree the whole program stays the same, only replace 1 in the constructor by the desired polynomial degree.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>          fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div></div><!-- fragment --><p>The next four members represent the linear system to be solved. <code>system_matrix</code> and <code>right_hand_side</code> are generated by <code>assemble_system()</code>, the <code>solution</code> is computed in <code>solve()</code>. The <code>sparsity_pattern</code> is used to determine the location of nonzero elements in <code>system_matrix</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       right_hand_side;</div></div><!-- fragment --><p>Finally, we have to provide functions that assemble the cell, boundary, and inner face terms. Within the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework, the loop over all cells and much of the setup of operations will be done outside this class, so all we have to provide are these three operations. They will then work on intermediate objects for which first, we here define typedefs to the info objects handed to the local integration functions in order to make our life easier below.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> DoFInfo;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> CellInfo;</div></div><!-- fragment --><p>The following three functions are then the ones that get called inside the generic loop over all cells and faces. They are the ones doing the actual integration.</p>
<p>In our code below, these functions do not access member variables of the current class, so we can mark them as <code>static</code> and simply pass pointers to these functions to the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework. If, however, these functions would want to access member variables (or needed additional arguments beyond the ones specified below), we could use the facilities of boost::bind (or std::bind, respectively) to provide the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework with objects that act as if they had the required number and types of arguments, but have in fact other arguments already bound.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> integrate_cell_term (DoFInfo &amp;dinfo,</div><div class="line">                                   CellInfo &amp;info);</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> integrate_boundary_term (DoFInfo &amp;dinfo,</div><div class="line">                                       CellInfo &amp;info);</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> integrate_face_term (DoFInfo &amp;dinfo1,</div><div class="line">                                   DoFInfo &amp;dinfo2,</div><div class="line">                                   CellInfo &amp;info1,</div><div class="line">                                   CellInfo &amp;info2);</div><div class="line">};</div></div><!-- fragment --><p>We start with the constructor. The 1 in the constructor call of <code>fe</code> is the polynomial degree.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">AdvectionProblem&lt;dim&gt;::AdvectionProblem ()</div><div class="line">  :</div><div class="line">  mapping (),</div><div class="line">  fe (1),</div><div class="line">  dof_handler (triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system ()</div><div class="line">{</div></div><!-- fragment --><p>In the function that sets up the usual finite element data structures, we first need to distribute the DoFs.</p>
<div class="fragment"><div class="line">dof_handler.distribute_dofs (fe);</div></div><!-- fragment --><p>We start by generating the sparsity pattern. To this end, we first fill an intermediate object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> with the couplings appearing in the system. After building the pattern, this object is copied to <code>sparsity_pattern</code> and can be discarded.</p>
<p>To build the sparsity pattern for DG discretizations, we can call the function analogue to <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>, which is called <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line"><a class="code" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">sparsity_pattern.copy_from(dsp);</div></div><!-- fragment --><p>Finally, we set up the structure of all components of the linear system.</p>
<div class="fragment"><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line">  solution.reinit (dof_handler.n_dofs());</div><div class="line">  right_hand_side.reinit (dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Theassemble_systemfunction"></a> </p><h4>The assemble_system function</h4>
<p>Here we see the major difference to assembling by hand. Instead of writing loops over cells and faces, we leave all this to the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework. In order to do so, we just have to define local integration functions and use one of the classes in namespace <a class="el" href="namespaceMeshWorker_1_1Assembler.html">MeshWorker::Assembler</a> to build the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system ()</div><div class="line">{</div></div><!-- fragment --><p>This is the magic object, which knows everything about the data structures and local integration. This is the object doing the work in the function <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop()</a>, which is implicitly called by <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">MeshWorker::integration_loop()</a> below. After the functions to which we provide pointers did the local integration, the <a class="el" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple</a> object distributes these into the global sparse matrix and the right hand side vector.</p>
<div class="fragment"><div class="line"><a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div></div><!-- fragment --><p>First, we initialize the quadrature formulae and the update flags in the worker base class. For quadrature, we play safe and use a <a class="el" href="classQGauss.html">QGauss</a> formula with number of points one higher than the polynomial degree used. Since the quadratures for cells, boundary and interior faces can be selected independently, we have to hand over this value three times.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = dof_handler.get_fe().degree+1;</div><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a2ccc96521da795a762213a979c581138">initialize_gauss_quadrature</a>(n_gauss_points,</div><div class="line">                                     n_gauss_points,</div><div class="line">                                     n_gauss_points);</div></div><!-- fragment --><p>These are the types of values we need for integrating our system. They are added to the flags used on cells, boundary and interior faces, as well as interior neighbor faces, which is forced by the four <code>true</code> values.</p>
<div class="fragment"><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a1cf1a84cfec1e6fc176b50489c91d92a">initialize_update_flags</a>();</div><div class="line"><a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>            |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>;</div><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a84f63629724e517c250f56d59f096afd">add_update_flags</a>(update_flags, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div></div><!-- fragment --><p>After preparing all data in <code>info_box</code>, we initialize the <a class="el" href="classFEValues.html">FEValues</a> objects in there.</p>
<div class="fragment"><div class="line">info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div></div><!-- fragment --><p>The object created so far helps us do the local integration on each cell and face. Now, we need an object which receives the integrated (local) data and forwards them to the assembler.</p>
<div class="fragment"><div class="line"><a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div></div><!-- fragment --><p>Now, we have to create the assembler object and tell it, where to put the local data. These will be our system matrix and the right hand side.</p>
<div class="fragment"><div class="line"><a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">assembler;</div><div class="line">assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(system_matrix, right_hand_side);</div></div><!-- fragment --><p>Finally, the integration loop over all active cells (determined by the first argument, which is an active iterator).</p>
<p>As noted in the discussion when declaring the local integration functions in the class declaration, the arguments expected by the assembling integrator class are not actually function pointers. Rather, they are objects that can be called like functions with a certain number of arguments. Consequently, we could also pass objects with appropriate operator() implementations here, or the result of std::bind if the local integrators were, for example, non-static member functions.</p>
<div class="fragment"><div class="line">  MeshWorker::loop&lt;dim, dim, MeshWorker::DoFInfo&lt;dim&gt;, <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> &gt;</div><div class="line">  (dof_handler.begin_active(), dof_handler.end(),</div><div class="line">   dof_info, info_box,</div><div class="line">   &amp;AdvectionProblem&lt;dim&gt;::integrate_cell_term,</div><div class="line">   &amp;AdvectionProblem&lt;dim&gt;::integrate_boundary_term,</div><div class="line">   &amp;AdvectionProblem&lt;dim&gt;::integrate_face_term,</div><div class="line">   assembler);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thelocalintegrators"></a> </p><h4>The local integrators</h4>
<p>These are the functions given to the <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">MeshWorker::integration_loop()</a> called just above. They compute the local contributions to the system matrix and right hand side on cells and faces.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::integrate_cell_term (DoFInfo &amp;dinfo,</div><div class="line">                                                 CellInfo &amp;info)</div><div class="line">{</div></div><!-- fragment --><p>First, let us retrieve some of the objects used here from <code>info</code>. Note that these objects can handle much more complex structures, thus the access here looks more complicated than might seem necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe_v = info.fe_values();</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;local_matrix = dinfo.matrix(0).matrix;</div><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div></div><!-- fragment --><p>With these objects, we continue local integration like always. First, we loop over the quadrature points and compute the advection vector in the current point.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> beta;</div><div class="line">    beta(0) = -fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(point)(1);</div><div class="line">    beta(1) = fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(point)(0);</div><div class="line">    beta /= beta.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div></div><!-- fragment --><p>We solve a homogeneous equation, thus no right hand side shows up in the cell term. What's left is integrating the matrix entries.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">          local_matrix(i,j) -= beta*fe_v.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,point)*</div><div class="line">                               fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,point) *</div><div class="line">                               JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now the same for the boundary terms. Note that now we use <a class="el" href="classFEValuesBase.html">FEValuesBase</a>, the base class for both <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a>, in order to get access to normal vectors.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::integrate_boundary_term (DoFInfo &amp;dinfo,</div><div class="line">                                                     CellInfo &amp;info)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe_v = info.fe_values();</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;local_matrix = dinfo.matrix(0).matrix;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;local_vector = dinfo.vector(0).block(0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a> ();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; g(fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> BoundaryValues&lt;dim&gt; boundary_function;</div><div class="line">  boundary_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), g);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> beta;</div><div class="line">      beta(0) = -fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(point)(1);</div><div class="line">      beta(1) = fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(point)(0);</div><div class="line">      beta /= beta.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_n=beta * normals[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">      <span class="keywordflow">if</span> (beta_n&gt;0)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">            local_matrix(i,j) += beta_n *</div><div class="line">                                 fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,point) *</div><div class="line">                                 fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,point) *</div><div class="line">                                 JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">          local_vector(i) -= beta_n *</div><div class="line">                             g[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] *</div><div class="line">                             fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,point) *</div><div class="line">                             JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, the interior face terms. The difference here is that we receive two info objects, one for each cell adjacent to the face and we assemble four matrices, one for each cell and two for coupling back and forth.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::integrate_face_term (DoFInfo &amp;dinfo1,</div><div class="line">                                                 DoFInfo &amp;dinfo2,</div><div class="line">                                                 CellInfo &amp;info1,</div><div class="line">                                                 CellInfo &amp;info2)</div><div class="line">{</div></div><!-- fragment --><p>For quadrature points, weights, etc., we use the <a class="el" href="classFEValuesBase.html">FEValuesBase</a> object of the first argument.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe_v = info1.fe_values();</div></div><!-- fragment --><p>For additional shape functions, we have to ask the neighbors <a class="el" href="classFEValuesBase.html">FEValuesBase</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe_v_neighbor = info2.fe_values();</div></div><!-- fragment --><p>Then we get references to the four local matrices. The letters u and v refer to trial and test functions, respectively. The numbers indicate the cells provided by info1 and info2. By convention, the two matrices in each info object refer to the test functions on the respective cell. The first matrix contains the interior couplings of that cell, while the second contains the couplings between cells.</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;u1_v1_matrix = dinfo1.matrix(0,<span class="keyword">false</span>).matrix;</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;u2_v1_matrix = dinfo1.matrix(0,<span class="keyword">true</span>).matrix;</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;u1_v2_matrix = dinfo2.matrix(0,<span class="keyword">true</span>).matrix;</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;u2_v2_matrix = dinfo2.matrix(0,<span class="keyword">false</span>).matrix;</div></div><!-- fragment --><p>Here, following the previous functions, we would have the local right hand side vectors. Fortunately, the interface terms only involve the solution and the right hand side does not receive any contributions.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line"><span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a> ();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> beta;</div><div class="line">    beta(0) = -fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(point)(1);</div><div class="line">    beta(1) = fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(point)(0);</div><div class="line">    beta /= beta.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta_n=beta * normals[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">    <span class="keywordflow">if</span> (beta_n&gt;0)</div><div class="line">      {</div></div><!-- fragment --><p>This term we've already seen:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">    u1_v1_matrix(i,j) += beta_n *</div><div class="line">                         fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,point) *</div><div class="line">                         fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,point) *</div><div class="line">                         JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div></div><!-- fragment --><p>We additionally assemble the term <img class="formulaInl" alt="$(\beta\cdot n u,\hat v)_{\partial \kappa_+}$" src="form_1463.png"/>,</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">        u1_v2_matrix(k,j) -= beta_n *</div><div class="line">                             fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,point) *</div><div class="line">                             fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k,point) *</div><div class="line">                             JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div></div><!-- fragment --><p>This one we've already seen, too:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">    u2_v1_matrix(i,l) += beta_n *</div><div class="line">                         fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(l,point) *</div><div class="line">                         fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,point) *</div><div class="line">                         JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div></div><!-- fragment --><p>And this is another new one: <img class="formulaInl" alt="$(\beta\cdot n \hat u,\hat v)_{\partial \kappa_-}$" src="form_1464.png"/>:</p>
<div class="fragment"><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">              u2_v2_matrix(k,l) -= beta_n *</div><div class="line">                                   fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(l,point) *</div><div class="line">                                   fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k,point) *</div><div class="line">                                   JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Alltherest"></a> </p><h3>All the rest</h3>
<p>For this simple problem we use the simplest possible solver, called Richardson iteration, that represents a simple defect correction. This, in combination with a block SSOR preconditioner, that uses the special block matrix structure of system matrices arising from DG discretizations. The size of these blocks are the number of DoFs per cell. Here, we use a SSOR preconditioning as we have not renumbered the DoFs according to the flow field. If the DoFs are renumbered in the downstream direction of the flow, then a block Gauss-Seidel preconditioner (see the <a class="el" href="classPreconditionBlockSOR.html">PreconditionBlockSOR</a> class with relaxation=1) does a much better job.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution)</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;&gt;</a>      solver (solver_control);</div></div><!-- fragment --><p>Here we create the preconditioner,</p>
<div class="fragment"><div class="line"><a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; preconditioner;</div></div><!-- fragment --><p>then assign the matrix to it and set the right block size:</p>
<div class="fragment"><div class="line">preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.dofs_per_cell);</div></div><!-- fragment --><p>After these preparations we are ready to start the linear solver.</p>
<div class="fragment"><div class="line">  solver.solve (system_matrix, solution, right_hand_side,</div><div class="line">                preconditioner);</div><div class="line">}</div></div><!-- fragment --><p>We refine the grid according to a very simple refinement criterion, namely an approximation to the gradient of the solution. As here we consider the DG(1) method (i.e. we use piecewise bilinear shape functions) we could simply compute the gradients on each cell. But we do not want to base our refinement indicator on the gradients on each cell only, but want to base them also on jumps of the discontinuous solution function over faces between neighboring cells. The simplest way of doing that is to compute approximative gradients by difference quotients including the cell under consideration and its neighbors. This is done by the <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class that computes the approximate gradients in a way similar to the <code>GradientEstimation</code> described in <a class="el" href="step_9.html">step-9</a> of this tutorial. In fact, the <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class was developed following the <code>GradientEstimation</code> class of <a class="el" href="step_9.html">step-9</a>. Relating to the discussion in <a class="el" href="step_9.html">step-9</a>, here we consider <img class="formulaInl" alt="$h^{1+d/2}|\nabla_h u_h|$" src="form_1465.png"/>. Furthermore we note that we do not consider approximate second derivatives because solutions to the linear advection equation are in general not in <img class="formulaInl" alt="$H^2$" src="form_1466.png"/> but in <img class="formulaInl" alt="$H^1$" src="form_38.png"/> (to be more precise, in <img class="formulaInl" alt="$H^1_\beta$" src="form_1467.png"/>) only.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid ()</div><div class="line">{</div></div><!-- fragment --><p>The <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class computes the gradients to float precision. This is sufficient as they are approximate and serve as refinement indicators only.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> gradient_indicator (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>Now the approximate gradients are computed</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDerivativeApproximation.html#ace2a9964b7da0d28c8184346902a6563">DerivativeApproximation::approximate_gradient</a> (mapping,</div><div class="line">                                               dof_handler,</div><div class="line">                                               solution,</div><div class="line">                                               gradient_indicator);</div></div><!-- fragment --><p>and they are cell-wise scaled by the factor <img class="formulaInl" alt="$h^{1+d/2}$" src="form_1468.png"/></p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.end();</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no=0; cell!=endc; ++cell, ++cell_no)</div><div class="line">  gradient_indicator(cell_no)*=std::pow(cell-&gt;diameter(), 1+1.0*dim/2);</div></div><!-- fragment --><p>Finally they serve as refinement indicator.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                   gradient_indicator,</div><div class="line">                                                   0.3, 0.1);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">}</div></div><!-- fragment --><p>The output of this program consists of eps-files of the adaptively refined grids and the numerical solutions given in gnuplot format. This was covered in previous examples and will not be further commented on.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>Write the grid in eps format.</p>
<div class="fragment"><div class="line">std::string filename = <span class="stringliteral">&quot;grid-&quot;</span>;</div><div class="line">filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">filename += <span class="stringliteral">&quot;.eps&quot;</span>;</div><div class="line">deallog &lt;&lt; <span class="stringliteral">&quot;Writing grid to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">std::ofstream eps_output (filename.c_str());</div><div class="line"></div><div class="line"><a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">grid_out.<a class="code" href="classGridOut.html#a7e31485bb55254bfa5cd3ab55f8d1748">write_eps</a> (triangulation, eps_output);</div></div><!-- fragment --><p>Output of the solution in gnuplot format.</p>
<div class="fragment"><div class="line">  filename = <span class="stringliteral">&quot;sol-&quot;</span>;</div><div class="line">  filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  filename += <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">  std::ofstream gnuplot_output (filename.c_str());</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.add_data_vector (solution, <span class="stringliteral">&quot;u&quot;</span>);</div><div class="line"></div><div class="line">  data_out.build_patches ();</div><div class="line"></div><div class="line">  data_out.write_gnuplot(gnuplot_output);</div><div class="line">}</div></div><!-- fragment --><p>The following <code>run</code> function is similar to previous examples.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle)</div><div class="line">      {</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation);</div><div class="line"></div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid ();</div><div class="line"></div><div class="line"></div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system ();</div><div class="line"></div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">                &lt;&lt; dof_handler.n_dofs()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line">        solve (solution);</div><div class="line"></div><div class="line">        output_results (cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The following <code>main</code> function is similar to previous examples as well, and need not be commented on.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step12::AdvectionProblem&lt;2&gt; dgmethod;</div><div class="line">      dgmethod.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of this program consist of the console output, the eps files including the grids, and the solutions given in gnuplot format. </p><div class="fragment"><div class="line">DEAL::Cycle 0</div><div class="line">DEAL::Number of active cells:       64</div><div class="line">DEAL::Number of degrees of freedom: 256</div><div class="line">DEAL:Richardson::Starting value 0.176777</div><div class="line">DEAL:Richardson::Convergence step 4 value 3.33123e-17</div><div class="line">DEAL::Writing grid to &lt;grid-0.eps&gt;</div><div class="line">DEAL::Writing solution to &lt;sol-0.gnuplot&gt;</div><div class="line">DEAL::Cycle 1</div><div class="line">DEAL::Number of active cells:       112</div><div class="line">DEAL::Number of degrees of freedom: 448</div><div class="line">DEAL:Richardson::Starting value 0.153093</div><div class="line">DEAL:Richardson::Convergence step 9 value 3.74479e-17</div><div class="line">DEAL::Writing grid to &lt;grid-1.eps&gt;</div><div class="line">DEAL::Writing solution to &lt;sol-1.gnuplot&gt;</div><div class="line">DEAL::Cycle 2</div><div class="line">DEAL::Number of active cells:       214</div><div class="line">DEAL::Number of degrees of freedom: 856</div><div class="line">DEAL:Richardson::Starting value 0.149870</div><div class="line">DEAL:Richardson::Convergence step 16 value 1.41017e-14</div><div class="line">DEAL::Writing grid to &lt;grid-2.eps&gt;</div><div class="line">DEAL::Writing solution to &lt;sol-2.gnuplot&gt;</div><div class="line">DEAL::Cycle 3</div><div class="line">DEAL::Number of active cells:       415</div><div class="line">DEAL::Number of degrees of freedom: 1660</div><div class="line">DEAL:Richardson::Starting value 0.149053</div><div class="line">DEAL:Richardson::Convergence step 26 value 4.92424e-15</div><div class="line">DEAL::Writing grid to &lt;grid-3.eps&gt;</div><div class="line">DEAL::Writing solution to &lt;sol-3.gnuplot&gt;</div><div class="line">DEAL::Cycle 4</div><div class="line">DEAL::Number of active cells:       796</div><div class="line">DEAL::Number of degrees of freedom: 3184</div><div class="line">DEAL:Richardson::Starting value 0.148848</div><div class="line">DEAL:Richardson::Convergence step 44 value 5.80787e-14</div><div class="line">DEAL::Writing grid to &lt;grid-4.eps&gt;</div><div class="line">DEAL::Writing solution to &lt;sol-4.gnuplot&gt;</div><div class="line">DEAL::Cycle 5</div><div class="line">DEAL::Number of active cells:       1561</div><div class="line">DEAL::Number of degrees of freedom: 6244</div><div class="line">DEAL:Richardson::Starting value 0.131369</div><div class="line">DEAL:Richardson::Convergence step 81 value 2.39812e-13</div><div class="line">DEAL::Writing grid to &lt;grid-5.eps&gt;</div><div class="line">DEAL::Writing solution to &lt;sol-5.gnuplot&gt;</div></div><!-- fragment --><p>We show the solutions on the initial mesh, the mesh after two and after five adaptive refinement steps.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-0.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-2.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5.png"/>
</div>
<p>Then we show the final grid (after 5 refinement steps) and the solution again, this time with a nicer 3d rendering (obtained using the <a class="el" href="namespaceDataOutBase.html#a80b27325af6e59e2449593730bfaa6b0">DataOutBase::write_vtk</a> function and the VTK-based VisIt visualization program) that better shows the sharpness of the jump on the refined mesh and the over- and undershoots of the solution along the interface:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.grid-5.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.3d-solution.png"/>
</div>
<p>And finally we show a plot of a 3d computation.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5-3d.png"/>
</div>
<p><a class="anchor" id="dg-vs-cg"></a> <a class="anchor" id="Whyusediscontinuouselements"></a></p><h3>Why use discontinuous elements</h3>
<p>In this program we have used discontinuous elements. It is a legitimate question to ask why not simply use the normal, continuous ones. Of course, to everyone with a background in numerical methods, the answer is obvious: the continuous Galerkin (cG) method is not stable for the transport equation, unless one specifically adds stabilization terms. The DG method, however, <em>is</em> stable. Illustrating this with the current program is not very difficult; in fact, only the following minor modifications are necessary:</p><ul>
<li>Change the element to <a class="el" href="classFE__Q.html">FE_Q</a> instead of <a class="el" href="classFE__DGQ.html">FE_DGQ</a>.</li>
<li>Add handling of hanging node constraints in exactly the same way as <a class="el" href="step_6.html">step-6</a>.</li>
<li>We need a different solver; the direct solver in <a class="el" href="step_29.html">step-29</a> is a convenient choice. An experienced deal.II user will be able to do this in less than 10 minutes.</li>
</ul>
<p>While the 2d solution has been shown above, containing a number of small spikes at the interface that are, however, stable in height under mesh refinement, results look much different when using a continuous element:</p>
<table align="center">
<tr>
<td valign="top">0 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-0.png"/>
</div>
 <p class="endtd"></p>
</td><td valign="top">1 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-1.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td valign="top">2 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-2.png"/>
</div>
 <p class="endtd"></p>
</td><td valign="top">3 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-3.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td valign="top">4 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-4.png"/>
</div>
 <p class="endtd"></p>
</td><td valign="top">5 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-5.png"/>
</div>
   </td></tr>
</table>
<p>In refinement iteration 5, the image can't be plotted in a reasonable way any more as a 3d plot. We thus show a color plot with a range of <img class="formulaInl" alt="$[-1,2]$" src="form_1469.png"/> (the solution values of the exact solution lie in <img class="formulaInl" alt="$[0,1]$" src="form_364.png"/>, of course). In any case, it is clear that the continuous Galerkin solution exhibits oscillatory behavior that gets worse and worse as the mesh is refined more and more.</p>
<p>There are a number of strategies to stabilize the cG method, if one wants to use continuous elements for some reason. Discussing these methods is beyond the scope of this tutorial program; an interested reader could, for example, take a look at <a class="el" href="step_31.html">step-31</a>.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>Given that the exact solution is known in this case, one interesting avenue for further extensions would be to confirm the order of convergence for this program. In the current case, the solution is non-smooth, and so we can not expect to get a particularly high order of convergence, even if we used higher order elements. But even if the solution <em>is</em> smooth, the equation is not elliptic and so it is not immediately clear that we should obtain a convergence order that equals that of the optimal interpolation estimates (i.e. for example that we would get <img class="formulaInl" alt="$h^3$" src="form_1470.png"/> convergence in the <img class="formulaInl" alt="$L^2$" src="form_700.png"/> norm by using quadratic elements).</p>
<p>In fact, for hyperbolic equations, theoretical predictions often indicate that the best one can hope for is an order one half below the interpolation estimate. For example, for the streamline diffusion method (an alternative method to the DG method used here to stabilize the solution of the transport equation), one can prove that for elements of degree <img class="formulaInl" alt="$p$" src="form_202.png"/>, the order of convergence is <img class="formulaInl" alt="$p+\frac 12$" src="form_1471.png"/> on arbitrary meshes. While the observed order is frequently <img class="formulaInl" alt="$p+1$" src="form_353.png"/> on uniformly refined meshes, one can construct so-called Peterson meshes on which the worse theoretical bound is actually attained. This should be relatively simple to verify, for example using the <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> function.</p>
<p>A different direction is to observe that the solution of transport problems often has discontinuities and that therefore a mesh in which we <em>bisect</em> every cell in every coordinate direction may not be optimal. Rather, a better strategy would be to only cut cells in the direction parallel to the discontinuity. This is called <em>anisotropic mesh refinement</em> and is the subject of <a class="el" href="step_30.html">step-30</a>. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2015 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Guido Kanschat, Texas A&amp;M University, 2009</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q1.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_richardson.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition_block.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/derivative_approximation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/dof_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/integration_info.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/simple.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/meshworker/loop.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues:  <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues () {};</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;double&gt; &amp;values,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component=0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size()==points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(),points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;values.size(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (points[i](0)&lt;0.5)</div><div class="line">          values[i]=1.;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          values[i]=0.;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>AdvectionProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AdvectionProblem ();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> solve (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution);</div><div class="line">    <span class="keywordtype">void</span> refine_grid ();</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       right_hand_side;</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> DoFInfo;</div><div class="line">    <span class="keyword">typedef</span> <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> CellInfo;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> integrate_cell_term (DoFInfo &amp;dinfo,</div><div class="line">                                     CellInfo &amp;info);</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> integrate_boundary_term (DoFInfo &amp;dinfo,</div><div class="line">                                         CellInfo &amp;info);</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> integrate_face_term (DoFInfo &amp;dinfo1,</div><div class="line">                                     DoFInfo &amp;dinfo2,</div><div class="line">                                     CellInfo &amp;info1,</div><div class="line">                                     CellInfo &amp;info2);</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  AdvectionProblem&lt;dim&gt;::AdvectionProblem ()</div><div class="line">    :</div><div class="line">    mapping (),</div><div class="line">    fe (1),</div><div class="line">    dof_handler (triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs (fe);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.n_dofs());</div><div class="line">    right_hand_side.reinit (dof_handler.n_dofs());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = dof_handler.get_fe().degree+1;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a2ccc96521da795a762213a979c581138">initialize_gauss_quadrature</a>(n_gauss_points,</div><div class="line">                                         n_gauss_points,</div><div class="line">                                         n_gauss_points);</div><div class="line"></div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a1cf1a84cfec1e6fc176b50489c91d92a">initialize_update_flags</a>();</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>            |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a84f63629724e517c250f56d59f096afd">add_update_flags</a>(update_flags, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt;dim&gt;</a> dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">    assembler;</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(system_matrix, right_hand_side);</div><div class="line"></div><div class="line">    MeshWorker::loop&lt;dim, dim, MeshWorker::DoFInfo&lt;dim&gt;, <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> &gt;</div><div class="line">    (dof_handler.begin_active(), dof_handler.end(),</div><div class="line">     dof_info, info_box,</div><div class="line">     &amp;AdvectionProblem&lt;dim&gt;::integrate_cell_term,</div><div class="line">     &amp;AdvectionProblem&lt;dim&gt;::integrate_boundary_term,</div><div class="line">     &amp;AdvectionProblem&lt;dim&gt;::integrate_face_term,</div><div class="line">     assembler);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::integrate_cell_term (DoFInfo &amp;dinfo,</div><div class="line">                                                   CellInfo &amp;info)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe_v = info.fe_values();</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;local_matrix = dinfo.matrix(0).matrix;</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> beta;</div><div class="line">        beta(0) = -fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)(1);</div><div class="line">        beta(1) = fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)(0);</div><div class="line">        beta /= beta.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">            local_matrix(i,j) -= beta*fe_v.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)*</div><div class="line">                                 fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                 JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::integrate_boundary_term (DoFInfo &amp;dinfo,</div><div class="line">                                                       CellInfo &amp;info)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe_v = info.fe_values();</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;local_matrix = dinfo.matrix(0).matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;local_vector = dinfo.vector(0).block(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a> ();</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; g(fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> BoundaryValues&lt;dim&gt; boundary_function;</div><div class="line">    boundary_function.value_list (fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), g);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> beta;</div><div class="line">        beta(0) = -fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)(1);</div><div class="line">        beta(1) = fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)(0);</div><div class="line">        beta /= beta.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta_n=beta * normals[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        <span class="keywordflow">if</span> (beta_n&gt;0)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">              local_matrix(i,j) += beta_n *</div><div class="line">                                   fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                   JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">            local_vector(i) -= beta_n *</div><div class="line">                               g[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] *</div><div class="line">                               fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                               JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::integrate_face_term (DoFInfo &amp;dinfo1,</div><div class="line">                                                   DoFInfo &amp;dinfo2,</div><div class="line">                                                   CellInfo &amp;info1,</div><div class="line">                                                   CellInfo &amp;info2)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe_v = info1.fe_values();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValuesBase.html">FEValuesBase&lt;dim&gt;</a> &amp;fe_v_neighbor = info2.fe_values();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;u1_v1_matrix = dinfo1.matrix(0,<span class="keyword">false</span>).matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;u2_v1_matrix = dinfo1.matrix(0,<span class="keyword">true</span>).matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;u1_v2_matrix = dinfo2.matrix(0,<span class="keyword">true</span>).matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;u2_v2_matrix = dinfo2.matrix(0,<span class="keyword">false</span>).matrix;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> ();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;1,dim&gt; &gt; &amp;normals = fe_v.<a class="code" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a> ();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> beta;</div><div class="line">        beta(0) = -fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)(1);</div><div class="line">        beta(1) = fe_v.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)(0);</div><div class="line">        beta /= beta.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta_n=beta * normals[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">        <span class="keywordflow">if</span> (beta_n&gt;0)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">                u1_v1_matrix(i,j) += beta_n *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">                u1_v2_matrix(k,j) -= beta_n *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                u2_v1_matrix(i,l) += beta_n *</div><div class="line">                                     fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(l,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>&lt;fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                u2_v2_matrix(k,l) -= beta_n *</div><div class="line">                                     fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(l,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     fe_v_neighbor.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>];</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve (<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution)</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line">    <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;&gt;</a>      solver (solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a> &gt; preconditioner;</div><div class="line"></div><div class="line">    preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.dofs_per_cell);</div><div class="line"></div><div class="line">    solver.solve (system_matrix, solution, right_hand_side,</div><div class="line">                  preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> gradient_indicator (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceDerivativeApproximation.html#ace2a9964b7da0d28c8184346902a6563">DerivativeApproximation::approximate_gradient</a> (mapping,</div><div class="line">                                                   dof_handler,</div><div class="line">                                                   solution,</div><div class="line">                                                   gradient_indicator);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.end();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no=0; cell!=endc; ++cell, ++cell_no)</div><div class="line">      gradient_indicator(cell_no)*=std::pow(cell-&gt;diameter(), 1+1.0*dim/2);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                     gradient_indicator,</div><div class="line">                                                     0.3, 0.1);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::string filename = <span class="stringliteral">&quot;grid-&quot;</span>;</div><div class="line">    filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    filename += <span class="stringliteral">&quot;.eps&quot;</span>;</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Writing grid to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::ofstream eps_output (filename.c_str());</div><div class="line"></div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a7e31485bb55254bfa5cd3ab55f8d1748">write_eps</a> (triangulation, eps_output);</div><div class="line"></div><div class="line">    filename = <span class="stringliteral">&quot;sol-&quot;</span>;</div><div class="line">    filename += (<span class="charliteral">&#39;0&#39;</span> + cycle);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (cycle &lt; 10, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    filename += <span class="stringliteral">&quot;.gnuplot&quot;</span>;</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::ofstream gnuplot_output (filename.c_str());</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.add_data_vector (solution, <span class="stringliteral">&quot;u&quot;</span>);</div><div class="line"></div><div class="line">    data_out.build_patches ();</div><div class="line"></div><div class="line">    data_out.write_gnuplot(gnuplot_output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle)</div><div class="line">      {</div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation);</div><div class="line"></div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid ();</div><div class="line"></div><div class="line"></div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system ();</div><div class="line"></div><div class="line">        deallog &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">                &lt;&lt; dof_handler.n_dofs()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line">        solve (solution);</div><div class="line"></div><div class="line">        output_results (cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step12::AdvectionProblem&lt;2&gt; dgmethod;</div><div class="line">      dgmethod.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
