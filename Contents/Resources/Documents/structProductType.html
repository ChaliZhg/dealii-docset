<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ProductType&lt; T, U &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a> &#124;
<a href="structProductType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ProductType&lt; T, U &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="template__constraints_8h_source.html">deal.II/base/template_constraints.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a9347907242887810203c52394d91eb1c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9347907242887810203c52394d91eb1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, std::complex&lt; U &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structProductType.html#a9347907242887810203c52394d91eb1c">operator*</a> (const std::complex&lt; T &gt; &amp;left, const std::complex&lt; U &gt; &amp;right)</td></tr>
<tr class="separator:a9347907242887810203c52394d91eb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d0e1f219a6cf79f806efe8a8c0458f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a00d0e1f219a6cf79f806efe8a8c0458f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; U &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structProductType.html#a00d0e1f219a6cf79f806efe8a8c0458f">operator*</a> (const std::complex&lt; T &gt; &amp;left, const U &amp;right)</td></tr>
<tr class="separator:a00d0e1f219a6cf79f806efe8a8c0458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0db87cc3a952eb59e0e97bf5a8a1c8f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab0db87cc3a952eb59e0e97bf5a8a1c8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structProductType.html">ProductType</a>&lt; typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; T &gt;::type, std::complex&lt; U &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structProductType.html#ab0db87cc3a952eb59e0e97bf5a8a1c8f">operator*</a> (const T &amp;left, const std::complex&lt; U &gt; &amp;right)</td></tr>
<tr class="separator:ab0db87cc3a952eb59e0e97bf5a8a1c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename U&gt;<br />
struct ProductType&lt; T, U &gt;</h3>

<p>A class with a local typedef that represents the type that results from the product of two variables of type <code>T</code> and <code>U</code>. In other words, we would like to infer the type of the <code>product</code> variable in code like this: </p><div class="fragment"><div class="line">T t;</div><div class="line">U u;</div><div class="line"><span class="keyword">auto</span> product = t*u;</div></div><!-- fragment --><p> The local typedef of this structure represents the type the variable <code>product</code> would have.</p>
<h3>Where is this useful</h3>
<p>The purpose of this class is principally to represent the type one needs to use to represent the values or gradients of finite element fields at quadrature points. For example, assume you are storing the values <img class="formulaInl" alt="$U_j$" src="form_75.png"/> of unknowns in a Vector&lt;float&gt;, then evaluating <img class="formulaInl" alt="$u_h(x_q) = \sum_j U_j \varphi_j(x_q)$" src="form_470.png"/> at quadrature points results in values <img class="formulaInl" alt="$u_h(x_q)$" src="form_471.png"/> that need to be stored as <code>double</code> variables because the <img class="formulaInl" alt="$U_j$" src="form_75.png"/> are <code>float</code> values and the <img class="formulaInl" alt="$\varphi_j(x_q)$" src="form_472.png"/> are computed as <code>double</code> values, and the product are then <code>double</code> values. On the other hand, if you store your unknowns <img class="formulaInl" alt="$U_j$" src="form_75.png"/> as <code>std::complex&lt;double&gt;</code> values and you try to evaluate <img class="formulaInl" alt="$\nabla u_h(x_q) = \sum_j U_j \nabla\varphi_j(x_q)$" src="form_473.png"/> at quadrature points, then the gradients <img class="formulaInl" alt="$\nabla u_h(x_q)$" src="form_474.png"/> need to be stored as objects of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim,std::complex&lt;double&gt;&gt;</code> because that's what you get when you multiply a complex number by a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> (the type used to represent the gradient of shape functions of scalar finite elements).</p>
<p>Likewise, if you are using a vector valued element (with dim components) and the <img class="formulaInl" alt="$U_j$" src="form_75.png"/> are stored as <code>double</code> variables, then <img class="formulaInl" alt="$u_h(x_q) = \sum_j U_j \varphi_j(x_q)$" src="form_470.png"/> needs to have type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> (because the shape functions have type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code>). Finally, if you store the <img class="formulaInl" alt="$U_j$" src="form_75.png"/> as objects of type <code>std::complex&lt;double&gt;</code> and you have a vector valued element, then the gradients <img class="formulaInl" alt="$\nabla u_h(x_q) = \sum_j U_j \nabla\varphi_j(x_q)$" src="form_473.png"/> will result in objects of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;2,dim,std::complex&lt;double&gt; &gt;</code>.</p>
<p>In all of these cases, this type is used to identify which type needs to be used for the result of computing the product of unknowns and the values, gradients, or other properties of shape functions.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00026">26</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a9347907242887810203c52394d91eb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9347907242887810203c52394d91eb1c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, std::complex&lt; U &gt; &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide an <code>operator*</code> that operates on mixed complex floating point types. Annoyingly, the standard library does not provide such an operator... </p>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00039">39</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>

</div>
</div>
<a id="a00d0e1f219a6cf79f806efe8a8c0458f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d0e1f219a6cf79f806efe8a8c0458f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; U &gt;::type &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide an <code>operator*</code> for a scalar multiplication of a complex floating point type with a different real floating point type. Annoyingly, the standard library does not provide such an operator... </p>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00057">57</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>

</div>
</div>
<a id="ab0db87cc3a952eb59e0e97bf5a8a1c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0db87cc3a952eb59e0e97bf5a8a1c8f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structProductType.html">ProductType</a>&lt; typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; T &gt;::type, std::complex&lt; U &gt; &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide an <code>operator*</code> for a scalar multiplication of a real floating point type with a different complex floating point type. Annoyingly, the standard library does not provide such an operator... </p>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00075">75</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>deal.II/base/<a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a></li>
<li>deal.II/base/<a class="el" href="template__constraints_8h_source.html">template_constraints.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
