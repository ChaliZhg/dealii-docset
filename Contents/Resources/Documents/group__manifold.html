<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Manifold description for triangulations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Manifold description for triangulations<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Manifold description for triangulations:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__manifold.svg" width="294" height="50"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCompositionManifold.html">CompositionManifold&lt; dim, spacedim, chartdim, intermediate_dim, dim1, dim2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html">Manifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html">FlatManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html">ChartManifold&lt; dim, spacedim, chartdim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPolarManifold.html">PolarManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html">SphericalManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCylindricalManifold.html">CylindricalManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionManifold.html">FunctionManifold&lt; dim, spacedim, chartdim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTorusManifold.html">TorusManifold&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation&lt; dim, spacedim &gt;::set_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number, const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;manifold_object)</td></tr>
<tr class="separator:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b19e49bf436938a74e1700252c06928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga0b19e49bf436938a74e1700252c06928">Triangulation&lt; dim, spacedim &gt;::set_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga0b19e49bf436938a74e1700252c06928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2acfbef517fd03855c4b371f3e182f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">Triangulation&lt; dim, spacedim &gt;::set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:gae2acfbef517fd03855c4b371f3e182f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">Triangulation&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa4e0af28512cb5f9cc8cb3b95a38c669">Triangulation&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> b_id, const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2131fc63fb23e2e7eabb570b1e852e4a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2131fc63fb23e2e7eabb570b1e852e4a">Triangulation&lt; dim, spacedim &gt;::get_manifold</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number) const</td></tr>
<tr class="separator:ga2131fc63fb23e2e7eabb570b1e852e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41320ae1978763a1b83608e10408d68f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga41320ae1978763a1b83608e10408d68f">Triangulation&lt; dim, spacedim &gt;::get_manifold_ids</a> () const</td></tr>
<tr class="separator:ga41320ae1978763a1b83608e10408d68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with boundary and manifold ids</h2></td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2ea00d3c65f290a020a268df8fb50c19">GridTools::copy_boundary_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const bool reset_boundary_ids=false)</td></tr>
<tr class="separator:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga306131b2b48ca10bb9a51e189806193c">GridTools::copy_material_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const bool compute_face_ids=false)</td></tr>
<tr class="separator:ga306131b2b48ca10bb9a51e189806193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with manifold indicators</h2></td></tr>
<tr class="memitem:gafbeb21da36433dc2ec117b9694ca2557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor&lt; structdim, dim, spacedim &gt;::set_manifold_id</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>) const</td></tr>
<tr class="separator:gafbeb21da36433dc2ec117b9694ca2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">TriaAccessor&lt; structdim, dim, spacedim &gt;::set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>) const</td></tr>
<tr class="separator:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with boundary indicators</h2></td></tr>
<tr class="memitem:ga853633832f20bf91d674749b9ae83827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga853633832f20bf91d674749b9ae83827">TriaAccessor&lt; 0, 1, spacedim &gt;::set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>)</td></tr>
<tr class="separator:ga853633832f20bf91d674749b9ae83827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h3>Overview</h3>
<p>The classes in this module are concerned with the description of the manifold in which the domain that a <a class="el" href="classTriangulation.html">Triangulation</a> describes lives. This manifold description is necessary in two contexts:</p>
<ul>
<li>
<p class="startli">Mesh refinement: Whenever a cell is refined, it is necessary to introduce new vertices in the <a class="el" href="classTriangulation.html">Triangulation</a>. In the simplest case, one assumes that the objects that make up the <a class="el" href="classTriangulation.html">Triangulation</a> are straight line segments, a bi-linear surface or a tri-linear volume. The next vertex is then simply put into the middle of the old ones (where "middle" means a suitable average of the locations of the pre-existing vertices). This is the default behavior of the <a class="el" href="classTriangulation.html">Triangulation</a> class, and is described by the <a class="el" href="classFlatManifold.html">FlatManifold</a> class.</p>
<p>On the other hand, if one deals with curved geometries, or geometries which require a denser refinement in some direction, this is not the appropriate thing to do. The classes derived from the <a class="el" href="classManifold.html">Manifold</a> base class therefore describe the geometry of a domain. One can then attach an object of a class derived from this base class to the <a class="el" href="classTriangulation.html">Triangulation</a> object using the <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> function associating it with a manifold id (see <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>), use this manifold id on the cells, faces or edges of the triangulation that should be described by this manifold using the <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor::set_manifold_id()</a> function, and then the <a class="el" href="classTriangulation.html">Triangulation</a> will ask the manifold object where a new vertex to be located on a cell, face or edge so attributed should be located upon mesh refinement. Several classes already exist to support the most common geometries, e.g., CylinderManifold, or <a class="el" href="classPolarManifold.html">PolarManifold</a>, which represent respectively the geometry obtained when describing your space in cylindrical coordinates or in polar coordinates.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Integration: When using higher order finite element methods, it is often necessary to compute cell terms (like cell contributions to the matrix and right hand side of the linear system) using curved approximations of the boundary, rather than the straight line approximation. The actual implementation of such curved elements happens in the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class (see the <a class="el" href="group__mapping.html">Mappings between reference and real cell</a> module), which however obtains its information about the boundary of the domain from the classes described here. The same is, of course, true when integrating boundary terms (e.g., inhomogenous Neumann boundary conditions).</p>
<p class="endli"></p>
</li>
</ul>
<p>In deal.II, a <a class="el" href="classManifold.html">Manifold</a> is seen as a collection of points, together with a notion of distance between points (on the manifold). New points are typically obtained by providing a local coordinate system on the manifold, identifying existing points in the local coordinate system (pulling them back using the local map to obtain their local coordinates), find the new point in the local coordinate system by weighted sums of the existing points, and transforming back the point in the real space (pushing it forward using the local map). The main class that implements this mechanism is the <a class="el" href="classChartManifold.html">ChartManifold</a> class, and this is the class that users will likely overload for complex geometries.</p>
<p>While this process is non trivial in most cases of interest, for most of the trivial geometries, like cylinders, spheres or shells, deal.II provides reasonable implementations. More complicated examples can be described using the techniques shown in <a class="el" href="step_53.html">step-53</a> and <a class="el" href="step_54.html">step-54</a>.</p>
<p>The boundary of a <a class="el" href="classTriangulation.html">Triangulation</a> is a special case of <a class="el" href="classManifold.html">Manifold</a>, for which additional information can be useful in user codes, such as normal vectors to surfaces or to curves. If your coarse mesh is reasonably shaped, you might be interested in only attaching a manifold description to boundary portion of your domain. This can be done using the <a class="el" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">Triangulation::set_boundary()</a> function, which take as arguments a <a class="el" href="classBoundary.html">Boundary</a> object (derived from <a class="el" href="classManifold.html">Manifold</a>). Notice that <a class="el" href="classTriangulation.html">Triangulation</a> uses only the <a class="el" href="classManifold.html">Manifold</a> interface, not the <a class="el" href="classBoundary.html">Boundary</a> interface. Other tools, however, might need to compute exact normals at quadrature points, and therefore a wrapper to query <a class="el" href="classBoundary.html">Boundary</a> objects is provided.</p>
<h3>An example</h3>
<p>A simple example why dealing with curved geometries is already provided by <a class="el" href="step_1.html">step-1</a>, though it is not elaborated there. For example, consider this small variation of the <code>second_grid()</code> function shown there, where we simply refine <em>every</em> cell several times and do not deal with boundaries at all: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> center (1,0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            center, inner_radius, outer_radius,</div><div class="line">                            10);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div></div><!-- fragment --><p> This code leads to a mesh that looks like this:</p>
<div class="image">
<img src="hypershell-nothing.png" alt="hypershell-nothing.png"/>
</div>
<p> Our intention was to get a mesh that resembles a ring. However, since we did not describe this to the triangulation, what happens is that we start with the 10 coarse cells in circumferential direction we told <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> to create, and each of these is then 3 times globally refined. Each time refinement requires a new vertex, it is placed in the middle of the existing ones, regardless of what we may have intended (but omitted to describe in code).</p>
<p>This is easily remedied. <a class="el" href="step_1.html">step-1</a> already shows how to do this. Consider this code: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> center (1,0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            center, inner_radius, outer_radius,</div><div class="line">                            10);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classHyperShellBoundary.html">HyperShellBoundary&lt;2&gt;</a> boundary_description(center);</div><div class="line">triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (0, boundary_description);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3); </div></div><!-- fragment --><p> This code is better, producing the following mesh:</p>
<div class="image">
<img src="hypershell-boundary-only.png" alt="hypershell-boundary-only.png"/>
</div>
<p> The mesh looks better in that it faithfully reproduces the circular inner and outer boundaries of the domain. However, it is still possible to identify the original 10 cells by the kinks in the tangential lines. They result from the fact that every time a cell is refined, new vertices on interior lines are just placed into the middle of the existing line (the boundary lines are handled differently because we have attached boundary objects). In other words, they end up in places that may be in the geometric middle of a straight line, but not on a circle around the center.</p>
<p>This can be remedied by assigning a manifold description not only to the lines along the boundary, but also to the radial lines and cells (which, in turn, will inherit it to the new lines that are created upon mesh refinement). This code achieves this: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> center (1,0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            center, inner_radius, outer_radius,</div><div class="line">                            10);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> boundary_description(center);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, boundary_description);</div><div class="line"></div><div class="line"><a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  cell-&gt;set_all_manifold_ids (0);  </div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div></div><!-- fragment --><p> This leads to the following mesh:</p>
<div class="image">
<img src="hypershell-all.png" alt="hypershell-all.png"/>
</div>
<p> So why does this matter? After all, the last two meshes describe the exact same domain and we know that upon mesh refinement we obtain the correct solution regardless of the choice of cells, as long as the diameter of the largest cell goes to zero.</p>
<p>There are two answers to this question. First, the numerical effort of solving a partial differential equation to a certain accuracy typically depends on the <em>quality</em> of cells since the constant <img class="formulaInl" alt="$C$" src="form_43.png"/> in error estimates of the form <img class="formulaInl" alt="$\|u-u_h\|_{H^1} \le Ch^p \|u\|_{H^{p+1}}$" src="form_131.png"/> depends on factors such as the maximal ratio of radii of the smallest circumscribed to largest inscribed circle over all cells (for triangles; or a suitable generalization for other types of cells). Thus, it is worthwhile creating meshes with cells that are as well-formed as possible. This is arguably not so much of an issue for the meshes shown above, but is sometimes an issue. Consider, for example, the following code and mesh: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> center (1,0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            center, inner_radius, outer_radius,</div><div class="line">                            4);    <span class="comment">// four circumferential cells</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classHyperShellBoundary.html">HyperShellBoundary&lt;2&gt;</a> boundary_description(center);</div><div class="line">triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (0, boundary_description);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3); </div></div><!-- fragment --><div class="image">
<img src="hypershell-boundary-only-4.png" alt="hypershell-boundary-only-4.png"/>
</div>
<p> Here, we create only four circumferential cells in the beginning, and refining them leads to the mesh shown. Clearly, here we have cells with bad aspect ratios.</p>
<p>If we drive this further and start with a coarse mesh of only three cells (which may be inappropriate here, since we know that it is not sufficient, but may also be impossible to avoid for complex geometries generated in mesh generators), then we obtain the following mesh:</p>
<div class="image">
<img src="hypershell-boundary-only-3.png" alt="hypershell-boundary-only-3.png"/>
</div>
<p> This mesh neither has the correct geometry after refinement, nor do all cells have positive area as is necessary for the finite element method to work. However, even when starting with such in inopportune mesh, we can make things work by attaching a suitable geometry description not only to the boundary but also to interior cells and edges, using the same code as above: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> center (1,0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            center, inner_radius, outer_radius,</div><div class="line">                            3);    <span class="comment">// three circumferential cells</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> boundary_description(center);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, boundary_description);</div><div class="line"></div><div class="line"><a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  cell-&gt;set_all_manifold_ids (0);  </div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div></div><!-- fragment --><div class="image">
<img src="hypershell-all-3.png" alt="hypershell-all-3.png"/>
</div>
<p> Here, even starting with an initial, inappropriately chosen mesh retains our ability to adequately refine the mesh into one that will serve us well. This example may be manufactured here, but it is relevant, for example in the context of what <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> produces in 3d (see the documentation of this function). It is also germane to the cases discussed in the <a class="el" href="DEALGlossary.html#GlossDistorted">glossary entry on distorted cells</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Luca Heltai, 2013 </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2ea00d3c65f290a020a268df8fb50c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ea00d3c65f290a020a268df8fb50c19">&#9670;&nbsp;</a></span>copy_boundary_to_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::copy_boundary_to_manifold_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reset_boundary_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy boundary ids to manifold ids on faces and edges at the boundary. The default manifold_id for new <a class="el" href="classTriangulation.html">Triangulation</a> objects is <a class="el" href="namespacenumbers.html#a13049bc76f27e3b976d6b08d0736cb1b">numbers::invalid_manifold_id</a>. This function copies the boundary_ids of the boundary faces and edges to the manifold_ids of the same faces and edges, allowing the user to change the boundary_ids and use them for boundary conditions regardless of the geometry, which will use manifold_ids to create new points. Only active cells will be iterated over. This is a function you'd typically call when there is only one active level on your <a class="el" href="classTriangulation.html">Triangulation</a>. Mesh refinement will then inherit these indicators to child cells, faces, and edges.</p>
<p>The optional parameter <code>reset_boundary_ids</code>, indicates whether this function should reset the boundary_ids of boundary faces and edges to its default value 0 after copying its value to the manifold_id. By default, boundary_ids are left untouched.</p>
<dl class="section author"><dt>Author</dt><dd>Luca Heltai, 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04062">4062</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ga306131b2b48ca10bb9a51e189806193c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga306131b2b48ca10bb9a51e189806193c">&#9670;&nbsp;</a></span>copy_material_to_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::copy_material_to_manifold_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>compute_face_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy material ids to manifold ids. The default manifold_id for new <a class="el" href="classTriangulation.html">Triangulation</a> objects is <a class="el" href="namespacenumbers.html#a13049bc76f27e3b976d6b08d0736cb1b">numbers::invalid_manifold_id</a>. When refinements occurs, the <a class="el" href="classTriangulation.html">Triangulation</a> asks where to locate new points to the underlying manifold.</p>
<p>When reading a <a class="el" href="classTriangulation.html">Triangulation</a> from a supported input format, typical information that can be stored in a file are boundary conditions for boundary faces (which we store in the boundary_id of the faces), material types for cells (which we store in the material_id of the cells) and in some cases subdomain ids for cells (which we store in the subdomain_id of the cell).</p>
<p>If you read one of these grids into a <a class="el" href="classTriangulation.html">Triangulation</a>, you might still want to use the material_id specified in the input file as a manifold_id description. In this case you can associate a <a class="el" href="classManifold.html">Manifold</a> object to internal cells, and this object will be used by the <a class="el" href="classTriangulation.html">Triangulation</a> to query <a class="el" href="classManifold.html">Manifold</a> objects for new points. This function iterates over active cells and copies the material_ids to the manifold_ids.</p>
<p>The optional parameter <code>compute_face_ids</code>, indicates whether this function should also set the manifold_ids of the faces (both for internal faces and for faces on the boundary). If set to true, then each face will get a manifold_id equal to the minimum of the surrounding manifold_ids, ensuring that a unique manifold id is selected for each face of the <a class="el" href="classTriangulation.html">Triangulation</a>. By default, face manifold_ids are not computed.</p>
<dl class="section author"><dt>Author</dt><dd>Luca Heltai, 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04105">4105</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ga9f9d720f5fbdcdf3dcbb445feefbdb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">&#9670;&nbsp;</a></span>set_manifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign a manifold object to a certain part of the the triangulation. If an object with manifold number <code>number</code> is refined, this object is used to find the location of new vertices (see the results section of <a class="el" href="step_49.html">step-49</a> for a more in-depth discussion of this, with examples). It is also used for non-linear (i.e.: non-Q1) transformations of cells to the unit cell in shape function calculations.</p>
<p>The <code>manifold_object</code> is not copied and MUST persist until the triangulation is destroyed. This is also true for triangulations generated from this one by <code>copy_triangulation</code>.</p>
<p>It is possible to remove or replace the boundary object during the lifetime of a non-empty triangulation. Usually, this is done before the first refinement and is dangerous afterwards. Removal of a manifold object is done by <code>set_manifold(number)</code>, i.e. the function of same name but only one argument. This operation then replaces the manifold object given before by a straight manifold approximation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09118">9118</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga0b19e49bf436938a74e1700252c06928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b19e49bf436938a74e1700252c06928">&#9670;&nbsp;</a></span>set_manifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset those parts of the triangulation with the given manifold_id to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object. This is the default state of a triangulation, and undoes assignment of a different <a class="el" href="classManifold.html">Manifold</a> object by the function of same name and two arguments.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09138">9138</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="gae2acfbef517fd03855c4b371f3e182f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2acfbef517fd03855c4b371f3e182f7">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold_id of all cells and faces to the given argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09149">9149</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga1f1ea841946c94c079388ecf9ad2c00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1ea841946c94c079388ecf9ad2c00c">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces to the given argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09164">9164</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="gaa4e0af28512cb5f9cc8cb3b95a38c669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e0af28512cb5f9cc8cb3b95a38c669">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces and edges with given boundary_id <code>b_id</code> to the given manifold_id <code>number</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09181">9181</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga2131fc63fb23e2e7eabb570b1e852e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2131fc63fb23e2e7eabb570b1e852e4a">&#9670;&nbsp;</a></span>get_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to a <a class="el" href="classManifold.html">Manifold</a> object used for this triangulation. Number is the same as in <code>set_manifold</code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09231">9231</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga41320ae1978763a1b83608e10408d68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41320ae1978763a1b83608e10408d68f">&#9670;&nbsp;</a></span>get_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_manifold_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector containing all manifold indicators assigned to the objects of this <a class="el" href="classTriangulation.html">Triangulation</a>. Note, that each manifold indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09288">9288</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="gafbeb21da36433dc2ec117b9694ca2557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbeb21da36433dc2ec117b9694ca2557">&#9670;&nbsp;</a></span>set_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_manifold_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold indicator. The same applies as for the <code><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id()</a></code> function.</p>
<p>Note that it only sets the manifold object of the current object itself, not the indicators of the ones that bound it, nor of its children. For example, in 3d, if this function is called on a face, then the manifold indicator of the 4 edges that bound the face remain unchanged. If you want to set the manifold indicators of face, edges and all children at the same time, use the <a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">set_all_manifold_ids()</a> function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga160a26ce22b36607556bcdcc20bc6d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga160a26ce22b36607556bcdcc20bc6d61">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do as <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id()</a> but also set the manifold indicators of the objects that bound the current object. For example, in 3d, if <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id()</a> is called on a face, then the manifold indicator of the 4 edges that bound the face remain unchanged. On the other hand, the manifold indicators of face and edges are all set at the same time using the current function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga853633832f20bf91d674749b9ae83827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga853633832f20bf91d674749b9ae83827">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, 1, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold indicator of this object and all of its lower- dimensional sub-objects. Since this object only represents a single vertex, there are no lower-dimensional object and this function is equivalent to calling <a class="el" href="group__boundary.html#gaea37d3b925b8e6a2c02d9ef9c454ed54">set_manifold_id()</a> with the same argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
