<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GridGenerator Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">GridGenerator Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Creating meshes for basic geometries</div></td></tr>
<tr class="memitem:acea0cbcd68e52ce8113d1134b87de403"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acea0cbcd68e52ce8113d1134b87de403"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</td></tr>
<tr class="separator:acea0cbcd68e52ce8113d1134b87de403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe4bebfe752ba2a50542780efd3eb6e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:adbe4bebfe752ba2a50542780efd3eb6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#adbe4bebfe752ba2a50542780efd3eb6e">simplex</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, dim &gt; &amp;tria, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;vertices)</td></tr>
<tr class="memdesc:adbe4bebfe752ba2a50542780efd3eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulation of a d-simplex with (d+1) vertices and mesh cells.  <a href="#adbe4bebfe752ba2a50542780efd3eb6e">More...</a><br /></td></tr>
<tr class="separator:adbe4bebfe752ba2a50542780efd3eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5d7022d456db0356f11427473f4f76"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:adc5d7022d456db0356f11427473f4f76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">subdivided_hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const unsigned int repetitions, const double left=0., const double right=1.)</td></tr>
<tr class="separator:adc5d7022d456db0356f11427473f4f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56019d263ae45708302d5d7599f0d458"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a56019d263ae45708302d5d7599f0d458"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const bool colorize=false)</td></tr>
<tr class="separator:a56019d263ae45708302d5d7599f0d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76417d7404b75cf53c732f456e6e971"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac76417d7404b75cf53c732f456e6e971"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned int &gt; &amp;repetitions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const bool colorize=false)</td></tr>
<tr class="separator:ac76417d7404b75cf53c732f456e6e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e245f7c5788b6dcfcf93279a67fdbbb"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a0e245f7c5788b6dcfcf93279a67fdbbb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a0e245f7c5788b6dcfcf93279a67fdbbb">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;step_sizes, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p_1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p_2, const bool colorize=false)</td></tr>
<tr class="separator:a0e245f7c5788b6dcfcf93279a67fdbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96bbbe1d7cd1a894dcc038028a9684a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ab96bbbe1d7cd1a894dcc038028a9684a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ab96bbbe1d7cd1a894dcc038028a9684a">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;spacing, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const <a class="el" href="classTable.html">Table</a>&lt; dim, <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> &gt; &amp;material_id, const bool colorize=false)</td></tr>
<tr class="separator:ab96bbbe1d7cd1a894dcc038028a9684a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c54698f4666a44ac3982ee62f87ee9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a76c54698f4666a44ac3982ee62f87ee9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a76c54698f4666a44ac3982ee62f87ee9">cheese</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned int &gt; &amp;holes)</td></tr>
<tr class="memdesc:a76c54698f4666a44ac3982ee62f87ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rectangular domain with rectangular pattern of holes.  <a href="#a76c54698f4666a44ac3982ee62f87ee9">More...</a><br /></td></tr>
<tr class="separator:a76c54698f4666a44ac3982ee62f87ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e307e1d25f732db3deffdecce164c9"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aa5e307e1d25f732db3deffdecce164c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aa5e307e1d25f732db3deffdecce164c9">general_cell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;vertices, const bool colorize=false)</td></tr>
<tr class="separator:aa5e307e1d25f732db3deffdecce164c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324b8447f05b148e2f58bdbcf89f5325"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a324b8447f05b148e2f58bdbcf89f5325"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a324b8447f05b148e2f58bdbcf89f5325">parallelogram</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const bool colorize=false)</td></tr>
<tr class="separator:a324b8447f05b148e2f58bdbcf89f5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff29b277d8a71f91993a9b7ca9949547"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aff29b277d8a71f91993a9b7ca9949547"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aff29b277d8a71f91993a9b7ca9949547">parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners) [dim], const bool colorize=false)</td></tr>
<tr class="separator:aff29b277d8a71f91993a9b7ca9949547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd57165adbc1178577f61bb9bf5fa3e1"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:afd57165adbc1178577f61bb9bf5fa3e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#afd57165adbc1178577f61bb9bf5fa3e1">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned int n_subdivisions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners) [dim], const bool colorize=false)</td></tr>
<tr class="separator:afd57165adbc1178577f61bb9bf5fa3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29b6f85fac7f656a83202521658f76a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ae29b6f85fac7f656a83202521658f76a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ae29b6f85fac7f656a83202521658f76a">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned int(&amp;n_subdivisions)[dim], const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners) [dim], const bool colorize=false)</td></tr>
<tr class="separator:ae29b6f85fac7f656a83202521658f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dc883cabdb8fbfeb0ccfeafb0c050d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac6dc883cabdb8fbfeb0ccfeafb0c050d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ac6dc883cabdb8fbfeb0ccfeafb0c050d">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;origin, const std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, dim &gt; &amp;edges, const std::vector&lt; unsigned int &gt; &amp;subdivisions=std::vector&lt; unsigned int &gt;(), const bool colorize=false)</td></tr>
<tr class="separator:ac6dc883cabdb8fbfeb0ccfeafb0c050d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c537aebe22842ec22de2c8b5c545896"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2c537aebe22842ec22de2c8b5c545896"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a2c537aebe22842ec22de2c8b5c545896">enclosed_hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const double left=0., const double right=1., const double thickness=1., const bool colorize=false)</td></tr>
<tr class="separator:a2c537aebe22842ec22de2c8b5c545896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a81f736ef95164a9d9bf0f844ac682b"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a0a81f736ef95164a9d9bf0f844ac682b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a0a81f736ef95164a9d9bf0f844ac682b">hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const double radius=1.)</td></tr>
<tr class="separator:a0a81f736ef95164a9d9bf0f844ac682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726a92e2da3358854990f768dcf58bb6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a726a92e2da3358854990f768dcf58bb6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a726a92e2da3358854990f768dcf58bb6">hyper_sphere</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;center=<a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;(), const double radius=1.)</td></tr>
<tr class="separator:a726a92e2da3358854990f768dcf58bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712f95340c7002afbd5d6fb755e12a61"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a712f95340c7002afbd5d6fb755e12a61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a712f95340c7002afbd5d6fb755e12a61">quarter_hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const double radius=1.)</td></tr>
<tr class="separator:a712f95340c7002afbd5d6fb755e12a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af218d0939daf0732e3b507a27ea5d8e3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:af218d0939daf0732e3b507a27ea5d8e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">half_hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const double radius=1.)</td></tr>
<tr class="separator:af218d0939daf0732e3b507a27ea5d8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const double radius=1., const double half_length=1.)</td></tr>
<tr class="separator:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63c93351f77276c20de07c91d3c1e48"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ae63c93351f77276c20de07c91d3c1e48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ae63c93351f77276c20de07c91d3c1e48">truncated_cone</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const double radius_0=1.0, const double radius_1=0.5, const double half_length=1.0)</td></tr>
<tr class="separator:ae63c93351f77276c20de07c91d3c1e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a04f98a456ca1942a071d3a20ef5b4dbe">hyper_cross</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned int &gt; &amp;sizes, const bool colorize_cells=false)</td></tr>
<tr class="memdesc:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A center cell with stacks of cell protruding from each surface.  <a href="#a04f98a456ca1942a071d3a20ef5b4dbe">More...</a><br /></td></tr>
<tr class="separator:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2a4ad8296c2b72a11d23b5969e8cc0"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a3b2a4ad8296c2b72a11d23b5969e8cc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a3b2a4ad8296c2b72a11d23b5969e8cc0">hyper_L</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const double left=-1., const double right=1., const bool colorize=false)</td></tr>
<tr class="separator:a3b2a4ad8296c2b72a11d23b5969e8cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114625911496e4f51758fe00562a14a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5114625911496e4f51758fe00562a14a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a5114625911496e4f51758fe00562a14a">hyper_cube_slit</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</td></tr>
<tr class="separator:a5114625911496e4f51758fe00562a14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85de345ccd86a53e63746709c8e1dfc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad85de345ccd86a53e63746709c8e1dfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center, const double inner_radius, const double outer_radius, const unsigned int n_cells=0, bool colorize=false)</td></tr>
<tr class="separator:ad85de345ccd86a53e63746709c8e1dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a6f31aa1d176dd99c2183efdb4b9cb5f5">half_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center, const double inner_radius, const double outer_radius, const unsigned int n_cells=0, const bool colorize=false)</td></tr>
<tr class="separator:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#acd7c51b0e8032db65db9a5ff73ccca50">quarter_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;center, const double inner_radius, const double outer_radius, const unsigned int n_cells=0, const bool colorize=false)</td></tr>
<tr class="separator:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a760789a93b1e0fe7f5c2675c31b6f14f">cylinder_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const double length, const double inner_radius, const double outer_radius, const unsigned int n_radial_cells=0, const unsigned int n_axial_cells=0)</td></tr>
<tr class="separator:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706244fbc35b96c34ef6065cd047dc32"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a706244fbc35b96c34ef6065cd047dc32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a706244fbc35b96c34ef6065cd047dc32">torus</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const double R, const double r)</td></tr>
<tr class="separator:a706244fbc35b96c34ef6065cd047dc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add14cab546d033c1eaacc9234c64ebcd"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:add14cab546d033c1eaacc9234c64ebcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">hyper_cube_with_cylindrical_hole</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, const double inner_radius=.25, const double outer_radius=.5, const double L=.5, const unsigned int repetitions=1, const bool colorize=false)</td></tr>
<tr class="separator:add14cab546d033c1eaacc9234c64ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626225354aa3f249f64dc67319e34bf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a626225354aa3f249f64dc67319e34bf8">moebius</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;tria, const unsigned int n_cells, const unsigned int n_rotations, const double R, const double r)</td></tr>
<tr class="separator:a626225354aa3f249f64dc67319e34bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creating meshes from other meshes</div></td></tr>
<tr class="memitem:a0dace8884c1510160d7b6cbb313523e9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0dace8884c1510160d7b6cbb313523e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">merge_triangulations</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_2, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="separator:a0dace8884c1510160d7b6cbb313523e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843fe2c5c77374c51fcd18f05690b902"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a843fe2c5c77374c51fcd18f05690b902"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a843fe2c5c77374c51fcd18f05690b902">create_union_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_2, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="separator:a843fe2c5c77374c51fcd18f05690b902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada140ece81bf38a23e738e0e57f89e97"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ada140ece81bf38a23e738e0e57f89e97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ada140ece81bf38a23e738e0e57f89e97">create_triangulation_with_removed_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;input_triangulation, const std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;cells_to_remove, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="separator:ada140ece81bf38a23e738e0e57f89e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add67475b53b365d65a3fe3eb6f156fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const unsigned int n_slices, const double height, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;result)</td></tr>
<tr class="separator:add67475b53b365d65a3fe3eb6f156fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe86bf1a4502131ec811a6de41ab41e9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim1, int spacedim2&gt; </td></tr>
<tr class="memitem:afe86bf1a4502131ec811a6de41ab41e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">flatten_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim1 &gt; &amp;in_tria, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim2 &gt; &amp;out_tria)</td></tr>
<tr class="separator:afe86bf1a4502131ec811a6de41ab41e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creating lower-dimensional meshes from parts of higher-dimensional</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>meshes </p>
</div></td></tr>
<tr class="memitem:a436de9caf79ff916ca9bd16dddf30493"><td class="memTemplParams" colspan="2">template&lt;template&lt; int, int &gt; class MeshType, int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a436de9caf79ff916ca9bd16dddf30493"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; typename MeshType&lt; dim-1, spacedim &gt;::cell_iterator, typename MeshType&lt; dim, spacedim &gt;::face_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a436de9caf79ff916ca9bd16dddf30493">extract_boundary_mesh</a> (const MeshType&lt; dim, spacedim &gt; &amp;volume_mesh, MeshType&lt; dim-1, spacedim &gt; &amp;surface_mesh, const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a436de9caf79ff916ca9bd16dddf30493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exceptions</div></td></tr>
<tr class="memitem:ga4cb8ac2354150d4d873e7505363bc97c"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga4cb8ac2354150d4d873e7505363bc97c">ExcInvalidRadii</a> ()</td></tr>
<tr class="separator:ga4cb8ac2354150d4d873e7505363bc97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb029233357359d05af753a57b2f0db1"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gadb029233357359d05af753a57b2f0db1">ExcInvalidRepetitions</a> (int arg1)</td></tr>
<tr class="separator:gadb029233357359d05af753a57b2f0db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a5361affdfca76320d2762ea5daa3b"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga61a5361affdfca76320d2762ea5daa3b">ExcInvalidRepetitionsDimension</a> (int arg1)</td></tr>
<tr class="separator:ga61a5361affdfca76320d2762ea5daa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f2d5f1ca9da3c3f5146aa4e05d1fea1"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3f2d5f1ca9da3c3f5146aa4e05d1fea1">ExcInvalidInputOrientation</a> ()</td></tr>
<tr class="separator:ga3f2d5f1ca9da3c3f5146aa4e05d1fea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides a collection of functions for generating triangulations for some basic geometries.</p>
<p>Some of these functions receive a flag <code>colorize</code>. If this is set, parts of the boundary receive different <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">boundary indicators</a>), allowing them to be distinguished for the purpose of attaching geometry objects and evaluating different boundary conditions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acea0cbcd68e52ce8113d1134b87de403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea0cbcd68e52ce8113d1134b87de403">&#9670;&nbsp;</a></span>hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation with a hypercube (line in 1D, square in 2D, etc) consisting of exactly one cell. The hypercube volume is the tensor product interval <img class="formulaInl" alt="$[left,right]^{\text{dim}}$" src="form_807.png"/> in the present number of dimensions, where the limits are given as arguments. They default to zero and unity, then producing the unit hypercube.</p>
<p>If the argument <code>colorize</code> is false, all boundary indicators are set to zero ("not colorized") for 2d and 3d. If it is true, the boundary is colorized as in <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>. In 1d the indicators are always colorized, see <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<div class="image">
<img src="hyper_cubes.png" alt="hyper_cubes.png"/>
</div>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero. For example, a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> will be a square in the xy plane with z=0.</p>
<p>See also <a class="el" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">subdivided_hyper_cube()</a> for a coarse mesh consisting of several cells. See <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>, if different lengths in different ordinate directions are required.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l00404">404</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="adbe4bebfe752ba2a50542780efd3eb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe4bebfe752ba2a50542780efd3eb6e">&#9670;&nbsp;</a></span>simplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::simplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulation of a d-simplex with (d+1) vertices and mesh cells. </p>
<p>The <code>vertices</code> argument contains a vector with all d+1 vertices of the simplex. They must be given in an order such that the vectors from the first vertex to each of the others form a right-handed system. And I am not happy about the discrimination involved here.</p>
<p>The meshes generated in two and three dimensions are</p>
<div class="image">
<img src="simplex_2d.png" alt="simplex_2d.png"/>
</div>
 <div class="image">
<img src="simplex_3d.png" alt="simplex_3d.png"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> to create. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">vertices</td><td>The dim+1 corners of the simplex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,2&gt;</code>, <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;3,3&gt;</code>.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Guido Kanschat </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2015 </dd></dl>

</div>
</div>
<a id="adc5d7022d456db0356f11427473f4f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5d7022d456db0356f11427473f4f76">&#9670;&nbsp;</a></span>subdivided_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube()</a>, but with the difference that not only one cell is created but each coordinate direction is subdivided into <code>repetitions</code> cells. Thus, the number of cells filling the given volume is <code>repetitions<sup>dim</sup></code>.</p>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero. For example, a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> will be a square in the xy plane with z=0.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l01108">1108</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="a56019d263ae45708302d5d7599f0d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56019d263ae45708302d5d7599f0d458">&#9670;&nbsp;</a></span>hyper_rectangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coordinate-parallel brick from the two diagonally opposite corner points <code>p1</code> and <code>p2</code>.</p>
<p>If the <code>colorize</code> flag is <code>true</code>, the <code>boundary_ids</code> of the boundary faces are assigned, such that the lower one in <code>x-direction</code> is 0, the upper one is 1. The indicators for the surfaces in <code>y-direction</code> are 2 and 3, the ones for <code>z</code> are 4 and 5. This corresponds to the numbers of faces of the unit square of cube as laid out in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class. Importantly, however, in 3d colorization does not set <code>boundary_ids</code> of <em>edges</em>, but only of <em>faces</em>, because each boundary edge is shared between two faces and it is not clear how the boundary id of an edge should be set in that case. This may later on lead to problems if one wants to assign boundary or manifold objects to parts of the boundary with certain boundary indicators since then the boundary object may not apply to the edges bounding the face it is meant to describe.</p>
<p>Additionally, if <code>colorize</code> is <code>true</code>, material ids are assigned to the cells according to the octant their center is in: being in the right half space for any coordinate direction <em>x<sub>i</sub></em> adds 2<sup>i</sup>. For instance, a cell with center point (1,-1,1) yields a material id 5, assuming that the center of the hyper rectangle lies at the origin.</p>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero. For example, a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> will be a rectangle in the xy plane with z=0, defined by the two opposing corners <code>p1</code> and <code>p2</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l00341">341</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="ac76417d7404b75cf53c732f456e6e971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76417d7404b75cf53c732f456e6e971">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coordinate-parallel brick from the two diagonally opposite corner points <code>p1</code> and <code>p2</code>. The number of cells in coordinate direction <code>i</code> is given by the integer <code>repetitions[i]</code>.</p>
<p>To get cells with an aspect ratio different from that of the domain, use different numbers of subdivisions, given by <code>repetitions</code>, in different coordinate directions. The minimum number of subdivisions in each direction is 1.</p>
<p>If the <code>colorize</code> flag is set, the <code>boundary_ids</code> of the surfaces are assigned, such that the lower one in <code>x-direction</code> is 0, the upper one is 1 (the left and the right vertical face). The indicators for the surfaces in <code>y-direction</code> are 2 and 3, the ones for <code>z</code> are 4 and 5. Additionally, material ids are assigned to the cells according to the octant their center is in: being in the right half plane for any coordinate direction <em>x<sub>i</sub></em> adds 2<sup>i</sup>. For instance, the center point (1,-1,1) yields a material id 5 (this means that in 2d only material ids 0,1,2,3 are assigned independent from the number of repetitions).</p>
<p>Note that the <code>colorize</code> flag is ignored in 1d and is assumed to always be true. That means the boundary indicator is 0 on the left and 1 on the right. See <a class="el" href="step_15.html">step-15</a> for details.</p>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero. For example, a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> will be a rectangle in the xy plane with z=0, defined by the two opposing corners <code>p1</code> and <code>p2</code>.</p>
<dl class="section note"><dt>Note</dt><dd>For an example of the use of this function see the <a class="el" href="step_28.html">step-28</a> tutorial program.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> to create. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">repetitions</td><td>A vector of <code>dim</code> positive values denoting the number of cells to generate in that direction.</td></tr>
    <tr><td class="paramname">p1</td><td>First corner point.</td></tr>
    <tr><td class="paramname">p2</td><td>Second corner opposite to <code>p1</code>.</td></tr>
    <tr><td class="paramname">colorize</td><td>Assign different boundary ids if set to true. The same comments apply as for the <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a> function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l01132">1132</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="a0e245f7c5788b6dcfcf93279a67fdbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e245f7c5788b6dcfcf93279a67fdbbb">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>step_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function. However, here the second argument does not denote the number of subdivisions in each coordinate direction, but a sequence of step sizes for each coordinate direction. The domain will therefore be subdivided into <code>step_sizes[i].size()</code> cells in coordinate direction <code>i</code>, with width <code>step_sizes[i][j]</code> for the <code>j</code>th cell.</p>
<p>This function is therefore the right one to generate graded meshes where cells are concentrated in certain areas, rather than a uniformly subdivided mesh as the previous function generates.</p>
<p>The step sizes have to add up to the dimensions of the hyper rectangle specified by the points <code>p1</code> and <code>p2</code>. </p>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l01281">1281</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="ab96bbbe1d7cd1a894dcc038028a9684a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96bbbe1d7cd1a894dcc038028a9684a">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; dim, <a class="el" href="namespacetypes.html#a7ec62ce920d2700c16ec6cf457d0c0aa">types::material_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but with the following twist: the <code>material_id</code> argument is a dim-dimensional array that, for each cell, indicates which material_id should be set. In addition, and this is the major new functionality, if the material_id of a cell is <code>(unsigned char)(-1)</code>, then that cell is deleted from the triangulation, i.e. the domain will have a void there.</p>
<dl class="section note"><dt>Note</dt><dd>If you need a lot of holes, you may consider <a class="el" href="namespaceGridGenerator.html#a76c54698f4666a44ac3982ee62f87ee9" title="Rectangular domain with rectangular pattern of holes. ">cheese()</a>. </dd></dl>

</div>
</div>
<a id="a76c54698f4666a44ac3982ee62f87ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c54698f4666a44ac3982ee62f87ee9">&#9670;&nbsp;</a></span>cheese()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cheese </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>holes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rectangular domain with rectangular pattern of holes. </p>
<p>The domain itself is rectangular, very much as if it had been generated by <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">subdivided_hyper_rectangle()</a>. The argument <code>holes</code> specifies how many square holes the domain should have in each coordinate direction. The total number of mesh cells in that direction is then twice this number plus one.</p>
<p>The number of holes in one direction must be at least one.</p>
<p>An example with two by three holes is</p>
<div class="image">
<img src="cheese_2d.png" alt="cheese_2d.png"/>
</div>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> to create. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">holes</td><td>Positive number of holes in each of the dim directions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Guido Kanschat </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l01769">1769</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="aa5e307e1d25f732db3deffdecce164c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e307e1d25f732db3deffdecce164c9">&#9670;&nbsp;</a></span>general_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::general_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A general quadrilateral in 2d or a general hexahedron in 3d. It is the responsibility of the user to provide the vertices in the right order (see the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class) because the vertices are stored in the same order as they are given. It is also important to make sure that the volume of the cell is positive.</p>
<p>If the argument <code>colorize</code> is false, all boundary indicators are set to zero ("not colorized") for 2d and 3d. If it is true, the boundary is colorized as in <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>. In 1d the indicators are always colorized, see <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Bruno Turcksin </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l00756">756</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="a324b8447f05b148e2f58bdbcf89f5325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324b8447f05b148e2f58bdbcf89f5325">&#9670;&nbsp;</a></span>parallelogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::parallelogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A parallelogram. The first corner point is the origin. The <code>dim</code> adjacent points are the ones given in the second argument and the fourth point will be the sum of these two vectors. Colorizing is done in the same way as in <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in 2d only.</dd>
<dd>
The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="aff29b277d8a71f91993a9b7ca9949547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff29b277d8a71f91993a9b7ca9949547">&#9670;&nbsp;</a></span>parallelepiped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A parallelepiped. The first corner point is the origin. The <code>dim</code> adjacent points are vectors describing the edges of the parallelepiped with respect to the origin. Additional points are sums of these dim vectors. Colorizing is done according to <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function silently reorders the vertices on the cells to lexicographic ordering (see <code>GridReordering::reorder_grid</code>). In other words, if reordering of the vertices does occur, the ordering of vertices in the array of <code>corners</code> will no longer refer to the same triangulation.</dd>
<dd>
The triangulation needs to be void upon calling this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l00816">816</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="afd57165adbc1178577f61bb9bf5fa3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd57165adbc1178577f61bb9bf5fa3e1">&#9670;&nbsp;</a></span>subdivided_parallelepiped() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A subdivided parallelepiped. The first corner point is the origin. The <code>dim</code> adjacent points are vectors describing the edges of the parallelepiped with respect to the origin. Additional points are sums of these dim vectors. The variable <code>n_subdivisions</code> designates the number of subdivisions in each of the <code>dim</code> directions. Colorizing is done according to <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l00832">832</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="ae29b6f85fac7f656a83202521658f76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29b6f85fac7f656a83202521658f76a">&#9670;&nbsp;</a></span>subdivided_parallelepiped() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int(&amp;)&#160;</td>
          <td class="paramname"><em>n_subdivisions</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A subdivided parallelepiped, i.e., the same as above, but where the number of subdivisions in each of the <code>dim</code> directions may vary. Colorizing is done according to <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l00851">851</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="ac6dc883cabdb8fbfeb0ccfeafb0c050d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6dc883cabdb8fbfeb0ccfeafb0c050d">&#9670;&nbsp;</a></span>subdivided_parallelepiped() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdivisions</em> = <code>std::vector&lt;unsigned&#160;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A subdivided parallelepiped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> to create. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">origin</td><td>First corner of the parallelepiped.</td></tr>
    <tr><td class="paramname">edges</td><td>An array of <code>dim</code> tensors describing the length and direction of the edges from <code>origin</code>.</td></tr>
    <tr><td class="paramname">subdivisions</td><td>Number of subdivisions in each of the dim directions. Each entry must be positive. An empty vector is equivalent to one subdivision in each direction.</td></tr>
    <tr><td class="paramname">colorize</td><td>Assign different boundary ids if set to true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for all combinations of <code>dim</code> and <code>spacedim</code>.</dd>
<dd>
You likely need to help the compiler by explicitly specifying the two template parameters when calling this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l00882">882</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="a2c537aebe22842ec22de2c8b5c545896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c537aebe22842ec22de2c8b5c545896">&#9670;&nbsp;</a></span>enclosed_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::enclosed_hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>thickness</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hypercube with a layer of hypercubes around it. The first two parameters give the lower and upper bound of the inner hypercube in all coordinate directions. <code>thickness</code> marks the size of the layer cells.</p>
<p>If the flag <code>colorize</code> is set, the outer cells get material id's according to the following scheme: extending over the inner cube in (+/-) x-direction: 1/2. In y-direction 4/8, in z-direction 16/32. The cells at corners and edges (3d) get these values bitwise or'd.</p>
<p>Presently only available in 2d and 3d.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="a0a81f736ef95164a9d9bf0f844ac682b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a81f736ef95164a9d9bf0f844ac682b">&#9670;&nbsp;</a></span>hyper_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation with a hyperball, i.e. a circle or a ball around <code>center</code> with given <code>radius</code>.</p>
<p>In order to avoid degenerate cells at the boundaries, the circle is triangulated by five cells, the ball by seven cells. The diameter of the center cell is chosen so that the aspect ratio of the boundary cells after one refinement is optimized.</p>
<p>This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</p>
<p>You should attach a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to the cells and faces for correct placement of vertices upon refinement and to be able to use higher order mappings.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="a726a92e2da3358854990f768dcf58bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726a92e2da3358854990f768dcf58bb6">&#9670;&nbsp;</a></span>hyper_sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_sphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a hyper sphere, i.e., a surface of a ball in <code>spacedim</code> dimensions. This function only exists for dim+1=spacedim in 2 and 3 space dimensions.</p>
<p>You should attach a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to the cells and faces for correct placement of vertices upon refinement and to be able to use higher order mappings.</p>
<p>The following pictures are generated with: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2,3&gt;</a>   triangulation;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2,3&gt;</a> surface_description;</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridGenerator.html#a726a92e2da3358854990f768dcf58bb6">GridGenerator::hyper_sphere</a>(triangulation);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, surface_description);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div></div><!-- fragment --><p>See the <a class="el" href="group__manifold.html">documentation module on manifolds</a> for more details.</p>
<div class="image">
<img src="sphere.png" alt="sphere.png"/>
</div>
 <div class="image">
<img src="sphere_section.png" alt="sphere_section.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l03065">3065</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="a712f95340c7002afbd5d6fb755e12a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712f95340c7002afbd5d6fb755e12a61">&#9670;&nbsp;</a></span>quarter_hyper_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::quarter_hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This class produces a hyper-ball intersected with the positive orthant relative to <code>center</code>, which contains three elements in 2d and four in 3d.</p>
<p>The boundary indicators for the final triangulation are 0 for the curved boundary and 1 for the cut plane.</p>
<p>The appropriate boundary class is <a class="el" href="classHyperBallBoundary.html">HyperBallBoundary</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="af218d0939daf0732e3b507a27ea5d8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af218d0939daf0732e3b507a27ea5d8e3">&#9670;&nbsp;</a></span>half_hyper_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::half_hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This class produces a half hyper-ball around <code>center</code>, which contains four elements in 2d and 6 in 3d. The cut plane is perpendicular to the <em>x</em>-axis.</p>
<p>The boundary indicators for the final triangulation are 0 for the curved boundary and 1 for the cut plane.</p>
<p>The appropriate boundary class is <a class="el" href="classHalfHyperBallBoundary.html">HalfHyperBallBoundary</a>, or <a class="el" href="classHyperBallBoundary.html">HyperBallBoundary</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="a5cdda7b4a76d509af7d1a8dc1320ddb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdda7b4a76d509af7d1a8dc1320ddb0">&#9670;&nbsp;</a></span>cylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a cylinder around the <img class="formulaInl" alt="$x$" src="form_9.png"/>-axis. The cylinder extends from <code>x=-half_length</code> to <code>x=+half_length</code> and its projection into the <code>yz-plane</code> is a circle of radius <code>radius</code>.</p>
<p>In two dimensions, the cylinder is a rectangle from <code>x=-half_length</code> to <code>x=+half_length</code> and from <code>y=-radius</code> to <code>y=radius</code>.</p>
<p>The boundaries are colored according to the following scheme: 0 for the hull of the cylinder, 1 for the left hand face and 2 for the right hand face.</p>
<p>If you want the cylinder to revolve around a different axis than the <img class="formulaInl" alt="$x$" src="form_9.png"/>-axis, then simply rotate the mesh generated by this function using the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> function using a rotation operator as argument.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="ae63c93351f77276c20de07c91d3c1e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63c93351f77276c20de07c91d3c1e48">&#9670;&nbsp;</a></span>truncated_cone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::truncated_cone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius_0</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius_1</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a cut cone around the x-axis. The cone extends from <code>x=-half_length</code> to <code>x=half_length</code> and its projection into the <code>yz-plane</code> is a circle of radius <code>radius_0</code> at <code>x=-half_length</code> and a circle of radius <code>radius_1</code> at <code>x=+half_length</code>. In between the radius is linearly decreasing.</p>
<p>In two dimensions, the cone is a trapezoid from <code>x=-half_length</code> to <code>x=+half_length</code> and from <code>y=-radius_0</code> to <code>y=radius_0</code> at <code>x=-half_length</code> and from <code>y=-radius_1</code> to <code>y=radius_1</code> at <code>x=+half_length</code>. In between the range of <code>y</code> is linearly decreasing.</p>
<p>The boundaries are colored according to the following scheme: 0 for the hull of the cone, 1 for the left hand face and 2 for the right hand face.</p>
<p>An example of use can be found in the documentation of the <a class="el" href="classConeBoundary.html">ConeBoundary</a> class, with which you probably want to associate boundary indicator 0 (the hull of the cone).</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Markus B&uuml;rg, 2009 </dd></dl>

</div>
</div>
<a id="a04f98a456ca1942a071d3a20ef5b4dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f98a456ca1942a071d3a20ef5b4dbe">&#9670;&nbsp;</a></span>hyper_cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A center cell with stacks of cell protruding from each surface. </p>
<p>Each of the square mesh cells is Cartesian and has size one in each coordinate direction. The center of cell number zero is the origin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>A <a class="el" href="classTriangulation.html">Triangulation</a> object which has to be empty.</td></tr>
    <tr><td class="paramname">sizes</td><td>A vector of integers of dimension <a class="el" href="structGeometryInfo.html#a16f862f2b86e608697f7a36acffcaec4">GeometryInfo&lt;dim&gt;::faces_per_cell</a> with the following meaning: the legs of the cross are stacked on the faces of the center cell, in the usual order of deal.II cells, namely first <img class="formulaInl" alt="$-x$" src="form_808.png"/>, then <img class="formulaInl" alt="$x$" src="form_9.png"/>, then <img class="formulaInl" alt="$-y$" src="form_809.png"/> and so on. The corresponding entries in <code>sizes</code> name the number of cells stacked on this face. All numbers may be zero, thus L- and T-shaped domains are specializations of this domain.</td></tr>
    <tr><td class="paramname">colorize_cells</td><td>If colorization is chosen, then the material id of a cells corresponds to the leg it is in. The id of the center cell is zero, and then the legs are numbered starting at one.</td></tr>
  </table>
  </dd>
</dl>
<p>Examples in two and three dimensions are</p>
<div class="image">
<img src="hyper_cross_2d.png" alt="hyper_cross_2d.png"/>
</div>
 <div class="image">
<img src="hyper_cross_3d.png" alt="hyper_cross_3d.png"/>
</div>
<dl class="section author"><dt>Author</dt><dd>Guido Kanschat </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l01885">1885</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="a3b2a4ad8296c2b72a11d23b5969e8cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2a4ad8296c2b72a11d23b5969e8cc0">&#9670;&nbsp;</a></span>hyper_L()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_L </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>left</em> = <code>-1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation with a hyper-L (in 2d or 3d) consisting of exactly <code>2^dim-1</code> cells. It produces the hypercube with the interval [<em>left,right</em>] without the hypercube made out of the interval [<em>(left+right)/2,right</em>] for each coordinate. Because the domain is about the simplest one with a reentrant (i.e., non-convex) corner, solutions of many partial differential equation have singularities at this corner. That is, at the corner, the gradient or a higher derivative (depending on the boundary conditions chosen) does not remain bounded. As a consequence, this domain is often used to test convergence of schemes when the solution lacks regularity.</p>
<p>If the <code>colorize</code> flag is set, the <code>boundary_ids</code> of the surfaces are assigned, such that the left boundary is 0, and the others are set with growing number accordingly to the counterclockwise. Colorize option works only with 2-dimensional problem. This function will create the classical L-shape in 2d and it will look like the following in 3d:</p>
<div class="image">
<img src="hyper_l.png" alt="hyper_l.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>The 3d domain is also often referred to as the "Fichera corner", named after Gaetano Fichera (1922-1996) who first computed an approximation of the corner singularity exponent of the lowest eigenfunction of the domain.</dd></dl>
<p>This function exists for triangulations of all space dimensions, but throws an error if called in 1d.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="a5114625911496e4f51758fe00562a14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5114625911496e4f51758fe00562a14a">&#9670;&nbsp;</a></span>hyper_cube_slit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube_slit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given <a class="el" href="classTriangulation.html">Triangulation</a> with a hypercube with a slit. In each coordinate direction, the hypercube extends from <code>left</code> to <code>right</code>.</p>
<p>In 2d, the split goes in vertical direction from <code>x=(left+right)/2, y=left</code> to the center of the square at <code>x=y=(left+right)/2</code>.</p>
<p>In 3d, the 2d domain is just extended in the <em>z</em>-direction, such that a plane cuts the lower half of a rectangle in two. This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</p>
<p>If <code>colorize</code> is set to <code>true</code>, the faces forming the slit are marked with boundary id 1 and 2, respectively.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="ad85de345ccd86a53e63746709c8e1dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85de345ccd86a53e63746709c8e1dfc">&#9670;&nbsp;</a></span>hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a hyper-shell, the region between two spheres around <code>center</code>, with given <code>inner_radius</code> and <code>outer_radius</code>. The number <code>n_cells</code> indicates the number of cells of the resulting triangulation, i.e., how many cells form the ring (in 2d) or the shell (in 3d).</p>
<p>If the flag <code>colorize</code> is <code>true</code>, then the outer boundary will have the indicator 1, while the inner boundary has id zero. In 3d, this applies to both the faces and the edges of these boundaries. If the flag is <code>false</code>, both have indicator zero.</p>
<p>You should attach a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to the cells and faces for correct placement of vertices upon refinement and to be able to use higher order mappings. Alternatively, it is also possible to attach a <a class="el" href="classHyperShellBoundary.html">HyperShellBoundary</a> to the inner and outer boundary. This will create inferior meshes as described below.</p>
<p>In 2d, the number <code>n_cells</code> of elements for this initial triangulation can be chosen arbitrarily. If the number of initial cells is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio.</p>
<p>In 3d, only certain numbers are allowed, 6 (or the default 0) for a surface based on a hexahedron (i.e. 6 panels on the inner sphere extruded in radial direction to form 6 cells), 12 for the rhombic dodecahedron, and 96 (see below).</p>
<p>While the <a class="el" href="classSphericalManifold.html">SphericalManifold</a>, that is demonstrated in the documentation of the <a class="el" href="group__manifold.html">documentation module on manifolds</a>, creates reasonable meshes for any number of <code>n_cells</code> if attached to all cells and boundaries, the situation is less than ideal when only attaching a <a class="el" href="classHyperShellBoundary.html">HyperShellBoundary</a>. Then, only vertices on the boundaries are placed at the correct distance from the center. As an example, the 3d meshes give rise to the following meshes upon one refinement:</p>
<div class="image">
<img src="hypershell3d-6.png" alt="hypershell3d-6.png"/>
</div>
 <div class="image">
<img src="hypershell3d-12.png" alt="hypershell3d-12.png"/>
</div>
<p>Neither of these meshes is particularly good since one ends up with poorly shaped cells at the inner edge upon refinement. For example, this is the middle plane of the mesh for the <code>n_cells=6</code>:</p>
<div class="image">
<img src="hyper_shell_6_cross_plane.png" alt="hyper_shell_6_cross_plane.png"/>
</div>
<p>The mesh generated with <code>n_cells=12</code> is better but still not good. As a consequence, you may also specify <code>n_cells=96</code> as a third option. The mesh generated in this way is based on a once refined version of the one with <code>n_cells=12</code>, where all internal nodes are re-placed along a shell somewhere between the inner and outer boundary of the domain. The following two images compare half of the hyper shell for <code>n_cells=12</code> and <code>n_cells=96</code> (note that the doubled radial lines on the cross section are artifacts of the visualization):</p>
<div class="image">
<img src="hyper_shell_12_cut.png" alt="hyper_shell_12_cut.png"/>
</div>
 <div class="image">
<img src="hyper_shell_96_cut.png" alt="hyper_shell_96_cut.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</dd>
<dd>
The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="a6f31aa1d176dd99c2183efdb4b9cb5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f31aa1d176dd99c2183efdb4b9cb5f5">&#9670;&nbsp;</a></span>half_hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::half_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a half hyper-shell, i.e. the space between two circles in two space dimensions and the region between two spheres in 3d, with given inner and outer radius and a given number of elements for this initial triangulation. However, opposed to the previous function, it does not produce a whole shell, but only one half of it, namely that part for which the first component is restricted to non-negative values. The purpose of this class is to enable computations for solutions which have rotational symmetry, in which case the half shell in 2d represents a shell in 3d.</p>
<p>If the number of initial cells is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio.</p>
<p>If colorize is set to true, the inner, outer, and the part of the boundary where <img class="formulaInl" alt="$x=0$" src="form_810.png"/>, get indicator 0, 1, and 2, respectively. Otherwise all indicators are set to 0.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="acd7c51b0e8032db65db9a5ff73ccca50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7c51b0e8032db65db9a5ff73ccca50">&#9670;&nbsp;</a></span>quarter_hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::quarter_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a domain that is the intersection between a hyper-shell with given inner and outer radius, i.e. the space between two circles in two space dimensions and the region between two spheres in 3d, and the positive quadrant (in 2d) or octant (in 3d). In 2d, this is indeed a quarter of the full annulus, while the function is a misnomer in 3d because there the domain is not a quarter but one eighth of the full shell.</p>
<p>If the number of initial cells is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio in 2d.</p>
<p>If <code>colorize</code> is set to true, the inner, outer, left, and right boundary get indicator 0, 1, 2, and 3 in 2d, respectively. Otherwise all indicators are set to 0. In 3d indicator 2 is at the face x=0, 3 at y=0, 4 at z=0.</p>
<dl class="section note"><dt>Note</dt><dd>The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="a760789a93b1e0fe7f5c2675c31b6f14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760789a93b1e0fe7f5c2675c31b6f14f">&#9670;&nbsp;</a></span>cylinder_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cylinder_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_radial_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_axial_cells</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a domain that is the space between two cylinders in 3d, with given length, inner and outer radius and a given number of elements. The cylinder shell is built around the <img class="formulaInl" alt="$z$" src="form_11.png"/>-axis with the two faces located at <img class="formulaInl" alt="$z = 0$" src="form_811.png"/> and <img class="formulaInl" alt="$z = $" src="form_812.png"/> <code>length</code>.</p>
<p>If <code>n_radial_cells</code> is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio. The same holds for <code>n_axial_cells</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Although this function is declared as a template, it does not make sense in 1D and 2D. Also keep in mind that this object is rotated and positioned differently than the one created by <a class="el" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder()</a>.</dd>
<dd>
The triangulation needs to be void upon calling this function. </dd></dl>

</div>
</div>
<a id="a706244fbc35b96c34ef6065cd047dc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706244fbc35b96c34ef6065cd047dc32">&#9670;&nbsp;</a></span>torus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::torus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce the volume or surface mesh of a torus. The axis of the torus is the <img class="formulaInl" alt="$y$" src="form_10.png"/>-axis while the plane of the torus is the <img class="formulaInl" alt="$x$" src="form_9.png"/>- <img class="formulaInl" alt="$z$" src="form_11.png"/> plane.</p>
<p>If <code>dim</code> is 3, the mesh will be the volume of the torus. By default, the boundary faces will have manifold id 0 and you should attach a <a class="el" href="classTorusManifold.html">TorusManifold</a> to it. The cells will have manifold id 1 and you should attach a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to it.</p>
<p>If <code>dim</code> is 2, the mesh will describe the surface of the torus. All cells and faces will have manifold id 0 and you should attach a <a class="el" href="classTorusManifold.html">TorusManifold</a> to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be filled.</td></tr>
    <tr><td class="paramname">R</td><td>The radius of the circle, which forms the middle line of the torus containing the loop of cells. Must be greater than <code>r</code>.</td></tr>
    <tr><td class="paramname">r</td><td>The inner radius of the torus.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for Triangulation&lt;2,3&gt; and Triangulation&lt;3,3&gt;. </dd></dl>

</div>
</div>
<a id="add14cab546d033c1eaacc9234c64ebcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add14cab546d033c1eaacc9234c64ebcd">&#9670;&nbsp;</a></span>hyper_cube_with_cylindrical_hole()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube_with_cylindrical_hole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>inner_radius</em> = <code>.25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>outer_radius</em> = <code>.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>L</em> = <code>.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>repetitions</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This class produces a square in the <em>xy</em>-plane with a circular hole in the middle. Square and circle are centered at the origin. In 3d, this geometry is extruded in <img class="formulaInl" alt="$z$" src="form_11.png"/> direction to the interval <img class="formulaInl" alt="$[0,L]$" src="form_813.png"/>.</p>
<div class="image">
<img src="cubes_hole.png" alt="cubes_hole.png"/>
</div>
<p>It is implemented in 2d and 3d, and takes the following arguments:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>The triangulation to be filled. </td></tr>
    <tr><td class="paramname">inner_radius</td><td>Radius of the internal hole. </td></tr>
    <tr><td class="paramname">outer_radius</td><td>Half of the edge length of the square. </td></tr>
    <tr><td class="paramname">L</td><td>Extension in <code>z-direction</code> (only used in 3d). </td></tr>
    <tr><td class="paramname">repetitions</td><td>Number of subdivisions along the <code>z-direction</code>. </td></tr>
    <tr><td class="paramname">colorize</td><td>Whether to assign different boundary indicators to different faces. The colors are given in lexicographic ordering for the flat faces (0 to 3 in 2d, 0 to 5 in 3d) plus the curved hole (4 in 2d, and 6 in 3d). If <code>colorize</code> is set to false, then flat faces get the number 0 and the hole gets number 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a626225354aa3f249f64dc67319e34bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626225354aa3f249f64dc67319e34bf8">&#9670;&nbsp;</a></span>moebius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::moebius </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_rotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a ring of cells in 3d that is cut open, twisted and glued together again. This results in a kind of moebius-loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be worked on. </td></tr>
    <tr><td class="paramname">n_cells</td><td>The number of cells in the loop. Must be greater than 4. </td></tr>
    <tr><td class="paramname">n_rotations</td><td>The number of rotations (Pi/2 each) to be performed before gluing the loop together. </td></tr>
    <tr><td class="paramname">R</td><td>The radius of the circle, which forms the middle line of the torus containing the loop of cells. Must be greater than <code>r</code>. </td></tr>
    <tr><td class="paramname">r</td><td>The radius of the cylinder bent together as a loop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dace8884c1510160d7b6cbb313523e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dace8884c1510160d7b6cbb313523e9">&#9670;&nbsp;</a></span>merge_triangulations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::merge_triangulations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the two triangulations specified as the first two arguments, create the triangulation that contains the cells of both triangulation and store it in the third parameter. Previous content of <code>result</code> will be deleted.</p>
<p>This function is most often used to compose meshes for more complicated geometries if the geometry can be composed of simpler parts for which functions exist to generate coarse meshes. For example, the channel mesh used in <a class="el" href="step_35.html">step-35</a> could in principle be created using a mesh created by the <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> function and several rectangles, and merging them using the current function. The rectangles will have to be translated to the right for this, a task that can be done using the <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> function (other tools to transform individual mesh building blocks are <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, <a class="el" href="namespaceGridTools.html#aa7ea00f2009014a52520c05beadc78b6">GridTools::rotate</a>, and <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>).</p>
<dl class="section note"><dt>Note</dt><dd>The two input triangulations must be coarse meshes that have no refined cells.</dd>
<dd>
The function copies the material ids of the cells of the two input triangulations into the output triangulation but it currently makes no attempt to do the same for boundary ids. In other words, if the two coarse meshes have anything but the default boundary indicators, then you will currently have to set boundary indicators again by hand in the output triangulation.</dd>
<dd>
For a related operation on refined meshes when both meshes are derived from the same coarse mesh, see <a class="el" href="namespaceGridGenerator.html#a843fe2c5c77374c51fcd18f05690b902">GridGenerator::create_union_triangulation()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l03872">3872</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="a843fe2c5c77374c51fcd18f05690b902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843fe2c5c77374c51fcd18f05690b902">&#9670;&nbsp;</a></span>create_union_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::create_union_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the two triangulations specified as the first two arguments, create the triangulation that contains the finest cells of both triangulation and store it in the third parameter. Previous content of <code>result</code> will be deleted.</p>
<dl class="section note"><dt>Note</dt><dd>This function is intended to create an adaptively refined triangulation that contains the <em>most refined cells</em> from two input triangulations that were derived from the <em>same</em> coarse grid by adaptive refinement. This is an operation sometimes needed when one solves for two variables of a coupled problem on separately refined meshes on the same domain (for example because these variables have boundary layers in different places) but then needs to compute something that involves both variables or wants to output the result into a single file. In both cases, in order not to lose information, the two solutions can not be interpolated onto the respectively other mesh because that may be coarser than the ones on which the variable was computed. Rather, one needs to have a mesh for the domain that is at least as fine as each of the two initial meshes. This function computes such a mesh.</dd>
<dd>
If you want to create a mesh that is the merger of two other coarse meshes, for example in order to compose a mesh for a complicated geometry from meshes for simpler geometries, then this is not the function for you. Instead, consider <a class="el" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations()</a>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Both of the source conditions need to be available entirely locally. In other words, they can not be objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l03930">3930</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="ada140ece81bf38a23e738e0e57f89e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada140ece81bf38a23e738e0e57f89e97">&#9670;&nbsp;</a></span>create_triangulation_with_removed_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::create_triangulation_with_removed_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells_to_remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates a triangulation that consists of the same cells as are present in the first argument, except those cells that are listed in the second argument. The purpose of the function is to generate geometries <em>subtractively</em> from the geometry described by an existing triangulation. A prototypical case is a 2d domain with rectangular holes. This can be achieved by first meshing the entire domain and then using this function to get rid of the cells that are located at the holes. Likewise, you could create the mesh that <a class="el" href="namespaceGridGenerator.html#a3b2a4ad8296c2b72a11d23b5969e8cc0">GridGenerator::hyper_L()</a> produces by starting with a <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, refining it once, and then calling the current function with a single cell in the second argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_triangulation</td><td>The original triangulation that serves as the template from which the new one is to be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells_to_remove</td><td>A list of cells of the triangulation provided as first argument that should be removed (i.e., that should not show up in the result. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The resulting triangulation that consists of the same cells as are in <code>input_triangulation</code>, with the exception of the cells listed in <code>cells_to_remove</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Because we cannot create triangulations de novo that contain adaptively refined cells, the input triangulation needs to have all of its cells on the same level. Oftentimes, this will in fact be the coarsest level, but it is allowed to pass in a triangulation that has been refined <em>globally</em> a number of times. The output triangulation will in that case simply be a mesh with only one level that consists of the active cells of the input minus the ones listed in the second argument. However, the input triangulation must not have been <em>adaptively</em> refined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l03986">3986</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="add67475b53b365d65a3fe3eb6f156fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add67475b53b365d65a3fe3eb6f156fa9">&#9670;&nbsp;</a></span>extrude_triangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a 2d <a class="el" href="classTriangulation.html">Triangulation</a> that is being extruded in z direction by the total height of <code>height</code> using <code>n_slices</code> slices (minimum is 2). The boundary indicators of the faces of <code>input</code> are going to be assigned to the corresponding side walls in z direction. The bottom and top get the next two free boundary indicators.</p>
<dl class="section note"><dt>Note</dt><dd>The 2d input triangulation <code>input</code> must be a coarse mesh that has no refined cells. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l04030">4030</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="afe86bf1a4502131ec811a6de41ab41e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe86bf1a4502131ec811a6de41ab41e9">&#9670;&nbsp;</a></span>flatten_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim1, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::flatten_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an input triangulation <code>in_tria</code>, this function makes a new flat triangulation <code>out_tria</code> which contains a single level with all active cells of the input triangulation. If <code>spacedim1</code> and <code>spacedim2</code> are different, only the smallest spacedim components of the vertices are copied over. This is useful to create a Triangulation&lt;2,3&gt; out of a Triangulation&lt;2,2&gt;, or to project a Triangulation&lt;2,3&gt; into a Triangulation&lt;2,2&gt;, by neglecting the z components of the vertices.</p>
<p>No internal checks are performed on the vertices, which are assumed to make sense topologically in the target <code>spacedim2</code> dimensional space. If this is not the case, you will encounter problems when using the triangulation later on.</p>
<p>All information about cell manifold_ids and material ids are copied from one triangulation to the other, and only the boundary manifold_ids and boundary_ids are copied over from the faces of <code>in_tria</code> to the faces of <code>out_tria</code>. If you need to specify manifold ids on interior faces, they have to be specified manually after the triangulation is created.</p>
<p>This function will fail if the input <a class="el" href="classTriangulation.html">Triangulation</a> is of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, as well as when the input <a class="el" href="classTriangulation.html">Triangulation</a> contains hanging nodes.</p>
<dl class="section author"><dt>Author</dt><dd>Luca Heltai, 2014 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l04377">4377</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
<a id="a436de9caf79ff916ca9bd16dddf30493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436de9caf79ff916ca9bd16dddf30493">&#9670;&nbsp;</a></span>extract_boundary_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; int, int &gt; class MeshType, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; typename MeshType&lt; dim-1, spacedim &gt;::cell_iterator, typename MeshType&lt; dim, spacedim &gt;::face_iterator &gt; GridGenerator::extract_boundary_mesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshType&lt; dim-1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements a boundary subgrid extraction. Given a &lt;dim,spacedim&gt;-Triangulation (the "volume mesh") the function extracts a subset of its boundary (the "surface mesh"). The boundary to be extracted is specified by a list of boundary_ids. If none is specified the whole boundary will be extracted. The function is used in <a class="el" href="step_38.html">step-38</a>.</p>
<p>The function also builds a mapping linking the cells on the surface mesh to the corresponding faces on the volume one. This mapping is the return value of the function.</p>
<dl class="section note"><dt>Note</dt><dd>The function builds the surface mesh by creating a coarse mesh from the selected faces of the coarse cells of the volume mesh. It copies the boundary indicators of these faces to the cells of the coarse surface mesh. The surface mesh is then refined in the same way as the faces of the volume mesh are. In order to ensure that the surface mesh has the same vertices as the volume mesh, it is therefore important that you assign appropriate boundary objects through <a class="el" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">Triangulation::set_boundary()</a> to the surface mesh object before calling this function. If you don't, the refinement will happen under the assumption that all faces are straight (i.e using the <a class="el" href="classStraightBoundary.html">StraightBoundary</a> class) rather than any curved boundary object you may want to use to determine the location of new vertices.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. The map that is returned will be between cell iterators pointing into the container describing the surface mesh and face iterators of the volume mesh container. If MeshType is <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, then the function will re-build the triangulation underlying the second argument and return a map between appropriate iterators into the MeshType arguments. However, the function will not actually distribute degrees of freedom on this newly created surface mesh.</td></tr>
    <tr><td class="paramname">dim</td><td>The dimension of the cells of the volume mesh. For example, if dim==2, then the cells are quadrilaterals that either live in the plane, or form a surface in a higher-dimensional space. The dimension of the cells of the surface mesh is consequently dim-1. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The dimension of the space in which both the volume and the surface mesh live.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">volume_mesh</td><td>A container of cells that define the volume mesh. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">surface_mesh</td><td>A container whose associated triangulation will be built to consist of the cells that correspond to the (selected portion of) the boundary of the volume mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_ids</td><td>A list of boundary indicators denoting that subset of faces of volume cells for which this function should extract the surface mesh. If left at its default, i.e., if the set is empty, then the function operates on <em>all</em> boundary faces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map that for each cell of the surface mesh (key) returns an iterator to the corresponding face of a cell of the volume mesh (value). The keys include both active and non-active cells of the surface mesh. For dim=2 (i.e., where volume cells are quadrilaterals and surface cells are lines), the order of vertices of surface cells and the corresponding volume faces match. For dim=3 (i.e., where volume cells are hexahedra and surface cells are quadrilaterals), the order of vertices may not match in order to ensure that each surface cell has a right-handed coordinate system when viewed from one of the two sides of the surface connecting the cells of the surface mesh.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm outlined above assumes that all faces on higher refinement levels always have exactly the same boundary indicator as their parent face. Consequently, we can start with coarse level faces and build the surface mesh based on that. It would not be very difficult to extend the function to also copy boundary indicators from finer level faces to their corresponding surface mesh cells, for example to accommodate different geometry descriptions in the case of curved boundaries (but this is not currently implemented). </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__generator_8cc_source.html#l04468">4468</a> of file <a class="el" href="grid__generator_8cc_source.html">grid_generator.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
