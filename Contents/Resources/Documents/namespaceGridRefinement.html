<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GridRefinement Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GridRefinement Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac44f3847eab02da8322cb16fc69e9e57"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ac44f3847eab02da8322cb16fc69e9e57"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#ac44f3847eab02da8322cb16fc69e9e57">adjust_refine_and_coarsen_number_fraction</a> (const unsigned int current_n_cells, const unsigned int max_n_cells, const double top_fraction_of_cells, const double bottom_fraction_of_cells)</td></tr>
<tr class="separator:ac44f3847eab02da8322cb16fc69e9e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2500638aae40fe3bfbf094754645dc57"><td class="memTemplParams" colspan="2">template&lt;int dim, class VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a2500638aae40fe3bfbf094754645dc57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">refine_and_coarsen_fixed_number</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const VectorType &amp;criteria, const double top_fraction_of_cells, const double bottom_fraction_of_cells, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max())</td></tr>
<tr class="separator:a2500638aae40fe3bfbf094754645dc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f710b99d29b38baa84400c945baa3c"><td class="memTemplParams" colspan="2">template&lt;int dim, class VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a40f710b99d29b38baa84400c945baa3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a40f710b99d29b38baa84400c945baa3c">refine_and_coarsen_fixed_fraction</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const VectorType &amp;criteria, const double top_fraction, const double bottom_fraction, const unsigned int max_n_cells=std::numeric_limits&lt; unsigned int &gt;::max())</td></tr>
<tr class="separator:a40f710b99d29b38baa84400c945baa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d78628e900af6dc05114f756aa3114"><td class="memTemplParams" colspan="2">template&lt;int dim, class VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ab5d78628e900af6dc05114f756aa3114"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#ab5d78628e900af6dc05114f756aa3114">refine_and_coarsen_optimize</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const VectorType &amp;criteria, const unsigned int order=2)</td></tr>
<tr class="separator:ab5d78628e900af6dc05114f756aa3114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609b76e87a312bdf27893d1362a27886"><td class="memTemplParams" colspan="2">template&lt;int dim, class VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a609b76e87a312bdf27893d1362a27886"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a609b76e87a312bdf27893d1362a27886">refine</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const VectorType &amp;criteria, const double threshold, const unsigned int max_to_mark=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a609b76e87a312bdf27893d1362a27886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421d11af54a649588e4beccf23d62c5d"><td class="memTemplParams" colspan="2">template&lt;int dim, class VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a421d11af54a649588e4beccf23d62c5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a421d11af54a649588e4beccf23d62c5d">coarsen</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const VectorType &amp;criteria, const double threshold)</td></tr>
<tr class="separator:a421d11af54a649588e4beccf23d62c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3827d1d2e4968c329220b083a431b7d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab3827d1d2e4968c329220b083a431b7d">ExcNegativeCriteria</a> ()</td></tr>
<tr class="separator:gab3827d1d2e4968c329220b083a431b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8ab217f39dcf26b6fbf499913e9b6d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafd8ab217f39dcf26b6fbf499913e9b6d">ExcInvalidParameterValue</a> ()</td></tr>
<tr class="separator:gafd8ab217f39dcf26b6fbf499913e9b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of functions controlling refinement and coarsening of <a class="el" href="classTriangulation.html">Triangulation</a> objects.</p>
<p>The functions in this namespace form two categories. There are the auxiliary functions <a class="el" href="namespaceGridRefinement.html#a609b76e87a312bdf27893d1362a27886">refine()</a> and <a class="el" href="namespaceGridRefinement.html#a421d11af54a649588e4beccf23d62c5d">coarsen()</a>. More important for users are the other functions, which implement refinement strategies, as being found in the literature on adaptive finite element methods. For mathematical discussion of these methods, consider works by D&ouml;rfler, Morin, Nochetto, Rannacher, Stevenson and many more.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Thomas Richter, Guido Kanschat 1998, 2000, 2009 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac44f3847eab02da8322cb16fc69e9e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44f3847eab02da8322cb16fc69e9e57">&#9670;&nbsp;</a></span>adjust_refine_and_coarsen_number_fraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; GridRefinement::adjust_refine_and_coarsen_number_fraction </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>current_n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>max_n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>top_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>bottom_fraction_of_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of double values of which the first is adjusted refinement fraction of cells and the second is adjusted coarsening fraction of cells.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">current_n_cells</td><td>The current cell number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_n_cells</td><td>The maximal number of cells. If current cell number <code>current_n_cells</code> is already exceeded maximal cell number <code>max_n_cells</code>, refinement fraction of cells will be set to zero and coarsening fraction of cells will be adjusted to reduce cell number to @ max_n_cells. If cell number is going to be exceeded only upon refinement, then refinement and coarsening fractions are going to be adjusted with a same ratio in an attempt to reach the maximum number of cells. Be aware though that through proliferation of refinement due to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a>, this number is only an indicator. The default value of this argument is to impose no limit on the number of cells.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_fraction_of_cells</td><td>The requested fraction of active cells to be refined.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom_fraction_of_cells</td><td>The requested fraction of active cells to be coarsened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Usually you do not need to call this function explicitly. Pass <code>max_n_cells</code> to function <a class="el" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">refine_and_coarsen_fixed_number()</a> or function <a class="el" href="namespaceGridRefinement.html#a40f710b99d29b38baa84400c945baa3c">refine_and_coarsen_fixed_fraction()</a> and they will call this function if necessary. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2grid__refinement_8cc_source.html#l00292">292</a> of file <a class="el" href="grid_2grid__refinement_8cc_source.html">grid_refinement.cc</a>.</p>

</div>
</div>
<a id="a2500638aae40fe3bfbf094754645dc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2500638aae40fe3bfbf094754645dc57">&#9670;&nbsp;</a></span>refine_and_coarsen_fixed_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine_and_coarsen_fixed_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>top_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>bottom_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>max_n_cells</em> = <code>std::numeric_limits&lt;unsigned&#160;int&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides a refinement strategy with predictable growth in the size of the mesh by refining a given fraction of all cells.</p>
<p>The function takes a vector of refinement <code>criteria</code> and two values between zero and one denoting the fractions of cells to be refined and coarsened. It flags cells for further processing by <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a> according to the following greedy algorithm:</p>
<ol>
<li>
<p class="startli">Sort the cells according to descending values of <code>criteria</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Mark the <code>top_fraction_of_cells</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> active cells with the largest refinement criteria for refinement.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Mark the <code>bottom_fraction_of_cells</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> active cells with the smallest refinement criteria for coarsening.</p>
<p class="endli"></p>
</li>
</ol>
<p>As an example, with no coarsening, setting <code>top_fraction_of_cells</code> to 1/3 will result in approximately doubling the number of cells in two dimensions. That is because each of these 1/3 of cells will be replaced by its four children, resulting in <img class="formulaInl" alt="$4\times \frac 13 N$" src="form_814.png"/> cells, whereas the remaining 2/3 of cells remains untouched &ndash; thus yielding a total of <img class="formulaInl" alt="$4\times \frac 13 N + \frac 23 N = 2N$" src="form_815.png"/> cells. The same effect in three dimensions is achieved by refining 1/7th of the cells. These values are therefore frequently used because they ensure that the cost of computations on subsequent meshes become expensive sufficiently quickly that the fraction of time spent on the coarse meshes is not too large. On the other hand, the fractions are small enough that mesh adaptation does not refine too many cells in each step.</p>
<dl class="section note"><dt>Note</dt><dd>This function only sets the coarsening and refinement flags. The mesh is not changed until you call <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">triangulation</td><td>The triangulation whose cells this function is supposed to mark for coarsening and refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">criteria</td><td>The refinement criterion for each mesh cell. Entries may not be negative.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_fraction_of_cells</td><td>The fraction of cells to be refined. If this number is zero, no cells will be refined. If it equals one, the result will be flagging for global refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom_fraction_of_cells</td><td>The fraction of cells to be coarsened. If this number is zero, no cells will be coarsened.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_n_cells</td><td>This argument can be used to specify a maximal number of cells. If this number is going to be exceeded upon refinement, then refinement and coarsening fractions are going to be adjusted in an attempt to reach the maximum number of cells. Be aware though that through proliferation of refinement due to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a>, this number is only an indicator. The default value of this argument is to impose no limit on the number of cells. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid_2grid__refinement_8cc_source.html#l00374">374</a> of file <a class="el" href="grid_2grid__refinement_8cc_source.html">grid_refinement.cc</a>.</p>

</div>
</div>
<a id="a40f710b99d29b38baa84400c945baa3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f710b99d29b38baa84400c945baa3c">&#9670;&nbsp;</a></span>refine_and_coarsen_fixed_fraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine_and_coarsen_fixed_fraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>top_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>bottom_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>max_n_cells</em> = <code>std::numeric_limits&lt;unsigned&#160;int&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides a refinement strategy controlling the reduction of the error estimate.</p>
<p>Also known as the <b>bulk criterion</b> or D&ouml;rfler marking, this function computes the thresholds for refinement and coarsening such that the <code>criteria</code> of cells getting flagged for refinement make up for a certain fraction of the total error. We explain its operation for refinement, coarsening works analogously.</p>
<p>Let <em>c<sub>K</sub></em> be the criterion of cell <em>K</em>. Then the total error estimate is computed by the formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E = \sum_{K\in \cal T} c_K. \]" src="form_816.png"/>
</p>
<p>If <em> 0 &lt; a &lt; 1</em> is <code>top_fraction</code>, then we refine the smallest subset <img class="formulaInl" alt="$\cal M$" src="form_817.png"/> of the <a class="el" href="classTriangulation.html">Triangulation</a> <img class="formulaInl" alt="$\cal T$" src="form_818.png"/> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ a E \le \sum_{K\in \cal M} c_K \]" src="form_819.png"/>
</p>
<p>The algorithm is performed by the greedy algorithm described in <a class="el" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">refine_and_coarsen_fixed_number()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The often used formula with squares on the left and right is recovered by actually storing the square of <em>c<sub>K</sub></em> in the vector <code>criteria</code>.</dd></dl>
<p>From the point of view of implementation, this time we really need to sort the array of criteria. Just like the other strategy described above, this function only computes the threshold values and then passes over to <a class="el" href="namespaceGridRefinement.html#a609b76e87a312bdf27893d1362a27886">refine()</a> and <a class="el" href="namespaceGridRefinement.html#a421d11af54a649588e4beccf23d62c5d">coarsen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>The triangulation whose cells this function is supposed to mark for coarsening and refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">criteria</td><td>The refinement criterion computed on each mesh cell. Entries may not be negative.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_fraction</td><td>The fraction of the total estimate which should be refined. If this number is zero, no cells will be refined. If it equals one, the result will be flagging for global refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom_fraction</td><td>The fraction of the estimate coarsened. If this number is zero, no cells will be coarsened.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_n_cells</td><td>This argument can be used to specify a maximal number of cells. If this number is going to be exceeded upon refinement, then refinement and coarsening fractions are going to be adjusted in an attempt to reach the maximum number of cells. Be aware though that through proliferation of refinement due to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a>, this number is only an indicator. The default value of this argument is to impose no limit on the number of cells. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid_2grid__refinement_8cc_source.html#l00422">422</a> of file <a class="el" href="grid_2grid__refinement_8cc_source.html">grid_refinement.cc</a>.</p>

</div>
</div>
<a id="ab5d78628e900af6dc05114f756aa3114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d78628e900af6dc05114f756aa3114">&#9670;&nbsp;</a></span>refine_and_coarsen_optimize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine_and_coarsen_optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>order</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine the triangulation by flagging certain cells to reach a grid that is optimal with respect to an objective function that tries to balance reducing the error and increasing the numerical cost when the mesh is refined. Specifically, this function makes the assumption that if you refine a cell <img class="formulaInl" alt="$K$" src="form_57.png"/> with error indicator <img class="formulaInl" alt="$\eta_K$" src="form_820.png"/> provided by the second argument to this function, then the error on the children (for all children together) will only be <img class="formulaInl" alt="$2^{-\text{order}}\eta_K$" src="form_821.png"/> where <code>order</code> is the third argument of this function. This makes the assumption that the error is only a local property on a mesh and can be reduced by local refinement &ndash; an assumption that is true for the interpolation operator, but not for the usual Galerkin projection, although it is approximately true for elliptic problems where the Greens function decays quickly and the error here is not too much affected by a too coarse mesh somewhere else.</p>
<p>With this, we can define the objective function this function tries to optimize. Let us assume that the mesh currently has <img class="formulaInl" alt="$N_0$" src="form_822.png"/> cells. Then, if we refine the <img class="formulaInl" alt="$m$" src="form_253.png"/> cells with the largest errors, we expect to get (in <img class="formulaInl" alt="$d$" src="form_301.png"/> space dimensions) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ N(m) = (N_0-m) + 2^d m = N_0 + (2^d-1)m \]" src="form_823.png"/>
</p>
<p> cells ( <img class="formulaInl" alt="$N_0-m$" src="form_824.png"/> are not refined, and each of the <img class="formulaInl" alt="$m$" src="form_253.png"/> cells we refine yield <img class="formulaInl" alt="$2^d$" src="form_825.png"/> child cells. On the other hand, with refining <img class="formulaInl" alt="$m$" src="form_253.png"/> cells, and using the assumptions above, we expect that the error will be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \eta^\text{exp}(m) = \sum_{K, K\; \text{will not be refined}} \eta_K + \sum_{K, K\; \text{will be refined}} 2^{-\text{order}}\eta_K \]" src="form_826.png"/>
</p>
<p> where the first sum extends over <img class="formulaInl" alt="$N_0-m$" src="form_824.png"/> cells and the second over the <img class="formulaInl" alt="$m$" src="form_253.png"/> cells that will be refined. Note that <img class="formulaInl" alt="$N(m)$" src="form_827.png"/> is an increasing function of <img class="formulaInl" alt="$m$" src="form_253.png"/> whereas <img class="formulaInl" alt="$\eta^\text{exp}(m)$" src="form_828.png"/> is a decreasing function.</p>
<p>This function then tries to find that number <img class="formulaInl" alt="$m$" src="form_253.png"/> of cells to refine for which the objective function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ J(m) = N(m)^{\text{order}/d} \eta^\text{exp}(m) \]" src="form_829.png"/>
</p>
<p> is minimal.</p>
<p>The rationale for this function is two-fold. First, compared to the <a class="el" href="namespaceGridRefinement.html#a40f710b99d29b38baa84400c945baa3c">refine_and_coarsen_fixed_fraction()</a> and <a class="el" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">refine_and_coarsen_fixed_number()</a> functions, this function has the property that if all refinement indicators are the same (i.e., we have achieved a mesh where the error per cell is equilibrated), then the entire mesh is refined. This is based on the observation that a mesh with equilibrated error indicators is the optimal mesh (i.e., has the least overall error) among all meshes with the same number of cells. (For proofs of this, see R. Becker, M. Braack, R. Rannacher: "Numerical simulation of laminar flames at low Mach number
with adaptive finite elements", Combustion Theory and Modelling, Vol. 3, Nr. 3, p. 503-534 1999; and W. Bangerth, R. Rannacher: "Adaptive Finite
Element Methods for Differential Equations", Birkhauser, 2003.)</p>
<p>Second, the function uses the observation that ideally, the error behaves like <img class="formulaInl" alt="$e \approx c N^{-\alpha}$" src="form_830.png"/> with some constant <img class="formulaInl" alt="$\alpha$" src="form_114.png"/> that depends on the dimension and the finite element degree. It should - given optimal mesh refinement - not depend so much on the regularity of the solution, as it is based on the idea, that all singularities can be resolved by refinement. Mesh refinement is then based on the idea that we want to make <img class="formulaInl" alt="$c=e N^\alpha$" src="form_831.png"/> small. This corresponds to the functional <img class="formulaInl" alt="$J(m)$" src="form_832.png"/> above.</p>
<dl class="section note"><dt>Note</dt><dd>This function was originally implemented by Thomas Richter. It follows a strategy described in T. Richter, "Parallel Multigrid Method
for Adaptive Finite Elements with Application to 3D Flow Problems", PhD thesis, University of Heidelberg, 2005. See in particular Section 4.3, pp. 42-43. </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2grid__refinement_8cc_source.html#l00552">552</a> of file <a class="el" href="grid_2grid__refinement_8cc_source.html">grid_refinement.cc</a>.</p>

</div>
</div>
<a id="a609b76e87a312bdf27893d1362a27886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609b76e87a312bdf27893d1362a27886">&#9670;&nbsp;</a></span>refine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>max_to_mark</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag all mesh cells for which the value in <code>criteria</code> exceeds <code>threshold</code> for refinement, but only flag up to <code>max_to_mark</code> cells.</p>
<p>The vector <code>criteria</code> contains a nonnegative value for each active cell, ordered in the canonical order of of <a class="el" href="group__Iterators.html#ga7f54e1f60de3cc5adb6ad00d23ee150b">Triangulation::active_cell_iterator</a>.</p>
<p>The cells are only flagged for refinement, they are not actually refined. To do so, you have to call <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a>.</p>
<p>This function does not implement a refinement strategy, it is more a helper function for the actual strategies. </p>

<p class="definition">Definition at line <a class="el" href="grid_2grid__refinement_8cc_source.html#l00228">228</a> of file <a class="el" href="grid_2grid__refinement_8cc_source.html">grid_refinement.cc</a>.</p>

</div>
</div>
<a id="a421d11af54a649588e4beccf23d62c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421d11af54a649588e4beccf23d62c5d">&#9670;&nbsp;</a></span>coarsen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::coarsen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag all mesh cells for which the value in <code>criteria</code> is less than <code>threshold</code> for coarsening.</p>
<p>The vector <code>criteria</code> contains a nonnegative value for each active cell, ordered in the canonical order of of <a class="el" href="group__Iterators.html#ga7f54e1f60de3cc5adb6ad00d23ee150b">Triangulation::active_cell_iterator</a>.</p>
<p>The cells are only flagged for coarsening, they are not actually coarsened. To do so, you have to call <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement()</a>.</p>
<p>This function does not implement a refinement strategy, it is more a helper function for the actual strategies. </p>

<p class="definition">Definition at line <a class="el" href="grid_2grid__refinement_8cc_source.html#l00275">275</a> of file <a class="el" href="grid_2grid__refinement_8cc_source.html">grid_refinement.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
