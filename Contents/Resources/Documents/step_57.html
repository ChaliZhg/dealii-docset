<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-57 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-57 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#NavierStokesEquations"> Navier Stokes Equations </a>
        <li><a href="#LinearizationofNavierStokesEquations"> Linearization of Navier-Stokes Equations </a>
        <li><a href="#FindinganInitialGuess"> Finding an Initial Guess </a>
        <li><a href="#TheSolverandPreconditioner">The Solver and Preconditioner </a>
        <li><a href="#TestCase"> Test Case </a>
        <li><a href="#Reference"> Reference </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeNavierStokesProblemcodeclasstemplate">The <code>NavierStokesProblem</code> class template</a>
        <li><a href="#Boundaryvaluesandrighthandside">Boundary values and right hand side</a>
        <li><a href="#BlockSchurPreconditionerforNavierStokesequations">BlockSchurPreconditioner for Navier Stokes equations</a>
        <li><a href="#StationaryNavierStokesclassimplementation">StationaryNavierStokes class implementation</a>
      <ul>
        <li><a href="#StationaryNavierStokesStationaryNavierStokes">StationaryNavierStokes::StationaryNavierStokes</a>
        <li><a href="#StationaryNavierStokessetup_dofs">StationaryNavierStokes::setup_dofs</a>
        <li><a href="#StationaryNavierStokesinitialize_system">StationaryNavierStokes::initialize_system</a>
        <li><a href="#StationaryNavierStokesassemble">StationaryNavierStokes::assemble</a>
        <li><a href="#StationaryNavierStokessolve">StationaryNavierStokes::solve</a>
        <li><a href="#StationaryNavierStokesrefine_mesh">StationaryNavierStokes::refine_mesh</a>
        <li><a href="#StationaryNavierStokesdimnewton_iteration">StationaryNavierStokes<dim>::newton_iteration</a>
        <li><a href="#StationaryNavierStokescompute_initial_guess">StationaryNavierStokes::compute_initial_guess</a>
        <li><a href="#StationaryNavierStokesoutput_results">StationaryNavierStokes::output_results</a>
        <li><a href="#StationaryNavierStokesprocess_solution">StationaryNavierStokes::process_solution</a>
        <li><a href="#StationaryNavierStokesrun">StationaryNavierStokes::run</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Testcase1Re400"> Test case 1: Re=400 </a>
        <li><a href="#Testcase2Re7500"> Test case 2: Re=7500 </a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Comparetoothersolvers">Compare to other solvers</a>
        <li><a href="#3Dcomputations">3D computations</a>
        <li><a href="#Parallelization">Parallelization</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Liang Zhao and Timo Heister</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grant DMS1522191 and the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-0949446 and The University of California-Davis. </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.484156"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.484156.svg" alt="10.5281/zenodo.484156"/></a> </dd></dl>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="NavierStokesEquations"></a></p><h3>Navier Stokes Equations </h3>
<p>In this tutorial we show how to solve the incompressible Navier Stokes equations (NSE) by Newton's method. The flow we consider here is assumed to be steady. In a domain <img class="formulaInl" alt="$\Omega \subset \mathbb{R}^{d}$" src="form_4083.png"/>, <img class="formulaInl" alt="$d=2,3$" src="form_4084.png"/>, with a piecewise smooth boundary <img class="formulaInl" alt="$\partial \Omega$" src="form_1561.png"/>, and a given force field <img class="formulaInl" alt="$\textbf{f}$" src="form_4085.png"/>, we seek a velocity field <img class="formulaInl" alt="$\textbf{u}$" src="form_1825.png"/> and a pressure field <img class="formulaInl" alt="$\textbf{p}$" src="form_4086.png"/> satisfying</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \nu \Delta\textbf{u} + (\textbf{u} \cdot \nabla)\textbf{u} + \nabla p &amp;=&amp; \textbf{f}\\ - \nabla \cdot \textbf{u} &amp;=&amp; 0 \end{eqnarray*}" src="form_4087.png"/>
</p>
<p>Different from the Stokes equations as discussed in <a class="el" href="step_22.html">step-22</a>, the NSE are a nonlinear system because of the convective term <img class="formulaInl" alt="$(\textbf{u} \cdot \nabla)\textbf{u}$" src="form_4088.png"/>. The first step of computing a numerical solution is to linearize the system and this will be done using Newton's method. A time-dependent problem is discussed in <a class="el" href="step_35.html">step-35</a>, where the system is linearized using the solution from the last time step and no nonlinear solve is necessary.</p>
<p><a class="anchor" id="LinearizationofNavierStokesEquations"></a></p><h3>Linearization of Navier-Stokes Equations </h3>
<p>Moving the right-hand side terms to the left, a nonlinear function is created as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} F(\mathbf{u}, p) = \left( \begin{array}{c} - \nu \Delta\mathbf{u} + (\mathbf{u} \cdot \nabla)\mathbf{u} + \nabla p - \mathbf{f} \\ - \nabla \cdot \mathbf{u} \\ \end{array} \right). \end{eqnarray*}" src="form_4089.png"/>
</p>
<p><img class="formulaInl" alt="$F(\textbf{u}, p)$" src="form_4090.png"/> is a nonlinear function whose root is the solution to the NSE. Assuming the initial guess is good enough to guarantee the convergence of Newton's iteration and denoting <img class="formulaInl" alt="$\textbf{x} = (\textbf{u}, p)$" src="form_4091.png"/>, Newton's iteration on a vector field can be defined as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \textbf{x}^{k+1} = \textbf{x}^{k} - (\nabla F(\textbf{x}^{k}))^{-1} F(\textbf{x}^{k}), \end{eqnarray*}" src="form_4092.png"/>
</p>
<p> where <img class="formulaInl" alt="$\textbf{x}^{k+1}$" src="form_4093.png"/> is the approximate solution in step k+1, <img class="formulaInl" alt="$\textbf{x}^{k}$" src="form_4094.png"/> represents the solution from the last step, and <img class="formulaInl" alt="$\nabla F(\textbf{x}^{k})$" src="form_4095.png"/> is the Jacobian matrix evaluated at <img class="formulaInl" alt="$\textbf{x}^{k}$" src="form_4094.png"/>. A similar iteration can be found in <a class="el" href="step_15.html">step-15</a>.</p>
<p>From Newton's iteration formula, we can observe that the new solution is obtained by adding an update term to the old solution. Instead of evaluating the Jacobian matrix and taking its inverse, we consider the update term as a whole, that is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \delta \textbf{x}^{k} = - (\nabla F(\textbf{x}^{k}))^{-1} F(\textbf{x}^{k}), \end{eqnarray*}" src="form_4096.png"/>
</p>
<p> where <img class="formulaInl" alt="$x^{k+1}=x^{k}+\delta x^{k}$" src="form_4097.png"/>.</p>
<p>Then we can evaluate the update term by solving the system </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \nabla F(\textbf{x}^{k}) \delta \textbf{x}^{k} = -F(\textbf{x}^{k}). \end{eqnarray*}" src="form_4098.png"/>
</p>
<p> Here, the left of the previous equation represents the directional gradient of <img class="formulaInl" alt="$F(\textbf{x})$" src="form_4099.png"/> along <img class="formulaInl" alt="$\delta \textbf{x}^{k}$" src="form_4100.png"/> at <img class="formulaInl" alt="$\textbf{x}^{k}$" src="form_4094.png"/>. By definition, the directional gradient is given by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} &amp; &amp;\nabla F(\mathbf{u}^{k}, p^{k}) (\delta \mathbf{u}^{k}, \delta p^{k}) \\ \\ &amp;=&amp; \lim_{\epsilon \to 0} \frac{1}{\epsilon} (F(\mathbf{u}^{k}+\epsilon \delta \mathbf{u}^{k}, p^{k}+\epsilon\nabla\delta p^{k}) - (F(\mathbf{u}^{k}, p^{k}))\\ \\ &amp;=&amp; \lim_{\epsilon \to 0} \frac{1}{\epsilon} \left( \begin{array}{c} - \epsilon\nu\Delta\delta \mathbf{u}^{k} + \epsilon\mathbf{u}^{k}\cdot\nabla\delta\mathbf{u}^{k}+\epsilon\delta\mathbf{u}^{k}\cdot\nabla\mathbf{u}^{k}+\epsilon^{2}\delta\mathbf{u}^{k}\cdot\nabla\delta\mathbf{u}^{k}+\epsilon \nabla\delta p^{k}\\ - \epsilon \nabla \cdot\delta \mathbf{u}^{k}\\ \end{array} \right)\\ \\ &amp;=&amp; \left( \begin{array}{c} - \nu\Delta\delta \mathbf{u}^{k} + \mathbf{u}^{k}\cdot\nabla\delta\mathbf{u}^{k}+\delta\mathbf{u}^{k}\cdot\nabla\mathbf{u}^{k}+ \nabla\delta p^{k}\\ - \nabla \cdot\delta \mathbf{u}^{k}\\ \end{array} \right). \end{eqnarray*}" src="form_4101.png"/>
</p>
<p>Therefore, we arrive at the linearized system:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \nu\Delta\delta\mathbf{u}^{k} + \mathbf{u}^{k}\cdot\nabla\delta\mathbf{u}^{k}+\delta\mathbf{u}^{k}\cdot\nabla\mathbf{u}^{k}+ \nabla\delta p^{k} = \mathbf{g}, \\ - \nabla \cdot\delta \mathbf{u}^{k} = \nabla\cdot\mathbf{u}^{k}, \end{eqnarray*}" src="form_4102.png"/>
</p>
<p>where <img class="formulaInl" alt="$\textbf{g} =\textbf{f}+\nu \Delta\textbf{u}^k -(\textbf{u}^k \cdot \nabla)\textbf{u}^k -\nabla p^k$" src="form_4103.png"/> and <img class="formulaInl" alt="$\textbf{u}^k$" src="form_4104.png"/> and <img class="formulaInl" alt="$p^k$" src="form_4105.png"/> are the solutions from the previous iteration. Additionally, the right hand side of the second equation is not zero since the discrete solution is not exactly divergence free (divergence free for the continuous solution). The right hand side here acts as a correction which leads the discrete solution of the velocity to be divergence free along Newton's iteration. In this linear system, the only unknowns are the update terms <img class="formulaInl" alt="$\delta \textbf{u}^{k}$" src="form_4106.png"/> and <img class="formulaInl" alt="$\delta p^{k}$" src="form_4107.png"/>, and we can use a similar strategy to the one used in <a class="el" href="step_22.html">step-22</a>. The weak form is derived like it is done in <a class="el" href="step_22.html">step-22</a>.</p>
<p>Now, Newton's iteration can be used to solve for the update terms:</p>
<ol>
<li>
Initialization: Initial guess <img class="formulaInl" alt="$u_0$" src="form_3041.png"/> and <img class="formulaInl" alt="$p_0$" src="form_3687.png"/>, tolerance <img class="formulaInl" alt="$\tau$" src="form_1599.png"/>; </li>
<li>
Linear solve to compute update term <img class="formulaInl" alt="$\delta\textbf{u}^{k}$" src="form_4108.png"/> and <img class="formulaInl" alt="$\delta p^k$" src="form_4109.png"/>; </li>
<li>
Update the approximation: <img class="formulaInl" alt="$\textbf{u}^{k+1} = \textbf{u}^{k} + \delta\textbf{u}^{k}$" src="form_4110.png"/> and <img class="formulaInl" alt="$p^{k+1} = p^{k} + \delta p^{k}$" src="form_4111.png"/>; </li>
<li>
Check residual norm: <img class="formulaInl" alt="$E^{k+1} = \|F(\mathbf{u}^{k+1}, p^{k+1})\|$" src="form_4112.png"/>: <ul>
<li>
If <img class="formulaInl" alt="$E^{k+1} \leq \tau$" src="form_4113.png"/>, STOP. </li>
<li>
If <img class="formulaInl" alt="$E^{k+1} &gt; \tau$" src="form_4114.png"/>, back to step 2. </li>
</ul>
</li>
</ol>
<p><a class="anchor" id="FindinganInitialGuess"></a></p><h3>Finding an Initial Guess </h3>
<p>Getting Newton's method to converge, the initial guess needs to be close enough to the solution, so it is crucial to find a good starting value.</p>
<p>When the viscosity <img class="formulaInl" alt="$\nu$" src="form_1655.png"/> is large, a good initial guess can be obtained by solving the Stokes equation with viscosity <img class="formulaInl" alt="$\nu$" src="form_1655.png"/>. While problem dependent, this works for <img class="formulaInl" alt="$\nu \geq 1/400$" src="form_4115.png"/> for the test problem considered here.</p>
<p>However, the convective term <img class="formulaInl" alt="$(\mathbf{u}\cdot\nabla)\mathbf{u}$" src="form_4116.png"/> will be dominant if the viscosity is small, like 1/7500 in test case 2. In this situation, we use a continuation method to set up a series of auxiliary NSE with viscosity approaching the one in the target NSE. Correspondingly, we create a sequence <img class="formulaInl" alt="$\{\nu_{i}\}$" src="form_4117.png"/> with <img class="formulaInl" alt="$\nu_{n}= \nu$" src="form_4118.png"/>, and accept that the solutions to two NSE with viscosity <img class="formulaInl" alt="$\nu_{i}$" src="form_4119.png"/> and <img class="formulaInl" alt="$\nu_{i+1}$" src="form_4120.png"/> are close if <img class="formulaInl" alt="$|\nu_{i} - \nu_{i+1}|$" src="form_4121.png"/> is small. Then we use the solution to the NSE with viscosity <img class="formulaInl" alt="$\nu_{i}$" src="form_4119.png"/> as the initial guess of the NSE with <img class="formulaInl" alt="$\nu_{i+1}$" src="form_4120.png"/>. This can be thought of as a staircase from the Stokes equations to the NSE we want to solve.</p>
<p>That is, we first solve a Stokes problem</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \nu_{1} \Delta\textbf{u} + \nabla p &amp;=&amp; \textbf{f}\\ - \nabla \cdot \textbf{u} &amp;=&amp; 0 \end{eqnarray*}" src="form_4122.png"/>
</p>
<p>to get the initial guess for</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \nu_{1} \Delta\textbf{u} + (\textbf{u} \cdot \nabla)\textbf{u} + \nabla p &amp;=&amp; \textbf{f},\\ - \nabla \cdot \textbf{u} &amp;=&amp; 0, \end{eqnarray*}" src="form_4123.png"/>
</p>
<p> which also acts as the initial guess of the continuation method. Here <img class="formulaInl" alt="$\nu_{1}$" src="form_4124.png"/> is relatively large so that the solution to the Stokes problem with viscosity <img class="formulaInl" alt="$\nu_{1}$" src="form_4124.png"/> can be used as an initial guess for the NSE in Newton's iteration.</p>
<p>Then the solution to</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \nu_{i} \Delta\textbf{u} + (\textbf{u} \cdot \nabla)\textbf{u} + \nabla p &amp;=&amp; \textbf{f},\\ - \nabla \cdot \textbf{u} &amp;=&amp; 0. \end{eqnarray*}" src="form_4125.png"/>
</p>
<p>acts as the initial guess for</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} - \nu_{i+1} \Delta\textbf{u} + (\textbf{u} \cdot \nabla)\textbf{u} + \nabla p &amp;=&amp; \textbf{f},\\ - \nabla \cdot \textbf{u} &amp;=&amp; 0. \end{eqnarray*}" src="form_4126.png"/>
</p>
<p>This process is repeated with a sequence of viscosities, <img class="formulaInl" alt="$\{\nu_i\}$" src="form_4127.png"/> that is determined experimentally so that the final solution can used as a starting guess for the Newton iteration.</p>
<p><a class="anchor" id="TheSolverandPreconditioner"></a></p><h3>The <a class="el" href="classSolver.html">Solver</a> and Preconditioner </h3>
<p>At each step of Newton's iteration, the problem results in solving a saddle point systems of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left( \begin{array}{cc} A &amp; B^{T} \\ B &amp; 0 \\ \end{array} \right) \left( \begin{array}{c} U \\ P \\ \end{array} \right) = \left( \begin{array}{c} F \\ 0 \\ \end{array} \right). \end{eqnarray*}" src="form_4128.png"/>
</p>
<p>This system matrix has the same block structure as the one in <a class="el" href="step_22.html">step-22</a>. However, the matrix <img class="formulaInl" alt="$A$" src="form_40.png"/> at (1, 1) corner is not symmetric because of the nonlinear term. Instead of solving the above system, we can solve the equivalent system</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left( \begin{array}{cc} A + \gamma B^TW^{-1}B &amp; B^{T} \\ B &amp; 0 \\ \end{array} \right) \left( \begin{array}{c} U \\ P \\ \end{array} \right) = \left( \begin{array}{c} F \\ 0 \\ \end{array} \right) \end{eqnarray*}" src="form_4129.png"/>
</p>
<p> with a parameter <img class="formulaInl" alt="$\gamma$" src="form_932.png"/> and an invertible matrix W. Here <img class="formulaInl" alt="$\gamma B^TW^{-1}B$" src="form_4130.png"/> is the Augmented Lagrangian term and see [1] for details.</p>
<p>Denoting the system matrix of the new system by <img class="formulaInl" alt="$G$" src="form_2300.png"/> and the right-hand side by <img class="formulaInl" alt="$b$" src="form_41.png"/>, we solve it iteratively with right preconditioning <img class="formulaInl" alt="$P^{-1}$" src="form_1901.png"/> as <img class="formulaInl" alt="$GP^{-1}y = b$" src="form_4131.png"/>, where</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} P^{-1} = \left(\begin{array}{cc} \tilde{A} &amp; B^T \\ 0 &amp; \tilde{S} \end{array}\right)^{-1}, \end{eqnarray*}" src="form_4132.png"/>
</p>
<p>with <img class="formulaInl" alt="$\tilde{A} = A + \gamma B^TW^{-1}B$" src="form_4133.png"/> and <img class="formulaInl" alt="$\tilde{S}$" src="form_4134.png"/> is the corresponding Schur complement <img class="formulaInl" alt="$\tilde{S} = B^T \tilde{A}^{-1} B$" src="form_4135.png"/>. We let <img class="formulaInl" alt="$W = M_p$" src="form_4136.png"/> where <img class="formulaInl" alt="$M_p$" src="form_1881.png"/> is the pressure mass matrix, then <img class="formulaInl" alt="$\tilde{S}^{-1}$" src="form_4137.png"/> can be approximated by</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \tilde{S}^{-1} \approx -(\nu+\gamma)M_p^{-1}. \end{eqnarray*}" src="form_4138.png"/>
</p>
<p> See [1] for details.</p>
<p>We decompose <img class="formulaInl" alt="$P^{-1}$" src="form_1901.png"/> as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} P^{-1} = \left(\begin{array}{cc} \tilde{A}^{-1} &amp; 0 \\ 0 &amp; I \end{array}\right) \left(\begin{array}{cc} I &amp; -B^T \\ 0 &amp; I \end{array}\right) \left(\begin{array}{cc} I &amp; 0 \\ 0 &amp; \tilde{S}^{-1} \end{array}\right). \end{eqnarray*}" src="form_4139.png"/>
</p>
<p>Here two inexact solvers will be needed for <img class="formulaInl" alt="$\tilde{A}^{-1}$" src="form_4140.png"/> and <img class="formulaInl" alt="$\tilde{S}^{-1}$" src="form_4137.png"/>, respectively (see [1]). Since the pressure mass matrix is symmetric and positive definite, CG with ILU as a preconditioner is appropriate to use for <img class="formulaInl" alt="$\tilde{S}^{-1}$" src="form_4137.png"/>. For simplicity, we use the direct solver UMFPACK for <img class="formulaInl" alt="$\tilde{A}^{-1}$" src="form_4140.png"/>. The last ingredient is a sparse matrix-vector product with <img class="formulaInl" alt="$B^T$" src="form_66.png"/>. Instead of computing the matrix product in the augmented Lagrangian term in <img class="formulaInl" alt="$\tilde{A}$" src="form_2705.png"/>, we assemble Grad-Div stabilization <img class="formulaInl" alt="$(\nabla \cdot \phi _{i}, \nabla \cdot \phi _{j}) \approx (B^T M_p^{-1}B)_{ij}$" src="form_4141.png"/>, as explained in [2].</p>
<p><a class="anchor" id="TestCase"></a></p><h3>Test Case </h3>
<p>Here we use the lid driven cavity flow as our test case, see [3] for details. The computational domain is the unit square and the right-hand side <img class="formulaInl" alt="$f=0$" src="form_1715.png"/>. The boundary condition is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (u(x, y), v(x,y)) &amp;=&amp; (1,0) \qquad\qquad \textrm{if}\ y = 1 \\ (u(x, y), v(x,y)) &amp;=&amp; (0,0) \qquad\qquad \textrm{else}. \end{eqnarray*}" src="form_4142.png"/>
</p>
<p>When solving this problem, the error consists of the nonlinear error (from Newton's iteration) and the discretization error (depending on mesh size). The nonlinear part decreases with each Newton iteration and the discretization error reduces with mesh refinement. In this example, the solution from the coarse mesh is transferred to successively finer meshes and used as an initial guess. Therefore, the nonlinear error is always brought below the tolerance of Newton's iteration and the discretization error is reduced with each mesh refinement.</p>
<p>Inside the loop, we involve three solvers: one for <img class="formulaInl" alt="$\tilde{A}^{-1}$" src="form_4140.png"/>, one for <img class="formulaInl" alt="$M_p^{-1}$" src="form_1880.png"/> and one for <img class="formulaInl" alt="$Gx=b$" src="form_4143.png"/>. The first two solvers are invoked in the preconditioner and the outer solver gives us the update term. Overall convergence is controlled by the nonlinear residual and Newton's method does not have to require an exact Jacobian, so for the outer linear solver we employ FGMRES with a relative tolerance of only 1e-4. In fact, we use the truncated Newton solve for this system. As described in <a class="el" href="step_22.html">step-22</a>, the inner linear solves are also not required to be done very accurately. Here we use CG with a relative tolerance of 1e-6 for the pressure mass matrix. As expected, we still see convergence of the nonlinear residual down to 1e-14. Also, we use a simple line search algorithm for globalization of the Newton method.</p>
<p>The cavity reference values for Re=400 and Re=7500 are from [4] and [5], respectively, where "Re" represents the Reynold number and can be located at [8]. Here the viscosity is defined by 1/Re. Even though we can still find a solution for Re=10000 and the references contain results for comparison, we limit our discussion here to Re=7500. This is because the solution is no longer stationary starting around Re=8000 but instead becomes periodic, see [7] for details.</p>
<p><a class="anchor" id="Reference"></a></p><h3>Reference </h3>
<ol>
<li>
An Augmented Lagrangian-Based Approach to the Oseen Problem, M. Benzi and M. Olshanskii, SIAM J. SCI. COMPUT. 2006 </li>
<li>
Efficient augmented Lagrangian-type preconditioning for the Oseen problem using Grad-Div stabilization, Timo Heister and Gerd Rapin </li>
<li>
<a href="http://www.cfd-online.com/Wiki/Lid-driven_cavity_problem">http://www.cfd-online.com/Wiki/Lid-driven_cavity_problem</a> </li>
<li>
High-Re solution for incompressible flow using the Navier-Stokes Equations and a <a class="el" href="classMultigrid.html">Multigrid</a> Method, U. Ghia, K. N. Ghia, and C. T. Shin </li>
<li>
Numerical solutions of 2-D steady incompressible driven cavity flow at high Reynolds numbers, E. Erturk, T.C. Corke and C. Gokcol </li>
<li>
Implicit Weighted ENO Schemes for the Three-Dimensional Incompressible Navier-Stokes Equations, Yang et al, 1998 </li>
<li>
The 2D lid-driven cavity problem revisited, C. Bruneau and M. Saad, 2006 </li>
<li>
<a href="https://en.wikipedia.org/wiki/Reynolds_number">https://en.wikipedia.org/wiki/Reynolds_number</a> </li>
</ol>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As usual, we start by including some well-known files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_gmres.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div></div><!-- fragment --><p>To transfer solutions between meshes, this file is included:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/solution_transfer.h&gt;</span></div></div><!-- fragment --><p>This file includes UMFPACK: the direct solver:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div></div><!-- fragment --><p>And the one for ILU preconditioner:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_ilu.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step57</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeNavierStokesProblemcodeclasstemplate"></a> </p><h3>The <code>NavierStokesProblem</code> class template</h3>
<p>This is the main function and its member functions. As explained in the introduction, what we obtain at each step is the Newton's update, so we define two variables: the present solution and the update. Additionally, the evaluation point is for temporarily holding Newton update in line search. A sparse matrix for the pressure mass matrix is created for the operator of a block Schur complement preconditioner. We use one <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> for Dirichlet boundary conditions at the initial step and a zero <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> for the Newton is defined by 1/Re which has been discussed in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StationaryNavierStokes</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StationaryNavierStokes(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> run(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> initialize_system();</div><div class="line">  <span class="keywordtype">void</span> assemble(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> assemble_matrix);</div><div class="line">  <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span> assemble_rhs(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span> solve(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line">  <span class="keywordtype">void</span> process_solution(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement);</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> newton_iteration(<span class="keyword">const</span> <span class="keywordtype">double</span> tolerance,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iteration,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_initial_step,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">bool</span> output_result);</div><div class="line">  <span class="keywordtype">void</span> compute_initial_guess(<span class="keywordtype">double</span> step_size);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> viscosity;</div><div class="line">  <span class="keywordtype">double</span> gamma;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           degree;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; dofs_per_block;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>           triangulation;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>                fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>              dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>             zero_constraints;</div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>             nonzero_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>         sparsity_pattern;</div><div class="line">  <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>    system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>         pressure_mass_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>          present_solution;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>          newton_update;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>          system_rhs;</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>          evaluation_point;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundaryvaluesandrighthandside"></a> </p><h3><a class="el" href="classBoundary.html">Boundary</a> values and right hand side</h3>
<p>In this problem we set the velocity along the upper surface of the cavity to be one and zero on the other three walls. The right hand side function is zero so we do not need to set the right hand side function in this tutorial. The number of components of the boundary function is dim+1. In practice, the boundary values are applied to our solution through <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> which is obtained by using <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>. The components of boundary value functions are required to be chosen according to the finite element space. Therefore we have to define the boundary value of pressure even though we actually do not need it.</p>
<p>The following function represents the boundary values:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues() : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1) {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span>   <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point &lt;dim&gt;</a>    &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component &lt; this-&gt;n_components,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, this-&gt;n_components));</div><div class="line">  <span class="keywordflow">if</span> (component == 0 &amp;&amp; std::abs(p[dim-1]-1.0) &lt; 1e-10)</div><div class="line">    <span class="keywordflow">return</span> 1.0;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value ( <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                         <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#aa568b98591fc2bda09b28539789aef7d">n_components</a>; ++c)</div><div class="line">    values(c) = BoundaryValues&lt;dim&gt;::value (p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BlockSchurPreconditionerforNavierStokesequations"></a> </p><h3>BlockSchurPreconditioner for Navier Stokes equations</h3>
<p>The block Schur complement preconditioner is defined in this part. As discussed in the introduction, the preconditioner in Krylov iterative methods is implemented as a matrix-vector product operator. In practice, the Schur complement preconditioner is decomposed as a product of three matrices (as presented in the first section). The <img class="formulaInl" alt="$\tilde{A}^{-1}$" src="form_4140.png"/> in the first factor involves a solve for the linear system <img class="formulaInl" alt="$\tilde{A}x=b$" src="form_4144.png"/>. Here we solve this system via a direct solver for simplicity. The computation involved in the second factor is a simple matrix-vector multiplication. The Schur complement <img class="formulaInl" alt="$\tilde{S}$" src="form_4134.png"/> can be well approximated by the pressure mass matrix and its inverse can be obtained through an inexact solver. Because the pressure mass matrix is symmetric and positive definite, we can use CG to solve the corresponding linear system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line"><span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BlockSchurPreconditioner (<span class="keywordtype">double</span>                                     gamma,</div><div class="line">                            <span class="keywordtype">double</span>                                     viscosity,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>            &amp;S,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>                 &amp;P,</div><div class="line">                            <span class="keyword">const</span> PreconditionerMp                     &amp;Mppreconditioner);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult (<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> gamma;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;stokes_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &amp;pressure_mass_matrix;</div><div class="line">  <span class="keyword">const</span> PreconditionerMp &amp;mp_preconditioner;</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_inverse;</div><div class="line">};</div></div><!-- fragment --><p>We can notice that the initialization of the inverse of the matrix at (0,0) corner is completed in the constructor. If so, every application of the preconditioner then no longer requires the computation of the matrix factors.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line">BlockSchurPreconditioner&lt;PreconditionerMp&gt;::</div><div class="line">BlockSchurPreconditioner (<span class="keywordtype">double</span>                           gamma,</div><div class="line">                          <span class="keywordtype">double</span>                           viscosity,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>  &amp;S,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>       &amp;P,</div><div class="line">                          <span class="keyword">const</span> PreconditionerMp           &amp;Mppreconditioner)</div><div class="line">  :</div><div class="line">  gamma                (gamma),</div><div class="line">  viscosity            (viscosity),</div><div class="line">  stokes_matrix        (S),</div><div class="line">  pressure_mass_matrix (P),</div><div class="line">  mp_preconditioner    (Mppreconditioner)</div><div class="line">{</div><div class="line">  A_inverse.initialize(stokes_matrix.block(0,0));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BlockSchurPreconditioner&lt;PreconditionerMp&gt;::</div><div class="line">vmult (<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> utmp(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1e-6 * src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div><div class="line"></div><div class="line">    dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1) = 0.0;</div><div class="line">    cg.solve(pressure_mass_matrix,</div><div class="line">             dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">             mp_preconditioner);</div><div class="line">    dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1) *= -(viscosity+gamma);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    stokes_matrix.block(0,1).vmult(utmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">    utmp *= -1.0;</div><div class="line">    utmp += src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0);</div><div class="line">  }</div><div class="line"></div><div class="line">  A_inverse.vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokesclassimplementation"></a> </p><h3>StationaryNavierStokes class implementation</h3>
<p><a class="anchor" id="StationaryNavierStokesStationaryNavierStokes"></a> </p><h4>StationaryNavierStokes::StationaryNavierStokes</h4>
<p>The constructor of this class looks very similar to the one in <a class="el" href="step_22.html">step-22</a>. The only difference is the viscosity and the Augmented Lagrangian coefficient gamma.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StationaryNavierStokes&lt;dim&gt;::StationaryNavierStokes(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  :</div><div class="line">  viscosity(1.0/7500.0),</div><div class="line">  gamma(1.0),</div><div class="line">  degree(degree),</div><div class="line">  triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing),</div><div class="line">  fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree+1), dim,</div><div class="line">     <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree),   1),</div><div class="line">  dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokessetup_dofs"></a> </p><h4>StationaryNavierStokes::setup_dofs</h4>
<p>This function initializes the <a class="el" href="classDoFHandler.html">DoFHandler</a> enumerating the degrees of freedom and constraints on the current mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  system_matrix.clear();</div><div class="line">  pressure_mass_matrix.<a class="code" href="classSparseMatrix.html#a45f664681373fd3a1f8dd965395d360d">clear</a>();</div></div><!-- fragment --><p>The first step is to associate DoFs with a given mesh.</p>
<div class="fragment"><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div></div><!-- fragment --><p>We renumber the components to have all velocity DoFs come before the pressure DoFs to be able to split the solution vector in two blocks which are separately accessed in the block preconditioner.</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; block_component(dim+1, 0);</div><div class="line">block_component[dim] = 1;</div><div class="line"><a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> (dof_handler, block_component);</div><div class="line"></div><div class="line">dofs_per_block.resize (2);</div><div class="line"><a class="code" href="namespaceDoFTools.html#abfd9796e22113e13b5802e384e56af4f">DoFTools::count_dofs_per_block</a> (dof_handler, dofs_per_block, block_component);</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_u = dofs_per_block[0];</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_p = dofs_per_block[1];</div></div><!-- fragment --><p>In Newton's scheme, we first apply the boundary condition on the solution obtained from the initial step. To make sure the boundary conditions remain satisfied during Newton's iteration, zero boundary conditions are used for the update <img class="formulaInl" alt="$\delta u^k$" src="form_4145.png"/>. Therefore we set up two different constraint objects.</p>
<div class="fragment"><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  {</div><div class="line">    nonzero_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a>(dof_handler, nonzero_constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             nonzero_constraints,</div><div class="line">                                             fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">  }</div><div class="line">  nonzero_constraints.close();</div><div class="line"></div><div class="line">  {</div><div class="line">    zero_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a>(dof_handler, zero_constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+1),</div><div class="line">                                             zero_constraints,</div><div class="line">                                             fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">  }</div><div class="line">  zero_constraints.close();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; dof_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; dof_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokesinitialize_system"></a> </p><h4>StationaryNavierStokes::initialize_system</h4>
<p>On each mesh the sparsity pattern and the size of the linear system are different. This function initializes them after mesh refinement.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::initialize_system()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp (dofs_per_block, dofs_per_block);</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp, nonzero_constraints);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a> (dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">  present_solution.reinit (dofs_per_block);</div><div class="line">  newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dofs_per_block);</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dofs_per_block);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokesassemble"></a> </p><h4>StationaryNavierStokes::assemble</h4>
<p>This function builds the system matrix and right hand side that we currently work on. The <code>initial_step</code> argument is used to determine which set of constraints we apply (nonzero for the initial step and zero for the others). The <code>assemble_matrix</code> flag determines whether to assemble the whole system or only the right hand side vector, respectively.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::assemble(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">bool</span> assemble_matrix)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (assemble_matrix)</div><div class="line">    system_matrix    = 0;</div><div class="line"></div><div class="line">  system_rhs       = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe,</div><div class="line">                           quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> );</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   local_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       local_rhs    (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div></div><!-- fragment --><p>For the linearized system, we create temporary storage for present velocity and gradient, and present pressure. In practice, they are all obtained through their shape functions at quadrature points.</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim&gt; &gt;  present_velocity_values    (n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;2, dim&gt; &gt;  present_velocity_gradients (n_q_points);</div><div class="line">std::vector&lt;double&gt;           present_pressure_values    (n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;double&gt;           div_phi_u                 (dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt; &gt;  phi_u                     (dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;2, dim&gt; &gt;  grad_phi_u                (dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;           phi_p                     (dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line"></div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs    = 0;</div><div class="line"></div><div class="line">    fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(evaluation_point,</div><div class="line">                                              present_velocity_values);</div><div class="line"></div><div class="line">    fe_values[velocities].<a class="code" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">get_function_gradients</a>(evaluation_point,</div><div class="line">                                                 present_velocity_gradients);</div><div class="line"></div><div class="line">    fe_values[pressure].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(evaluation_point,</div><div class="line">                                            present_pressure_values);</div></div><!-- fragment --><p>The assembly is similar to <a class="el" href="step_22.html">step-22</a>. An additional term with gamma as a coefficient is the Augmented Lagrangian (AL), which is assembled via grad-div stabilization. As we discussed in the introduction, the bottom right block of the system matrix should be zero. Since the pressure mass matrix is used while creating the preconditioner, we assemble it here and then move it into a separate <a class="el" href="classSparseMatrix.html">SparseMatrix</a> at the end (same as in <a class="el" href="step_22.html">step-22</a>).</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            div_phi_u[k]  =  fe_values[velocities].divergence (k, q);</div><div class="line">            grad_phi_u[k] =  fe_values[velocities].gradient(k, q);</div><div class="line">            phi_u[k]      =  fe_values[velocities].value(k, q);</div><div class="line">            phi_p[k]      =  fe_values[pressure]  .value(k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (assemble_matrix)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                  {</div><div class="line">                    local_matrix(i, j) += (  viscosity*<a class="code" href="classSymmetricTensor.html#a46543b446a9cef02b1aeaf2f9b5739ba">scalar_product</a>(grad_phi_u[j], grad_phi_u[i])</div><div class="line">                                             + present_velocity_gradients[q]*phi_u[j]*phi_u[i]</div><div class="line">                                             + grad_phi_u[j]*present_velocity_values[q]*phi_u[i]</div><div class="line">                                             - div_phi_u[i]*phi_p[j]</div><div class="line">                                             - phi_p[i]*div_phi_u[j]</div><div class="line">                                             + gamma*div_phi_u[j]*div_phi_u[i]</div><div class="line">                                             + phi_p[i] * phi_p[j])</div><div class="line">                                          * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> present_velocity_divergence =  <a class="code" href="classSymmetricTensor.html#a05096e7bc18fa734eae3bd1a5f08138e">trace</a>(present_velocity_gradients[q]);</div><div class="line">            local_rhs(i) += ( - viscosity*<a class="code" href="classSymmetricTensor.html#a46543b446a9cef02b1aeaf2f9b5739ba">scalar_product</a>(present_velocity_gradients[q],grad_phi_u[i])</div><div class="line">                              - present_velocity_gradients[q]*present_velocity_values[q]*phi_u[i]</div><div class="line">                              + present_pressure_values[q]*div_phi_u[i]</div><div class="line">                              + present_velocity_divergence*phi_p[i]</div><div class="line">                              - gamma*present_velocity_divergence*div_phi_u[i])</div><div class="line">                            * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints_used = initial_step ? nonzero_constraints : zero_constraints;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (assemble_matrix)</div><div class="line">      {</div><div class="line">        constraints_used.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a>(local_matrix,</div><div class="line">                                                    local_rhs,</div><div class="line">                                                    local_dof_indices,</div><div class="line">                                                    system_matrix,</div><div class="line">                                                    system_rhs);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        constraints_used.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a>(local_rhs,</div><div class="line">                                                    local_dof_indices,</div><div class="line">                                                    system_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (assemble_matrix)</div><div class="line">  {</div></div><!-- fragment --><p>Finally we move pressure mass matrix into a separate matrix:</p>
<div class="fragment"><div class="line">pressure_mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(1,1));</div><div class="line">pressure_mass_matrix.<a class="code" href="classSparseMatrix.html#a104b9a4c9fc720b0201e7668b058e3d1">copy_from</a>(system_matrix.block(1,1));</div></div><!-- fragment --><p>Note that settings this pressure block to zero is not identical to not assembling anything in this block, because this operation here will (incorrectly) delete diagonal entries that come in from hanging node constraints for pressure DoFs. This means that our whole system matrix will have rows that are completely zero. Luckily, FGMRES handles these rows without any problem.</p>
<div class="fragment"><div class="line">      system_matrix.block(1,1) = 0;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  assemble(initial_step, <span class="keyword">true</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::assemble_rhs(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  assemble(initial_step, <span class="keyword">false</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokessolve"></a> </p><h4>StationaryNavierStokes::solve</h4>
<p>In this function, we use FGMRES together with the block preconditioner, which is defined at the beginning of the program, to solve the linear system. What we obtain at this step is the solution vector. If this is the initial step, the solution vector gives us an initial guess for the Navier Stokes equations. For the initial step, nonzero constraints are applied in order to make sure boundary conditions are satisfied. In the following steps, we will solve for the Newton update so zero constraints are used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::solve (<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints_used = initial_step ? nonzero_constraints : zero_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.m(), 1e-4*system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>(), <span class="keyword">true</span>);</div><div class="line">  <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;BlockVector&lt;double&gt;</a> &gt; gmres(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> pmass_preconditioner;</div><div class="line">  pmass_preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a> (pressure_mass_matrix,</div><div class="line">                                   <a class="code" href="classSparseLUDecomposition_1_1AdditionalData.html">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> BlockSchurPreconditioner&lt;SparseILU&lt;double&gt; &gt;</div><div class="line">  preconditioner (gamma,</div><div class="line">                  viscosity,</div><div class="line">                  system_matrix,</div><div class="line">                  pressure_mass_matrix,</div><div class="line">                  pmass_preconditioner);</div><div class="line"></div><div class="line">  gmres.solve (system_matrix,</div><div class="line">               newton_update,</div><div class="line">               system_rhs,</div><div class="line">               preconditioner);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; ****FGMRES steps: &quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constraints_used.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokesrefine_mesh"></a> </p><h4>StationaryNavierStokes::refine_mesh</h4>
<p>After finding a good initial guess on the coarse mesh, we hope to decrease the error through refining the mesh. Here we do adaptive refinement similar to <a class="el" href="step_15.html">step-15</a> except that we use the Kelly estimator on the velocity only. We also need to transfer the current solution to the next mesh using the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(degree+1),</div><div class="line">                                      <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                      present_solution,</div><div class="line">                                      estimated_error_per_cell,</div><div class="line">                                      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocity));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                   estimated_error_per_cell,</div><div class="line">                                                   0.3, 0.0);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">  <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, BlockVector&lt;double&gt;</a> &gt; solution_transfer(dof_handler);</div><div class="line">  solution_transfer.prepare_for_coarsening_and_refinement(present_solution);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div></div><!-- fragment --><p>First the <a class="el" href="classDoFHandler.html">DoFHandler</a> is set up and constraints are generated. Then we create a temporary vector "tmp", whose size is according with the solution on the new mesh.</p>
<div class="fragment"><div class="line">setup_dofs();</div><div class="line"></div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> tmp (dofs_per_block);</div></div><!-- fragment --><p>Transfer solution from coarse to fine mesh and apply boundary value constraints to the new transfered solution. Note that present_solution is still a vector corresponding to the old mesh.</p>
<div class="fragment"><div class="line">solution_transfer.interpolate(present_solution, tmp);</div><div class="line">nonzero_constraints.distribute(tmp);</div></div><!-- fragment --><p>Finally set up matrix and vectors and set the present_solution to the interpolated data.</p>
<div class="fragment"><div class="line">  initialize_system();</div><div class="line">  present_solution = tmp;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokesdimnewton_iteration"></a> </p><h4>StationaryNavierStokes&lt;dim&gt;::newton_iteration</h4>
<p>This function implements the Newton iteration with given tolerance, maximum number of iterations, and the number of mesh refinements to do. "is_initial_step" is the flag to tell us whether "setup_system" is necessary, and which part, system matrix or right hand side vector, should be assembled. If we do a line search, the right hand side is already assembled while checking the residual norm in the last iteration. Therefore, we just need to assemble the system matrix at the current iteration. The last argument "output_result" is whether output should be produced.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::newton_iteration(<span class="keyword">const</span> <span class="keywordtype">double</span> tolerance,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iteration,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_refinement,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">bool</span>  is_initial_step,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">bool</span>  output_result)</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> current_res;</div><div class="line">  <span class="keywordtype">double</span> last_res;</div><div class="line">  <span class="keywordtype">bool</span>   first_step = is_initial_step;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement = 0; refinement &lt; max_refinement+1; ++refinement)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> outer_iteration = 0;</div><div class="line">      last_res = 1.0;</div><div class="line">      current_res = 1.0;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;************  refinement = &quot;</span> &lt;&lt; refinement &lt;&lt; <span class="stringliteral">&quot; ************ &quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;viscosity= &quot;</span> &lt;&lt; viscosity &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">while</span> ((first_step || (current_res &gt; tolerance)) &amp;&amp; outer_iteration &lt; max_iteration)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (first_step)</div><div class="line">            {</div><div class="line">              setup_dofs();</div><div class="line">              initialize_system();</div><div class="line">              evaluation_point = present_solution;</div><div class="line">              assemble_system(first_step);</div><div class="line">              solve(first_step);</div><div class="line">              present_solution = newton_update;</div><div class="line">              nonzero_constraints.distribute(present_solution);</div><div class="line">              first_step = <span class="keyword">false</span>;</div><div class="line">              evaluation_point = present_solution;</div><div class="line">              assemble_rhs(first_step);</div><div class="line">              current_res = system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot;******************************&quot;</span> &lt;&lt; std::endl;</div><div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot; The residual of initial guess is &quot;</span> &lt;&lt; current_res &lt;&lt; std::endl;</div><div class="line">              std::cout &lt;&lt; <span class="stringliteral">&quot; Initialization complete!  &quot;</span> &lt;&lt; std::endl;</div><div class="line">              last_res = current_res;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              evaluation_point = present_solution;</div><div class="line">              assemble_system(first_step);</div><div class="line">              solve(first_step);</div></div><!-- fragment --><p>To make sure our solution is getting close to the exact solution, we let the solution be updated with a weight alpha such that the new residual is smaller than the one of last step, which is done in the following loop. Also the line search method can be located in <a class="el" href="step_15.html">step-15</a>.</p>
<div class="fragment"><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">double</span> alpha = 1.0; alpha &gt; 1e-5; alpha *= 0.5)</div><div class="line">                {</div><div class="line">                  evaluation_point = present_solution;</div><div class="line">                  evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update);</div><div class="line">                  nonzero_constraints.distribute(evaluation_point);</div><div class="line">                  assemble_rhs(first_step);</div><div class="line">                  current_res = system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line">                  std::cout &lt;&lt; <span class="stringliteral">&quot; alpha = &quot;</span> &lt;&lt; std::setw(6) &lt;&lt; alpha &lt;&lt; std::setw(0)</div><div class="line">                            &lt;&lt; <span class="stringliteral">&quot; res = &quot;</span> &lt;&lt; current_res &lt;&lt; std::endl;</div><div class="line">                  <span class="keywordflow">if</span> (current_res &lt; last_res)</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">              {</div><div class="line">                present_solution = evaluation_point;</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot; ---- Iteration &quot;</span> &lt;&lt; outer_iteration &lt;&lt; <span class="stringliteral">&quot; residual: &quot;</span> &lt;&lt; current_res &lt;&lt; std::endl;</div><div class="line">                last_res = current_res;</div><div class="line">              }</div><div class="line"></div><div class="line">            }</div><div class="line">          ++outer_iteration;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (output_result)</div><div class="line">            {</div><div class="line">              output_results (max_iteration*refinement+outer_iteration);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (current_res &lt;= tolerance)</div><div class="line">                process_solution(refinement);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (refinement &lt; max_refinement)</div><div class="line">        {</div><div class="line">          refine_mesh();</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot;        Do refinement ------   &quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokescompute_initial_guess"></a> </p><h4>StationaryNavierStokes::compute_initial_guess</h4>
<p>This function will provide us with an initial guess by using a continuation method as we discussed in the introduction. The Reynolds number is increased step-by-step until we reach the target value. By experiment, the solution to Stokes is good enough to be the initial guess of NSE with Reynolds number 1000 so we start there. To make sure the solution from previous problem is close enough to the next one, the step size must be small enough.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::compute_initial_guess(<span class="keywordtype">double</span> step_size)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> target_Re = 1.0/viscosity;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> is_initial_step = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">double</span> Re=1000.0; Re &lt; target_Re; Re = std::min(Re+step_size, target_Re))</div><div class="line">    {</div><div class="line">      viscosity = 1.0/Re;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot; Searching for initial guess with Re = &quot;</span> &lt;&lt; Re &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      newton_iteration(1e-12, 50, 0, is_initial_step, <span class="keyword">false</span>);</div><div class="line">      is_initial_step = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokesoutput_results"></a> </p><h4>StationaryNavierStokes::output_results</h4>
<p>This function is the same as in <a class="el" href="step_22.html">step-22</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_index)<span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names (dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.push_back (<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  data_component_interpretation</div><div class="line">  (dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation</div><div class="line">  .push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (present_solution, solution_names,</div><div class="line">                            <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                            data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  std::ostringstream filename;</div><div class="line">  filename &lt;&lt; 1.0/viscosity</div><div class="line">           &lt;&lt; <span class="stringliteral">&quot;-solution-&quot;</span></div><div class="line">           &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_index, 4)</div><div class="line">           &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line"></div><div class="line">  std::ofstream output (filename.str().c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokesprocess_solution"></a> </p><h4>StationaryNavierStokes::process_solution</h4>
<p>In our test case, we do not know the analytical solution. This function outputs the velocity components along x=0.5 and y from 0 to 1 so they can be compared with data from the literature.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::process_solution(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement)</div><div class="line">{</div><div class="line">  std::ostringstream filename;</div><div class="line">  filename &lt;&lt; (1.0/viscosity) &lt;&lt; <span class="stringliteral">&quot;-line-&quot;</span> &lt;&lt; refinement &lt;&lt; <span class="stringliteral">&quot;.txt&quot;</span>;</div><div class="line"></div><div class="line">  std::ofstream f (filename.str().c_str());</div><div class="line">  f &lt;&lt; <span class="stringliteral">&quot;# y u_x u_y&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p;</div><div class="line">  p(0)= 0.5;</div><div class="line">  p(1)= 0.5;</div><div class="line"></div><div class="line">  f &lt;&lt; std::scientific;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;=100; ++i)</div><div class="line">    {</div><div class="line">      p(dim-1) = i/100.0;</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp_vector(dim+1);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#aaee3adabb3fb97ac5d8996cd712b20e1">VectorTools::point_value</a>(dof_handler, present_solution, p, tmp_vector);</div><div class="line">      f &lt;&lt; p(dim-1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">        f &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; tmp_vector(j);</div><div class="line">      f &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="StationaryNavierStokesrun"></a> </p><h4>StationaryNavierStokes::run</h4>
<p>This is the last step of this program. In this part, we generate the grid and run the other functions respectively. The max refinement can be set by the argument.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::run(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement)</div><div class="line">{</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> Re =  1.0/viscosity;</div></div><!-- fragment --><p>If the viscosity is smaller than 1/1000, we have to first search for an initial guess via a continuation method. What we should notice is the search is always on the initial mesh, that is the <img class="formulaInl" alt="$8 \times 8$" src="form_1401.png"/> mesh in this program. After that, we just do the same as we did when viscosity is larger than 1/1000: run Newton's iteration, refine the mesh, transfer solutions, and repeat.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (Re &gt; 1000.0)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;       Searching for initial guess ... &quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> step_size = 2000.0;</div><div class="line">    compute_initial_guess(step_size);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;       Initial guess obtained            &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;                  *                      &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;                  *                      &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;                  *                      &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;                  *                      &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;       Computing solution with target Re = &quot;</span> &lt;&lt; Re &lt;&lt; std::endl;</div><div class="line">    viscosity = 1.0/Re;</div><div class="line">    newton_iteration(1e-12, 50, refinement, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div></div><!-- fragment --><p>When the viscosity is larger than 1/1000, the solution to Stokes equations is good enough as an initial guess. If so, we do not need to search for the initial guess using a continuation method. Newton's iteration can be started directly.</p>
<div class="fragment"><div class="line">        newton_iteration(1e-12, 50, refinement, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step57;</div><div class="line"></div><div class="line">      StationaryNavierStokes&lt;2&gt; flow(/ * degree = * /1);</div><div class="line">      flow.run(4);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Now we use the method we discussed above to solve Navier Stokes equations with viscosity 1/400 and 1/7500.</p>
<p><a class="anchor" id="Testcase1Re400"></a></p><h3>Test case 1: Re=400 </h3>
<p>In the first test case the viscosity is set to be 1/400. As we discussed in the introduction, the initial guess is the solution to the corresponding Stokes problem. In the following table, the residuals at each Newton's iteration on every mesh is shown. The data in the table shows that Newton's iteration converges quadratically.</p>
<table align="center" class="doxtable">
<tr>
<th>Re=400 </th><th colspan="2">Mesh0 </th><th colspan="2">Mesh1 </th><th colspan="2">Mesh2 </th><th colspan="2">Mesh3 </th><th colspan="2">Mesh4  </th></tr>
<tr>
<th>Newton iter  </th><th>Residual  </th><th>FGMRES  </th><th>Residual  </th><th>FGMRES  </th><th>Residual  </th><th>FGMRES  </th><th>Residual  </th><th>FGMRES  </th><th>Residual  </th><th>FGMRES   </th></tr>
<tr>
<td>1 </td><td>3.7112e-03 </td><td>5 </td><td>6.4189e-03 </td><td>3 </td><td>2.4338e-03 </td><td>3 </td><td>1.0570e-03 </td><td>3 </td><td>4.9499e-04 </td><td>3  </td></tr>
<tr>
<td>2 </td><td>7.0849e-04 </td><td>5.0000e+00 </td><td>9.9458e-04 </td><td>5 </td><td>1.1409e-04 </td><td>6 </td><td>1.3544e-05 </td><td>6 </td><td>1.4171e-06 </td><td>6  </td></tr>
<tr>
<td>3 </td><td>1.9980e-05 </td><td>5.0000e+00 </td><td>4.5007e-05 </td><td>5 </td><td>2.9020e-08 </td><td>5 </td><td>4.4021e-10 </td><td>6 </td><td>6.3435e-11 </td><td>6  </td></tr>
<tr>
<td>4 </td><td>2.3165e-09 </td><td>6.0000e+00 </td><td>1.6891e-07 </td><td>5 </td><td>1.2338e-14 </td><td>7 </td><td>1.8506e-14 </td><td>8 </td><td>8.8563e-15 </td><td>8  </td></tr>
<tr>
<td>5 </td><td>1.2585e-13 </td><td>7.0000e+00 </td><td>1.4520e-11 </td><td>6 </td><td>1.9044e-13 </td><td>8 </td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>6 </td><td></td><td></td><td>1.3998e-15 </td><td>8 </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p>The following figures show the sequence of generated grids. For the case of Re=400, the initial guess is obtained by solving Stokes on an <img class="formulaInl" alt="$8 \times 8$" src="form_1401.png"/> mesh, and the mesh is refined adaptively. Between meshes, the solution from the coarse mesh is interpolated to the fine mesh to be used as an initial guess.</p>
<table align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re400_Mesh0.png" width="232px"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re400_Mesh1.png" width="232px"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re400_Mesh2.png" width="232px"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re400_Mesh3.png" width="232px"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re400_Mesh4.png" width="232px"/>
</div>
   </td></tr>
</table>
<p>This picture is the graphical streamline result of lid-driven cavity with Re=400. </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re400_Streamline.png"/>
</div>
<p>Then the solution is compared with a reference solution from [4] and the reference solution data can be found in the file "ref_2d_ghia_u.txt".</p>
<div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-57.compare-Re400.svg" style="width:50%"></object>
</div>
<p><a class="anchor" id="Testcase2Re7500"></a></p><h3>Test case 2: Re=7500 </h3>
<p>Newton's iteration requires a good initial guess. However, the nonlinear term dominates when the Reynold number is large, so that the solution to the Stokes equations may be far away from the exact solution. If the Stokes solution acts as the initial guess, the convergence will be lost. The following picture shows that the nonlinear iteration gets stuck and the residual no longer decreases in further iterations.</p>
<div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-57.Re7500_loss_convergence.svg" style="width:50%"></object>
</div>
<p>The initial guess, therefore, has to be obtained via a continuation method which has been discussed in the introduction. Here the step size in the continuation method, that is <img class="formulaInl" alt="$|\nu_{i}-\nu_{i+1}|$" src="form_4146.png"/>, is 2000 and the initial mesh is of size <img class="formulaInl" alt="$32 \times 32$" src="form_4147.png"/>. After obtaining an initial guess, the mesh is refined as in the previous test case. The following picture shows that at each refinement Newton's iteration has quadratic convergence. 52 steps of Newton's iterations are executed for solving this test case.</p>
<div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-57.Re7500_get_convergence.svg" style="width:50%"></object>
</div>
<p>We also show the residual from each step of Newton's iteration on every mesh. The quadratic convergence is clearly visible in the table.</p>
<table align="center" class="doxtable">
<tr>
<th>Re=7500 </th><th colspan="2">Mesh0 </th><th colspan="2">Mesh1 </th><th colspan="2">Mesh2 </th><th colspan="2">Mesh3 </th><th colspan="2">Mesh4  </th></tr>
<tr>
<th>Newton iter  </th><th>Residual  </th><th>FGMRES  </th><th>Residual  </th><th>FGMRES  </th><th>Residual  </th><th>FGMRES  </th><th>Residual  </th><th>FGMRES  </th><th>Residual  </th><th>FGMRES   </th></tr>
<tr>
<td>1 </td><td>1.8922e-06 </td><td>6 </td><td>4.2506e-03 </td><td>3 </td><td>1.4299e-03 </td><td>3 </td><td>4.8793e-04 </td><td>2 </td><td>1.8998e-04 </td><td>2  </td></tr>
<tr>
<td>2 </td><td>3.1644e-09 </td><td>8 </td><td>1.3732e-03 </td><td>7 </td><td>4.1506e-04 </td><td>7 </td><td>9.1119e-05 </td><td>8 </td><td>1.3555e-05 </td><td>8  </td></tr>
<tr>
<td>3 </td><td>1.7611e-14 </td><td>9 </td><td>2.1946e-04 </td><td>6 </td><td>1.7881e-05 </td><td>6 </td><td>5.2678e-07 </td><td>7 </td><td>9.3739e-09 </td><td>7  </td></tr>
<tr>
<td>4 </td><td></td><td></td><td>8.8269e-06 </td><td>6 </td><td>6.8210e-09 </td><td>7 </td><td>2.2770e-11 </td><td>8 </td><td>1.2588e-13 </td><td>9  </td></tr>
<tr>
<td>5 </td><td></td><td></td><td>1.2974e-07 </td><td>7 </td><td>1.2515e-13 </td><td>9 </td><td>1.7801e-14 </td><td>1 </td><td></td><td></td></tr>
<tr>
<td>6 </td><td></td><td></td><td>4.4352e-11 </td><td>7 </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>7 </td><td></td><td></td><td>6.2863e-15 </td><td>9 </td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p>The sequence of generated grids looks like this: </p><table align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re7500_Mesh0.png" width="232px"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re7500_Mesh1.png" width="232px"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re7500_Mesh2.png" width="232px"/>
</div>
   </td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re7500_Mesh3.png" width="232px"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re7500_Mesh4.png" width="232px"/>
</div>
   </td></tr>
</table>
<p>We compare our solution with reference solution from [5]. </p><div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-57.compare-Re7500.svg" style="width:50%"></object>
</div>
<p> The following picture presents the graphical result. </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-57.Re7500_Streamline.png"/>
</div>
<p>Furthermore, the error consists of the nonlinear error, which is decreasing as Newton's iteration going on, and the discretization error, which depends on the mesh size. That is why we have to refine the mesh and repeat Newton's iteration on the next finer mesh. From the table above, we can see that the residual (nonlinear error) is below 1e-12 on each mesh, but the following picture shows us the difference between solutions on subsequently finer meshes.</p>
<div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-57.converge-Re7500.svg" style="width:50%"></object>
</div>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Comparetoothersolvers"></a></p><h4>Compare to other solvers</h4>
<p>It is easy to compare the currently implemented linear solver to just using UMFPACK for the whole linear system. You need to remove the nullspace containing the constant pressures and it is done in <a class="el" href="step_56.html">step-56</a>. More interesting is the comparison to other state of the art preconditioners like PCD. It turns out that the preconditioner here is very competitive, as can be seen in the paper [2].</p>
<p>The following table shows the timing results between our iterative approach (FGMRES) compared to a direct solver (UMFPACK) for the whole system with viscosity set to 1/400. Even though we use the same direct solver for the velocity block in the iterative solver, it is considerably faster and consumes less memory. This will be even more pronounced in 3d.</p>
<table align="center" border="1">
<tr>
<th>Ref </th><th>DoFs </th><th>Iterative: Total/s (Setup/s) </th><th>Direct: Total/s (Setup/s)  </th></tr>
<tr>
<td>5 </td><td>9539 </td><td>0.10 (0.06) </td><td>0.13 (0.12)  </td></tr>
<tr>
<td>6 </td><td>37507 </td><td>0.58 (0.37) </td><td>1.03 (0.97)  </td></tr>
<tr>
<td>7 </td><td>148739 </td><td>3.59 (2.73) </td><td>7.78 (7.53)  </td></tr>
<tr>
<td>8 </td><td>592387 </td><td>29.17 (24.94) </td><td>(&gt;4GB RAM)  </td></tr>
</table>
<p><a class="anchor" id="3Dcomputations"></a></p><h4>3D computations</h4>
<p>The code is set up to also run in 3d. Of course the reference values are different, see [6] for example. High resolution computations are not doable with this example as is, because a direct solver for the velocity block does not work well in 3d. Rather, a parallel solver based on algebraic or geometric multigrid is needed. See below.</p>
<p><a class="anchor" id="Parallelization"></a></p><h4>Parallelization</h4>
<p>For larger computations, especially in 3D, it is necessary to implement MPI parallel solvers and preconditioners. A good starting point would be <a class="el" href="step_55.html">step-55</a>, which uses algebraic multigrid for the velocity block for the Stokes equations. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2008 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Liang Zhao and Timo Heister, Clemson University, 2016</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_gmres.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/solution_transfer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_ilu.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step57</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>StationaryNavierStokes</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StationaryNavierStokes(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> run(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> initialize_system();</div><div class="line">    <span class="keywordtype">void</span> assemble(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">bool</span> assemble_matrix);</div><div class="line">    <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span> assemble_rhs(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span> solve(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line">    <span class="keywordtype">void</span> process_solution(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement);</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> newton_iteration(<span class="keyword">const</span> <span class="keywordtype">double</span> tolerance,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iteration,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinements,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">bool</span> is_initial_step,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">bool</span> output_result);</div><div class="line">    <span class="keywordtype">void</span> compute_initial_guess(<span class="keywordtype">double</span> step_size);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> viscosity;</div><div class="line">    <span class="keywordtype">double</span> gamma;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           degree;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; dofs_per_block;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>           triangulation;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>                fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>              dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>             zero_constraints;</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>             nonzero_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>         sparsity_pattern;</div><div class="line">    <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>    system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>         pressure_mass_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>          present_solution;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>          newton_update;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>          system_rhs;</div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>          evaluation_point;</div><div class="line"></div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues() : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1) {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>   vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point &lt;dim&gt;</a>    &amp;p,</div><div class="line">                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component &lt; this-&gt;n_components,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, this-&gt;n_components));</div><div class="line">    <span class="keywordflow">if</span> (component == 0 &amp;&amp; std::abs(p[dim-1]-1.0) &lt; 1e-10)</div><div class="line">      <span class="keywordflow">return</span> 1.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::vector_value ( <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                           <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values )<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      values(c) = BoundaryValues&lt;dim&gt;::value (p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line">  <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner (<span class="keywordtype">double</span>                                     gamma,</div><div class="line">                              <span class="keywordtype">double</span>                                     viscosity,</div><div class="line">                              <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>            &amp;S,</div><div class="line">                              <span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>                 &amp;P,</div><div class="line">                              <span class="keyword">const</span> PreconditionerMp                     &amp;Mppreconditioner);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult (<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> gamma;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a> &amp;stokes_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> &amp;pressure_mass_matrix;</div><div class="line">    <span class="keyword">const</span> PreconditionerMp &amp;mp_preconditioner;</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_inverse;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line">  BlockSchurPreconditioner&lt;PreconditionerMp&gt;::</div><div class="line">  BlockSchurPreconditioner (<span class="keywordtype">double</span>                           gamma,</div><div class="line">                            <span class="keywordtype">double</span>                           viscosity,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>  &amp;S,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>       &amp;P,</div><div class="line">                            <span class="keyword">const</span> PreconditionerMp           &amp;Mppreconditioner)</div><div class="line">    :</div><div class="line">    gamma                (gamma),</div><div class="line">    viscosity            (viscosity),</div><div class="line">    stokes_matrix        (S),</div><div class="line">    pressure_mass_matrix (P),</div><div class="line">    mp_preconditioner    (Mppreconditioner)</div><div class="line">  {</div><div class="line">    A_inverse.initialize(stokes_matrix.block(0,0));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerMp&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BlockSchurPreconditioner&lt;PreconditionerMp&gt;::</div><div class="line">  vmult (<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>       &amp;dst,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> utmp(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(1000, 1e-6 * src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>    cg (solver_control);</div><div class="line"></div><div class="line">      dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1) = 0.0;</div><div class="line">      cg.solve(pressure_mass_matrix,</div><div class="line">               dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">               mp_preconditioner);</div><div class="line">      dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1) *= -(viscosity+gamma);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      stokes_matrix.block(0,1).vmult(utmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">      utmp *= -1.0;</div><div class="line">      utmp += src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0);</div><div class="line">    }</div><div class="line"></div><div class="line">    A_inverse.vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  StationaryNavierStokes&lt;dim&gt;::StationaryNavierStokes(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    :</div><div class="line">    viscosity(1.0/7500.0),</div><div class="line">    gamma(1.0),</div><div class="line">    degree(degree),</div><div class="line">    triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing),</div><div class="line">    fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree+1), dim,</div><div class="line">       <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(degree),   1),</div><div class="line">    dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    system_matrix.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    pressure_mass_matrix.<a class="code" href="classSparseMatrix.html#a45f664681373fd3a1f8dd965395d360d">clear</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; block_component(dim+1, 0);</div><div class="line">    block_component[dim] = 1;</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> (dof_handler, block_component);</div><div class="line"></div><div class="line">    dofs_per_block.resize (2);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#abfd9796e22113e13b5802e384e56af4f">DoFTools::count_dofs_per_block</a> (dof_handler, dofs_per_block, block_component);</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_u = dofs_per_block[0];</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_p = dofs_per_block[1];</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    {</div><div class="line">      nonzero_constraints.clear();</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a>(dof_handler, nonzero_constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               BoundaryValues&lt;dim&gt;(),</div><div class="line">                                               nonzero_constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">    }</div><div class="line">    nonzero_constraints.close();</div><div class="line"></div><div class="line">    {</div><div class="line">      zero_constraints.clear();</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a>(dof_handler, zero_constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+1),</div><div class="line">                                               zero_constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocities));</div><div class="line">    }</div><div class="line">    zero_constraints.close();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; dof_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; dof_p &lt;&lt; <span class="charliteral">&#39;)&#39;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::initialize_system()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp (dofs_per_block, dofs_per_block);</div><div class="line">      <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp, nonzero_constraints);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a> (dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">    present_solution.reinit (dofs_per_block);</div><div class="line">    newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dofs_per_block);</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dofs_per_block);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::assemble(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">bool</span> assemble_matrix)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (assemble_matrix)</div><div class="line">      system_matrix    = 0;</div><div class="line"></div><div class="line">    system_rhs       = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(degree+2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe,</div><div class="line">                             quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   local_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       local_rhs    (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt; &gt;  present_velocity_values    (n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt; &gt;  present_velocity_gradients (n_q_points);</div><div class="line">    std::vector&lt;double&gt;           present_pressure_values    (n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;           div_phi_u                 (dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt; &gt;  phi_u                     (dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt; &gt;  grad_phi_u                (dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;           phi_p                     (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a>(cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(evaluation_point,</div><div class="line">                                                  present_velocity_values);</div><div class="line"></div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">get_function_gradients</a>(evaluation_point,</div><div class="line">                                                     present_velocity_gradients);</div><div class="line"></div><div class="line">        fe_values[pressure].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(evaluation_point,</div><div class="line">                                                present_pressure_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                div_phi_u[k]  =  fe_values[velocities].divergence (k, q);</div><div class="line">                grad_phi_u[k] =  fe_values[velocities].gradient(k, q);</div><div class="line">                phi_u[k]      =  fe_values[velocities].value(k, q);</div><div class="line">                phi_p[k]      =  fe_values[pressure]  .value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (assemble_matrix)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                      {</div><div class="line">                        local_matrix(i, j) += (  viscosity*scalar_product(grad_phi_u[j], grad_phi_u[i])</div><div class="line">                                                 + present_velocity_gradients[q]*phi_u[j]*phi_u[i]</div><div class="line">                                                 + grad_phi_u[j]*present_velocity_values[q]*phi_u[i]</div><div class="line">                                                 - div_phi_u[i]*phi_p[j]</div><div class="line">                                                 - phi_p[i]*div_phi_u[j]</div><div class="line">                                                 + gamma*div_phi_u[j]*div_phi_u[i]</div><div class="line">                                                 + phi_p[i] * phi_p[j])</div><div class="line">                                              * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordtype">double</span> present_velocity_divergence =  trace(present_velocity_gradients[q]);</div><div class="line">                local_rhs(i) += ( - viscosity*scalar_product(present_velocity_gradients[q],grad_phi_u[i])</div><div class="line">                                  - present_velocity_gradients[q]*present_velocity_values[q]*phi_u[i]</div><div class="line">                                  + present_pressure_values[q]*div_phi_u[i]</div><div class="line">                                  + present_velocity_divergence*phi_p[i]</div><div class="line">                                  - gamma*present_velocity_divergence*div_phi_u[i])</div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints_used = initial_step ? nonzero_constraints : zero_constraints;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (assemble_matrix)</div><div class="line">          {</div><div class="line">            constraints_used.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a>(local_matrix,</div><div class="line">                                                        local_rhs,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        system_matrix,</div><div class="line">                                                        system_rhs);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            constraints_used.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a>(local_rhs,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        system_rhs);</div><div class="line">          }</div><div class="line"></div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (assemble_matrix)</div><div class="line">      {</div><div class="line"></div><div class="line">        pressure_mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(sparsity_pattern.<a class="code" href="classBlockSparsityPatternBase.html#a3b5d5639d633f6cf9f131614c2bdc3b3">block</a>(1,1));</div><div class="line">        pressure_mass_matrix.<a class="code" href="classSparseMatrix.html#a104b9a4c9fc720b0201e7668b058e3d1">copy_from</a>(system_matrix.block(1,1));</div><div class="line"></div><div class="line">        system_matrix.block(1,1) = 0;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    assemble(initial_step, <span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::assemble_rhs(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    assemble(initial_step, <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::solve (<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraints_used = initial_step ? nonzero_constraints : zero_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.m(), 1e-4*system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>(), <span class="keyword">true</span>);</div><div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;BlockVector&lt;double&gt;</a> &gt; gmres(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> pmass_preconditioner;</div><div class="line">    pmass_preconditioner.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a> (pressure_mass_matrix,</div><div class="line">                                     <a class="code" href="classSparseLUDecomposition_1_1AdditionalData.html">SparseILU&lt;double&gt;::AdditionalData</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> BlockSchurPreconditioner&lt;SparseILU&lt;double&gt; &gt;</div><div class="line">    preconditioner (gamma,</div><div class="line">                    viscosity,</div><div class="line">                    system_matrix,</div><div class="line">                    pressure_mass_matrix,</div><div class="line">                    pmass_preconditioner);</div><div class="line"></div><div class="line">    gmres.solve (system_matrix,</div><div class="line">                 newton_update,</div><div class="line">                 system_rhs,</div><div class="line">                 preconditioner);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; ****FGMRES steps: &quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints_used.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(degree+1),</div><div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                        present_solution,</div><div class="line">                                        estimated_error_per_cell,</div><div class="line">                                        fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(velocity));</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                     estimated_error_per_cell,</div><div class="line">                                                     0.3, 0.0);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, BlockVector&lt;double&gt;</a> &gt; solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(present_solution);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> tmp (dofs_per_block);</div><div class="line"></div><div class="line">    solution_transfer.interpolate(present_solution, tmp);</div><div class="line">    nonzero_constraints.distribute(tmp);</div><div class="line"></div><div class="line">    initialize_system();</div><div class="line">    present_solution = tmp;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::newton_iteration(<span class="keyword">const</span> <span class="keywordtype">double</span> tolerance,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iteration,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_refinement,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">bool</span>  is_initial_step,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">bool</span>  output_result)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">double</span> current_res;</div><div class="line">    <span class="keywordtype">double</span> last_res;</div><div class="line">    <span class="keywordtype">bool</span>   first_step = is_initial_step;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement = 0; refinement &lt; max_refinement+1; ++refinement)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> outer_iteration = 0;</div><div class="line">        last_res = 1.0;</div><div class="line">        current_res = 1.0;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;************  refinement = &quot;</span> &lt;&lt; refinement &lt;&lt; <span class="stringliteral">&quot; ************ &quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;viscosity= &quot;</span> &lt;&lt; viscosity &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">while</span> ((first_step || (current_res &gt; tolerance)) &amp;&amp; outer_iteration &lt; max_iteration)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (first_step)</div><div class="line">              {</div><div class="line">                setup_dofs();</div><div class="line">                initialize_system();</div><div class="line">                evaluation_point = present_solution;</div><div class="line">                assemble_system(first_step);</div><div class="line">                solve(first_step);</div><div class="line">                present_solution = newton_update;</div><div class="line">                nonzero_constraints.distribute(present_solution);</div><div class="line">                first_step = <span class="keyword">false</span>;</div><div class="line">                evaluation_point = present_solution;</div><div class="line">                assemble_rhs(first_step);</div><div class="line">                current_res = system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;******************************&quot;</span> &lt;&lt; std::endl;</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot; The residual of initial guess is &quot;</span> &lt;&lt; current_res &lt;&lt; std::endl;</div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot; Initialization complete!  &quot;</span> &lt;&lt; std::endl;</div><div class="line">                last_res = current_res;</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                evaluation_point = present_solution;</div><div class="line">                assemble_system(first_step);</div><div class="line">                solve(first_step);</div><div class="line"></div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">double</span> alpha = 1.0; alpha &gt; 1e-5; alpha *= 0.5)</div><div class="line">                  {</div><div class="line">                    evaluation_point = present_solution;</div><div class="line">                    evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update);</div><div class="line">                    nonzero_constraints.distribute(evaluation_point);</div><div class="line">                    assemble_rhs(first_step);</div><div class="line">                    current_res = system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot; alpha = &quot;</span> &lt;&lt; std::setw(6) &lt;&lt; alpha &lt;&lt; std::setw(0)</div><div class="line">                              &lt;&lt; <span class="stringliteral">&quot; res = &quot;</span> &lt;&lt; current_res &lt;&lt; std::endl;</div><div class="line">                    <span class="keywordflow">if</span> (current_res &lt; last_res)</div><div class="line">                      <span class="keywordflow">break</span>;</div><div class="line">                  }</div><div class="line">                {</div><div class="line">                  present_solution = evaluation_point;</div><div class="line">                  std::cout &lt;&lt; <span class="stringliteral">&quot; ---- Iteration &quot;</span> &lt;&lt; outer_iteration &lt;&lt; <span class="stringliteral">&quot; residual: &quot;</span> &lt;&lt; current_res &lt;&lt; std::endl;</div><div class="line">                  last_res = current_res;</div><div class="line">                }</div><div class="line"></div><div class="line">              }</div><div class="line">            ++outer_iteration;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (output_result)</div><div class="line">              {</div><div class="line">                output_results (max_iteration*refinement+outer_iteration);</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (current_res &lt;= tolerance)</div><div class="line">                  process_solution(refinement);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement &lt; max_refinement)</div><div class="line">          {</div><div class="line">            refine_mesh();</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot;        Do refinement ------   &quot;</span> &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::compute_initial_guess(<span class="keywordtype">double</span> step_size)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> target_Re = 1.0/viscosity;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> is_initial_step = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> Re=1000.0; Re &lt; target_Re; Re = std::min(Re+step_size, target_Re))</div><div class="line">      {</div><div class="line">        viscosity = 1.0/Re;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Searching for initial guess with Re = &quot;</span> &lt;&lt; Re &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        newton_iteration(1e-12, 50, 0, is_initial_step, <span class="keyword">false</span>);</div><div class="line">        is_initial_step = <span class="keyword">false</span>;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_index)<span class="keyword">  const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names (dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation</div><div class="line">    (dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation</div><div class="line">    .push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (present_solution, solution_names,</div><div class="line">                              <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                              data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">    std::ostringstream filename;</div><div class="line">    filename &lt;&lt; 1.0/viscosity</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot;-solution-&quot;</span></div><div class="line">             &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (output_index, 4)</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line"></div><div class="line">    std::ofstream output (filename.str().c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::process_solution(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement)</div><div class="line">  {</div><div class="line">    std::ostringstream filename;</div><div class="line">    filename &lt;&lt; (1.0/viscosity) &lt;&lt; <span class="stringliteral">&quot;-line-&quot;</span> &lt;&lt; refinement &lt;&lt; <span class="stringliteral">&quot;.txt&quot;</span>;</div><div class="line"></div><div class="line">    std::ofstream f (filename.str().c_str());</div><div class="line">    f &lt;&lt; <span class="stringliteral">&quot;# y u_x u_y&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p;</div><div class="line">    p(0)= 0.5;</div><div class="line">    p(1)= 0.5;</div><div class="line"></div><div class="line">    f &lt;&lt; std::scientific;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;=100; ++i)</div><div class="line">      {</div><div class="line">        p(dim-1) = i/100.0;</div><div class="line"></div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp_vector(dim+1);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#aaee3adabb3fb97ac5d8996cd712b20e1">VectorTools::point_value</a>(dof_handler, present_solution, p, tmp_vector);</div><div class="line">        f &lt;&lt; p(dim-1);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;dim; j++)</div><div class="line">          f &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; tmp_vector(j);</div><div class="line">        f &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StationaryNavierStokes&lt;dim&gt;::run(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement)</div><div class="line">  {</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> Re =  1.0/viscosity;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (Re &gt; 1000.0)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;       Searching for initial guess ... &quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> step_size = 2000.0;</div><div class="line">        compute_initial_guess(step_size);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;       Initial guess obtained            &quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;                  *                      &quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;                  *                      &quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;                  *                      &quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;                  *                      &quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;       Computing solution with target Re = &quot;</span> &lt;&lt; Re &lt;&lt; std::endl;</div><div class="line">        viscosity = 1.0/Re;</div><div class="line">        newton_iteration(1e-12, 50, refinement, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line"></div><div class="line">        newton_iteration(1e-12, 50, refinement, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step57;</div><div class="line"></div><div class="line">      StationaryNavierStokes&lt;2&gt; flow(<span class="comment">/* degree = */</span>1);</div><div class="line">      flow.run(4);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
