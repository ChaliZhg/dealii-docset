<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MatrixFree&lt; dim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMatrixFree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MatrixFree&lt; dim, Number &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="matrix__free_8h_source.html">deal.II/matrix_free/matrix_free.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MatrixFree&lt; dim, Number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMatrixFree__inherit__graph.svg" width="195" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">1: Construction and initialization</div></td></tr>
<tr class="memitem:aa1a67353d69cf79108efc2b2a576496e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa1a67353d69cf79108efc2b2a576496e">MatrixFree</a> ()</td></tr>
<tr class="separator:aa1a67353d69cf79108efc2b2a576496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa790532ac73973ce9e06fd36cb919d3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa790532ac73973ce9e06fd36cb919d3a">MatrixFree</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;other)</td></tr>
<tr class="separator:aa790532ac73973ce9e06fd36cb919d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1103f9bc3a5ff09027e68eca4010d88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad1103f9bc3a5ff09027e68eca4010d88">~MatrixFree</a> ()</td></tr>
<tr class="separator:ad1103f9bc3a5ff09027e68eca4010d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8999754a8b1501b3d3797fac6e61ba81"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename QuadratureType &gt; </td></tr>
<tr class="memitem:a8999754a8b1501b3d3797fac6e61ba81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8999754a8b1501b3d3797fac6e61ba81">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const DoFHandlerType &amp;dof_handler, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a8999754a8b1501b3d3797fac6e61ba81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe2c234d691373f2d3acaa6682b034b"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename QuadratureType &gt; </td></tr>
<tr class="memitem:a2fe2c234d691373f2d3acaa6682b034b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2fe2c234d691373f2d3acaa6682b034b">reinit</a> (const DoFHandlerType &amp;dof_handler, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a2fe2c234d691373f2d3acaa6682b034b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8053302b07f1fb5aa9c2233483d26d"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename QuadratureType &gt; </td></tr>
<tr class="memitem:a8c8053302b07f1fb5aa9c2233483d26d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8c8053302b07f1fb5aa9c2233483d26d">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const DoFHandlerType &amp;dof_handler, const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;constraint, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_dofs, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()) 1</td></tr>
<tr class="separator:a8c8053302b07f1fb5aa9c2233483d26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2aa786fc9abde4abbc60c10323b816"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename QuadratureType &gt; </td></tr>
<tr class="memitem:aec2aa786fc9abde4abbc60c10323b816"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aec2aa786fc9abde4abbc60c10323b816">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:aec2aa786fc9abde4abbc60c10323b816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e5270ec645199013503d2a3884fb33"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename QuadratureType &gt; </td></tr>
<tr class="memitem:a31e5270ec645199013503d2a3884fb33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a31e5270ec645199013503d2a3884fb33">reinit</a> (const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a31e5270ec645199013503d2a3884fb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9022d7a67654a0ed82547b03ec3743"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename QuadratureType &gt; </td></tr>
<tr class="memitem:a6d9022d7a67654a0ed82547b03ec3743"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6d9022d7a67654a0ed82547b03ec3743">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()) 1</td></tr>
<tr class="separator:a6d9022d7a67654a0ed82547b03ec3743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0b560738948f6b8041e452ad32a9aa"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename QuadratureType &gt; </td></tr>
<tr class="memitem:a2e0b560738948f6b8041e452ad32a9aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2e0b560738948f6b8041e452ad32a9aa">reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a2e0b560738948f6b8041e452ad32a9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c76c26a70824aedda1a91f61fdde91"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename QuadratureType &gt; </td></tr>
<tr class="memitem:a79c76c26a70824aedda1a91f61fdde91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a79c76c26a70824aedda1a91f61fdde91">reinit</a> (const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a79c76c26a70824aedda1a91f61fdde91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ea8c23f9dd724c4bdba90920c89dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af0ea8c23f9dd724c4bdba90920c89dae">copy_from</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;matrix_free_base)</td></tr>
<tr class="separator:af0ea8c23f9dd724c4bdba90920c89dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada65411919b8f5cac76c36f7f510ccc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ada65411919b8f5cac76c36f7f510ccc9">clear</a> ()</td></tr>
<tr class="separator:ada65411919b8f5cac76c36f7f510ccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2: Loop over cells</div></td></tr>
<tr class="memitem:a523c939c0f87d8ad17d81bb3a2667b02"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a523c939c0f87d8ad17d81bb3a2667b02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a523c939c0f87d8ad17d81bb3a2667b02">cell_loop</a> (const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned int, unsigned int &gt; &amp;)&gt; &amp;cell_operation, OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a523c939c0f87d8ad17d81bb3a2667b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24292e5886a4a2fe8cf1d89bbcb8b6e"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:af24292e5886a4a2fe8cf1d89bbcb8b6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af24292e5886a4a2fe8cf1d89bbcb8b6e">cell_loop</a> (void(CLASS::*function_pointer)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned int, unsigned int &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:af24292e5886a4a2fe8cf1d89bbcb8b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef043b8cef13b1e3b8776ec1c1d1d41f"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:aef043b8cef13b1e3b8776ec1c1d1d41f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aef043b8cef13b1e3b8776ec1c1d1d41f">cell_loop</a> (void(CLASS::*function_pointer)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned int, unsigned int &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:aef043b8cef13b1e3b8776ec1c1d1d41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaced6b21522068599a10e5f57d904ddc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aaced6b21522068599a10e5f57d904ddc">create_cell_subrange_hp</a> (const std::pair&lt; unsigned int, unsigned int &gt; &amp;range, const unsigned int fe_degree, const unsigned int vector_component=0) const</td></tr>
<tr class="separator:aaced6b21522068599a10e5f57d904ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc902400294dfa2c79cb7c5f898283b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aecc902400294dfa2c79cb7c5f898283b">create_cell_subrange_hp_by_index</a> (const std::pair&lt; unsigned int, unsigned int &gt; &amp;range, const unsigned int fe_index, const unsigned int vector_component=0) const</td></tr>
<tr class="separator:aecc902400294dfa2c79cb7c5f898283b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3: Initialization of vectors</div></td></tr>
<tr class="memitem:a254dd56fdce3104116caf6099f003467"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a254dd56fdce3104116caf6099f003467"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a254dd56fdce3104116caf6099f003467">initialize_dof_vector</a> (VectorType &amp;vec, const unsigned int vector_component=0) const</td></tr>
<tr class="separator:a254dd56fdce3104116caf6099f003467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ccfe4bec382fef3cac5db878e389ab"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ae9ccfe4bec382fef3cac5db878e389ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ae9ccfe4bec382fef3cac5db878e389ab">initialize_dof_vector</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number2 &gt; &amp;vec, const unsigned int vector_component=0) const</td></tr>
<tr class="separator:ae9ccfe4bec382fef3cac5db878e389ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3a5c54630c23a6cdf5a7afe7c177d2"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2d3a5c54630c23a6cdf5a7afe7c177d2">get_vector_partitioner</a> (const unsigned int vector_component=0) const</td></tr>
<tr class="separator:a2d3a5c54630c23a6cdf5a7afe7c177d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6199d3bb4d57afa7853de8cf5260d9b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ae6199d3bb4d57afa7853de8cf5260d9b">get_locally_owned_set</a> (const unsigned int fe_component=0) const</td></tr>
<tr class="separator:ae6199d3bb4d57afa7853de8cf5260d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c039966dc34104dcd7e9d03291aa85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad7c039966dc34104dcd7e9d03291aa85">get_ghost_set</a> (const unsigned int fe_component=0) const</td></tr>
<tr class="separator:ad7c039966dc34104dcd7e9d03291aa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31a0eee233848b9661579f1087d654f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad31a0eee233848b9661579f1087d654f">get_constrained_dofs</a> (const unsigned int fe_component=0) const</td></tr>
<tr class="separator:ad31a0eee233848b9661579f1087d654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cab744529aef389a126a74e825eabb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9cab744529aef389a126a74e825eabb6">renumber_dofs</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering, const unsigned int vector_component=0)</td></tr>
<tr class="separator:a9cab744529aef389a126a74e825eabb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">5: Access of internal data structure (expert mode)</div></td></tr>
<tr class="memitem:ac52e418ce7e67af6dba4d09cd1e5cca1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac52e418ce7e67af6dba4d09cd1e5cca1">get_task_info</a> () const</td></tr>
<tr class="separator:ac52e418ce7e67af6dba4d09cd1e5cca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673b540c48a2b84225373848925a07c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1SizeInfo.html">internal::MatrixFreeFunctions::SizeInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a673b540c48a2b84225373848925a07c3">get_size_info</a> () const</td></tr>
<tr class="separator:a673b540c48a2b84225373848925a07c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6190fea0f4990a7a6e909ec0ed1d206"><td class="memItemLeft" align="right" valign="top"><a id="ad6190fea0f4990a7a6e909ec0ed1d206"></a>
const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt; dim, Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_mapping_info</b> () const</td></tr>
<tr class="separator:ad6190fea0f4990a7a6e909ec0ed1d206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29ff9be2f8714a22eea34bb89a482c6"><td class="memItemLeft" align="right" valign="top">const internal::MatrixFreeFunctions::DoFInfo &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad29ff9be2f8714a22eea34bb89a482c6">get_dof_info</a> (const unsigned int fe_component=0) const</td></tr>
<tr class="separator:ad29ff9be2f8714a22eea34bb89a482c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d7935c4ceb824757db814693ebe269"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a48d7935c4ceb824757db814693ebe269">n_constraint_pool_entries</a> () const</td></tr>
<tr class="separator:a48d7935c4ceb824757db814693ebe269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72827d984d40fbd9f29bd2015f158679"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a72827d984d40fbd9f29bd2015f158679">constraint_pool_begin</a> (const unsigned int pool_index) const</td></tr>
<tr class="separator:a72827d984d40fbd9f29bd2015f158679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489e824b58927febccdee07738350e49"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a489e824b58927febccdee07738350e49">constraint_pool_end</a> (const unsigned int pool_index) const</td></tr>
<tr class="separator:a489e824b58927febccdee07738350e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4e50ad204d7de0460b72d85fee4dc3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4c4e50ad204d7de0460b72d85fee4dc3">get_shape_info</a> (const unsigned int fe_component=0, const unsigned int quad_index=0, const unsigned int hp_active_fe_index=0, const unsigned int hp_active_quad_index=0) const</td></tr>
<tr class="separator:a4c4e50ad204d7de0460b72d85fee4dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac703a39e958f59adb9fbe609e349b9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac703a39e958f59adb9fbe609e349b9c9">acquire_scratch_data</a> () const</td></tr>
<tr class="separator:ac703a39e958f59adb9fbe609e349b9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1665768e1aef8c2a040bbc27b87a0912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1665768e1aef8c2a040bbc27b87a0912">release_scratch_data</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number &gt; &gt; *memory) const</td></tr>
<tr class="separator:a1665768e1aef8c2a040bbc27b87a0912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae193296e6b480871346e50e3e6945787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ae193296e6b480871346e50e3e6945787">internal_reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; 1 &gt; &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data)</td></tr>
<tr class="separator:ae193296e6b480871346e50e3e6945787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec657438ad47b1dbb138c6f9e96b38a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aec657438ad47b1dbb138c6f9e96b38a8">internal_reinit</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const std::vector&lt; const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; 1 &gt; &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> additional_data)</td></tr>
<tr class="separator:aec657438ad47b1dbb138c6f9e96b38a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab40dd4a77c27332d5712c014c87312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8ab40dd4a77c27332d5712c014c87312">initialize_indices</a> (const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set)</td></tr>
<tr class="separator:a8ab40dd4a77c27332d5712c014c87312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4d5707c95caf6fada36143b74d4521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0f4d5707c95caf6fada36143b74d4521">initialize_dof_handlers</a> (const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;<a class="el" href="classMatrixFree.html#a057e94bb1e5a222bc314479fa29d31ed">dof_handlers</a>, const unsigned int level)</td></tr>
<tr class="separator:a0f4d5707c95caf6fada36143b74d4521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d99f3980f143735380e36fac259a00b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4d99f3980f143735380e36fac259a00b">initialize_dof_handlers</a> (const std::vector&lt; const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; *&gt; &amp;<a class="el" href="classMatrixFree.html#a057e94bb1e5a222bc314479fa29d31ed">dof_handlers</a>, const unsigned int level)</td></tr>
<tr class="separator:a4d99f3980f143735380e36fac259a00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a057e94bb1e5a222bc314479fa29d31ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a057e94bb1e5a222bc314479fa29d31ed">dof_handlers</a></td></tr>
<tr class="separator:a057e94bb1e5a222bc314479fa29d31ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809308f14c114b50967bae3c274c8c70"><td class="memItemLeft" align="right" valign="top">std::vector&lt; internal::MatrixFreeFunctions::DoFInfo &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a809308f14c114b50967bae3c274c8c70">dof_info</a></td></tr>
<tr class="separator:a809308f14c114b50967bae3c274c8c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19632f7ddcd8ccd6cf53ffd0e4564098"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a19632f7ddcd8ccd6cf53ffd0e4564098">constraint_pool_data</a></td></tr>
<tr class="separator:a19632f7ddcd8ccd6cf53ffd0e4564098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b1125b841a2e45709d1e008c943626"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a26b1125b841a2e45709d1e008c943626">constraint_pool_row_index</a></td></tr>
<tr class="separator:a26b1125b841a2e45709d1e008c943626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd233be90c57c51be1107d8643daf25c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt; dim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#acd233be90c57c51be1107d8643daf25c">mapping_info</a></td></tr>
<tr class="separator:acd233be90c57c51be1107d8643daf25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22928fb178a580ecf368fd657982ddcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 4, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; Number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a22928fb178a580ecf368fd657982ddcf">shape_info</a></td></tr>
<tr class="separator:a22928fb178a580ecf368fd657982ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe96d5df46f76ca3d98ef57ec27a5e2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a7fe96d5df46f76ca3d98ef57ec27a5e2">cell_level_index</a></td></tr>
<tr class="separator:a7fe96d5df46f76ca3d98ef57ec27a5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e4ee0c4f798956a22383f1f9e9eb6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1SizeInfo.html">internal::MatrixFreeFunctions::SizeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a23e4ee0c4f798956a22383f1f9e9eb6d">size_info</a></td></tr>
<tr class="separator:a23e4ee0c4f798956a22383f1f9e9eb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33df2e9baaab5baa8032c70eebbc7951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a33df2e9baaab5baa8032c70eebbc7951">task_info</a></td></tr>
<tr class="separator:a33df2e9baaab5baa8032c70eebbc7951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d6c660ceb8d60fc2584e1fb57961df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a88d6c660ceb8d60fc2584e1fb57961df">indices_are_initialized</a></td></tr>
<tr class="separator:a88d6c660ceb8d60fc2584e1fb57961df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94607b35b2b190f93608fbb2bd07d837"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a94607b35b2b190f93608fbb2bd07d837">mapping_is_initialized</a></td></tr>
<tr class="separator:a94607b35b2b190f93608fbb2bd07d837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985badc35ecb59cb4df28f244bdf6a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; std::list&lt; std::pair&lt; bool, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a985badc35ecb59cb4df28f244bdf6a21">scratch_pad</a></td></tr>
<tr class="separator:a985badc35ecb59cb4df28f244bdf6a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
4: General information</h2></td></tr>
<tr class="memitem:a1af7c60f93329604788066981737462a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1af7c60f93329604788066981737462a">n_components</a> () const</td></tr>
<tr class="separator:a1af7c60f93329604788066981737462a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97351f7a44d67f656d96571ec6a8c83"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad97351f7a44d67f656d96571ec6a8c83">n_physical_cells</a> () const</td></tr>
<tr class="separator:ad97351f7a44d67f656d96571ec6a8c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9143bf7be90031800cf8fcffbb5b0aaf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9143bf7be90031800cf8fcffbb5b0aaf">n_macro_cells</a> () const</td></tr>
<tr class="separator:a9143bf7be90031800cf8fcffbb5b0aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de2d8b643a39ae3d4628fe930ca97ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6de2d8b643a39ae3d4628fe930ca97ea">get_dof_handler</a> (const unsigned int fe_component=0) const</td></tr>
<tr class="separator:a6de2d8b643a39ae3d4628fe930ca97ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7db9ef51c24f2796c70caec8718c74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;::cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a5e7db9ef51c24f2796c70caec8718c74">get_cell_iterator</a> (const unsigned int macro_cell_number, const unsigned int vector_number, const unsigned int fe_component=0) const</td></tr>
<tr class="separator:a5e7db9ef51c24f2796c70caec8718c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26682ebec4187d45f52d2eee4b361218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt;::active_cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a26682ebec4187d45f52d2eee4b361218">get_hp_cell_iterator</a> (const unsigned int macro_cell_number, const unsigned int vector_number, const unsigned int fe_component=0) const</td></tr>
<tr class="separator:a26682ebec4187d45f52d2eee4b361218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2e6f411e70d007950bfc3e814d4795"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4f2e6f411e70d007950bfc3e814d4795">at_irregular_cell</a> (const unsigned int macro_cell_number) const</td></tr>
<tr class="separator:a4f2e6f411e70d007950bfc3e814d4795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d2bfd6d4a6e164b919eb9f69259b90"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac6d2bfd6d4a6e164b919eb9f69259b90">n_components_filled</a> (const unsigned int macro_cell_number) const</td></tr>
<tr class="separator:ac6d2bfd6d4a6e164b919eb9f69259b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7497379eabc615164102ce7e94b44a71"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a7497379eabc615164102ce7e94b44a71">get_dofs_per_cell</a> (const unsigned int fe_component=0, const unsigned int hp_active_fe_index=0) const</td></tr>
<tr class="separator:a7497379eabc615164102ce7e94b44a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c84d1051d3600fd53ba9e0195d7310"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a19c84d1051d3600fd53ba9e0195d7310">get_n_q_points</a> (const unsigned int quad_index=0, const unsigned int hp_active_fe_index=0) const</td></tr>
<tr class="separator:a19c84d1051d3600fd53ba9e0195d7310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b415c592ce9ca9c07fe26f62b6653e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a12b415c592ce9ca9c07fe26f62b6653e">get_dofs_per_face</a> (const unsigned int fe_component=0, const unsigned int hp_active_fe_index=0) const</td></tr>
<tr class="separator:a12b415c592ce9ca9c07fe26f62b6653e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7190a076084bcfb3a4e79eef3ca05cd0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a7190a076084bcfb3a4e79eef3ca05cd0">get_n_q_points_face</a> (const unsigned int quad_index=0, const unsigned int hp_active_fe_index=0) const</td></tr>
<tr class="separator:a7190a076084bcfb3a4e79eef3ca05cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd0d08351f31bdcc50efb65068544f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#addd0d08351f31bdcc50efb65068544f4">get_quadrature</a> (const unsigned int quad_index=0, const unsigned int hp_active_fe_index=0) const</td></tr>
<tr class="separator:addd0d08351f31bdcc50efb65068544f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cffd94649edc6ad64bc1648843c2b83"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9cffd94649edc6ad64bc1648843c2b83">get_face_quadrature</a> (const unsigned int quad_index=0, const unsigned int hp_active_fe_index=0) const</td></tr>
<tr class="separator:a9cffd94649edc6ad64bc1648843c2b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5167548d93deb20a938868fb63bd469c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a5167548d93deb20a938868fb63bd469c">indices_initialized</a> () const</td></tr>
<tr class="separator:a5167548d93deb20a938868fb63bd469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20997407cf1d40d0bf32f7bdb75b149"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac20997407cf1d40d0bf32f7bdb75b149">mapping_initialized</a> () const</td></tr>
<tr class="separator:ac20997407cf1d40d0bf32f7bdb75b149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8432b77b9796e2f6d04d7c1d81e34903"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8432b77b9796e2f6d04d7c1d81e34903">memory_consumption</a> () const</td></tr>
<tr class="separator:a8432b77b9796e2f6d04d7c1d81e34903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183262825e9f6668e1b08fa7840048ae"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:a183262825e9f6668e1b08fa7840048ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a183262825e9f6668e1b08fa7840048ae">print_memory_consumption</a> (StreamType &amp;out) const</td></tr>
<tr class="separator:a183262825e9f6668e1b08fa7840048ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae88b0e439247b3e5c19693b83af8192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aae88b0e439247b3e5c19693b83af8192">print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aae88b0e439247b3e5c19693b83af8192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c89cfe10214bbc1387d940928ebdee"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:ab8c89cfe10214bbc1387d940928ebdee"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab8c89cfe10214bbc1387d940928ebdee">is_supported</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:ab8c89cfe10214bbc1387d940928ebdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename Number = double&gt;<br />
class MatrixFree&lt; dim, Number &gt;</h3>

<p>This class collects all the data that is stored for the matrix free implementation. The storage scheme is tailored towards several loops performed with the same data, i.e., typically doing many matrix-vector products or residual computations on the same mesh. The class is used in <a class="el" href="step_37.html">step-37</a> and <a class="el" href="step_48.html">step-48</a>.</p>
<p>This class does not implement any operations involving finite element basis functions, i.e., regarding the operation performed on the cells. For these operations, the class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> is designed to use the data collected in this class.</p>
<p>The stored data can be subdivided into three main components:</p>
<ul>
<li>DoFInfo: It stores how local degrees of freedom relate to global degrees of freedom. It includes a description of constraints that are evaluated as going through all local degrees of freedom on a cell.</li>
<li>MappingInfo: It stores the transformations from real to unit cells that are necessary in order to build derivatives of finite element functions and find location of quadrature weights in physical space.</li>
<li>ShapeInfo: It contains the shape functions of the finite element, evaluated on the unit cell.</li>
</ul>
<p>Besides the initialization routines, this class implements only a single operation, namely a loop over all cells (<a class="el" href="classMatrixFree.html#a523c939c0f87d8ad17d81bb3a2667b02">cell_loop()</a>). This loop is scheduled in such a way that cells that share degrees of freedom are not worked on simultaneously, which implies that it is possible to write to vectors (or matrices) in parallel without having to explicitly synchronize access to these vectors and matrices. This class does not implement any shape values, all it does is to cache the respective data. To implement finite element operations, use the class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> (or some of the related classes).</p>
<p>This class traverses the cells in a different order than the usual <a class="el" href="classTriangulation.html">Triangulation</a> class in deal.II, in order to be flexible with respect to parallelization in shared memory and vectorization.</p>
<p>Vectorization is implemented by merging several topological cells into one so-called macro cell. This enables the application of all cell-related operations for several cells with one CPU instruction and is one of the main features of this framework.</p>
<p>For details on usage of this class, see the description of <a class="el" href="classFEEvaluation.html">FEEvaluation</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Katharina Kormann, Martin Kronbichler, 2010, 2011 </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00109">109</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa1a67353d69cf79108efc2b2a576496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a67353d69cf79108efc2b2a576496e">&#9670;&nbsp;</a></span>MatrixFree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default empty constructor. Does nothing. </p>

</div>
</div>
<a id="aa790532ac73973ce9e06fd36cb919d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa790532ac73973ce9e06fd36cb919d3a">&#9670;&nbsp;</a></span>MatrixFree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor, calls copy_from </p>

</div>
</div>
<a id="ad1103f9bc3a5ff09027e68eca4010d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1103f9bc3a5ff09027e68eca4010d88">&#9670;&nbsp;</a></span>~MatrixFree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::~<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8999754a8b1501b3d3797fac6e61ba81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8999754a8b1501b3d3797fac6e61ba81">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename QuadratureType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the information needed to perform loops over cells. The <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> describe the layout of degrees of freedom, the <a class="el" href="classDoFHandler.html">DoFHandler</a> and the mapping describe the transformations from unit to real cell, and the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> together with the quadrature formula describe the local operations. Note that the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> must either be scalar or contain several copies of the same element. Mixing several different elements into one <a class="el" href="classFESystem.html">FESystem</a> is not allowed. In that case, use the initialization function with several <a class="el" href="classDoFHandler.html">DoFHandler</a> arguments. </p>

</div>
</div>
<a id="a2fe2c234d691373f2d3acaa6682b034b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe2c234d691373f2d3acaa6682b034b">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename QuadratureType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> mapping. </p>

</div>
</div>
<a id="a8c8053302b07f1fb5aa9c2233483d26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8053302b07f1fb5aa9c2233483d26d">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename QuadratureType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000098">Deprecated:</a></b></dt><dd>Setting the index set specifically is not supported any more. Use the reinit function without index set argument to choose the one provided by <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a>. </dd></dl>

</div>
</div>
<a id="aec2aa786fc9abde4abbc60c10323b816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2aa786fc9abde4abbc60c10323b816">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename QuadratureType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the information needed to perform loops over cells. The <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> describe the layout of degrees of freedom, the <a class="el" href="classDoFHandler.html">DoFHandler</a> and the mapping describe the transformations from unit to real cell, and the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> together with the quadrature formula describe the local operations. As opposed to the scalar case treated with the other initialization functions, this function allows for problems with two or more different finite elements. The <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> to each element must be passed as pointers to the initialization function. Note that the finite element underlying an <a class="el" href="classDoFHandler.html">DoFHandler</a> must either be scalar or contain several copies of the same element. Mixing several different elements into one <code>FE_System</code> is not allowed.</p>
<p>This function also allows for using several quadrature formulas, e.g. when the description contains independent integrations of elements of different degrees. However, the number of different quadrature formulas can be sets independently from the number of <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a>, when several elements are always integrated with the same quadrature formula. </p>

</div>
</div>
<a id="a31e5270ec645199013503d2a3884fb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e5270ec645199013503d2a3884fb33">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename QuadratureType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> mapping. </p>

</div>
</div>
<a id="a6d9022d7a67654a0ed82547b03ec3743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9022d7a67654a0ed82547b03ec3743">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename QuadratureType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000099">Deprecated:</a></b></dt><dd>Setting the index set specifically is not supported any more. Use the reinit function without index set argument to choose the one provided by <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a>. </dd></dl>

</div>
</div>
<a id="a2e0b560738948f6b8041e452ad32a9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0b560738948f6b8041e452ad32a9aa">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename QuadratureType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as before, but now the index set description of the locally owned range of degrees of freedom is taken from the <a class="el" href="classDoFHandler.html">DoFHandler</a>. Moreover, only a single quadrature formula is used, as might be necessary when several components in a vector-valued problem are integrated together based on the same quadrature formula. </p>

</div>
</div>
<a id="a79c76c26a70824aedda1a91f61fdde91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c76c26a70824aedda1a91f61fdde91">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename QuadratureType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> mapping. </p>

</div>
</div>
<a id="af0ea8c23f9dd724c4bdba90920c89dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ea8c23f9dd724c4bdba90920c89dae">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_free_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function. Creates a deep copy of all data structures. It is usually enough to keep the data for different operations once, so this function should not be needed very often. </p>

</div>
</div>
<a id="ada65411919b8f5cac76c36f7f510ccc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada65411919b8f5cac76c36f7f510ccc9">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all data fields and brings the class into a condition similar to after having called the default constructor. </p>

</div>
</div>
<a id="a523c939c0f87d8ad17d81bb3a2667b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523c939c0f87d8ad17d81bb3a2667b02">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned int, unsigned int &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method runs the loop over all cells (in parallel) and performs the MPI data exchange on the source vector and destination vector. The first argument indicates a function object that has the following signature: <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code>, where the first argument passes the data of the calling class and the last argument defines the range of cells which should be worked on (typically more than one cell should be worked on in order to reduce overheads). One can pass a pointer to an object in this place if it has an <code>operator()</code> with the correct set of arguments since such a pointer can be converted to the function object. </p>

</div>
</div>
<a id="af24292e5886a4a2fe8cf1d89bbcb8b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24292e5886a4a2fe8cf1d89bbcb8b6e">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned int, unsigned int &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>function_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the second variant to run the loop over all cells, now providing a function pointer to a member function of class <code>CLASS</code> with the signature <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt;&amp;)const</code>. This method obviates the need to call std::bind to bind the class into the given function in case the local function needs to access data in the class (i.e., it is a non-static member function). </p>

</div>
</div>
<a id="aef043b8cef13b1e3b8776ec1c1d1d41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef043b8cef13b1e3b8776ec1c1d1d41f">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned int, unsigned int &gt; &amp;)&#160;</td>
          <td class="paramname"><em>function_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for class member functions which are non-const. </p>

</div>
</div>
<a id="aaced6b21522068599a10e5f57d904ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaced6b21522068599a10e5f57d904ddc">&#9670;&nbsp;</a></span>create_cell_subrange_hp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned int,unsigned int&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::create_cell_subrange_hp </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the hp adaptive case, a subrange of cells as computed during the cell loop might contain elements of different degrees. Use this function to compute what the subrange for an individual finite element degree is. The finite element degree is associated to the vector component given in the function call. </p>

</div>
</div>
<a id="aecc902400294dfa2c79cb7c5f898283b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc902400294dfa2c79cb7c5f898283b">&#9670;&nbsp;</a></span>create_cell_subrange_hp_by_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned int,unsigned int&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::create_cell_subrange_hp_by_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned int, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the hp adaptive case, a subrange of cells as computed during the cell loop might contain elements of different degrees. Use this function to compute what the subrange for a given index the hp finite element, as opposed to the finite element degree in the other function. </p>

</div>
</div>
<a id="a254dd56fdce3104116caf6099f003467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254dd56fdce3104116caf6099f003467">&#9670;&nbsp;</a></span>initialize_dof_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_dof_vector </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize function for a general vector. The length of the vector is equal to the total number of degrees in the <a class="el" href="classDoFHandler.html">DoFHandler</a>. If the vector is of class <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number&gt;, the ghost entries are set accordingly. For vector-valued problems with several <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> underlying this class, the parameter <code>vector_component</code> defines which component is to be used.</p>
<p>For the vectors used with <a class="el" href="classMatrixFree.html">MatrixFree</a> and in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>, a vector needs to hold all <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs</a> and also some of the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>. The selection of DoFs is such that one can read all degrees of freedom on all locally relevant elements (locally active) plus the degrees of freedom that contraints expand into from the locally owned cells. However, not all locally relevant DoFs are stored because most of them would never be accessed in matrix-vector products and result in too much data sent around which impacts the performance. </p>

</div>
</div>
<a id="ae9ccfe4bec382fef3cac5db878e389ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ccfe4bec382fef3cac5db878e389ab">&#9670;&nbsp;</a></span>initialize_dof_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_dof_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize function for a distributed vector. The length of the vector is equal to the total number of degrees in the <a class="el" href="classDoFHandler.html">DoFHandler</a>. If the vector is of class <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number&gt;, the ghost entries are set accordingly. For vector-valued problems with several <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> underlying this class, the parameter <code>vector_component</code> defines which component is to be used.</p>
<p>For the vectors used with <a class="el" href="classMatrixFree.html">MatrixFree</a> and in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>, a vector needs to hold all <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs</a> and also some of the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>. The selection of DoFs is such that one can read all degrees of freedom on all locally relevant elements (locally active) plus the degrees of freedom that contraints expand into from the locally owned cells. However, not all locally relevant DoFs are stored because most of them would never be accessed in matrix-vector products and result in too much data sent around which impacts the performance. </p>

</div>
</div>
<a id="a2d3a5c54630c23a6cdf5a7afe7c177d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3a5c54630c23a6cdf5a7afe7c177d2">&#9670;&nbsp;</a></span>get_vector_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_vector_partitioner </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioner that represents the locally owned data and the ghost indices where access is needed to for the cell loop. The partitioner is constructed from the locally owned dofs and ghost dofs given by the respective fields. If you want to have specific information about these objects, you can query them with the respective access functions. If you just want to initialize a (parallel) vector, you should usually prefer this data structure as the data exchange information can be reused from one vector to another. </p>

</div>
</div>
<a id="ae6199d3bb4d57afa7853de8cf5260d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6199d3bb4d57afa7853de8cf5260d9b">&#9670;&nbsp;</a></span>get_locally_owned_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_locally_owned_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the set of cells that are oned by the processor. </p>

</div>
</div>
<a id="ad7c039966dc34104dcd7e9d03291aa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c039966dc34104dcd7e9d03291aa85">&#9670;&nbsp;</a></span>get_ghost_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_ghost_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the set of ghost cells needed but not owned by the processor. </p>

</div>
</div>
<a id="ad31a0eee233848b9661579f1087d654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31a0eee233848b9661579f1087d654f">&#9670;&nbsp;</a></span>get_constrained_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned int&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_constrained_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of all degrees of freedom that are constrained. The list is returned in MPI-local index space for the locally owned range of the vector, not in global MPI index space that spans all MPI processors. To get numbers in global index space, call <code><a class="el" href="classMatrixFree.html#a2d3a5c54630c23a6cdf5a7afe7c177d2">get_vector_partitioner()</a>-&gt;local_to_global</code> on an entry of the vector. In addition, it only returns the indices for degrees of freedom that are owned locally, not for ghosts. </p>

</div>
</div>
<a id="a9cab744529aef389a126a74e825eabb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cab744529aef389a126a74e825eabb6">&#9670;&nbsp;</a></span>renumber_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::renumber_dofs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>vector_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls renumber_dofs function in dof_info which renumbers the degrees of freedom according to the ordering for parallelization. </p>

</div>
</div>
<a id="ab8c89cfe10214bbc1387d940928ebdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c89cfe10214bbc1387d940928ebdee">&#9670;&nbsp;</a></span>is_supported()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::is_supported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether a given <a class="el" href="classFiniteElement.html">FiniteElement</a> <code>fe</code> is supported by this class. </p>

</div>
</div>
<a id="a1af7c60f93329604788066981737462a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af7c60f93329604788066981737462a">&#9670;&nbsp;</a></span>n_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of different <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> specified at initialization. </p>

</div>
</div>
<a id="ad97351f7a44d67f656d96571ec6a8c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97351f7a44d67f656d96571ec6a8c83">&#9670;&nbsp;</a></span>n_physical_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_physical_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of cells this structure is based on. If you are using a usual <a class="el" href="classDoFHandler.html">DoFHandler</a>, it corresponds to the number of (locally owned) active cells. Note that most data structures in this class do not directly act on this number but rather on <a class="el" href="classMatrixFree.html#a9143bf7be90031800cf8fcffbb5b0aaf">n_macro_cells()</a> which gives the number of cells as seen when lumping several cells together with vectorization. </p>

</div>
</div>
<a id="a9143bf7be90031800cf8fcffbb5b0aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9143bf7be90031800cf8fcffbb5b0aaf">&#9670;&nbsp;</a></span>n_macro_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_macro_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of macro cells that this structure works on, i.e., the number of cell chunks that are worked on after the application of vectorization which in general works on several cells at once. The cell range in <code>cell_loop</code> runs from zero to <a class="el" href="classMatrixFree.html#a9143bf7be90031800cf8fcffbb5b0aaf">n_macro_cells()</a> (exclusive), so this is the appropriate size if you want to store arrays of data for all cells to be worked on. This number is approximately <a class="el" href="classMatrixFree.html#ad97351f7a44d67f656d96571ec6a8c83">n_physical_cells()</a>/VectorizedArray::n_array_elements (depending on how many cell chunks that do not get filled up completely). </p>

</div>
</div>
<a id="a6de2d8b643a39ae3d4628fe930ca97ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de2d8b643a39ae3d4628fe930ca97ea">&#9670;&nbsp;</a></span>get_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In case this structure was built based on a <a class="el" href="classDoFHandler.html">DoFHandler</a>, this returns the <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

</div>
</div>
<a id="a5e7db9ef51c24f2796c70caec8718c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7db9ef51c24f2796c70caec8718c74">&#9670;&nbsp;</a></span>get_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;::cell_iterator <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>macro_cell_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>vector_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the cell iterator in deal.II speak to a given cell in the renumbering of this structure.</p>
<p>Note that the cell iterators in deal.II go through cells differently to what the cell loop of this class does. This is because several cells are worked on together (vectorization), and since cells with neighbors on different MPI processors need to be accessed at a certain time when accessing remote data and overlapping communication with computation. </p>

</div>
</div>
<a id="a26682ebec4187d45f52d2eee4b361218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26682ebec4187d45f52d2eee4b361218">&#9670;&nbsp;</a></span>get_hp_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt;dim&gt;::active_cell_iterator <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_hp_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>macro_cell_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>vector_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the cell iterator in deal.II speak to a given cell in the renumbering of this structure. This function returns an exception in case the structure was not constructed based on an <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>.</p>
<p>Note that the cell iterators in deal.II go through cells differently to what the cell loop of this class does. This is because several cells are worked on together (vectorization), and since cells with neighbors on different MPI processors need to be accessed at a certain time when accessing remote data and overlapping communication with computation. </p>

</div>
</div>
<a id="a4f2e6f411e70d007950bfc3e814d4795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2e6f411e70d007950bfc3e814d4795">&#9670;&nbsp;</a></span>at_irregular_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::at_irregular_cell </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>macro_cell_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Since this class uses vectorized data types with usually more than one value in the data field, a situation might occur when some components of the vector type do not correspond to an actual cell in the mesh. When using only this class, one usually does not need to bother about that fact since the values are padded with zeros. However, when this class is mixed with deal.II access to cells, care needs to be taken. This function returns <code>true</code> if not all <code>vectorization_length</code> cells for the given <code>macro_cell</code> are real cells. To find out how many cells are actually used, use the function <code>n_components_filled</code>. </p>

</div>
</div>
<a id="ac6d2bfd6d4a6e164b919eb9f69259b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d2bfd6d4a6e164b919eb9f69259b90">&#9670;&nbsp;</a></span>n_components_filled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_components_filled </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>macro_cell_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this function to find out how many cells over the length of vectorization data types correspond to real cells in the mesh. For most given <code>macro_cells</code>, this is just <code>vectorization_length</code> many, but there might be one or a few meshes (where the numbers do not add up) where there are less such components filled, indicated by the function <code>at_irregular_cell</code>. </p>

</div>
</div>
<a id="a7497379eabc615164102ce7e94b44a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7497379eabc615164102ce7e94b44a71">&#9670;&nbsp;</a></span>get_dofs_per_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_dofs_per_cell </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of degrees of freedom per cell for a given hp index. </p>

</div>
</div>
<a id="a19c84d1051d3600fd53ba9e0195d7310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c84d1051d3600fd53ba9e0195d7310">&#9670;&nbsp;</a></span>get_n_q_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_n_q_points </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of quadrature points per cell for a given hp index. </p>

</div>
</div>
<a id="a12b415c592ce9ca9c07fe26f62b6653e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b415c592ce9ca9c07fe26f62b6653e">&#9670;&nbsp;</a></span>get_dofs_per_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_dofs_per_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of degrees of freedom on each face of the cell for given hp index. </p>

</div>
</div>
<a id="a7190a076084bcfb3a4e79eef3ca05cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7190a076084bcfb3a4e79eef3ca05cd0">&#9670;&nbsp;</a></span>get_n_q_points_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_n_q_points_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of quadrature points on each face of the cell for given hp index. </p>

</div>
</div>
<a id="addd0d08351f31bdcc50efb65068544f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd0d08351f31bdcc50efb65068544f4">&#9670;&nbsp;</a></span>get_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_quadrature </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the quadrature rule for given hp index. </p>

</div>
</div>
<a id="a9cffd94649edc6ad64bc1648843c2b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cffd94649edc6ad64bc1648843c2b83">&#9670;&nbsp;</a></span>get_face_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_face_quadrature </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the quadrature rule for given hp index. </p>

</div>
</div>
<a id="a5167548d93deb20a938868fb63bd469c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5167548d93deb20a938868fb63bd469c">&#9670;&nbsp;</a></span>indices_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::indices_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether or not the indexation has been set. </p>

</div>
</div>
<a id="ac20997407cf1d40d0bf32f7bdb75b149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20997407cf1d40d0bf32f7bdb75b149">&#9670;&nbsp;</a></span>mapping_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::mapping_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether or not the geometry-related information for the cells has been set. </p>

</div>
</div>
<a id="a8432b77b9796e2f6d04d7c1d81e34903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8432b77b9796e2f6d04d7c1d81e34903">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an approximation of the memory consumption of this class in bytes. </p>

</div>
</div>
<a id="a183262825e9f6668e1b08fa7840048ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183262825e9f6668e1b08fa7840048ae">&#9670;&nbsp;</a></span>print_memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::print_memory_consumption </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a detailed summary of memory consumption in the different structures of this class to the given output stream. </p>

</div>
</div>
<a id="aae88b0e439247b3e5c19693b83af8192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae88b0e439247b3e5c19693b83af8192">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a summary of this class to the given output stream. It is focused on the indices, and does not print all the data stored. </p>

</div>
</div>
<a id="ac52e418ce7e67af6dba4d09cd1e5cca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52e418ce7e67af6dba4d09cd1e5cca1">&#9670;&nbsp;</a></span>get_task_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_task_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return information on task graph. </p>

</div>
</div>
<a id="a673b540c48a2b84225373848925a07c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673b540c48a2b84225373848925a07c3">&#9670;&nbsp;</a></span>get_size_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1SizeInfo.html">internal::MatrixFreeFunctions::SizeInfo</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_size_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return information on system size. </p>

</div>
</div>
<a id="ad29ff9be2f8714a22eea34bb89a482c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29ff9be2f8714a22eea34bb89a482c6">&#9670;&nbsp;</a></span>get_dof_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const internal::MatrixFreeFunctions::DoFInfo&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_dof_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return information on indexation degrees of freedom. </p>

</div>
</div>
<a id="a48d7935c4ceb824757db814693ebe269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d7935c4ceb824757db814693ebe269">&#9670;&nbsp;</a></span>n_constraint_pool_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::n_constraint_pool_entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of weights in the constraint pool. </p>

</div>
</div>
<a id="a72827d984d40fbd9f29bd2015f158679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72827d984d40fbd9f29bd2015f158679">&#9670;&nbsp;</a></span>constraint_pool_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::constraint_pool_begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>pool_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the first number in the constraint pool data with index <code>pool_index</code> (to be used together with <code><a class="el" href="classMatrixFree.html#a489e824b58927febccdee07738350e49">constraint_pool_end()</a></code>). </p>

</div>
</div>
<a id="a489e824b58927febccdee07738350e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489e824b58927febccdee07738350e49">&#9670;&nbsp;</a></span>constraint_pool_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::constraint_pool_end </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>pool_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to one past the last number in the constraint pool data with index <code>pool_index</code> (to be used together with <code><a class="el" href="classMatrixFree.html#a72827d984d40fbd9f29bd2015f158679">constraint_pool_begin()</a></code>). </p>

</div>
</div>
<a id="a4c4e50ad204d7de0460b72d85fee4dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4e50ad204d7de0460b72d85fee4dc3">&#9670;&nbsp;</a></span>get_shape_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;Number&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::get_shape_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>hp_active_quad_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the unit cell information for given hp index. </p>

</div>
</div>
<a id="ac703a39e958f59adb9fbe609e349b9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac703a39e958f59adb9fbe609e349b9c9">&#9670;&nbsp;</a></span>acquire_scratch_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number&gt; &gt;* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::acquire_scratch_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains a scratch data object for internal use. Make sure to release it afterwards by passing the pointer you obtain from this object to the <a class="el" href="classMatrixFree.html#a1665768e1aef8c2a040bbc27b87a0912">release_scratch_data()</a> function. This interface is used by <a class="el" href="classFEEvaluation.html">FEEvaluation</a> objects for storing their data structures.</p>
<p>The organization of the internal data structure is a thread-local storage of a list of vectors. Multiple threads will each get a separate storage field and separate vectors, ensuring thread safety. The mechanism to acquire and release objects is similar to the mechanisms used for the local contributions of <a class="el" href="namespaceWorkStream.html">WorkStream</a>, see <a class="el" href="DEALGlossary.html#workstream_paper">the WorkStream paper</a></p>

</div>
</div>
<a id="a1665768e1aef8c2a040bbc27b87a0912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1665768e1aef8c2a040bbc27b87a0912">&#9670;&nbsp;</a></span>release_scratch_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::release_scratch_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number &gt; &gt; *&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes the object of the scratchpad available again. </p>

</div>
</div>
<a id="ae193296e6b480871346e50e3e6945787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae193296e6b480871346e50e3e6945787">&#9670;&nbsp;</a></span>internal_reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::internal_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the actual reinit function that sets up the indices for the <a class="el" href="classDoFHandler.html">DoFHandler</a> case. </p>

</div>
</div>
<a id="aec657438ad47b1dbb138c6f9e96b38a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec657438ad47b1dbb138c6f9e96b38a8">&#9670;&nbsp;</a></span>internal_reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::internal_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as before but for <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> instead of generic <a class="el" href="classDoFHandler.html">DoFHandler</a> type. </p>

</div>
</div>
<a id="a8ab40dd4a77c27332d5712c014c87312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab40dd4a77c27332d5712c014c87312">&#9670;&nbsp;</a></span>initialize_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the fields in DoFInfo together with the constraint pool that holds all different weights in the constraints (not part of DoFInfo because several DoFInfo classes can have the same weights which consequently only need to be stored once). </p>

</div>
</div>
<a id="a0f4d5707c95caf6fada36143b74d4521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4d5707c95caf6fada36143b74d4521">&#9670;&nbsp;</a></span>initialize_dof_handlers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_dof_handlers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> based on a <a class="el" href="classhp_1_1DoFHandler.html">DoFHandler&lt;dim&gt;</a> argument. </p>

</div>
</div>
<a id="a4d99f3980f143735380e36fac259a00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d99f3980f143735380e36fac259a00b">&#9670;&nbsp;</a></span>initialize_dof_handlers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::initialize_dof_handlers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> based on a hp::DoFHandler&lt;dim&gt; argument. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a057e94bb1e5a222bc314479fa29d31ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057e94bb1e5a222bc314479fa29d31ed">&#9670;&nbsp;</a></span>dof_handlers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::dof_handlers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointers to the <a class="el" href="structMatrixFree_1_1DoFHandlers.html">DoFHandlers</a> underlying the current problem. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00952">952</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a809308f14c114b50967bae3c274c8c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809308f14c114b50967bae3c274c8c70">&#9670;&nbsp;</a></span>dof_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;internal::MatrixFreeFunctions::DoFInfo&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::dof_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains the information about degrees of freedom on the individual cells and constraints. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00958">958</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a19632f7ddcd8ccd6cf53ffd0e4564098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19632f7ddcd8ccd6cf53ffd0e4564098">&#9670;&nbsp;</a></span>constraint_pool_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Number&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::constraint_pool_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains the weights for constraints stored in DoFInfo. Filled into a separate field since several vector components might share similar weights, which reduces memory consumption. Moreover, it obviates template arguments on DoFInfo and keeps it a plain field of indices only. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00966">966</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a26b1125b841a2e45709d1e008c943626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b1125b841a2e45709d1e008c943626">&#9670;&nbsp;</a></span>constraint_pool_row_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::constraint_pool_row_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains an indicator to the start of the ith index in the constraint pool data. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00972">972</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="acd233be90c57c51be1107d8643daf25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd233be90c57c51be1107d8643daf25c">&#9670;&nbsp;</a></span>mapping_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt;dim,Number&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::mapping_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Holds information on transformation of cells from reference cell to real cell that is needed for evaluating integrals. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00978">978</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a22928fb178a580ecf368fd657982ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22928fb178a580ecf368fd657982ddcf">&#9670;&nbsp;</a></span>shape_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;4,<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;Number&gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::shape_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains shape value information on the unit cell. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00983">983</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a7fe96d5df46f76ca3d98ef57ec27a5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe96d5df46f76ca3d98ef57ec27a5e2">&#9670;&nbsp;</a></span>cell_level_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned int,unsigned int&gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::cell_level_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Describes how the cells are gone through. With the cell level (first index in this field) and the index within the level, one can reconstruct a deal.II cell iterator and use all the traditional things deal.II offers to do with cell iterators. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00991">991</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a23e4ee0c4f798956a22383f1f9e9eb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e4ee0c4f798956a22383f1f9e9eb6d">&#9670;&nbsp;</a></span>size_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1SizeInfo.html">internal::MatrixFreeFunctions::SizeInfo</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::size_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores how many cells we have, how many cells that we see after applying vectorization (i.e., the number of macro cells), and MPI-related stuff. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00997">997</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a33df2e9baaab5baa8032c70eebbc7951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33df2e9baaab5baa8032c70eebbc7951">&#9670;&nbsp;</a></span>task_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::task_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Information regarding the shared memory parallelization. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01002">1002</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a88d6c660ceb8d60fc2584e1fb57961df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d6c660ceb8d60fc2584e1fb57961df">&#9670;&nbsp;</a></span>indices_are_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::indices_are_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores whether indices have been initialized. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01007">1007</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a94607b35b2b190f93608fbb2bd07d837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94607b35b2b190f93608fbb2bd07d837">&#9670;&nbsp;</a></span>mapping_is_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::mapping_is_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores whether indices have been initialized. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01012">1012</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a985badc35ecb59cb4df28f244bdf6a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985badc35ecb59cb4df28f244bdf6a21">&#9670;&nbsp;</a></span>scratch_pad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt;std::list&lt;std::pair&lt;bool, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number&gt; &gt; &gt; &gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number &gt;::scratch_pad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scratchpad memory for use in evaluation. We allow more than one evaluation object to attach to this field (this, the outer std::vector), so we need to keep tracked of whether a certain data field is already used (first part of pair) and keep a list of objects. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01021">1021</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deal.II/matrix_free/<a class="el" href="matrix__free_8h_source.html">matrix_free.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
