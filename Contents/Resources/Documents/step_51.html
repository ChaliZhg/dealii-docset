<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-51 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-51 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HybridizablediscontinuousGalerkinmethods">  Hybridizable discontinuous Galerkin methods</a>
      <ul>
        <li><a href="#Reducingthesizeofthelinearsystem"> Reducing the size of the linear system </a>
        <li><a href="#Solutionqualityandratesofconvergence"> Solution quality and rates of convergence</a>
      </ul>
        <li><a href="#HDGappliedtotheconvectiondiffusionproblem"> HDG applied to the convection-diffusion problem </a>
      <ul>
        <li><a href="#Postprocessingandsuperconvergence"> Post-processing and super-convergence </a>
      </ul>
        <li><a href="#Problemspecificdata"> Problem specific data </a>
        <li><a href="#Implementation"> Implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#TheHDGsolverclass">The HDG solver class</a>
        <li><a href="#TheHDGclassimplementation">The HDG class implementation</a>
      <ul>
        <li><a href="#Constructor">Constructor</a>
        <li><a href="#HDGsetup_system">HDG::setup_system</a>
        <li><a href="#HDGPerTaskData">HDG::PerTaskData</a>
        <li><a href="#HDGScratchData">HDG::ScratchData</a>
        <li><a href="#HDGPostProcessScratchData">HDG::PostProcessScratchData</a>
        <li><a href="#HDGassemble_system">HDG::assemble_system</a>
        <li><a href="#HDGassemble_system_one_cell">HDG::assemble_system_one_cell</a>
        <li><a href="#HDGcopy_local_to_global">HDG::copy_local_to_global</a>
        <li><a href="#HDGsolve">HDG::solve</a>
        <li><a href="#HDGpostprocess">HDG::postprocess</a>
        <li><a href="#HDGpostprocess_one_cell">HDG::postprocess_one_cell</a>
        <li><a href="#HDGoutput_results">HDG::output_results</a>
        <li><a href="#HDGrefine_grid">HDG::refine_grid</a>
        <li><a href="#HDGrun">HDG::run</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
      <ul>
        <li><a href="#Convergencetables">Convergence tables</a>
      </ul>
        <li><a href="#Comparisonwithcontinuousfiniteelements">Comparison with continuous finite elements</a>
      <ul>
        <li><a href="#Resultsfor2D">Results for 2D</a>
        <li><a href="#Resultsfor3D">Results for 3D</a>
      </ul>
        <li><a href="#Possibilitiesforimprovements">Possibilities for improvements</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Martin Kronbichler and Scott Miller. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program presents the implementation of a hybridizable discontinuous Galkerin method for the convection-diffusion equation.</p>
<p><a class="anchor" id="HybridizablediscontinuousGalerkinmethods"></a></p><h3>Hybridizable discontinuous Galerkin methods</h3>
<p>One common argument against the use of discontinuous Galerkin elements is the large number of globally coupled degrees of freedom that one must solve in an implicit system. This is because, unlike continuous finite elements, in typical discontinuous elements there is one degree of freedom at each vertex <em>for each of the adjacent elements</em>, rather than just one, and similarly for edges and faces. As an example of how fast the number of unknowns grows, consider the <code>FE_DGP_Monomial</code> basis: each scalar solution component is represented by polynomials of degree <img class="formulaInl" alt="$p$" src="form_202.png"/> with <img class="formulaInl" alt="$(1/dim!)*\prod_{i=1}^{dim}(p+i)$" src="form_3890.png"/> degrees of freedom per element. Typically, all degrees of freedom in an element are coupled to all of the degrees of freedom in the adjacent elements. The resulting discrete equations yield very large linear systems very quickly, especially for systems of equations in 2 or 3 dimensions.</p>
<p><a class="anchor" id="Reducingthesizeofthelinearsystem"></a></p><h4>Reducing the size of the linear system </h4>
<p>To alleviate the computational cost of solving such large linear systems, the hybridizable discontinuous Galerkin (HDG) methodology was introduced by Cockburn and co-workers (see the references in the recent HDG overview article by N.C. Nguyen and J. Peraire: <em>Hybridizable discontinuous Galerkin methods for partial differential equations in continuum mechanics</em>, Journal of Computational <a class="el" href="namespacePhysics.html">Physics</a>, 2012, 231:18, 5955-5988. <a href="http://dx.doi.org/10.1016/j.jcp.2012.02.033">[DOI]</a>). The HDG method achieves this goal by formulating the mathematical problem using Dirichlet-to-Neumann mappings. The partial differential equations are first written as a first order system, and each field is then discretized via a DG method. At this point the single-valued "trace" values on the skeleton of the mesh, i.e. element faces, are taken to be independent unknown quantities. The Dirichlet-to-Neumann map concept then permits the following solution procedure: </p><ol>
<li>
Use local element interior data to enforce a Neumann condition on the skeleton of the triangulation. The global problem is then to solve for the trace values, which are the only globally coupled unknowns. </li>
<li>
Use the known skeleton values as Dirichlet data for solving local element-level solutions. This is known as the 'local solver', and is an <em>embarrassingly parallel</em> element-by-element solution process. </li>
</ol>
<p>The above procedure also has a linear algebra interpretation and is referred to as static condensation. Let us write the complete linear system associated to the HDG problem as a block system with the discrete DG variables <img class="formulaInl" alt="$U$" src="form_203.png"/> as first block and the skeleton variables <img class="formulaInl" alt="$\Lambda$" src="form_3313.png"/> as the second block: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \begin{pmatrix} A &amp; B \\ C &amp; D \end{pmatrix} \begin{pmatrix} U \\ \Lambda \end{pmatrix} = \begin{pmatrix} F \\ G \end{pmatrix}. \end{eqnarray*}" src="form_3891.png"/>
</p>
<p> Our aim is now to eliminate the <img class="formulaInl" alt="$U$" src="form_203.png"/> block with a Schur complement approach similar to <a class="el" href="step_20.html">step-20</a>, which results in the following two steps: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (D - C A^{-1} B) \Lambda &amp;=&amp; G - C A^{-1} F, \\ A U &amp;=&amp; F - B \Lambda. \end{eqnarray*}" src="form_3892.png"/>
</p>
<p> The point is that the presence of <img class="formulaInl" alt="$A^{-1}$" src="form_1098.png"/> is not a problem because <img class="formulaInl" alt="$A$" src="form_40.png"/> is a block diagonal matrix where each block corresponds to one cell and is therefore easy enough to invert. The coupling to other cells is introduced by the matrices <img class="formulaInl" alt="$B$" src="form_65.png"/> and <img class="formulaInl" alt="$C$" src="form_43.png"/> over the skeleton variable. The block-diagonality of <img class="formulaInl" alt="$A$" src="form_40.png"/> and the structure in <img class="formulaInl" alt="$B$" src="form_65.png"/> and <img class="formulaInl" alt="$C$" src="form_43.png"/> allow us to invert the matrix <img class="formulaInl" alt="$A$" src="form_40.png"/> element by element (the local solution of the Dirichlet problem) and subtract <img class="formulaInl" alt="$CA^{-1}B$" src="form_3893.png"/> from <img class="formulaInl" alt="$D$" src="form_1015.png"/>. The steps in the Dirichlet-to-Neumann map concept hence correspond to </p><ol>
<li>
constructing the Schur complement matrix <img class="formulaInl" alt="$D-C A^{-1} B$" src="form_3894.png"/> and right hand side <img class="formulaInl" alt="$G - C A^{-1} F$" src="form_3895.png"/> <em>locally on each cell</em> and inserting the contribution into the global trace matrix in the usual way, </li>
<li>
solving the Schur complement system for <img class="formulaInl" alt="$\Lambda$" src="form_3313.png"/>, and </li>
<li>
solving for <img class="formulaInl" alt="$U$" src="form_203.png"/> using the second equation, given <img class="formulaInl" alt="$\Lambda$" src="form_3313.png"/>. </li>
</ol>
<p><a class="anchor" id="Solutionqualityandratesofconvergence"></a></p><h4>Solution quality and rates of convergence</h4>
<p>Another criticism of traditional DG methods is that the approximate fluxes converge suboptimally. The local HDG solutions can be shown to converge as <img class="formulaInl" alt="$\mathcal{O}(h^{p+1})$" src="form_3896.png"/>, i.e., at optimal order. Additionally, a super-convergence property can be used to post-process a new approximate solution that converges at the rate <img class="formulaInl" alt="$\mathcal{O}(h^{p+2})$" src="form_3897.png"/>.</p>
<p><a class="anchor" id="HDGappliedtotheconvectiondiffusionproblem"></a></p><h3>HDG applied to the convection-diffusion problem </h3>
<p>The HDG formulation used for this example is taken from <br />
 <b> N.C. Nguyen, J. Peraire, B. Cockburn: <em>An implicit high-order hybridizable discontinuous Galerkin method for linear convection–diffusion equations</em>, Journal of Computational <a class="el" href="namespacePhysics.html">Physics</a>, 2009, 228:9, 3232-3254. <a href="http://dx.doi.org/10.1016/j.jcp.2009.01.030">[DOI]</a> </b></p>
<p>We consider the convection-diffusion equation over the domain <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> with Dirichlet boundary <img class="formulaInl" alt="$\partial \Omega_D$" src="form_3898.png"/> and Neumann boundary <img class="formulaInl" alt="$\partial \Omega_N$" src="form_3899.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \nabla \cdot (\mathbf{c} u) - \nabla \cdot (\kappa \nabla u) &amp;=&amp; f, \quad \text{ in } \Omega, \\ u &amp;=&amp; g_D, \quad \text{ on } \partial \Omega_D, \\ (\mathbf{c} u - \kappa \nabla u)\cdot \mathbf{n} &amp;=&amp; g_N, \quad \text{ on } \partial \Omega_N. \end{eqnarray*}" src="form_3900.png"/>
</p>
<p>Introduce the auxiliary variable <img class="formulaInl" alt="$\mathbf{q}=-\kappa \nabla u$" src="form_3901.png"/> and rewrite the above equation as the first order system: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \mathbf{q} + \kappa \nabla u &amp;=&amp; 0, \quad \text{ in } \Omega, \\ \nabla \cdot (\mathbf{c} u + \mathbf{q}) &amp;=&amp; f, \quad \text{ in } \Omega, \\ u &amp;=&amp; g_D, \quad \text{ on } \partial \Omega_D, \\ (\mathbf{q} + \mathbf{c}u)\cdot\mathbf{n} &amp;=&amp; g_N, \quad \text{ on } \partial \Omega_N. \end{eqnarray*}" src="form_3902.png"/>
</p>
<p>We multiply these equations by the weight functions <img class="formulaInl" alt="$\mathbf{v}, w$" src="form_3468.png"/> and integrate by parts over every element <img class="formulaInl" alt="$K$" src="form_57.png"/> to obtain: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (\mathbf{v}, \kappa^{-1} \mathbf{q})_K - (\nabla\cdot\mathbf{v}, u)_K + \left&lt;\mathbf{v}\cdot\mathbf{n}, \hat{u}\right&gt;_{\partial K} &amp;=&amp; 0, \\ - (\nabla w, \mathbf{c} u + \mathbf{q})_K + \left&lt;w, (\widehat{\mathbf{c} u}+\hat{\mathbf{q}})\cdot\mathbf{n}\right&gt;_{\partial K} &amp;=&amp; (w,f)_K. \end{eqnarray*}" src="form_3903.png"/>
</p>
<p>The terms decorated with a hat denote the numerical traces (also commonly referred to as numerical fluxes). They are approximations to the interior values on the boundary of the element. To ensure conservation, these terms must be single-valued on any given element edge <img class="formulaInl" alt="$\partial K$" src="form_1759.png"/> even though, with discontinuous shape functions, there may of course be multiple values coming from the cells adjacent to an interface. We eliminate the numerical trace <img class="formulaInl" alt="$\hat{\mathbf{q}}$" src="form_3904.png"/> by using traces of the form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \widehat{\mathbf{c} u}+\hat{\mathbf{q}} = \mathbf{c}\hat{u} + \mathbf{q} + \tau(u - \hat{u})\mathbf{n} \quad \text{ on } \partial K. \end{eqnarray*}" src="form_3905.png"/>
</p>
<p>The variable <img class="formulaInl" alt="$\hat {u}$" src="form_3906.png"/> is introduced as an additional independent variable and is the one for which we finally set up a globally coupled linear system. As mentioned above, it is defined on the element faces and discontinuous from one face to another wherever faces meet (at vertices in 2d, and at edges and vertices in 3d). Values for <img class="formulaInl" alt="$u$" src="form_256.png"/> and <img class="formulaInl" alt="$\mathbf{q}$" src="form_3907.png"/> appearing in the numerical trace function are taken to be the cell's interior solution restricted to the boundary <img class="formulaInl" alt="$\partial K$" src="form_1759.png"/>.</p>
<p>The local stabilization parameter <img class="formulaInl" alt="$\tau$" src="form_1599.png"/> has effects on stability and accuracy of HDG solutions; see the literature for a further discussion. A stabilization parameter of unity is reported to be the choice which gives best results. A stabilization parameter <img class="formulaInl" alt="$\tau$" src="form_1599.png"/> that tends to infinity prohibits jumps in the solution over the element boundaries, making the HDG solution approach the approximation with continuous finite elements. In the program below, we choose the stabilization parameter as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \tau = \frac{\kappa}{\ell} + |\mathbf{c} \cdot \mathbf{n}| \end{eqnarray*}" src="form_3908.png"/>
</p>
<p> where we set the diffusion <img class="formulaInl" alt="$\kappa=1$" src="form_3909.png"/> and the diffusion length scale to <img class="formulaInl" alt="$\ell = \frac{1}{5}$" src="form_3910.png"/>.</p>
<p>The trace/skeleton variables in HDG methods are single-valued on element faces. As such, they must strongly represent the Dirichlet data on <img class="formulaInl" alt="$\partial\Omega_D$" src="form_3911.png"/>. This means that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \hat{u}|_{\partial \Omega_D} = g_D, \end{equation*}" src="form_3912.png"/>
</p>
<p> where the equal sign actually means an <img class="formulaInl" alt="$L_2$" src="form_608.png"/> projection of the boundary function <img class="formulaInl" alt="$g$" src="form_36.png"/> onto the space of the face variables (e.g. linear functions on the faces). This constraint is then applied to the skeleton variable <img class="formulaInl" alt="$\hat{u}$" src="form_3913.png"/> using inhomogeneous constraints by the method <a class="el" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">VectorTools::project_boundary_values</a>.</p>
<p>Summing the elemental contributions across all elements in the triangulation, enforcing the normal component of the numerical flux, and integrating by parts on the equation weighted by <img class="formulaInl" alt="$w$" src="form_859.png"/>, we arrive at the final form of the problem: Find <img class="formulaInl" alt="$(\mathbf{q}_h, u_h, \hat{u}_h) \in \mathcal{V}_h^p \times \mathcal{W}_h^p \times \mathcal{M}_h^p$" src="form_3914.png"/> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (\mathbf{v}, \kappa^{-1} \mathbf{q}_h)_{\mathcal{T}} - ( \nabla\cdot\mathbf{v}, u_h)_{\mathcal{T}} + \left&lt;\mathbf{v}\cdot\mathbf{n}, \hat{u}_h\right&gt;_{\partial\mathcal{T}} &amp;= 0, \quad &amp;&amp;\forall \mathbf{v} \in \mathcal{V}_h^p, \\ - (\nabla w, \mathbf{c} u_h)_{\mathcal{T}} + (w, \nabla \cdot \mathbf{q}_h)_{\mathcal{T}} + (w, (\mathbf{c}\cdot\mathbf{n}) \hat{u}_h)_{\partial \mathcal{T}} + \left&lt;w, \tau (u_h - \hat{u}_h)\right&gt;_{\partial \mathcal{T}} &amp;= (w, f)_{\mathcal{T}}, \quad &amp;&amp;\forall w \in \mathcal{W}_h^p, \\ \left&lt; \mu, \hat{u}_h\mathbf{c} \cdot \mathbf{n} + \mathbf{q}_h\cdot \mathbf{n} + \tau (u_h - \hat{u}_h)\right&gt;_{\partial \mathcal{T}} &amp;= \left&lt;\mu, g_N\right&gt;_{\partial\Omega_N}, \quad &amp;&amp;\forall \mu \in \mathcal{M}_h^p. \end{align*}" src="form_3915.png"/>
</p>
<p>The unknowns <img class="formulaInl" alt="$(\mathbf{q}_h, u_h)$" src="form_3916.png"/> are referred to as local variables; they are represented as standard DG variables. The unknown <img class="formulaInl" alt="$\hat{u}_h$" src="form_3917.png"/> is the skeleton variable which has support on the codimension-1 surfaces (faces) of the mesh.</p>
<p>We use the notation <img class="formulaInl" alt="$(\cdot, \cdot)_{\mathcal{T}} = \sum_K (\cdot, \cdot)_K$" src="form_3918.png"/> to denote the sum of integrals over all cells and <img class="formulaInl" alt="$\left&lt;\cdot, \cdot\right&gt;_{\partial \mathcal{T}} = \sum_K \left&lt;\cdot, \cdot\right&gt;_{\partial K}$" src="form_3919.png"/> to denote integration over all faces of all cells, i.e., interior faces are visited twice, once from each side and with the corresponding normal vectors. When combining the contribution from both elements sharing a face, the above equation yields terms familiar from the DG method, with jumps of the solution over the cell boundaries.</p>
<p>In the equation above, the space <img class="formulaInl" alt="$\mathcal {W}_h^{p}$" src="form_3920.png"/> for the scalar variable <img class="formulaInl" alt="$u_h$" src="form_722.png"/> is defined as the space of functions that are tensor product polynomials of degree <img class="formulaInl" alt="$p$" src="form_202.png"/> on each cell and discontinuous over the element boundaries <img class="formulaInl" alt="$\mathcal Q_{-p}$" src="form_3921.png"/>, i.e., the space described by <code>FE_DGQ&lt;dim&gt;(p)</code>. The space for the gradient or flux variable <img class="formulaInl" alt="$\mathbf{q}_i$" src="form_3922.png"/> is a vector element space where each component is a locally polynomial and discontinuous <img class="formulaInl" alt="$\mathcal Q_{-p}$" src="form_3921.png"/>. In the code below, we collect these two local parts together in one <a class="el" href="classFESystem.html">FESystem</a> where the first <code>dim</code> components denote the gradient part and the last scalar component corresponds to the scalar variable. For the skeleton component <img class="formulaInl" alt="$\hat{u}_h$" src="form_3917.png"/>, we define a space that consists of discontinuous tensor product polynomials that live on the element faces, which in deal.II is implemented by the class <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a>. This space is otherwise similar to <a class="el" href="classFE__DGQ.html">FE_DGQ</a>, i.e., the solution function is not continuous between two neighboring faces, see also the results section below for an illustration.</p>
<p>In the weak form given above, we can note the following coupling patterns: </p><ol>
<li>
The matrix <img class="formulaInl" alt="$A$" src="form_40.png"/> consists of local-local coupling terms. These arise when the local weighting functions <img class="formulaInl" alt="$(\mathbf{v}, w)$" src="form_3923.png"/> multiply the local solution terms <img class="formulaInl" alt="$(\mathbf{q}_h, u_h)$" src="form_3916.png"/>. Because the elements are discontinuous, <img class="formulaInl" alt="$A$" src="form_40.png"/> is block diagonal. </li>
<li>
The matrix <img class="formulaInl" alt="$B$" src="form_65.png"/> represents the local-face coupling. These are the terms with weighting functions <img class="formulaInl" alt="$(\mathbf{v}, w)$" src="form_3923.png"/> multiplying the skeleton variable <img class="formulaInl" alt="$\hat{u}_h$" src="form_3917.png"/>. </li>
<li>
The matrix <img class="formulaInl" alt="$C$" src="form_43.png"/> represents the face-local coupling, which involves the weighting function <img class="formulaInl" alt="$\mu$" src="form_1643.png"/> multiplying the local solutions <img class="formulaInl" alt="$(\mathbf{q}_h, u_h)$" src="form_3916.png"/>. </li>
<li>
The matrix <img class="formulaInl" alt="$D$" src="form_1015.png"/> is the face-face coupling; terms involve both <img class="formulaInl" alt="$\mu$" src="form_1643.png"/> and <img class="formulaInl" alt="$\hat{u}_h$" src="form_3917.png"/>. </li>
</ol>
<p><a class="anchor" id="Postprocessingandsuperconvergence"></a></p><h4>Post-processing and super-convergence </h4>
<p>One special feature of the HDG methods is that they typically allow for constructing an enriched solution that gains accuracy. This post-processing takes the HDG solution in an element-by-element fashion and combines it such that one can get <img class="formulaInl" alt="$\mathcal O(h^{p+2})$" src="form_3924.png"/> order of accuracy when using polynomials of degree <img class="formulaInl" alt="$p$" src="form_202.png"/>. For this to happen, there are two necessary ingredients: </p><ol>
<li>
The computed solution gradient <img class="formulaInl" alt="$\mathbf{q}_h$" src="form_3925.png"/> converges at optimal rate, i.e., <img class="formulaInl" alt="$\mathcal{O}(h^{p+1})$" src="form_3896.png"/>. </li>
<li>
The average of the scalar part of the solution, <em>u<sub>h</sub></em>, on each cell <img class="formulaInl" alt="$K$" src="form_57.png"/> super-converges at rate <img class="formulaInl" alt="$\mathcal{O}(h^{p+2})$" src="form_3897.png"/>. </li>
</ol>
<p>We now introduce a new variable <img class="formulaInl" alt="$u_h^* \in \mathcal{V}_h^{p+1}$" src="form_3926.png"/>, which we find by minimizing the expression <img class="formulaInl" alt="$|\kappa \nabla u_h^* + \mathbf{q}_h|^2$" src="form_3927.png"/> over the cell <img class="formulaInl" alt="$K$" src="form_57.png"/> under the constraint <img class="formulaInl" alt="$\left(1, u_h^*\right)_K = \left(1, u_h\right)_K$" src="form_3928.png"/>. The constraint is necessary because the minimization functional does not determine the constant part of <img class="formulaInl" alt="$u_h^*$" src="form_3929.png"/>. This translates to the following system of equations: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left(1, u_h^*\right)_K &amp;=&amp; \left(1, u_h\right)_K\\ \left(\nabla w_h^*, \kappa \nabla u_h^*\right)_K &amp;=&amp; -\left(\nabla w_h^*, \mathbf{q}_h\right)_K \quad \text{for all } w_h^* \in \mathcal Q^{p+1}. \end{eqnarray*}" src="form_3930.png"/>
</p>
<p>Since we test by the whole set of basis functions in the space of tensor product polynomials of degree <img class="formulaInl" alt="$p+1$" src="form_353.png"/> in the second set of equations, this is an overdetermined system with one more equation than unknowns. We fix this in the code below by omitting one of these equations (since the rows in the Laplacian are linearly dependent when representing a constant function). As we will see below, this form of the post-processing gives the desired super-convergence result with rate <img class="formulaInl" alt="$\mathcal {O}(h^{p+2})$" src="form_3931.png"/>. It should be noted that there is some freedom in constructing <img class="formulaInl" alt="$u_h^*$" src="form_3929.png"/> and this minimization approach to extract the information from the gradient is not the only one. In particular, the post-processed solution defined here does not satisfy the convection-diffusion equation in any sense. As an alternative, the paper by Nguyen, Peraire and Cockburn cited above suggests another somewhat more involved formula for convection-diffusion that can also post-process the flux variable into an <img class="formulaInl" alt="$H(\Omega,\mathrm{div})$" src="form_3932.png"/>-conforming variant and better represents the local convection-diffusion operator when the diffusion is small. We leave the implementation of a more sophisticated post-processing as a possible extension to the interested reader.</p>
<p>Note that for vector-valued problems, the post-processing works similarly. One simply sets the constraint for the mean value of each vector component separately and uses the gradient as the main source of information.</p>
<p><a class="anchor" id="Problemspecificdata"></a></p><h3>Problem specific data </h3>
<p>For this tutorial program, we consider almost the same test case as in <a class="el" href="step_7.html">step-7</a>. The computational domain is <img class="formulaInl" alt="$\Omega := [-1,1]^d$" src="form_3933.png"/> and the exact solution corresponds to the one in <a class="el" href="step_7.html">step-7</a>, except for a scaling. We use the following source centers <img class="formulaInl" alt="$x_i$" src="form_320.png"/> for the exponentials </p><ul>
<li>
1D: <img class="formulaInl" alt="$\{x_i\}^1 = \{ -\frac{1}{3}, 0, \frac{1}{3} \}$" src="form_3934.png"/>, </li>
<li>
2D: <img class="formulaInl" alt="$\{\mathbf{x}_i\}^2 = \{ (-\frac{1}{2},\frac{1}{2}), (-\frac{1}{2},-\frac{1}{2}), (\frac{1}{2},-\frac{1}{2}) \}$" src="form_3935.png"/>, </li>
<li>
3D: <img class="formulaInl" alt="$\{\mathbf{x}_i\}^3 = \{ (-\frac{1}{2},\frac{1}{2}, \frac{1}{4}), (-\frac{3}{5},-\frac{1}{2}, -\frac{1}{8}), (\frac{1}{2},-\frac{1}{2}, \frac{1}{2}) \}$" src="form_3936.png"/>. </li>
</ul>
<p>With the exact solution given, we then choose the forcing on the right hand side and the Neumann boundary condition such that we obtain this solution (manufactured solution technique). In this example, we choose the diffusion equal to one and the convection as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{c} = \begin{cases} 1, &amp; \textrm{dim}=1 \\ (y, -x), &amp; \textrm{dim}=2 \\ (y, -x, 1), &amp; \textrm{dim}=3 \end{cases} \]" src="form_3937.png"/>
</p>
<p> Note that the convection is divergence-free, <img class="formulaInl" alt="$\nabla \cdot c = 0$" src="form_3938.png"/>.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation </h3>
<p>Besides implementing the above equations, the implementation below provides the following features: </p><ul>
<li>
<a class="el" href="namespaceWorkStream.html">WorkStream</a> to parallelize local solvers. Workstream has been presented in detail in <a class="el" href="step_9.html">step-9</a>. </li>
<li>
Reconstruct the local DG solution from the trace. </li>
<li>
Post-processing the solution for superconvergence. </li>
<li>
<a class="el" href="classDataOutFaces.html">DataOutFaces</a> for direct output of the global skeleton solution. </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of the deal.II include files have already been covered in previous examples and are not commented on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor_function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/exceptions.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/work_stream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_bicgstab.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div></div><!-- fragment --><p>However, we do have a few new includes for the example. The first one defines finite element spaces on the faces of the triangulation, which we refer to as the 'skeleton'. These finite elements do not have any support on the element interior, and they represent polynomials that have a single value on each codimension-1 surface, but admit discontinuities on codimension-2 surfaces.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_face.h&gt;</span></div></div><!-- fragment --><p>The second new file we include defines a new type of sparse matrix. The regular <code><a class="el" href="classSparseMatrix.html">SparseMatrix</a></code> type stores indices to all non-zero entries. The <code><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a></code> takes advantage of the coupled nature of DG solutions. It stores an index to a matrix sub-block of a specified size. In the HDG context, this sub-block-size is actually the number of degrees of freedom per face defined by the skeleton solution field. This reduces the memory consumption of the matrix by up to one third and results in similar speedups when using the matrix in solvers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/chunk_sparse_matrix.h&gt;</span></div></div><!-- fragment --><p>The final new include for this example deals with data output. Since we have a finite element field defined on the skeleton of the mesh, we would like to visualize what that solution actually is. <a class="el" href="classDataOutFaces.html">DataOutFaces</a> does exactly this; the interface is the almost the same as the familiar <a class="el" href="classDataOut.html">DataOut</a>, but the output only has codimension-1 data for the simulation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out_faces.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>We start by putting the class into its own namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step51</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>The structure of the analytic solution is the same as in <a class="el" href="step_7.html">step-7</a>. There are two exceptions. Firstly, we also create a solution for the 3d case, and secondly, we scale the solution so its norm is of order unity for all values of the solution width.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionBase</div><div class="line">{</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_source_centers = 3;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>    source_centers[n_source_centers];</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>        width;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers]</div><div class="line">  = { <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers]</div><div class="line">  = { <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, -0.5),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5, -0.5)</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">SolutionBase&lt;3&gt;::source_centers[SolutionBase&lt;3&gt;::n_source_centers]</div><div class="line">  = { <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.5, +0.5, 0.25),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.6, -0.5, -0.125),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(+0.5, -0.5, 0.5)</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1./5.;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">  <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Solution () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> gradient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Solution&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">double</span> return_value = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line">      return_value += std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                               (this-&gt;width * this-&gt;width));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value /</div><div class="line">         Utilities::fixed_power&lt;dim&gt;(std::sqrt(2. * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>) * this-&gt;width);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> Solution&lt;dim&gt;::gradient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> return_value;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">      return_value += (-2 / (this-&gt;width * this-&gt;width) *</div><div class="line">                       std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                                (this-&gt;width * this-&gt;width)) *</div><div class="line">                       x_minus_xi);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value / Utilities::fixed_power&lt;dim&gt;(std::sqrt(2 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>) *</div><div class="line">                                                    this-&gt;width);</div><div class="line">}</div></div><!-- fragment --><p>This class implements a function where the scalar solution and its negative gradient are collected together. This function is used when computing the error of the HDG approximation and its implementation is to simply call value and gradient function of the Solution class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionAndGradient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">  <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SolutionAndGradient () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     &amp;v) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SolutionAndGradient&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;v)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(v.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim+1);</div><div class="line">  Solution&lt;dim&gt; solution;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> grad = solution.gradient(p);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">    v[d] = -grad[d];</div><div class="line">  v[dim] = solution.value(p);</div><div class="line">}</div></div><!-- fragment --><p>Next comes the implementation of the convection velocity. As described in the introduction, we choose a velocity field that is <img class="formulaInl" alt="$(y, -x)$" src="form_3939.png"/> in 2D and <img class="formulaInl" alt="$(y, -x, 1)$" src="form_3940.png"/> in 3D. This gives a divergence-free velocity field.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ConvectionVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1,dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConvectionVelocity() : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1,dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> <a class="code" href="classTensorFunction.html#a60e07c97b7b3b30c612644f9ca42d477">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a></div><div class="line">ConvectionVelocity&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> convection;</div><div class="line">  <span class="keywordflow">switch</span> (dim)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> 1:</div><div class="line">      convection[0] = 1;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> 2:</div><div class="line">      convection[0] = p[1];</div><div class="line">      convection[1] = -p[0];</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> 3:</div><div class="line">      convection[0] = p[1];</div><div class="line">      convection[1] = -p[0];</div><div class="line">      convection[2] = 1;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> convection;</div><div class="line">}</div></div><!-- fragment --><p>The last function we implement is the right hand side for the manufactured solution. It is very similar to <a class="el" href="step_7.html">step-7</a>, with the exception that we now have a convection term instead of the reaction term. Since the velocity field is incompressible, i.e. <img class="formulaInl" alt="$\nabla \cdot \mathbf{c} = 0$" src="form_3941.png"/>, this term simply reads <img class="formulaInl" alt="$\mathbf{c} \nabla u$" src="form_3942.png"/>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">  <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> convection = convection_velocity.value(p);</div><div class="line">  <span class="keywordtype">double</span> return_value = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">      return_value +=</div><div class="line">        ((2*dim - 2*convection*x_minus_xi - 4*x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>()/</div><div class="line">          (this-&gt;width * this-&gt;width)) /</div><div class="line">         (this-&gt;width * this-&gt;width) *</div><div class="line">         std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                  (this-&gt;width * this-&gt;width)));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> return_value / Utilities::fixed_power&lt;dim&gt;(std::sqrt(2 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>)</div><div class="line">                                                    * this-&gt;width);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheHDGsolverclass"></a> </p><h3>The HDG solver class</h3>
<p>The HDG solution procedure follows closely that of <a class="el" href="step_7.html">step-7</a>. The major difference is the use of three different sets of <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> and FE objects, along with the <code><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a></code> and the corresponding solutions vectors. We also use <a class="el" href="namespaceWorkStream.html">WorkStream</a> to enable a multithreaded local solution process which exploits the embarrassingly parallel nature of the local solver. For <a class="el" href="namespaceWorkStream.html">WorkStream</a>, we define the local operations on a cell and a copy function into the global matrix and vector. We do this both for the assembly (which is run twice, once when we generate the system matrix and once when we compute the element-interior solutions from the skeleton values) and for the postprocessing where we extract a solution that converges at higher order.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>HDG</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">enum</span> RefinementMode</div><div class="line">  {</div><div class="line">    global_refinement, adaptive_refinement</div><div class="line">  };</div><div class="line"></div><div class="line">  HDG (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree,</div><div class="line">       <span class="keyword">const</span> RefinementMode refinement_mode);</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system (<span class="keyword">const</span> <span class="keywordtype">bool</span> reconstruct_trace = <span class="keyword">false</span>);</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> postprocess ();</div><div class="line">  <span class="keywordtype">void</span> refine_grid (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cylce);</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div></div><!-- fragment --><p>Data for the assembly and solution of the primal variables.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PerTaskData;</div><div class="line"><span class="keyword">struct </span>ScratchData;</div></div><!-- fragment --><p>Post-processing the solution to obtain <img class="formulaInl" alt="$u^*$" src="form_3943.png"/> is an element-by-element procedure; as such, we do not need to assemble any global data and do not declare any 'task data' for <a class="el" href="namespaceWorkStream.html">WorkStream</a> to use.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PostProcessScratchData;</div></div><!-- fragment --><p>The following three functions are used by <a class="el" href="namespaceWorkStream.html">WorkStream</a> to do the actual work of the program.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_system_one_cell (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                               ScratchData &amp;scratch,</div><div class="line">                               PerTaskData &amp;task_data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> postprocess_one_cell (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                           PostProcessScratchData &amp;scratch,</div><div class="line">                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;empty_data);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div></div><!-- fragment --><p>The 'local' solutions are interior to each element. These represent the primal solution field <img class="formulaInl" alt="$u$" src="form_256.png"/> as well as the auxiliary field <img class="formulaInl" alt="$\mathbf{q}$" src="form_3907.png"/>.</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe_local;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_local;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution_local;</div></div><!-- fragment --><p>The new finite element type and corresponding <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> are used for the global skeleton solution that couples the element-level local solutions.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__FaceQ.html">FE_FaceQ&lt;dim&gt;</a>        fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div></div><!-- fragment --><p>As stated in the introduction, HDG solutions can be post-processed to attain superconvergence rates of <img class="formulaInl" alt="$\mathcal{O}(h^{p+2})$" src="form_3897.png"/>. The post-processed solution is a discontinuous finite element solution representing the primal variable on the interior of each cell. We define a FE type of degree <img class="formulaInl" alt="$p+1$" src="form_353.png"/> to represent this post-processed solution, which we only use for output after constructing it.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>          fe_u_post;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_u_post;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution_u_post;</div></div><!-- fragment --><p>The degrees of freedom corresponding to the skeleton strongly enforce Dirichlet boundary conditions, just as in a continuous Galerkin finite element method. We can enforce the boundary conditions in an analogous manner through the use of <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> constructs. In addition, hanging nodes are handled in the same way as for continuous finite elements: For the face elements which only define degrees of freedom on the face, this process sets the solution on the refined to be the one from the coarse side.</p>
<div class="fragment"><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div></div><!-- fragment --><p>The usage of the <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> class is similar to the usual sparse matrices: You need a sparsity pattern of type <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> and the actual matrix object. When creating the sparsity pattern, we just have to additionally pass the size of local blocks.</p>
<div class="fragment"><div class="line"><a class="code" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> sparsity_pattern;</div><div class="line"><a class="code" href="classChunkSparseMatrix.html">ChunkSparseMatrix&lt;double&gt;</a> system_matrix;</div></div><!-- fragment --><p>Same as <a class="el" href="step_7.html">step-7</a>:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> RefinementMode refinement_mode;</div><div class="line">  <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>     convergence_table;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheHDGclassimplementation"></a> </p><h3>The HDG class implementation</h3>
<p><a class="anchor" id="Constructor"></a> </p><h4>Constructor</h4>
<p>The constructor is similar to those in other examples, with the exception of handling multiple <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> and <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> objects. Note that we create a system of finite elements for the local DG part, including the gradient/flux part and the scalar part.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">HDG&lt;dim&gt;::HDG (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree,</div><div class="line">               <span class="keyword">const</span> RefinementMode refinement_mode) :</div><div class="line">  fe_local (<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), dim,</div><div class="line">            <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1),</div><div class="line">  dof_handler_local (triangulation),</div><div class="line">  fe (degree),</div><div class="line">  dof_handler (triangulation),</div><div class="line">  fe_u_post (degree+1),</div><div class="line">  dof_handler_u_post (triangulation),</div><div class="line">  refinement_mode (refinement_mode)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="HDGsetup_system"></a> </p><h4>HDG::setup_system</h4>
<p>The system for an HDG solution is setup in an analogous manner to most of the other tutorial programs. We are careful to distribute dofs with all of our <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> objects. The <code>solution</code> and <code>system_matrix</code> objects go with the global skeleton solution.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">HDG&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler_local.distribute_dofs(fe_local);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler_u_post.distribute_dofs(fe_u_post);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  solution.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  solution_local.reinit (dof_handler_local.n_dofs());</div><div class="line">  solution_u_post.reinit (dof_handler_u_post.n_dofs());</div><div class="line"></div><div class="line">  constraints.clear ();</div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler, constraints);</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a> boundary_functions;</div><div class="line">  Solution&lt;dim&gt; solution_function;</div><div class="line">  boundary_functions[0] = &amp;solution_function;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">VectorTools::project_boundary_values</a> (dof_handler,</div><div class="line">                                        boundary_functions,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1),</div><div class="line">                                        constraints);</div><div class="line">  constraints.close ();</div></div><!-- fragment --><p>When creating the chunk sparsity pattern, we first create the usual compressed sparsity pattern and then set the chunk size, which is equal to the number of dofs on a face, when copying this into the final sparsity pattern.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp,</div><div class="line">                                     constraints, <span class="keyword">false</span>);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp, fe.<a class="code" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>);</div><div class="line">  }</div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGPerTaskData"></a> </p><h4>HDG::PerTaskData</h4>
<p>Next comes the definition of the local data structures for the parallel assembly. The first structure <code>PerTaskData</code> contains the local vector and matrix that are written into the global matrix, whereas the ScratchData contains all data that we need for the local assembly. There is one variable worth noting here, namely the boolean variable <code>trace_reconstruct</code>. As mentioned in the introduction, we solve the HDG system in two steps. First, we create a linear system for the skeleton system where we condense the local part into it via the Schur complement <img class="formulaInl" alt="$D-CA^{-1}B$" src="form_3944.png"/>. Then, we solve for the local part using the skeleton solution. For these two steps, we need the same matrices on the elements twice, which we want to compute by two assembly steps. Since most of the code is similar, we do this with the same function but only switch between the two based on a flag that we set when starting the assembly. Since we need to pass this information on to the local worker routines, we store it once in the task data.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::PerTaskData</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_vector;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; dof_indices;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> trace_reconstruct;</div><div class="line"></div><div class="line">  PerTaskData(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs, <span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">    : cell_matrix(n_dofs, n_dofs),</div><div class="line">      cell_vector(n_dofs),</div><div class="line">      dof_indices(n_dofs),</div><div class="line">      trace_reconstruct(trace_reconstruct)</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGScratchData"></a> </p><h4>HDG::ScratchData</h4>
<p><code>ScratchData</code> contains persistent data for each thread within <code><a class="el" href="namespaceWorkStream.html">WorkStream</a></code>. The <code><a class="el" href="classFEValues.html">FEValues</a></code>, matrix, and vector objects should be familiar by now. There are two objects that need to be discussed: <code>std::vector&lt;std::vector&lt;unsigned int&gt;</code> &gt; fe_local_support_on_face and <code>std::vector&lt;std::vector&lt;unsigned int&gt;</code> &gt; fe_support_on_face. These are used to indicate whether or not the finite elements chosen have support (non-zero values) on a given face of the reference cell for the local part associated to <code>fe_local</code> and the skeleton part <code>fe</code>. We extract this information in the constructor and store it once for all cells that we work on. Had we not stored this information, we would be forced to assemble a large number of zero terms on each cell, which would significantly slow the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::ScratchData</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_local;</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_local;</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values;</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ll_matrix;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> lf_matrix;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> fl_matrix;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> tmp_matrix;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     l_rhs;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     tmp_rhs;</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; q_phi;</div><div class="line">  std::vector&lt;double&gt;         q_phi_div;</div><div class="line">  std::vector&lt;double&gt;         u_phi;</div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; u_phi_grad;</div><div class="line">  std::vector&lt;double&gt;         tr_phi;</div><div class="line">  std::vector&lt;double&gt;         trace_values;</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_local_support_on_face;</div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_support_on_face;</div><div class="line"></div><div class="line">  ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">  RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line">  <span class="keyword">const</span> Solution&lt;dim&gt; exact_solution;</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   &amp;quadrature_formula,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a> &amp;face_quadrature_formula,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags)</div><div class="line">    :</div><div class="line">    fe_values_local (fe_local, quadrature_formula, local_flags),</div><div class="line">    fe_face_values_local (fe_local, face_quadrature_formula, local_face_flags),</div><div class="line">    fe_face_values (fe, face_quadrature_formula, flags),</div><div class="line">    ll_matrix (fe_local.dofs_per_cell, fe_local.dofs_per_cell),</div><div class="line">    lf_matrix (fe_local.dofs_per_cell, fe.dofs_per_cell),</div><div class="line">    fl_matrix (fe.dofs_per_cell, fe_local.dofs_per_cell),</div><div class="line">    tmp_matrix (fe.dofs_per_cell, fe_local.dofs_per_cell),</div><div class="line">    l_rhs (fe_local.dofs_per_cell),</div><div class="line">    tmp_rhs (fe_local.dofs_per_cell),</div><div class="line">    q_phi (fe_local.dofs_per_cell),</div><div class="line">    q_phi_div (fe_local.dofs_per_cell),</div><div class="line">    u_phi (fe_local.dofs_per_cell),</div><div class="line">    u_phi_grad (fe_local.dofs_per_cell),</div><div class="line">    tr_phi (fe.dofs_per_cell),</div><div class="line">    trace_values(face_quadrature_formula.size()),</div><div class="line">    fe_local_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell),</div><div class="line">    fe_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_local.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (fe_local.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i,face))</div><div class="line">            fe_local_support_on_face[face].push_back(i);</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i,face))</div><div class="line">            fe_support_on_face[face].push_back(i);</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData &amp;sd)</div><div class="line">    :</div><div class="line">    fe_values_local (sd.fe_values_local.get_fe(),</div><div class="line">                     sd.fe_values_local.get_quadrature(),</div><div class="line">                     sd.fe_values_local.get_update_flags()),</div><div class="line">    fe_face_values_local (sd.fe_face_values_local.get_fe(),</div><div class="line">                          sd.fe_face_values_local.get_quadrature(),</div><div class="line">                          sd.fe_face_values_local.get_update_flags()),</div><div class="line">    fe_face_values (sd.fe_face_values.get_fe(),</div><div class="line">                    sd.fe_face_values.get_quadrature(),</div><div class="line">                    sd.fe_face_values.get_update_flags()),</div><div class="line">    ll_matrix (sd.ll_matrix),</div><div class="line">    lf_matrix (sd.lf_matrix),</div><div class="line">    fl_matrix (sd.fl_matrix),</div><div class="line">    tmp_matrix (sd.tmp_matrix),</div><div class="line">    l_rhs (sd.l_rhs),</div><div class="line">    tmp_rhs (sd.tmp_rhs),</div><div class="line">    q_phi (sd.q_phi),</div><div class="line">    q_phi_div (sd.q_phi_div),</div><div class="line">    u_phi (sd.u_phi),</div><div class="line">    u_phi_grad (sd.u_phi_grad),</div><div class="line">    tr_phi (sd.tr_phi),</div><div class="line">    trace_values(sd.trace_values),</div><div class="line">    fe_local_support_on_face(sd.fe_local_support_on_face),</div><div class="line">    fe_support_on_face(sd.fe_support_on_face)</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGPostProcessScratchData"></a> </p><h4>HDG::PostProcessScratchData</h4>
<p><code>PostProcessScratchData</code> contains the data used by <code><a class="el" href="namespaceWorkStream.html">WorkStream</a></code> when post-processing the local solution <img class="formulaInl" alt="$u^*$" src="form_3943.png"/>. It is similar, but much simpler, than <code>ScratchData</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>HDG&lt;dim&gt;::PostProcessScratchData</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_local;</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; u_values;</div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; u_gradients;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_sol;</div><div class="line"></div><div class="line">  PostProcessScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   &amp;quadrature_formula,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags)</div><div class="line">    :</div><div class="line">    fe_values_local (fe_local, quadrature_formula, local_flags),</div><div class="line">    fe_values (fe, quadrature_formula, flags),</div><div class="line">    u_values (quadrature_formula.size()),</div><div class="line">    u_gradients (quadrature_formula.size()),</div><div class="line">    cell_matrix (fe.dofs_per_cell, fe.dofs_per_cell),</div><div class="line">    cell_rhs (fe.dofs_per_cell),</div><div class="line">    cell_sol (fe.dofs_per_cell)</div><div class="line">  {}</div><div class="line"></div><div class="line">  PostProcessScratchData(<span class="keyword">const</span> PostProcessScratchData &amp;sd)</div><div class="line">    :</div><div class="line">    fe_values_local (sd.fe_values_local.get_fe(),</div><div class="line">                     sd.fe_values_local.get_quadrature(),</div><div class="line">                     sd.fe_values_local.get_update_flags()),</div><div class="line">    fe_values (sd.fe_values.get_fe(),</div><div class="line">               sd.fe_values.get_quadrature(),</div><div class="line">               sd.fe_values.get_update_flags()),</div><div class="line">    u_values (sd.u_values),</div><div class="line">    u_gradients (sd.u_gradients),</div><div class="line">    cell_matrix (sd.cell_matrix),</div><div class="line">    cell_rhs (sd.cell_rhs),</div><div class="line">    cell_sol (sd.cell_sol)</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="HDGassemble_system"></a> </p><h4>HDG::assemble_system</h4>
<p>The <code>assemble_system</code> function is similar to <code><a class="el" href="step_32.html">step-32</a></code>, where the quadrature formula and the update flags are set up, and then <code><a class="el" href="namespaceWorkStream.html">WorkStream</a></code> is used to do the work in a multi-threaded manner. The <code>trace_reconstruct</code> input parameter is used to decide whether we are solving for the global skeleton solution (false) or the local solution (true).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">HDG&lt;dim&gt;::assemble_system (<span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags ( <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  PerTaskData task_data (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">                         trace_reconstruct);</div><div class="line">  ScratchData scratch (fe, fe_local,</div><div class="line">                       quadrature_formula,</div><div class="line">                       face_quadrature_formula,</div><div class="line">                       local_flags,</div><div class="line">                       local_face_flags,</div><div class="line">                       flags);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  *<span class="keyword">this</span>,</div><div class="line">                  &amp;HDG&lt;dim&gt;::assemble_system_one_cell,</div><div class="line">                  &amp;HDG&lt;dim&gt;::copy_local_to_global,</div><div class="line">                  scratch,</div><div class="line">                  task_data);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGassemble_system_one_cell"></a> </p><h4>HDG::assemble_system_one_cell</h4>
<p>The real work of the HDG program is done by <code>assemble_system_one_cell</code>. Assembling the local matrices <img class="formulaInl" alt="$A, B, C$" src="form_3945.png"/> is done here, along with the local contributions of the global matrix <img class="formulaInl" alt="$D$" src="form_1015.png"/>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">HDG&lt;dim&gt;::assemble_system_one_cell (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                    ScratchData &amp;scratch,</div><div class="line">                                    PerTaskData &amp;task_data)</div><div class="line">{</div></div><!-- fragment --><p>Construct iterator for dof_handler_local for <a class="el" href="classFEValues.html">FEValues</a> reinit function.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">loc_cell (&amp;triangulation,</div><div class="line">          cell-&gt;level(),</div><div class="line">          cell-&gt;index(),</div><div class="line">          &amp;dof_handler_local);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = scratch.fe_values_local.get_quadrature().size();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = scratch.fe_face_values_local.get_quadrature().size();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loc_dofs_per_cell = scratch.fe_values_local.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().dofs_per_cell;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes (0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar (dim);</div><div class="line"></div><div class="line">scratch.ll_matrix = 0;</div><div class="line">scratch.l_rhs = 0;</div><div class="line"><span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">  {</div><div class="line">    scratch.lf_matrix = 0;</div><div class="line">    scratch.fl_matrix = 0;</div><div class="line">    task_data.cell_matrix = 0;</div><div class="line">    task_data.cell_vector = 0;</div><div class="line">  }</div><div class="line">scratch.fe_values_local.reinit (loc_cell);</div></div><!-- fragment --><p>We first compute the cell-interior contribution to <code>ll_matrix</code> matrix (referred to as matrix <img class="formulaInl" alt="$A$" src="form_40.png"/> in the introduction) corresponding to local-local coupling, as well as the local right-hand-side vector. We store the values at each quadrature point for the basis functions, the right-hand-side value, and the convection velocity, in order to have quick access to these fields.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> rhs_value</div><div class="line">      = scratch.right_hand_side.value(scratch.fe_values_local.quadrature_point(q));</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> convection</div><div class="line">      = scratch.convection_velocity.value(scratch.fe_values_local.quadrature_point(q));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_local.JxW(q);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;loc_dofs_per_cell; ++k)</div><div class="line">      {</div><div class="line">        scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k,q);</div><div class="line">        scratch.q_phi_div[k] = scratch.fe_values_local[fluxes].divergence(k,q);</div><div class="line">        scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k,q);</div><div class="line">        scratch.u_phi_grad[k] = scratch.fe_values_local[scalar].gradient(k,q);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;loc_dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;loc_dofs_per_cell; ++j)</div><div class="line">          scratch.ll_matrix(i,j) += (</div><div class="line">                                      scratch.q_phi[i] * scratch.q_phi[j]</div><div class="line">                                      -</div><div class="line">                                      scratch.q_phi_div[i] * scratch.u_phi[j]</div><div class="line">                                      +</div><div class="line">                                      scratch.u_phi[i] * scratch.q_phi_div[j]</div><div class="line">                                      -</div><div class="line">                                      (scratch.u_phi_grad[i] * convection) * scratch.u_phi[j]</div><div class="line">                                    ) * JxW;</div><div class="line">        scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW;</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Face terms are assembled on all faces of all elements. This is in contrast to more traditional DG methods, where each face is only visited once in the assembly procedure.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">  {</div><div class="line">    scratch.fe_face_values_local.reinit(loc_cell, face);</div><div class="line">    scratch.fe_face_values.reinit(cell, face);</div></div><!-- fragment --><p>The already obtained <img class="formulaInl" alt="$\hat{u}$" src="form_3913.png"/> values are needed when solving for the local variables.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">  scratch.fe_face_values.get_function_values (solution, scratch.trace_values);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_face_values.JxW(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> quadrature_point =</div><div class="line">      scratch.fe_face_values.quadrature_point(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> normal = scratch.fe_face_values.normal_vector(q);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> convection</div><div class="line">      = scratch.convection_velocity.value(quadrature_point);</div></div><!-- fragment --><p>Here we compute the stabilization parameter discussed in the introduction: since the diffusion is one and the diffusion length scale is set to 1/5, it simply results in a contribution of 5 for the diffusion part and the magnitude of convection through the element boundary in a centered scheme for the convection part.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tau_stab = (5. +</div><div class="line">                         std::abs(convection * normal));</div></div><!-- fragment --><p>We store the non-zero flux and scalar values, making use of the support_on_face information we created in <code>ScratchData</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;scratch.fe_local_support_on_face[face].size(); ++k)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk=scratch.fe_local_support_on_face[face][k];</div><div class="line">    scratch.q_phi[k] = scratch.fe_face_values_local[fluxes].value(kk,q);</div><div class="line">    scratch.u_phi[k] = scratch.fe_face_values_local[scalar].value(kk,q);</div><div class="line">  }</div></div><!-- fragment --><p>When <code>trace_reconstruct=false</code>, we are preparing to assemble the system for the skeleton variable <img class="formulaInl" alt="$\hat{u}$" src="form_3913.png"/>. If this is the case, we must assemble all local matrices associated with the problem: local-local, local-face, face-local, and face-face. The face-face matrix is stored as <code>TaskData::cell_matrix</code>, so that it can be assembled into the global system by <code>copy_local_to_global</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;scratch.fe_support_on_face[face].size(); ++k)</div><div class="line">      scratch.tr_phi[k] =</div><div class="line">        scratch.fe_face_values.shape_value(scratch.fe_support_on_face[face][k],q);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_local_support_on_face[face].size(); ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;scratch.fe_support_on_face[face].size(); ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_local_support_on_face[face][i];</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj=scratch.fe_support_on_face[face][j];</div><div class="line">          scratch.lf_matrix(ii,jj) += (</div><div class="line">                                        (scratch.q_phi[i] * normal</div><div class="line">                                         +</div><div class="line">                                         (convection * normal -</div><div class="line">                                          tau_stab) * scratch.u_phi[i])</div><div class="line">                                        * scratch.tr_phi[j]</div><div class="line">                                      ) * JxW;</div></div><!-- fragment --><p>Note the sign of the face-local matrix. We negate the sign during assembly here so that we can use the <a class="el" href="classFullMatrix.html#ac93d06d0f1305519dface996c8f93823">FullMatrix::mmult</a> with addition when computing the Schur complement.</p>
<div class="fragment"><div class="line">        scratch.fl_matrix(jj,ii) -= (</div><div class="line">                                      (scratch.q_phi[i] * normal</div><div class="line">                                       +</div><div class="line">                                       tau_stab * scratch.u_phi[i])</div><div class="line">                                      * scratch.tr_phi[j]</div><div class="line">                                    ) * JxW;</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_support_on_face[face].size(); ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;scratch.fe_support_on_face[face].size(); ++j)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_support_on_face[face][i];</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj=scratch.fe_support_on_face[face][j];</div><div class="line">        task_data.cell_matrix(ii,jj) += (</div><div class="line">                                          (convection * normal - tau_stab) *</div><div class="line">                                          scratch.tr_phi[i] * scratch.tr_phi[j]</div><div class="line">                                        ) * JxW;</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">      &amp;&amp;</div><div class="line">      (cell-&gt;face(face)-&gt;boundary_id() == 1))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value =</div><div class="line">        - scratch.exact_solution.gradient (quadrature_point) * normal</div><div class="line">        + convection * normal * scratch.exact_solution.value(quadrature_point);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_support_on_face[face].size(); ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_support_on_face[face][i];</div><div class="line">          task_data.cell_vector(ii) += scratch.tr_phi[i] * neumann_value * JxW;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This last term adds the contribution of the term <img class="formulaInl" alt="$\left&lt;w,\tau u_h\right&gt;_{\partial \mathcal T}$" src="form_3946.png"/> to the local matrix. As opposed to the face matrices above, we need it in both assembly stages.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_local_support_on_face[face].size(); ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;scratch.fe_local_support_on_face[face].size(); ++j)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_local_support_on_face[face][i];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj=scratch.fe_local_support_on_face[face][j];</div><div class="line">      scratch.ll_matrix(ii,jj) += tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW;</div><div class="line">    }</div></div><!-- fragment --><p>When <code>trace_reconstruct=true</code>, we are solving for the local solutions on an element by element basis. The local right-hand-side is calculated by replacing the basis functions <code>tr_phi</code> in the <code>lf_matrix</code> computation by the computed values <code>trace_values</code>. Of course, the sign of the matrix is now minus since we have moved everything to the other side of the equation.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_local_support_on_face[face].size(); ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_local_support_on_face[face][i];</div><div class="line">            scratch.l_rhs(ii) -= (scratch.q_phi[i] * normal</div><div class="line">                                  +</div><div class="line">                                  scratch.u_phi[i] * (convection * normal - tau_stab)</div><div class="line">                                 ) * scratch.trace_values[q] * JxW;</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Once assembly of all of the local contributions is complete, we must either: (1) assemble the global system, or (2) compute the local solution values and save them. In either case, the first step is to invert the local-local matrix.</p>
<div class="fragment"><div class="line">scratch.ll_matrix.gauss_jordan();</div></div><!-- fragment --><p>For (1), we compute the Schur complement and add it to the <code>cell_matrix</code>, matrix <img class="formulaInl" alt="$D$" src="form_1015.png"/> in the introduction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (task_data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);</div><div class="line">    scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);</div><div class="line">    scratch.tmp_matrix.mmult(task_data.cell_matrix, scratch.lf_matrix, <span class="keyword">true</span>);</div><div class="line">    cell-&gt;get_dof_indices(task_data.dof_indices);</div><div class="line">  }</div></div><!-- fragment --><p>For (2), we are simply solving (ll_matrix).(solution_local) = (l_rhs). Hence, we multiply <code>l_rhs</code> by our already inverted local-local matrix and store the result using the <code>set_dof_values</code> function.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);</div><div class="line">      loc_cell-&gt;set_dof_values(scratch.tmp_rhs, solution_local);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGcopy_local_to_global"></a> </p><h4>HDG::copy_local_to_global</h4>
<p>If we are in the first step of the solution, i.e. <code>trace_reconstruct=false</code>, then we assemble the local matrices into the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">    constraints.distribute_local_to_global (data.cell_matrix,</div><div class="line">                                            data.cell_vector,</div><div class="line">                                            data.dof_indices,</div><div class="line">                                            system_matrix, system_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGsolve"></a> </p><h4>HDG::solve</h4>
<p>The skeleton solution is solved for by using a BiCGStab solver with identity preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.m()*10,</div><div class="line">                                1e-11*system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;&gt;</a> solver (solver_control);</div><div class="line">  solver.solve (system_matrix, solution, system_rhs,</div><div class="line">                <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of BiCGStab iterations: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#aaddfdea0c37c5c468e7a76dc47840ff9">reinit</a>(0,0,0,1);</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div></div><!-- fragment --><p>Once we have solved for the skeleton solution, we can solve for the local solutions in an element-by-element fashion. We do this by re-using the same <code>assemble_system</code> function but switching <code>trace_reconstruct</code> to true.</p>
<div class="fragment"><div class="line">  assemble_system(<span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGpostprocess"></a> </p><h4>HDG::postprocess</h4>
<p>The postprocess method serves two purposes. First, we want to construct a post-processed scalar variables in the element space of degree <img class="formulaInl" alt="$p+1$" src="form_353.png"/> that we hope will converge at order <img class="formulaInl" alt="$p+2$" src="form_3947.png"/>. This is again an element-by-element process and only involves the scalar solution as well as the gradient on the local cell. To do this, we introduce the already defined scratch data together with some update flags and run the work stream to do this in parallel.</p>
<p>Secondly, we want to compute discretization errors just as we did in <a class="el" href="step_7.html">step-7</a>. The overall procedure is similar with calls to <a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a>. The difference is in how we compute the errors for the scalar variable and the gradient variable. In <a class="el" href="step_7.html">step-7</a>, we did this by computing <code>L2_norm</code> or <code>H1_seminorm</code> contributions. Here, we have a <a class="el" href="classDoFHandler.html">DoFHandler</a> with these two contributions computed and sorted by their vector component, <code>[0, dim)</code> for the gradient and <code>dim</code> for the scalar. To compute their value, we hence use a <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> with either of them, together with the <code>SolutionAndGradient</code> class introduced above that contains the analytic parts of either of them. Eventually, we also compute the L2-error of the post-processed solution and add the results into the convergence table.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">HDG&lt;dim&gt;::postprocess()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(fe_u_post.degree+1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags ( <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PostProcessScratchData scratch (fe_u_post, fe_local,</div><div class="line">                                    quadrature_formula,</div><div class="line">                                    local_flags,</div><div class="line">                                    flags);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_u_post.begin_active(),</div><div class="line">                    dof_handler_u_post.end(),</div><div class="line">                    std::bind (&amp;HDG&lt;dim&gt;::postprocess_one_cell,</div><div class="line">                               std::ref(*<span class="keyword">this</span>),</div><div class="line">                               std::placeholders::_1, std::placeholders::_2, std::placeholders::_3),</div><div class="line">                    std::function&lt;void(const unsigned int &amp;)&gt;(),</div><div class="line">                    scratch,</div><div class="line">                    0U);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> value_select (dim, dim+1);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_local,</div><div class="line">                                     solution_local,</div><div class="line">                                     SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                     difference_per_cell,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+2),</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                     &amp;value_select);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                            difference_per_cell,</div><div class="line">                                                            <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> gradient_select (std::pair&lt;unsigned int,unsigned int&gt;(0, dim),</div><div class="line">                                                dim+1);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_local,</div><div class="line">                                     solution_local,</div><div class="line">                                     SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                     difference_per_cell,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+2),</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                     &amp;gradient_select);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> grad_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                              difference_per_cell,</div><div class="line">                                                              <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_u_post,</div><div class="line">                                     solution_u_post,</div><div class="line">                                     Solution&lt;dim&gt;(),</div><div class="line">                                     difference_per_cell,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+3),</div><div class="line">                                     <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> post_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                              difference_per_cell,</div><div class="line">                                                              <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>,     triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>,      dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;val L2&quot;</span>,    L2_error);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;grad L2&quot;</span>,   grad_error);</div><div class="line">  convergence_table.add_value(<span class="stringliteral">&quot;val L2-post&quot;</span>, post_error);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGpostprocess_one_cell"></a> </p><h4>HDG::postprocess_one_cell</h4>
<p>This is the actual work done for the postprocessing. According to the discussion in the introduction, we need to set up a system that projects the gradient part of the DG solution onto the gradient of the post-processed variable. Moreover, we need to set the average of the new post-processed variable to equal the average of the scalar DG solution on the cell.</p>
<p>More technically speaking, the projection of the gradient is a system that would potentially fills our <code>dofs_per_cell</code> times <code>dofs_per_cell</code> matrix but is singular (the sum of all rows would be zero because the constant function has zero gradient). Therefore, we take one row away and use it for imposing the average of the scalar value. We pick the first row for the scalar part, even though we could pick any row for <img class="formulaInl" alt="$\mathcal Q_{-p}$" src="form_3921.png"/> elements. However, had we used <a class="el" href="classFE__DGP.html">FE_DGP</a> elements instead, the first row would correspond to the constant part already and deleting e.g. the last row would give us a singular system. This way, our program can also be used for those elements.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">HDG&lt;dim&gt;::postprocess_one_cell (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                PostProcessScratchData &amp;scratch,</div><div class="line">                                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;)</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  loc_cell (&amp;triangulation,</div><div class="line">            cell-&gt;level(),</div><div class="line">            cell-&gt;index(),</div><div class="line">            &amp;dof_handler_local);</div><div class="line"></div><div class="line">  scratch.fe_values_local.reinit (loc_cell);</div><div class="line">  scratch.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = scratch.fe_values.get_quadrature().size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.fe_values.dofs_per_cell;</div><div class="line"></div><div class="line">  scratch.fe_values_local[scalar].get_function_values(solution_local, scratch.u_values);</div><div class="line">  scratch.fe_values_local[fluxes].get_function_values(solution_local, scratch.u_gradients);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> sum = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i&lt;dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          sum = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">            sum += (scratch.fe_values.shape_grad(i,q) *</div><div class="line">                    scratch.fe_values.shape_grad(j,q)</div><div class="line">                   ) * scratch.fe_values.JxW(q);</div><div class="line">          scratch.cell_matrix(i,j) = <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        sum -= (scratch.fe_values.shape_grad(i,q) * scratch.u_gradients[q]</div><div class="line">               ) * scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_rhs(i) = <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">    {</div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        sum += scratch.fe_values.shape_value(j,q) * scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_matrix(0,j) = <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>;</div><div class="line">    }</div><div class="line">  {</div><div class="line">    sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      sum += scratch.u_values[q] * scratch.fe_values.JxW(q);</div><div class="line">    scratch.cell_rhs(0) = <a class="code" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a>;</div><div class="line">  }</div></div><!-- fragment --><p>Having assembled all terms, we can again go on and solve the linear system. We invert the matrix and then multiply the inverse by the right hand side. An alternative (and more numerically stable) method would have been to only factorize the matrix and apply the factorization.</p>
<div class="fragment"><div class="line">  scratch.cell_matrix.gauss_jordan();</div><div class="line">  scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);</div><div class="line">  cell-&gt;distribute_local_to_global(scratch.cell_sol, solution_u_post);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGoutput_results"></a> </p><h4>HDG::output_results</h4>
<p>We have 3 sets of results that we would like to output: the local solution, the post-processed local solution, and the skeleton solution. The former 2 both 'live' on element volumes, whereas the latter lives on codimension-1 surfaces of the triangulation. Our <code>output_results</code> function writes all local solutions to the same vtk file, even though they correspond to different <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> objects. The graphical output for the skeleton variable is done through use of the <code><a class="el" href="classDataOutFaces.html">DataOutFaces</a></code> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  std::string filename;</div><div class="line">  <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> global_refinement:</div><div class="line">      filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">      filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  std::string face_out(filename);</div><div class="line">  face_out += <span class="stringliteral">&quot;-face&quot;</span>;</div><div class="line"></div><div class="line">  filename += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>,1);</div><div class="line">  filename += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle,2);</div><div class="line">  filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">  std::ofstream output (filename.c_str());</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div></div><!-- fragment --><p>We first define the names and types of the local solution, and add the data to <code>data_out</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; names (dim, <span class="stringliteral">&quot;gradient&quot;</span>);</div><div class="line">names.push_back (<span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">component_interpretation</div><div class="line">(dim+1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">component_interpretation[dim]</div><div class="line">  = <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>;</div><div class="line">data_out.add_data_vector (dof_handler_local, solution_local,</div><div class="line">                          names, component_interpretation);</div></div><!-- fragment --><p>The second data item we add is the post-processed solution. In this case, it is a single scalar variable belonging to a different <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; post_name(1,<span class="stringliteral">&quot;u_post&quot;</span>);</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">post_comp_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">data_out.add_data_vector (dof_handler_u_post, solution_u_post,</div><div class="line">                          post_name, post_comp_type);</div><div class="line"></div><div class="line">data_out.build_patches (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">data_out.write_vtk (output);</div><div class="line"></div><div class="line">face_out += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>,1);</div><div class="line">face_out += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle,2);</div><div class="line">face_out += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">std::ofstream face_output (face_out.c_str());</div></div><!-- fragment --><p>The <code><a class="el" href="classDataOutFaces.html">DataOutFaces</a></code> class works analogously to the <code><a class="el" href="classDataOut.html">DataOut</a></code> class when we have a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> that defines the solution on the skeleton of the triangulation. We treat it as such here, and the code is similar to that above.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a> data_out_face(<span class="keyword">false</span>);</div><div class="line">  std::vector&lt;std::string&gt; face_name(1,<span class="stringliteral">&quot;u_hat&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  face_component_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  data_out_face.add_data_vector (dof_handler,</div><div class="line">                                 solution,</div><div class="line">                                 face_name,</div><div class="line">                                 face_component_type);</div><div class="line"></div><div class="line">  data_out_face.build_patches (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">  data_out_face.write_vtk (face_output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGrefine_grid"></a> </p><h4>HDG::refine_grid</h4>
<p>We implement two different refinement cases for HDG, just as in <code><a class="el" href="step_7.html">step-7</a></code>: adaptive_refinement and global_refinement. The global_refinement option recreates the entire triangulation every time. This is because we want to use a finer sequence of meshes than what we would get with one refinement step, namely 2, 3, 4, 6, 8, 12, 16, ... elements per direction.</p>
<p>The adaptive_refinement mode uses the <code><a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a></code> to give a decent indication of the non-regular regions in the scalar local solutions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::refine_grid (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">GridGenerator::subdivided_hyper_cube</a> (triangulation, 2, -1, 1);</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3-dim);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> global_refinement:</div><div class="line">      {</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">clear</a>();</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">GridGenerator::subdivided_hyper_cube</a> (triangulation, 2+(cycle%2), -1, 1);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3-dim+cycle/2);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">      {</div><div class="line">        <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">        <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a> neumann_boundary;</div><div class="line">        <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler_local,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(3),</div><div class="line">                                            neumann_boundary,</div><div class="line">                                            solution_local,</div><div class="line">                                            estimated_error_per_cell,</div><div class="line">                                            fe_local.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(scalar));</div><div class="line"></div><div class="line">        <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                         estimated_error_per_cell,</div><div class="line">                                                         0.3, 0.);</div><div class="line"></div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line"></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line">      }</div></div><!-- fragment --><p>Just as in <a class="el" href="step_7.html">step-7</a>, we set the boundary indicator of two of the faces to 1 where we want to specify Neumann boundary conditions instead of Dirichlet conditions. Since we re-create the triangulation every time for global refinement, the flags are set in every refinement step, not just at the beginning.</p>
<div class="fragment"><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a> (),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary())</div><div class="line">        <span class="keywordflow">if</span> ((std::fabs(cell-&gt;face(face)-&gt;center()(0) - (-1)) &lt; 1e-12)</div><div class="line">            ||</div><div class="line">            (std::fabs(cell-&gt;face(face)-&gt;center()(1) - (-1)) &lt; 1e-12))</div><div class="line">          cell-&gt;face(face)-&gt;set_boundary_id (1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="HDGrun"></a> </p><h4>HDG::run</h4>
<p>The functionality here is basically the same as <code><a class="el" href="step_7.html">step-7</a></code>. We loop over 10 cycles, refining the grid on each one. At the end, convergence tables are created.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> HDG&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;10; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      refine_grid (cycle);</div><div class="line">      setup_system ();</div><div class="line">      assemble_system (<span class="keyword">false</span>);</div><div class="line">      solve ();</div><div class="line">      postprocess();</div><div class="line">      output_results (cycle);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;val L2&quot;</span>, 3);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;grad L2&quot;</span>, 3);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">  convergence_table.set_precision(<span class="stringliteral">&quot;val L2-post&quot;</span>, 3);</div><div class="line">  convergence_table.set_scientific(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="keyword">true</span>);</div></div><!-- fragment --><p>There is one minor change for the convergence table compared to <a class="el" href="step_7.html">step-7</a>: Since we did not refine our mesh by a factor two in each cycle (but rather used the sequence 2, 3, 4, 6, 8, 12, ...), we need to tell the convergence rate evaluation about this. We do this by setting the number of cells as a reference column and additionally specifying the dimension of the problem, which gives the necessary information for the relation between number of cells and mesh size.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (refinement_mode == global_refinement)</div><div class="line">      {</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">      }</div><div class="line">    convergence_table.write_text(std::cout);</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// end of namespace Step51</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>Now for the three calls to the main class in complete analogy to <a class="el" href="step_7.html">step-7</a>.</p>
<div class="fragment"><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem (1, Step51::HDG&lt;dim&gt;::adaptive_refinement);</div><div class="line">        hdg_problem.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem (1, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q3 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem (3, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>We first have a look at the output generated by the program when run in 2D. In the four images below, we show the solution for polynomial degree <img class="formulaInl" alt="$p=1$" src="form_3474.png"/> and cycles 2, 3, 4, and 8 of the program. In the plots, we overlay the data generated from the internal data (DG part) with the skeleton part ( <img class="formulaInl" alt="$\hat{u}$" src="form_3913.png"/>) into the same plot. We had to generate two different data sets because cells and faces represent different geometric entities, the combination of which (in the same file) is not supported in the VTK output of deal.II.</p>
<p>The images show the distinctive features of HDG: The cell solution (colored surfaces) is discontinuous between the cells. The solution on the skeleton variable sits on the faces and ties together the local parts. The skeleton solution is not continuous on the vertices where the faces meet, even though its values are quite close along lines in the same coordinate direction. The skeleton solution can be interpreted as a rubber spring between the two sides that balances the jumps in the solution (or rather, the flux <img class="formulaInl" alt="$\kappa \nabla u + \mathbf{c} u$" src="form_3948.png"/>). From the picture at the top left, it is clear that the bulk solution frequently over- and undershoots and that the skeleton variable in indeed a better approximation to the exact solution; this explains why we can get a better solution using a postprocessing step.</p>
<p>As the mesh is refined, the jumps between the cells get small (we represent a smooth solution), and the skeleton solution approaches the interior parts. For cycle 8, there is no visible difference in the two variables. We also see how boundary conditions are implemented weakly and that the interior variables do not exactly satisfy boundary conditions. On the lower and left boundaries, we set Neumann boundary conditions, whereas we set Dirichlet conditions on the right and top boundaries.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_3.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_8.png"/>
</div>
  </td></tr>
</table>
<p>Next, we have a look at the post-processed solution, again at cycles 2, 3, 4, and 8. This is a discontinuous solution that is locally described by second order polynomials. While the solution does not look very good on the mesh of cycle two, it looks much better for cycles three and four. As shown by the convergence table below, we find that is also converges more quickly to the analytical solution.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_3.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_8.png"/>
</div>
  </td></tr>
</table>
<p>Finally, we look at the solution for <img class="formulaInl" alt="$p=3$" src="form_3949.png"/> at cycle 2. Despite the coarse mesh with only 64 cells, the post-processed solution is similar in quality to the linear solution (not post-processed) at cycle 8 with 4,096 cells. This clearly shows the superiority of high order methods for smooth solutions.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.sol_q3_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.post_q3_2.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="Convergencetables"></a></p><h4>Convergence tables</h4>
<p>When the program is run, it also outputs information about the respective steps and convergence tables with errors in the various components in the end. In 2D, the convergence tables look the following:</p>
<div class="fragment"><div class="line">Q1 elements, adaptive refinement:</div><div class="line">cells dofs   val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>    grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>  val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16    80 1.804e+01 2.207e+01   1.798e+01</div><div class="line">   31   170 9.874e+00 1.322e+01   9.798e+00</div><div class="line">   61   314 7.452e-01 3.793e+00   4.891e-01</div><div class="line">  121   634 3.240e-01 1.511e+00   2.616e-01</div><div class="line">  238  1198 8.585e-02 8.212e-01   1.808e-02</div><div class="line">  454  2290 4.802e-02 5.178e-01   2.195e-02</div><div class="line">  898  4378 2.561e-02 2.947e-01   4.318e-03</div><div class="line"> 1720  7864 1.306e-02 1.664e-01   2.978e-03</div><div class="line"> 3271 14638 7.025e-03 9.815e-02   1.075e-03</div><div class="line"> 6217 27214 4.119e-03 6.407e-02   9.975e-04</div><div class="line"></div><div class="line">Q1 elements, global refinement:</div><div class="line">cells dofs      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16    80 1.804e+01    - 2.207e+01    - 1.798e+01    -</div><div class="line">   36   168 6.125e+00 2.66 9.472e+00 2.09 6.084e+00 2.67</div><div class="line">   64   288 9.785e-01 6.38 4.260e+00 2.78 7.102e-01 7.47</div><div class="line">  144   624 2.730e-01 3.15 1.866e+00 2.04 6.115e-02 6.05</div><div class="line">  256  1088 1.493e-01 2.10 1.046e+00 2.01 2.880e-02 2.62</div><div class="line">  576  2400 6.965e-02 1.88 4.846e-01 1.90 9.204e-03 2.81</div><div class="line"> 1024  4224 4.018e-02 1.91 2.784e-01 1.93 4.027e-03 2.87</div><div class="line"> 2304  9408 1.831e-02 1.94 1.264e-01 1.95 1.236e-03 2.91</div><div class="line"> 4096 16640 1.043e-02 1.96 7.185e-02 1.96 5.306e-04 2.94</div><div class="line"> 9216 37248 4.690e-03 1.97 3.228e-02 1.97 1.599e-04 2.96</div><div class="line"></div><div class="line">Q3 elements, global refinement:</div><div class="line">cells dofs      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">   16   160 3.613e-01    - 1.891e+00    - 3.020e-01    -</div><div class="line">   36   336 6.411e-02 4.26 5.081e-01 3.24 3.238e-02 5.51</div><div class="line">   64   576 3.480e-02 2.12 2.533e-01 2.42 5.277e-03 6.31</div><div class="line">  144  1248 8.297e-03 3.54 5.924e-02 3.58 6.330e-04 5.23</div><div class="line">  256  2176 2.254e-03 4.53 1.636e-02 4.47 1.403e-04 5.24</div><div class="line">  576  4800 4.558e-04 3.94 3.277e-03 3.96 1.844e-05 5.01</div><div class="line"> 1024  8448 1.471e-04 3.93 1.052e-03 3.95 4.378e-06 5.00</div><div class="line"> 2304 18816 2.956e-05 3.96 2.104e-04 3.97 5.750e-07 5.01</div><div class="line"> 4096 33280 9.428e-06 3.97 6.697e-05 3.98 1.362e-07 5.01</div><div class="line"> 9216 74496 1.876e-06 3.98 1.330e-05 3.99 1.788e-08 5.01</div></div><!-- fragment --><p>One can see the error reduction upon grid refinement, and for the cases where global refinement was performed, also the convergence rates. The quadratic convergence rates of Q1 elements in the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> norm for both the scalar variable and the gradient variable is apparent, as is the cubic rate for the postprocessed scalar variable in the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> norm. Note this distinctive feature of an HDG solution. In typical continuous finite elements, the gradient of the solution of order <img class="formulaInl" alt="$p$" src="form_202.png"/> converges at rate <img class="formulaInl" alt="$p$" src="form_202.png"/> only, as opposed to <img class="formulaInl" alt="$p+1$" src="form_353.png"/> for the actual solution. Even though superconvergence results for finite elements are also available (e.g. superconvergent patch recovery first introduced by Zienkiewicz and Zhu), these are typically limited to structured meshes and other special cases. For Q3 HDG variables, the scalar variable and gradient converge at fourth order and the postprocessed scalar variable at fifth order.</p>
<p>The same convergence rates are observed in 3d. </p><div class="fragment"><div class="line">Q1 elements, adaptive refinement:</div><div class="line">cells   dofs    val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>    grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>  val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     144 7.122e+00 1.941e+01   6.102e+00</div><div class="line">    29     500 3.309e+00 1.023e+01   2.145e+00</div><div class="line">   113    1792 2.204e+00 1.023e+01   1.912e+00</div><div class="line">   379    5732 6.085e-01 5.008e+00   2.233e-01</div><div class="line">  1317   19412 1.543e-01 1.464e+00   4.196e-02</div><div class="line">  4579   64768 5.058e-02 5.611e-01   9.521e-03</div><div class="line"> 14596  199552 2.129e-02 3.122e-01   4.569e-03</div><div class="line"> 46180  611400 1.033e-02 1.622e-01   1.684e-03</div><div class="line">144859 1864212 5.007e-03 8.371e-02   7.364e-04</div><div class="line">451060 5684508 2.518e-03 4.562e-02   3.070e-04</div><div class="line"></div><div class="line">Q1 elements, global refinement:</div><div class="line">cells   dofs       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>          grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     144 7.122e+00    - 1.941e+01     - 6.102e+00    -</div><div class="line">    27     432 5.491e+00 0.64 2.184e+01 -0.29 4.448e+00 0.78</div><div class="line">    64     960 3.646e+00 1.42 1.299e+01  1.81 3.306e+00 1.03</div><div class="line">   216    3024 1.595e+00 2.04 8.550e+00  1.03 1.441e+00 2.05</div><div class="line">   512    6912 6.922e-01 2.90 5.306e+00  1.66 2.511e-01 6.07</div><div class="line">  1728   22464 2.915e-01 2.13 2.490e+00  1.87 8.588e-02 2.65</div><div class="line">  4096   52224 1.684e-01 1.91 1.453e+00  1.87 4.055e-02 2.61</div><div class="line"> 13824  172800 7.972e-02 1.84 6.861e-01  1.85 1.335e-02 2.74</div><div class="line"> 32768  405504 4.637e-02 1.88 3.984e-01  1.89 5.932e-03 2.82</div><div class="line">110592 1354752 2.133e-02 1.92 1.830e-01  1.92 1.851e-03 2.87</div><div class="line"></div><div class="line">Q3 elements, global refinement:</div><div class="line">cells   dofs       val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>        grad <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>      val <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a>-post</div><div class="line">     8     576 5.670e+00    - 1.868e+01    - 5.462e+00    -</div><div class="line">    27    1728 1.048e+00 4.16 6.988e+00 2.42 8.011e-01 4.73</div><div class="line">    64    3840 2.831e-01 4.55 2.710e+00 3.29 1.363e-01 6.16</div><div class="line">   216   12096 7.883e-02 3.15 7.721e-01 3.10 2.158e-02 4.55</div><div class="line">   512   27648 3.642e-02 2.68 3.305e-01 2.95 5.231e-03 4.93</div><div class="line">  1728   89856 8.546e-03 3.58 7.581e-02 3.63 7.640e-04 4.74</div><div class="line">  4096  208896 2.598e-03 4.14 2.313e-02 4.13 1.783e-04 5.06</div><div class="line"> 13824  691200 5.314e-04 3.91 4.697e-03 3.93 2.355e-05 4.99</div><div class="line"> 32768 1622016 1.723e-04 3.91 1.517e-03 3.93 5.602e-06 4.99</div><div class="line">110592 5419008 3.482e-05 3.94 3.055e-04 3.95 7.374e-07 5.00</div></div><!-- fragment --><p><a class="anchor" id="Comparisonwithcontinuousfiniteelements"></a></p><h3>Comparison with continuous finite elements</h3>
<p><a class="anchor" id="Resultsfor2D"></a></p><h4>Results for 2D</h4>
<p>The convergence tables verify the expected convergence rates stated in the introduction. Now, we want to show a quick comparison of the computational efficiency of the HDG method compared to a usual finite element (continuous Galkerin) method on the problem of this tutorial. Of course, stability aspects of the HDG method compared to continuous finite elements for transport-dominated problems are also important in practice, which is an aspect not seen on a problem with smooth analytic solution. In the picture below, we compare the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> error as a function of the number of degrees of freedom (left) and of the computing time spent in the linear solver (right) for two space dimensions of continuous finite elements (CG) and the hybridized discontinuous Galerkin method presented in this tutorial. As opposed to the tutorial where we only use unpreconditioned BiCGStab, the times shown in the figures below use the Trilinos algebraic multigrid preconditioner in <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a>. For the HDG part, a wrapper around <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> for the trace variable has been used in order to utilize the block structure in the matrix on the finest level.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_plain.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_plain.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The results in the graphs show that the HDG method is slower than continuous finite elements at <img class="formulaInl" alt="$p=1$" src="form_3474.png"/>, about equally fast for cubic elements and faster for sixth order elements. However, we have seen above that the HDG method actually produces solutions which are more accurate than what is represented in the original variables. Therefore, in the next two plots below we instead display the error of the post-processed solution for HDG (denoted by <img class="formulaInl" alt="$p=1^*$" src="form_3950.png"/> for example). We now see a clear advantage of HDG for the same amount of work for both <img class="formulaInl" alt="$p=3$" src="form_3949.png"/> and <img class="formulaInl" alt="$p=6$" src="form_3951.png"/>, and about the same quality for <img class="formulaInl" alt="$p=1$" src="form_3474.png"/>.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_post.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_post.png" width="400"/>
</div>
  </td></tr>
</table>
<p>Since the HDG method actually produces results converging as <img class="formulaInl" alt="$h^{p+2}$" src="form_3952.png"/>, we should compare it to a continuous Galerkin solution with the same asymptotic convergence behavior, i.e., <a class="el" href="classFE__Q.html">FE_Q</a> with degree <img class="formulaInl" alt="$p+1$" src="form_353.png"/>. If we do this, we get the convergence curves below. We see that CG with second order polynomials is again clearly better than HDG with linears. However, the advantage of HDG for higher orders remains.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2d_postb.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.2dt_postb.png" width="400"/>
</div>
  </td></tr>
</table>
<p>The results are in line with properties of DG methods in general: Best performance is typically not achieved for linear elements, but rather at somewhat higher order, usually around <img class="formulaInl" alt="$p=3$" src="form_3949.png"/>. This is because of a volume-to-surface effect for discontinuous solutions with too much of the solution living on the surfaces and hence duplicating work when the elements are linear. Put in other words, DG methods are often most efficient when used at relatively high order, despite their focus on a discontinuous (and hence, seemingly low accurate) representation of solutions.</p>
<p><a class="anchor" id="Resultsfor3D"></a></p><h4>Results for 3D</h4>
<p>We now show the same figures in 3D: The first row shows the number of degrees of freedom and computing time versus the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> error in the scalar variable <img class="formulaInl" alt="$u$" src="form_256.png"/> for CG and HDG at order <img class="formulaInl" alt="$p$" src="form_202.png"/>, the second row shows the post-processed HDG solution instead of the original one, and the third row compares the post-processed HDG solution with CG at order <img class="formulaInl" alt="$p+1$" src="form_353.png"/>. In 3D, the volume-to-surface effect makes the cost of HDG somewhat higher and the CG solution is clearly better than HDG for linears by any metric. For cubics, HDG and CG are of similar quality, whereas HDG is again more efficient for sixth order polynomials. One can alternatively also use the combination of <a class="el" href="classFE__DGP.html">FE_DGP</a> and <a class="el" href="classFE__FaceP.html">FE_FaceP</a> instead of (<a class="el" href="classFE__DGQ.html">FE_DGQ</a>, <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a>), which do not use tensor product polynomials of degree <img class="formulaInl" alt="$p$" src="form_202.png"/> but Legendre polynomials of <em>complete</em> degree <img class="formulaInl" alt="$p$" src="form_202.png"/>. There are fewer degrees of freedom on the skeleton variable for <a class="el" href="classFE__FaceP.html">FE_FaceP</a> for a given mesh size, but the solution quality (error vs. number of DoFs) is very similar to the results for <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a>.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_plain.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_plain.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_post.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_post.png" width="400"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3d_postb.png" width="400"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-51.3dt_postb.png" width="400"/>
</div>
  </td></tr>
</table>
<p>One final note on the efficiency comparison: We tried to use general-purpose sparse matrix structures and similar solvers (optimal AMG preconditioners for both without particular tuning of the AMG parameters on any of them) to give a fair picture of the cost versus accuracy of two methods, on a toy example. It should be noted however that geometric multigrid (GMG) for continuous finite elements is about a factor four to five faster for <img class="formulaInl" alt="$p=3$" src="form_3949.png"/> and <img class="formulaInl" alt="$p=6$" src="form_3951.png"/>. The authors of this tutorial have not seen similarly advanced solvers for the HDG linear systems. Also, there are other implementation aspects for CG available such as fast matrix-free approaches as shown in <a class="el" href="step_37.html">step-37</a> that make higher order continuous elements more competitive. Again, it is not clear to the authors of the tutorial whether similar improvements could be made for HDG.</p>
<p><a class="anchor" id="Possibilitiesforimprovements"></a></p><h3>Possibilities for improvements</h3>
<p>As already mentioned in the introduction, one possibility is to implement another post-processing technique as discussed in the literature.</p>
<p>A second item that is not done optimally relates to the performance of this program, which is of course an issue in practical applications (weighing in also the better solution quality of (H)DG methods for transport-dominated problems). Let us look at the computing time of the tutorial program and the share of the individual components:</p>
<table align="center" border="1">
<tr>
<th>&#160; </th><th>&#160; </th><th>Setup </th><th>Assemble </th><th>Solve </th><th>Trace reconstruct </th><th>Post-processing </th><th>Output  </th></tr>
<tr>
<th>&#160; </th><th>Total time </th><th colspan="6">Relative share  </th></tr>
<tr>
<td align="left">2D, Q1, cycle 9, 37,248 dofs </td><td align="center">5.34s </td><td align="center">0.7% </td><td align="center">1.2% </td><td align="center">89.5% </td><td align="center">0.9% </td><td align="center">2.3% </td><td align="center">5.4%  </td></tr>
<tr>
<td align="left">2D, Q3, cycle 9, 74,496 dofs </td><td align="center">22.2s </td><td align="center">0.4% </td><td align="center">4.3% </td><td align="center">84.1% </td><td align="center">4.1% </td><td align="center">3.5% </td><td align="center">3.6%  </td></tr>
<tr>
<td align="left">3D, Q1, cycle 7, 172,800 dofs </td><td align="center">9.06s </td><td align="center">3.1% </td><td align="center">8.9% </td><td align="center">42.7% </td><td align="center">7.0% </td><td align="center">20.6% </td><td align="center">17.7%  </td></tr>
<tr>
<td align="left">3D, Q3, cycle 7, 691,200 dofs </td><td align="center">516s </td><td align="center">0.6% </td><td align="center">34.5% </td><td align="center">13.4% </td><td align="center">32.8% </td><td align="center">17.1% </td><td align="center">1.5%  </td></tr>
</table>
<p>As can be seen from the table, the solver and assembly calls dominate the runtime of the program. This also gives a clear indication of where improvements would make the most sense:</p>
<ol>
<li>
<p class="startli">Better linear solvers: We use a BiCGStab iterative solver without preconditioner, where the number of iteration increases with increasing problem size (the number of iterations for Q1 elements and global refinements starts at 35 for the small sizes but increase up to 701 for the largest size). To do better, one could for example use an algebraic multigrid preconditioner from Trilinos. For diffusion-dominated problems such as the problem at hand with finer meshes, such a solver can be designed that uses the matrix-vector products from the more efficient <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> on the finest level, as long as we are not working in parallel with MPI. For MPI-parallelized computation, a standard <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> can be used.</p>
<p class="endli"></p>
</li>
<li>
Speed up assembly by pre-assembling parts that do not change from one cell to another (those that do neither contain variable coefficients nor mapping-dependent terms). </li>
</ol>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2013 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Martin Kronbichler, Technische Universität München,</span></div><div class="line"><span class="comment"> *         Scott T. Miller, The Pennsylvania State University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor_function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/exceptions.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/work_stream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/convergence_table.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_bicgstab.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_face.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/chunk_sparse_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out_faces.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step51</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SolutionBase</div><div class="line">  {</div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_source_centers = 3;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>    source_centers[n_source_centers];</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span>        width;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;1&gt;</a></div><div class="line">  SolutionBase&lt;1&gt;::source_centers[SolutionBase&lt;1&gt;::n_source_centers]</div><div class="line">    = { <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(-1.0 / 3.0),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(0.0),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;1&gt;</a>(+1.0 / 3.0)</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a></div><div class="line">  SolutionBase&lt;2&gt;::source_centers[SolutionBase&lt;2&gt;::n_source_centers]</div><div class="line">    = { <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, +0.5),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, -0.5),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(+0.5, -0.5)</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  SolutionBase&lt;3&gt;::source_centers[SolutionBase&lt;3&gt;::n_source_centers]</div><div class="line">    = { <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.5, +0.5, 0.25),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(-0.6, -0.5, -0.125),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(+0.5, -0.5, 0.5)</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> SolutionBase&lt;dim&gt;::width = 1./5.;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">    <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Solution () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> gradient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordtype">double</span> return_value = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line">        return_value += std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                                 (this-&gt;width * this-&gt;width));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value /</div><div class="line">           Utilities::fixed_power&lt;dim&gt;(std::sqrt(2. * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>) * this-&gt;width);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> Solution&lt;dim&gt;::gradient (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> return_value;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">        return_value += (-2 / (this-&gt;width * this-&gt;width) *</div><div class="line">                         std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                                  (this-&gt;width * this-&gt;width)) *</div><div class="line">                         x_minus_xi);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value / Utilities::fixed_power&lt;dim&gt;(std::sqrt(2 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>) *</div><div class="line">                                                      this-&gt;width);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SolutionAndGradient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">    <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SolutionAndGradient () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     &amp;v) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SolutionAndGradient&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;v)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(v.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), dim+1);</div><div class="line">    Solution&lt;dim&gt; solution;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> grad = solution.gradient(p);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">      v[d] = -grad[d];</div><div class="line">    v[dim] = solution.value(p);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ConvectionVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1,dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ConvectionVelocity() : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1,dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a></div><div class="line">  ConvectionVelocity&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> convection;</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 1:</div><div class="line">        convection[0] = 1;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        convection[0] = p[1];</div><div class="line">        convection[1] = -p[0];</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        convection[0] = p[1];</div><div class="line">        convection[1] = -p[0];</div><div class="line">        convection[2] = 1;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line">    <span class="keywordflow">return</span> convection;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;,</div><div class="line">    <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> convection = convection_velocity.value(p);</div><div class="line">    <span class="keywordtype">double</span> return_value = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;this-&gt;n_source_centers; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> x_minus_xi = p - this-&gt;source_centers[i];</div><div class="line"></div><div class="line">        return_value +=</div><div class="line">          ((2*dim - 2*convection*x_minus_xi - 4*x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>()/</div><div class="line">            (this-&gt;width * this-&gt;width)) /</div><div class="line">           (this-&gt;width * this-&gt;width) *</div><div class="line">           std::exp(-x_minus_xi.<a class="code" href="classTensor.html#af608705050a5681f6034f5cf7a041e54">norm_square</a>() /</div><div class="line">                    (this-&gt;width * this-&gt;width)));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> return_value / Utilities::fixed_power&lt;dim&gt;(std::sqrt(2 * <a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>)</div><div class="line">                                                      * this-&gt;width);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>HDG</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> RefinementMode</div><div class="line">    {</div><div class="line">      global_refinement, adaptive_refinement</div><div class="line">    };</div><div class="line"></div><div class="line">    HDG (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree,</div><div class="line">         <span class="keyword">const</span> RefinementMode refinement_mode);</div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system (<span class="keyword">const</span> <span class="keywordtype">bool</span> reconstruct_trace = <span class="keyword">false</span>);</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> postprocess ();</div><div class="line">    <span class="keywordtype">void</span> refine_grid (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cylce);</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle);</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PerTaskData;</div><div class="line">    <span class="keyword">struct </span>ScratchData;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>PostProcessScratchData;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system_one_cell (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                   ScratchData &amp;scratch,</div><div class="line">                                   PerTaskData &amp;task_data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> postprocess_one_cell (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                               PostProcessScratchData &amp;scratch,</div><div class="line">                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;empty_data);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line"></div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>        fe_local;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_local;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution_local;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__FaceQ.html">FE_FaceQ&lt;dim&gt;</a>        fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>          fe_u_post;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler_u_post;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution_u_post;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> sparsity_pattern;</div><div class="line">    <a class="code" href="classChunkSparseMatrix.html">ChunkSparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RefinementMode refinement_mode;</div><div class="line">    <a class="code" href="classConvergenceTable.html">ConvergenceTable</a>     convergence_table;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  HDG&lt;dim&gt;::HDG (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree,</div><div class="line">                 <span class="keyword">const</span> RefinementMode refinement_mode) :</div><div class="line">    fe_local (<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), dim,</div><div class="line">              <a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1),</div><div class="line">    dof_handler_local (triangulation),</div><div class="line">    fe (degree),</div><div class="line">    dof_handler (triangulation),</div><div class="line">    fe_u_post (degree+1),</div><div class="line">    dof_handler_u_post (triangulation),</div><div class="line">    refinement_mode (refinement_mode)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  HDG&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    dof_handler_local.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_local);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler_u_post.distribute_dofs(fe_u_post);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    solution.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    solution_local.reinit (dof_handler_local.n_dofs());</div><div class="line">    solution_u_post.reinit (dof_handler_u_post.n_dofs());</div><div class="line"></div><div class="line">    constraints.clear ();</div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler, constraints);</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a> boundary_functions;</div><div class="line">    Solution&lt;dim&gt; solution_function;</div><div class="line">    boundary_functions[0] = &amp;solution_function;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a5f69dee9fb8ad9f00bc39800573df130">VectorTools::project_boundary_values</a> (dof_handler,</div><div class="line">                                          boundary_functions,</div><div class="line">                                          <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1),</div><div class="line">                                          constraints);</div><div class="line">    constraints.close ();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp,</div><div class="line">                                       constraints, <span class="keyword">false</span>);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp, fe.<a class="code" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>);</div><div class="line">    }</div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::PerTaskData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_vector;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; dof_indices;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> trace_reconstruct;</div><div class="line"></div><div class="line">    PerTaskData(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs, <span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">      : cell_matrix(n_dofs, n_dofs),</div><div class="line">        cell_vector(n_dofs),</div><div class="line">        dof_indices(n_dofs),</div><div class="line">        trace_reconstruct(trace_reconstruct)</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::ScratchData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_local;</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_local;</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> ll_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> lf_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> fl_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> tmp_matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     l_rhs;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     tmp_rhs;</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt; q_phi;</div><div class="line">    std::vector&lt;double&gt;         q_phi_div;</div><div class="line">    std::vector&lt;double&gt;         u_phi;</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt; u_phi_grad;</div><div class="line">    std::vector&lt;double&gt;         tr_phi;</div><div class="line">    std::vector&lt;double&gt;         trace_values;</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_local_support_on_face;</div><div class="line">    std::vector&lt;std::vector&lt;unsigned int&gt; &gt; fe_support_on_face;</div><div class="line"></div><div class="line">    ConvectionVelocity&lt;dim&gt; convection_velocity;</div><div class="line">    RightHandSide&lt;dim&gt; right_hand_side;</div><div class="line">    <span class="keyword">const</span> Solution&lt;dim&gt; exact_solution;</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   &amp;quadrature_formula,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a> &amp;face_quadrature_formula,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags)</div><div class="line">      :</div><div class="line">      fe_values_local (fe_local, quadrature_formula, local_flags),</div><div class="line">      fe_face_values_local (fe_local, face_quadrature_formula, local_face_flags),</div><div class="line">      fe_face_values (fe, face_quadrature_formula, flags),</div><div class="line">      ll_matrix (fe_local.dofs_per_cell, fe_local.dofs_per_cell),</div><div class="line">      lf_matrix (fe_local.dofs_per_cell, fe.dofs_per_cell),</div><div class="line">      fl_matrix (fe.dofs_per_cell, fe_local.dofs_per_cell),</div><div class="line">      tmp_matrix (fe.dofs_per_cell, fe_local.dofs_per_cell),</div><div class="line">      l_rhs (fe_local.dofs_per_cell),</div><div class="line">      tmp_rhs (fe_local.dofs_per_cell),</div><div class="line">      q_phi (fe_local.dofs_per_cell),</div><div class="line">      q_phi_div (fe_local.dofs_per_cell),</div><div class="line">      u_phi (fe_local.dofs_per_cell),</div><div class="line">      u_phi_grad (fe_local.dofs_per_cell),</div><div class="line">      tr_phi (fe.dofs_per_cell),</div><div class="line">      trace_values(face_quadrature_formula.size()),</div><div class="line">      fe_local_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell),</div><div class="line">      fe_support_on_face(<a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe_local.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (fe_local.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i,face))</div><div class="line">              fe_local_support_on_face[face].push_back(i);</div><div class="line">          }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i,face))</div><div class="line">              fe_support_on_face[face].push_back(i);</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData &amp;sd)</div><div class="line">      :</div><div class="line">      fe_values_local (sd.fe_values_local.get_fe(),</div><div class="line">                       sd.fe_values_local.get_quadrature(),</div><div class="line">                       sd.fe_values_local.get_update_flags()),</div><div class="line">      fe_face_values_local (sd.fe_face_values_local.get_fe(),</div><div class="line">                            sd.fe_face_values_local.get_quadrature(),</div><div class="line">                            sd.fe_face_values_local.get_update_flags()),</div><div class="line">      fe_face_values (sd.fe_face_values.get_fe(),</div><div class="line">                      sd.fe_face_values.get_quadrature(),</div><div class="line">                      sd.fe_face_values.get_update_flags()),</div><div class="line">      ll_matrix (sd.ll_matrix),</div><div class="line">      lf_matrix (sd.lf_matrix),</div><div class="line">      fl_matrix (sd.fl_matrix),</div><div class="line">      tmp_matrix (sd.tmp_matrix),</div><div class="line">      l_rhs (sd.l_rhs),</div><div class="line">      tmp_rhs (sd.tmp_rhs),</div><div class="line">      q_phi (sd.q_phi),</div><div class="line">      q_phi_div (sd.q_phi_div),</div><div class="line">      u_phi (sd.u_phi),</div><div class="line">      u_phi_grad (sd.u_phi_grad),</div><div class="line">      tr_phi (sd.tr_phi),</div><div class="line">      trace_values(sd.trace_values),</div><div class="line">      fe_local_support_on_face(sd.fe_local_support_on_face),</div><div class="line">      fe_support_on_face(sd.fe_support_on_face)</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>HDG&lt;dim&gt;::PostProcessScratchData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_local;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; u_values;</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt; u_gradients;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_sol;</div><div class="line"></div><div class="line">    PostProcessScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_local,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   &amp;quadrature_formula,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags)</div><div class="line">      :</div><div class="line">      fe_values_local (fe_local, quadrature_formula, local_flags),</div><div class="line">      fe_values (fe, quadrature_formula, flags),</div><div class="line">      u_values (quadrature_formula.size()),</div><div class="line">      u_gradients (quadrature_formula.size()),</div><div class="line">      cell_matrix (fe.dofs_per_cell, fe.dofs_per_cell),</div><div class="line">      cell_rhs (fe.dofs_per_cell),</div><div class="line">      cell_sol (fe.dofs_per_cell)</div><div class="line">    {}</div><div class="line"></div><div class="line">    PostProcessScratchData(<span class="keyword">const</span> PostProcessScratchData &amp;sd)</div><div class="line">      :</div><div class="line">      fe_values_local (sd.fe_values_local.get_fe(),</div><div class="line">                       sd.fe_values_local.get_quadrature(),</div><div class="line">                       sd.fe_values_local.get_update_flags()),</div><div class="line">      fe_values (sd.fe_values.get_fe(),</div><div class="line">                 sd.fe_values.get_quadrature(),</div><div class="line">                 sd.fe_values.get_update_flags()),</div><div class="line">      u_values (sd.u_values),</div><div class="line">      u_gradients (sd.u_gradients),</div><div class="line">      cell_matrix (sd.cell_matrix),</div><div class="line">      cell_rhs (sd.cell_rhs),</div><div class="line">      cell_sol (sd.cell_sol)</div><div class="line">    {}</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  HDG&lt;dim&gt;::assemble_system (<span class="keyword">const</span> <span class="keywordtype">bool</span> trace_reconstruct)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; face_quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_face_flags (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags ( <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    PerTaskData task_data (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">                           trace_reconstruct);</div><div class="line">    ScratchData scratch (fe, fe_local,</div><div class="line">                         quadrature_formula,</div><div class="line">                         face_quadrature_formula,</div><div class="line">                         local_flags,</div><div class="line">                         local_face_flags,</div><div class="line">                         flags);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                    dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                    *<span class="keyword">this</span>,</div><div class="line">                    &amp;HDG&lt;dim&gt;::assemble_system_one_cell,</div><div class="line">                    &amp;HDG&lt;dim&gt;::copy_local_to_global,</div><div class="line">                    scratch,</div><div class="line">                    task_data);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  HDG&lt;dim&gt;::assemble_system_one_cell (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                      ScratchData &amp;scratch,</div><div class="line">                                      PerTaskData &amp;task_data)</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    loc_cell (&amp;triangulation,</div><div class="line">              cell-&gt;level(),</div><div class="line">              cell-&gt;index(),</div><div class="line">              &amp;dof_handler_local);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = scratch.fe_values_local.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = scratch.fe_face_values_local.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loc_dofs_per_cell = scratch.fe_values_local.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().dofs_per_cell;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes (0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar (dim);</div><div class="line"></div><div class="line">    scratch.ll_matrix = 0;</div><div class="line">    scratch.l_rhs = 0;</div><div class="line">    <span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">      {</div><div class="line">        scratch.lf_matrix = 0;</div><div class="line">        scratch.fl_matrix = 0;</div><div class="line">        task_data.cell_matrix = 0;</div><div class="line">        task_data.cell_vector = 0;</div><div class="line">      }</div><div class="line">    scratch.fe_values_local.reinit (loc_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> rhs_value</div><div class="line">          = scratch.right_hand_side.value(scratch.fe_values_local.quadrature_point(q));</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> convection</div><div class="line">          = scratch.convection_velocity.value(scratch.fe_values_local.quadrature_point(q));</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_local.JxW(q);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;loc_dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k,q);</div><div class="line">            scratch.q_phi_div[k] = scratch.fe_values_local[fluxes].divergence(k,q);</div><div class="line">            scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k,q);</div><div class="line">            scratch.u_phi_grad[k] = scratch.fe_values_local[scalar].gradient(k,q);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;loc_dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;loc_dofs_per_cell; ++j)</div><div class="line">              scratch.ll_matrix(i,j) += (</div><div class="line">                                          scratch.q_phi[i] * scratch.q_phi[j]</div><div class="line">                                          -</div><div class="line">                                          scratch.q_phi_div[i] * scratch.u_phi[j]</div><div class="line">                                          +</div><div class="line">                                          scratch.u_phi[i] * scratch.q_phi_div[j]</div><div class="line">                                          -</div><div class="line">                                          (scratch.u_phi_grad[i] * convection) * scratch.u_phi[j]</div><div class="line">                                        ) * JxW;</div><div class="line">            scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">      {</div><div class="line">        scratch.fe_face_values_local.reinit(loc_cell, face);</div><div class="line">        scratch.fe_face_values.reinit(cell, face);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">          scratch.fe_face_values.get_function_values (solution, scratch.trace_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_face_values.JxW(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> quadrature_point =</div><div class="line">              scratch.fe_face_values.quadrature_point(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> normal = scratch.fe_face_values.normal_vector(q);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> convection</div><div class="line">              = scratch.convection_velocity.value(quadrature_point);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> tau_stab = (5. +</div><div class="line">                                     std::abs(convection * normal));</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;scratch.fe_local_support_on_face[face].size(); ++k)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk=scratch.fe_local_support_on_face[face][k];</div><div class="line">                scratch.q_phi[k] = scratch.fe_face_values_local[fluxes].value(kk,q);</div><div class="line">                scratch.u_phi[k] = scratch.fe_face_values_local[scalar].value(kk,q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (!task_data.trace_reconstruct)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;scratch.fe_support_on_face[face].size(); ++k)</div><div class="line">                  scratch.tr_phi[k] =</div><div class="line">                    scratch.fe_face_values.shape_value(scratch.fe_support_on_face[face][k],q);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_local_support_on_face[face].size(); ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;scratch.fe_support_on_face[face].size(); ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_local_support_on_face[face][i];</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj=scratch.fe_support_on_face[face][j];</div><div class="line">                      scratch.lf_matrix(ii,jj) += (</div><div class="line">                                                    (scratch.q_phi[i] * normal</div><div class="line">                                                     +</div><div class="line">                                                     (convection * normal -</div><div class="line">                                                      tau_stab) * scratch.u_phi[i])</div><div class="line">                                                    * scratch.tr_phi[j]</div><div class="line">                                                  ) * JxW;</div><div class="line"></div><div class="line">                      scratch.fl_matrix(jj,ii) -= (</div><div class="line">                                                    (scratch.q_phi[i] * normal</div><div class="line">                                                     +</div><div class="line">                                                     tau_stab * scratch.u_phi[i])</div><div class="line">                                                    * scratch.tr_phi[j]</div><div class="line">                                                  ) * JxW;</div><div class="line">                    }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_support_on_face[face].size(); ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;scratch.fe_support_on_face[face].size(); ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_support_on_face[face][i];</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj=scratch.fe_support_on_face[face][j];</div><div class="line">                      task_data.cell_matrix(ii,jj) += (</div><div class="line">                                                        (convection * normal - tau_stab) *</div><div class="line">                                                        scratch.tr_phi[i] * scratch.tr_phi[j]</div><div class="line">                                                      ) * JxW;</div><div class="line">                    }</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary()</div><div class="line">                    &amp;&amp;</div><div class="line">                    (cell-&gt;face(face)-&gt;boundary_id() == 1))</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> neumann_value =</div><div class="line">                      - scratch.exact_solution.gradient (quadrature_point) * normal</div><div class="line">                      + convection * normal * scratch.exact_solution.value(quadrature_point);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_support_on_face[face].size(); ++i)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_support_on_face[face][i];</div><div class="line">                        task_data.cell_vector(ii) += scratch.tr_phi[i] * neumann_value * JxW;</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_local_support_on_face[face].size(); ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;scratch.fe_local_support_on_face[face].size(); ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_local_support_on_face[face][i];</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj=scratch.fe_local_support_on_face[face][j];</div><div class="line">                  scratch.ll_matrix(ii,jj) += tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW;</div><div class="line">                }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (task_data.trace_reconstruct)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;scratch.fe_local_support_on_face[face].size(); ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii=scratch.fe_local_support_on_face[face][i];</div><div class="line">                  scratch.l_rhs(ii) -= (scratch.q_phi[i] * normal</div><div class="line">                                        +</div><div class="line">                                        scratch.u_phi[i] * (convection * normal - tau_stab)</div><div class="line">                                       ) * scratch.trace_values[q] * JxW;</div><div class="line">                }</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    scratch.ll_matrix.gauss_jordan();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (task_data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);</div><div class="line">        scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);</div><div class="line">        scratch.tmp_matrix.mmult(task_data.cell_matrix, scratch.lf_matrix, <span class="keyword">true</span>);</div><div class="line">        cell-&gt;get_dof_indices(task_data.dof_indices);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);</div><div class="line">        loc_cell-&gt;set_dof_values(scratch.tmp_rhs, solution_local);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> PerTaskData &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (data.trace_reconstruct == <span class="keyword">false</span>)</div><div class="line">      constraints.distribute_local_to_global (data.cell_matrix,</div><div class="line">                                              data.cell_vector,</div><div class="line">                                              data.dof_indices,</div><div class="line">                                              system_matrix, system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (system_matrix.m()*10,</div><div class="line">                                  1e-11*system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;&gt;</a> solver (solver_control);</div><div class="line">    solver.solve (system_matrix, solution, system_rhs,</div><div class="line">                  <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of BiCGStab iterations: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#aaddfdea0c37c5c468e7a76dc47840ff9">reinit</a>(0,0,0,1);</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    assemble_system(<span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  HDG&lt;dim&gt;::postprocess()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(fe_u_post.degree+1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> local_flags (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags ( <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      PostProcessScratchData scratch (fe_u_post, fe_local,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      local_flags,</div><div class="line">                                      flags);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_u_post.begin_active(),</div><div class="line">                      dof_handler_u_post.end(),</div><div class="line">                      std::bind (&amp;HDG&lt;dim&gt;::postprocess_one_cell,</div><div class="line">                                 std::ref(*<span class="keyword">this</span>),</div><div class="line">                                 std::placeholders::_1, std::placeholders::_2, std::placeholders::_3),</div><div class="line">                      std::function&lt;void(const unsigned int &amp;)&gt;(),</div><div class="line">                      scratch,</div><div class="line">                      0U);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> value_select (dim, dim+1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_local,</div><div class="line">                                       solution_local,</div><div class="line">                                       SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                       difference_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+2),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                       &amp;value_select);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                              difference_per_cell,</div><div class="line">                                                              <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> gradient_select (std::pair&lt;unsigned int,unsigned int&gt;(0, dim),</div><div class="line">                                                  dim+1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_local,</div><div class="line">                                       solution_local,</div><div class="line">                                       SolutionAndGradient&lt;dim&gt;(),</div><div class="line">                                       difference_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+2),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                       &amp;gradient_select);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> grad_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                                difference_per_cell,</div><div class="line">                                                                <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (dof_handler_u_post,</div><div class="line">                                       solution_u_post,</div><div class="line">                                       Solution&lt;dim&gt;(),</div><div class="line">                                       difference_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+3),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> post_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                                difference_per_cell,</div><div class="line">                                                                <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>,     triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>,      dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;val L2&quot;</span>,    L2_error);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;grad L2&quot;</span>,   grad_error);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;val L2-post&quot;</span>, post_error);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  HDG&lt;dim&gt;::postprocess_one_cell (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                  PostProcessScratchData &amp;scratch,</div><div class="line">                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;)</div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    loc_cell (&amp;triangulation,</div><div class="line">              cell-&gt;level(),</div><div class="line">              cell-&gt;index(),</div><div class="line">              &amp;dof_handler_local);</div><div class="line"></div><div class="line">    scratch.fe_values_local.reinit (loc_cell);</div><div class="line">    scratch.fe_values.reinit(cell);</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> fluxes(0);</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = scratch.fe_values.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.fe_values.dofs_per_cell;</div><div class="line"></div><div class="line">    scratch.fe_values_local[scalar].get_function_values(solution_local, scratch.u_values);</div><div class="line">    scratch.fe_values_local[fluxes].get_function_values(solution_local, scratch.u_gradients);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i&lt;dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">          {</div><div class="line">            sum = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">              sum += (scratch.fe_values.shape_grad(i,q) *</div><div class="line">                      scratch.fe_values.shape_grad(j,q)</div><div class="line">                     ) * scratch.fe_values.JxW(q);</div><div class="line">            scratch.cell_matrix(i,j) = sum;</div><div class="line">          }</div><div class="line"></div><div class="line">        sum = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          sum -= (scratch.fe_values.shape_grad(i,q) * scratch.u_gradients[q]</div><div class="line">                 ) * scratch.fe_values.JxW(q);</div><div class="line">        scratch.cell_rhs(i) = sum;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">      {</div><div class="line">        sum = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          sum += scratch.fe_values.shape_value(j,q) * scratch.fe_values.JxW(q);</div><div class="line">        scratch.cell_matrix(0,j) = sum;</div><div class="line">      }</div><div class="line">    {</div><div class="line">      sum = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        sum += scratch.u_values[q] * scratch.fe_values.JxW(q);</div><div class="line">      scratch.cell_rhs(0) = sum;</div><div class="line">    }</div><div class="line"></div><div class="line">    scratch.cell_matrix.gauss_jordan();</div><div class="line">    scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);</div><div class="line">    cell-&gt;distribute_local_to_global(scratch.cell_sol, solution_u_post);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    std::string filename;</div><div class="line">    <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> global_refinement:</div><div class="line">        filename = <span class="stringliteral">&quot;solution-global&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">        filename = <span class="stringliteral">&quot;solution-adaptive&quot;</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    std::string face_out(filename);</div><div class="line">    face_out += <span class="stringliteral">&quot;-face&quot;</span>;</div><div class="line"></div><div class="line">    filename += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>,1);</div><div class="line">    filename += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle,2);</div><div class="line">    filename += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::ofstream output (filename.c_str());</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; names (dim, <span class="stringliteral">&quot;gradient&quot;</span>);</div><div class="line">    names.push_back (<span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    component_interpretation</div><div class="line">    (dim+1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    component_interpretation[dim]</div><div class="line">      = <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>;</div><div class="line">    data_out.add_data_vector (dof_handler_local, solution_local,</div><div class="line">                              names, component_interpretation);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; post_name(1,<span class="stringliteral">&quot;u_post&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    post_comp_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    data_out.add_data_vector (dof_handler_u_post, solution_u_post,</div><div class="line">                              post_name, post_comp_type);</div><div class="line"></div><div class="line">    data_out.build_patches (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    data_out.write_vtk (output);</div><div class="line"></div><div class="line">    face_out += <span class="stringliteral">&quot;-q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>,1);</div><div class="line">    face_out += <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle,2);</div><div class="line">    face_out += <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::ofstream face_output (face_out.c_str());</div><div class="line"></div><div class="line">    <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a> data_out_face(<span class="keyword">false</span>);</div><div class="line">    std::vector&lt;std::string&gt; face_name(1,<span class="stringliteral">&quot;u_hat&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    face_component_type(1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    data_out_face.add_data_vector (dof_handler,</div><div class="line">                                   solution,</div><div class="line">                                   face_name,</div><div class="line">                                   face_component_type);</div><div class="line"></div><div class="line">    data_out_face.build_patches (fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    data_out_face.write_vtk (face_output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::refine_grid (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">GridGenerator::subdivided_hyper_cube</a> (triangulation, 2, -1, 1);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3-dim);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">switch</span> (refinement_mode)</div><div class="line">        {</div><div class="line">        <span class="keywordflow">case</span> global_refinement:</div><div class="line">        {</div><div class="line">          triangulation.<a class="code" href="classTriangulation.html#afb1cccb342ab16530d8176f9b40cd9da">clear</a>();</div><div class="line">          <a class="code" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">GridGenerator::subdivided_hyper_cube</a> (triangulation, 2+(cycle%2), -1, 1);</div><div class="line">          triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3-dim+cycle/2);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> adaptive_refinement:</div><div class="line">        {</div><div class="line">          <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">          <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> scalar(dim);</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a> neumann_boundary;</div><div class="line">          <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler_local,</div><div class="line">                                              <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(3),</div><div class="line">                                              neumann_boundary,</div><div class="line">                                              solution_local,</div><div class="line">                                              estimated_error_per_cell,</div><div class="line">                                              fe_local.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(scalar));</div><div class="line"></div><div class="line">          <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                           estimated_error_per_cell,</div><div class="line">                                                           0.3, 0.);</div><div class="line"></div><div class="line">          triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line"></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line">    cell = triangulation.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a> (),</div><div class="line">    endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary())</div><div class="line">          <span class="keywordflow">if</span> ((std::fabs(cell-&gt;face(face)-&gt;center()(0) - (-1)) &lt; 1e-12)</div><div class="line">              ||</div><div class="line">              (std::fabs(cell-&gt;face(face)-&gt;center()(1) - (-1)) &lt; 1e-12))</div><div class="line">            cell-&gt;face(face)-&gt;set_boundary_id (1);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> HDG&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;10; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        refine_grid (cycle);</div><div class="line">        setup_system ();</div><div class="line">        assemble_system (<span class="keyword">false</span>);</div><div class="line">        solve ();</div><div class="line">        postprocess();</div><div class="line">        output_results (cycle);</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;val L2&quot;</span>, 3);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;grad L2&quot;</span>, 3);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;val L2-post&quot;</span>, 3);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (refinement_mode == global_refinement)</div><div class="line">      {</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;val L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;grad L2&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">        convergence_table</div><div class="line">        .evaluate_convergence_rates(<span class="stringliteral">&quot;val L2-post&quot;</span>, <span class="stringliteral">&quot;cells&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>, dim);</div><div class="line">      }</div><div class="line">    convergence_table.write_text(std::cout);</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// end of namespace Step51</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, adaptive refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem (1, Step51::HDG&lt;dim&gt;::adaptive_refinement);</div><div class="line">        hdg_problem.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem (1, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Solving with Q3 elements, global refinement&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;===========================================&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        Step51::HDG&lt;dim&gt; hdg_problem (3, Step51::HDG&lt;dim&gt;::global_refinement);</div><div class="line">        hdg_problem.run ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
