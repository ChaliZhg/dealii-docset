<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-49 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-49 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Generalconcernsaboutmeshes">General concerns about meshes</a>
        <li><a href="#Howtocreatemeshes">How to create meshes</a>
      <ul>
        <li><a href="#UsingGridGenerator">Using GridGenerator</a>
        <li><a href="#Constructingyourownmeshprogrammatically">Constructing your own mesh programmatically</a>
        <li><a href="#Importingfromexternalprograms">Importing from external programs</a>
      </ul>
        <li><a href="#ModifyingaMesh">Modifying a Mesh</a>
      <ul>
        <li><a href="#Transformations">Transformations</a>
        <li><a href="#MergingMeshes">Merging Meshes</a>
        <li><a href="#MovingVertices">Moving Vertices</a>
        <li><a href="#ExtrudingMeshes">Extruding Meshes</a>
      </ul>
        <li><a href="#Afteryouhaveacoarsemesh"> After you have a coarse mesh </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Generatingoutputforagivenmesh">Generating output for a given mesh</a>
        <li><a href="#Mainroutines">Main routines</a>
      <ul>
        <li><a href="#grid_1Loadingameshgeneratedbygmsh">grid_1: Loading a mesh generated by gmsh</a>
        <li><a href="#grid_2Mergingtriangulations">grid_2: Merging triangulations</a>
        <li><a href="#grid_3Movingvertices">grid_3: Moving vertices</a>
        <li><a href="#grid_4Demonstratingextrude_triangulation">grid_4: Demonstrating extrude_triangulation</a>
        <li><a href="#grid_5DemonstratingGridToolstransformpart1">grid_5: Demonstrating GridTools::transform, part 1</a>
        <li><a href="#grid_6DemonstratingGridToolstransformpart2">grid_6: Demonstrating GridTools::transform, part 2</a>
        <li><a href="#grid_7Demonstratingdistort_random">grid_7: Demonstrating distort_random</a>
      </ul>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#NextstepsCurvedboundaries">Next steps: Curved boundaries</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <em>This program was contributed by Timo Heister. Parts of the results section were contributed by Yuhan Zhou and Wolfgang Bangerth.</em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction </h1>
<p>This tutorial is an extension to <a class="el" href="step_1.html">step-1</a> and demonstrates several ways to obtain more involved meshes than the ones shown there.</p>
<p>Generating complex geometries is a challenging task, especially in three space dimensions. We will discuss several ways to do this, but this list is not exhaustive. Additionally, there is not one approach that fits all problems.</p>
<p>This example program shows some of ways to create and modify meshes for computations and outputs them as <code>.eps</code> files in much the same way as we do in <a class="el" href="step_1.html">step-1</a>. No other computations or adaptive refinements are done; the idea is that you can use the techniques used here as building blocks in other, more involved simulators. Please note that the example program does not show all the ways to generate meshes that are discussed in this introduction.</p>
<p><a class="anchor" id="Generalconcernsaboutmeshes"></a></p><h3>General concerns about meshes</h3>
<p>When you use adaptive mesh refinement, you definitely want the initial mesh to be as coarse as possible. The reason is that you can make it as fine as you want using adaptive refinement as long as you have memory and CPU time available. However, this requires that you don't waste mesh cells in parts of the domain where they don't pay off. As a consequence, you don't want to start with a mesh that is too fine to start with, because that takes up a good part of your cell budget already, and because you can't coarsen away cells that are in the initial mesh.</p>
<p>That said, your mesh needs to capture the given geometry adequately.</p>
<p><a class="anchor" id="Howtocreatemeshes"></a></p><h3>How to create meshes</h3>
<p>There are several ways to create an initial mesh. Meshes can be modified or combined in many ways as discussed later on.</p>
<p><a class="anchor" id="UsingGridGenerator"></a></p><h4>Using <a class="el" href="namespaceGridGenerator.html">GridGenerator</a></h4>
<p>The easiest way to generate meshes is to use the functions in namespace <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>, as already discussed in <a class="el" href="step_1.html">step-1</a>. There are many different helper functions available, including <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a>, <a class="el" href="namespaceGridGenerator.html#a0a81f736ef95164a9d9bf0f844ac682b">GridGenerator::hyper_ball()</a>, <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>, ...</p>
<p><a class="anchor" id="Constructingyourownmeshprogrammatically"></a></p><h4>Constructing your own mesh programmatically</h4>
<p>If there is no good fit in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace for what you want to do, you can always create a <a class="el" href="classTriangulation.html">Triangulation</a> in your program "by hand". For that, you need a list of vertices with their coordinates and a list of cells referencing those vertices. You can find an example in the function create_coarse_grid in <a class="el" href="step_14.html">step-14</a>. All the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> are implemented in this fashion.</p>
<p>We are happy to accept more functions to be added to <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>. So, if you end up writing a function that might be useful for a larger audience, please contribute it.</p>
<p><a class="anchor" id="Importingfromexternalprograms"></a></p><h4>Importing from external programs</h4>
<p>The class <a class="el" href="classGridIn.html">GridIn</a> can read many different mesh formats from a file from disk. How this is done is explained in <a class="el" href="step_5.html">step-5</a> and can be seen in the function <code>grid_1</code> in this example, see the code below.</p>
<p>Meshes can be generated from different tools like <a href="http://geuz.org/gmsh/" target="_top">gmsh</a>, <a href="https://lagrit.lanl.gov/" target="_top">lagrit</a> and <a href="http://cubit.sandia.gov/" target="_top">cubit</a>. See the documentation of <a class="el" href="classGridIn.html">GridIn</a> for more information. The problem is that deal.II needs meshes that only consist of quads and hexas &ndash; tetrahedral meshes won't work (this means tools like tetgen can not be used directly).</p>
<p>We will describe a possible workflow using Gmsh. Gmsh is the smallest and most quickly set up open source tool we are aware of. It can generate unstructured 2d quad meshes, but in 3d it can only extrude 2d meshes to get hexahedral meshes. 3D meshing of unstructured geometry into hexahedra is not supported at the time of writing this tutorial (early 2013).</p>
<p>In gmsh, a mesh is described in a text based <code>.geo</code> file, that can contain computations, loops, variables, etc. It is very flexible. The mesh is generated from a surface representation, which is build from a list of line loops, which is build from a list of lines, which are in turn built from points. The <code>.geo</code> script can be written and edited by hand or it can be generated automatically by creating objects graphically inside gmsh. In many cases it is best to combine both approaches. The file can be easily reloaded by pressing "reload" under the "Geometry" tab.</p>
<p>This tutorial contains an example <code>.geo</code> file, that describes a box with two objects cut out in the interior. This is how <code>untitled.geo</code> looks like in gmsh (displaying the boundary indicators as well as the mesh discussed further down below):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.gmsh_picture.png"/>
</div>
<p>You might want to open the <code>untitled.geo</code> file in a text editor (it is located in the same directory as the <code><a class="el" href="step_49.html">step-49</a>.cc</code> source file) to see how it is structured. You can see how the boundary of the domain is composed of a number of lines and how later on we combine several lines into "physical lines" (or "physical surfaces") that list the logical lines' numbers. "Physical" object are the ones that carry information about the boundary indicator (see <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">this glossary entry</a>).</p>
<dl class="section note"><dt>Note</dt><dd>It is important that this file contain "physical lines" and "physical
surfaces". These give the boundary indicators and material ids for use in deal.II. Without these physical entities, nothing will be imported into deal.II.</dd></dl>
<p>deal.II's <a class="el" href="classGridIn.html">GridIn</a> class can read the <code>.msh</code> format written by gmsh and that contains a mesh created for the geometry described by the <code>.geo</code> file. You generate the <code>.msh</code> from the <code>.geo</code> by running the commands</p>
<div class="fragment"><div class="line">gmsh -2 untitled.geo</div></div><!-- fragment --><p>on the command line, or by clicking "Mesh" and then "2D" inside Gmsh after loading the file. Now this is the mesh read from the <code>.msh</code> file and saved again by deal.II as an image (see the <code>grid_1</code> function of the current program):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-1.png"/>
</div>
<p><a class="anchor" id="ModifyingaMesh"></a></p><h3>Modifying a Mesh</h3>
<p>After acquiring one (or several) meshes in the ways described above, there are many ways to manipulate them before using them in a finite element computation.</p>
<p><a class="anchor" id="Transformations"></a></p><h4>Transformations</h4>
<p>The <a class="el" href="namespaceGridTools.html">GridTools</a> namespace contains a collection of small functions to transform a given mesh in various ways. The usage of the functions <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>, <a class="el" href="namespaceGridTools.html#aa7ea00f2009014a52520c05beadc78b6">GridTools::rotate</a>, <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a> is fairly obvious, so we won't discuss those functions here.</p>
<p>The function <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a> allows you to transform the vertices of a given mesh using a smooth function. An example of its use is also given in the results section of <a class="el" href="step_38.html">step-38</a> but let us show a simpler example here: In the function <code>grid_5()</code> of the current program, we perturb the y coordinate of a mesh with a sine curve:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-5a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-5.png"/>
</div>
 output mesh   </td></tr>
</table>
<p>Similarly, we can transform a regularly refined unit square to a wall-adapted mesh in y direction using the formula <img class="formulaInl" alt="$(x,y) \mapsto (x,\tanh(2*y)/\tanh(2))$" src="form_3883.png"/>. This is done in <code>grid_6()</code> of this tutorial: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-6a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-6.png"/>
</div>
 wall-adapted output mesh   </td></tr>
</table>
<p>Finally, the function <a class="el" href="namespaceGridTools.html#aec039d544c93a6e810427ad45ba0c84f">GridTools::distort_random</a> allows you to move vertices in the mesh (optionally ignoring boundary nodes) by a random amount. This is demonstrated in <code>grid_7()</code> and the result is as follows:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-7a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-7.png"/>
</div>
 perturbed output mesh   </td></tr>
</table>
<p>This function is primarily intended to negate some of the superconvergence effects one gets when studying convergence on regular meshes, as well as to suppress some optimizations in deal.II that can exploit the fact that cells are similar in shape. In practice, it is of course always better to work with a sequence of unstructured meshes (see possible extensions at the end of the this section).</p>
<p><a class="anchor" id="MergingMeshes"></a></p><h4>Merging Meshes</h4>
<p>The function <a class="el" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations()</a> allows you to merge two given <a class="el" href="classTriangulation.html">Triangulation</a> objects into a single one. For this to work, the vertices of the shared edge or face have to match exactly. Lining up the two meshes can be achieved using <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> and <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>. In the function <code>grid_2()</code> of this tutorial, we merge a square with a round hole (generated with <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>) and a rectangle (generated with <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a>). The function <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> allows you to specify the number of repetitions and the positions of the corners, so there is no need to shift the triangulation manually here. You should inspect the mesh graphically to make sure that cells line up correctly and no unpaired nodes exist in the merged <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>These are the input meshes and the output mesh:</p>
<table width="80%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" height="200px"/>
</div>
input mesh 1 </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2b.png" height="200px"/>
</div>
input mesh 2 </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2.png" height="200px"/>
</div>
merged mesh  </td></tr>
</table>
<p><a class="anchor" id="MovingVertices"></a></p><h4>Moving Vertices</h4>
<p>The function <code>grid_3()</code> demonstrates the ability to pick individual vertices and move them around in an existing mesh. Note that this has the potential to produce degenerate or inverted cells and you shouldn't expect anything useful to come of using such meshes. Here, we create a box with a cylindrical hole that is not exactly centered by moving the top vertices upwards:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-3a.png" height="200px"/>
</div>
<p> input mesh </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-3.png" height="200px"/>
</div>
 top vertices moved upwards   </td></tr>
</table>
<p>For the exact way how this is done, see the code below.</p>
<p><a class="anchor" id="ExtrudingMeshes"></a></p><h4>Extruding Meshes</h4>
<p>If you need a 3d mesh that can be created by extruding a given 2d mesh (that can be created in any of the ways given above), you can use the function <a class="el" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">GridGenerator::extrude_triangulation()</a>. See the <code>grid_4()</code> function in this tutorial for an example. Note that for this particular case, the given result could also be achieved using the 3d version of <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>. The main usage is a 2d mesh, generated for example with gmsh, that is read in from a <code>.msh</code> file as described above. This is the output from grid_4():</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-4base.png"/>
</div>
<p> input mesh </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-4.png"/>
</div>
 extruded output mesh   </td></tr>
</table>
<p><a class="anchor" id="Afteryouhaveacoarsemesh"></a></p><h3>After you have a coarse mesh </h3>
<p>Creating a coarse mesh using the methods discussed above is only the first step. When you have it, it will typically serve as the basis for further mesh refinement. This is not difficult &mdash; in fact, there is nothing else to do &mdash; if your geometry consists of only straight faces. However, this is often not the case if you have a more complex geometry and more steps than just creating the mesh are necessary. We will go over some of these steps in the <a href="#Results">results section</a> below.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>This tutorial program is odd in the sense that, unlike for most other steps, the introduction already provides most of the information on how to use the various strategies to generate meshes. Consequently, there is little that remains to be commented on here, and we intersperse the code with relatively little text. In essence, the code here simply provides a reference implementation of what has already been described in the introduction.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Generatingoutputforagivenmesh"></a> </p><h3>Generating output for a given mesh</h3>
<p>The following function generates some output for any of the meshes we will be generating in the remainder of this program. In particular, it generates the following information:</p>
<ul>
<li>Some general information about the number of space dimensions in which this mesh lives and its number of cells.</li>
<li>The number of boundary faces that use each boundary indicator, so that it can be compared with what we expect.</li>
</ul>
<p>Finally, the function outputs the mesh in encapsulated postscript (EPS) format that can easily be visualized in the same way as was done in <a class="el" href="step_1.html">step-1</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> print_mesh_info(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation,</div><div class="line">                     <span class="keyword">const</span> std::string        &amp;filename)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh info:&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; dimension: &quot;</span> &lt;&lt; dim &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; no. of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Next loop over all faces of all cells and find how often each boundary indicator is used (recall that if you access an element of a std::map object that doesn't exist, it is implicitly created and default initialized &ndash; to zero, in the current case &ndash; before we then increment it):</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::map&lt;unsigned int, unsigned int&gt; boundary_count;</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary())</div><div class="line">            boundary_count[cell-&gt;face(face)-&gt;boundary_id()]++;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; boundary indicators: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (std::map&lt;unsigned int, unsigned int&gt;::iterator it=boundary_count.begin();</div><div class="line">       it!=boundary_count.end();</div><div class="line">       ++it)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="stringliteral">&quot; times) &quot;</span>;</div><div class="line">    }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Finally, produce a graphical representation of the mesh to an output file :</p>
<div class="fragment"><div class="line">  std::ofstream out (filename.c_str());</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a7e31485bb55254bfa5cd3ab55f8d1748">write_eps</a> (triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; written to &quot;</span> &lt;&lt; filename</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Mainroutines"></a> </p><h3>Main routines</h3>
<p><a class="anchor" id="grid_1Loadingameshgeneratedbygmsh"></a> </p><h4>grid_1: Loading a mesh generated by gmsh</h4>
<p>In this first example, we show how to load the mesh for which we have discussed in the introduction how to generate it. This follows the same pattern as used in <a class="el" href="step_5.html">step-5</a> to load a mesh, although there it was written in a different file format (UCD instead of MSH).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_1 ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"></div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a> gridin;</div><div class="line">  gridin.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(triangulation);</div><div class="line">  std::ifstream f(<span class="stringliteral">&quot;untitled.msh&quot;</span>);</div><div class="line">  gridin.<a class="code" href="classGridIn.html#a83872db02e04f52ac52d578912f6da5e">read_msh</a>(f);</div><div class="line"></div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-1.eps&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_2Mergingtriangulations"></a> </p><h4>grid_2: Merging triangulations</h4>
<p>Here, we first create two triangulations and then merge them into one. As discussed in the introduction, it is important to ensure that the vertices at the common interface are located at the same coordinates.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_2 ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> (tria1, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria2;</div><div class="line">  std::vector&lt; unsigned int &gt; repetitions(2);</div><div class="line">  repetitions[0]=3;</div><div class="line">  repetitions[1]=2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (tria2, repetitions,</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0,-1.0),</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(4.0,1.0));</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations</a> (tria1, tria2, triangulation);</div><div class="line"></div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-2.eps&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_3Movingvertices"></a> </p><h4>grid_3: Moving vertices</h4>
<p>In this function, we move vertices of a mesh. This is simpler than one usually expects: if you ask a cell using <code>cell-&gt;vertex(i)</code> for the coordinates of its <code>i</code>th vertex, it doesn't just provide the location of this vertex but in fact a reference to the location where these coordinates are stored. We can then modify the value stored there.</p>
<p>So this is what we do in the first part of this function: We create a square of geometry <img class="formulaInl" alt="$[-1,1]^2$" src="form_1961.png"/> with a circular hole with radius 0.25 located at the origin. We then loop over all cells and all vertices and if a vertex has a <img class="formulaInl" alt="$y$" src="form_10.png"/> coordinate equal to one, we move it upward by 0.5.</p>
<p>Note that this sort of procedure does not usually work this way because one will typically encounter the same vertices multiple times and may move them more than once. It works here because we select the vertices we want to use based on their geometric location, and a vertex moved once will fail this test in the future. A more general approach to this problem would have been to keep a std::set of of those vertex indices that we have already moved (which we can obtain using <code>cell-&gt;vertex_index(i)</code> and only move those vertices whose index isn't in the set yet.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_3 ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> (triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;GeometryInfo&lt;2&gt;::vertices_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = cell-&gt;vertex(i);</div><div class="line">          <span class="keywordflow">if</span> (std::abs(v(1)-1.0)&lt;1e-5)</div><div class="line">            v(1) += 0.5;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>In the second step we will refine the mesh twice. To do this correctly, we have to associate a geometry object with the boundary of the hole; since the boundary of the hole has boundary indicator 1 (see the documentation of the function that generates the mesh), we need to create an object that describes a spherical manifold (i.e., a hyper ball) with appropriate center and assign it to the triangulation. Notice that the function that generates the triangulation sets the boundary indicators of the inner mesh, but leaves unchanged the manifold indicator. We copy the boundary indicator to the manifold indicators in order for the object to be refined accordingly. We can then refine twice:</p>
<div class="fragment"><div class="line"><a class="code" href="group__manifold.html#ga2ea00d3c65f290a020a268df8fb50c19">GridTools::copy_boundary_to_manifold_id</a>(triangulation);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> boundary_description(<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0,0));</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (1, boundary_description);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div></div><!-- fragment --><p>The mesh so generated is then passed to the function that generates output. In a final step we remove the boundary object again so that it is no longer in use by the triangulation when it is destroyed (the boundary object is destroyed first in this function since it was declared after the triangulation).</p>
<div class="fragment"><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-3.eps&quot;</span>);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (1);</div><div class="line">}</div></div><!-- fragment --><p>There is one snag to doing things as shown above: If one moves the nodes on the boundary as shown here, one often ends up with cells in the interior that are badly distorted since the interior nodes were not moved around. This is not that much of a problem in the current case since the mesh did not contain any internal nodes when the nodes were moved &ndash; it was the coarse mesh and it so happened that all vertices are at the boundary. It's also the case that the movement we had here was, compared to the average cell size not overly dramatic. Nevertheless, sometimes one does want to move vertices by a significant distance, and in that case one needs to move internal nodes as well. One way to do that automatically is to call the function <a class="el" href="namespaceGridTools.html#a6ea9a503f365395ed24460cb489d7f0e">GridTools::laplace_transform</a> that takes a set of transformed vertex coordinates and moves all of the other vertices in such a way that the resulting mesh has, in some sense, a small distortion.</p>
<p><a class="anchor" id="grid_4Demonstratingextrude_triangulation"></a> </p><h4>grid_4: Demonstrating extrude_triangulation</h4>
<p>This example takes the initial grid from the previous function and simply extrudes it into the third space dimension:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_4()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> out;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> (triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">GridGenerator::extrude_triangulation</a> (triangulation, 3, 2.0, out);</div><div class="line">  print_mesh_info (out, <span class="stringliteral">&quot;grid-4.eps&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_5DemonstratingGridToolstransformpart1"></a> </p><h4>grid_5: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 1</h4>
<p>This and the next example first create a mesh and then transform it by moving every node of the mesh according to a function that takes a point and returns a mapped point. In this case, we transform <img class="formulaInl" alt="$(x,y) \mapsto (x,y+\sin(\pi x/5))$" src="form_3884.png"/>.</p>
<p><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a> takes a triangulation and any kind of object that can be called like a function as arguments. This function-like argument can be simply the address of a function as in the current case, or an object that has an <code>operator()</code> as in the next example, or for example a <code>std::function&lt;<a class="el" href="classPoint.html">Point</a>&lt;2&gt;(const <a class="el" href="classPoint.html">Point</a>&lt;2&gt;)&gt;</code> object one can get via <code>std::bind</code> in more complex cases.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> grid_5_transform (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(in(0),</div><div class="line">                  in(1) + std::sin(in(0)/5.0*3.14159));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_5()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 14;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation,</div><div class="line">                                             repetitions,</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0,0.0),</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(10.0,1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a> (&amp;grid_5_transform, triangulation);</div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-5.eps&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_6DemonstratingGridToolstransformpart2"></a> </p><h4>grid_6: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 2</h4>
<p>In this second example of transforming points from an original to a new mesh, we will use the mapping <img class="formulaInl" alt="$(x,y) \mapsto (x,\tanh(2y)/\tanh(2))$" src="form_3885.png"/>. To make things more interesting, rather than doing so in a single function as in the previous example, we here create an object with an <code>operator()</code> that will be called by <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>. Of course, this object may in reality be much more complex: the object may have member variables that play a role in computing the new locations of vertices.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Grid6Func</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> trans(<span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> std::tanh(2*y)/tanh(2);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> operator() (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (in(0),</div><div class="line">                     trans(in(1)));</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_6()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  std::vector&lt; unsigned int &gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 40;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation,</div><div class="line">                                             repetitions,</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0,0.0),</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0,1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(Grid6Func(), triangulation);</div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-6.eps&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_7Demonstratingdistort_random"></a> </p><h4>grid_7: Demonstrating distort_random</h4>
<p>In this last example, we create a mesh and then distort its (interior) vertices by a random perturbation. This is not something you want to do for production computations, but it is a useful tool for testing discretizations and codes to make sure they don't work just by accident because the mesh happens to be uniformly structured and supporting super-convergence properties.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_7()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 16;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation, repetitions,</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0,0.0),</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0,1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#aec039d544c93a6e810427ad45ba0c84f">GridTools::distort_random</a> (0.3, triangulation, <span class="keyword">true</span>);</div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-7.eps&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function. There isn't much to do here, only to call the subfunctions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      grid_1 ();</div><div class="line">      grid_2 ();</div><div class="line">      grid_3 ();</div><div class="line">      grid_4 ();</div><div class="line">      grid_5 ();</div><div class="line">      grid_6 ();</div><div class="line">      grid_7 ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program produces a series of <code>.eps</code> files of the triangulations. The methods are discussed above.</p>
<p><a class="anchor" id="NextstepsCurvedboundaries"></a></p><h3>Next steps: Curved boundaries</h3>
<p>As mentioned in the introduction, creating a coarse mesh using the methods discussed here is only the first step. In order to refine a mesh, the <a class="el" href="classTriangulation.html">Triangulation</a> needs to know where to put new vertices on the mid-points of edges and faces. By default, these new points will be placed at the centers of the old edge but this isn't what you want if you need curved boundaries that aren't already adequately resolved by the coarse mesh. Several of the meshes shown in the introduction section fall into this category. For example, for this mesh the central hole is supposed to be round:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" height="200px"/>
</div>
<p>On the other hand, if you simply refine it, the <a class="el" href="classTriangulation.html">Triangulation</a> class can not know whether you wanted the hole to be round or to be an octagon. The default is to place new points along existing edges. After two mesh refinement steps, this would yield the following mesh, which is not what we wanted:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2d-refined.png" height="200px"/>
</div>
<p>What needs to happen is that you tell the triangulation that you in fact want to use a curved boundary. The way to do this requires three steps:</p><ul>
<li>Create an object that describes the boundary in terms that allow the <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement</a> function to ask the boundary description where a new point should be located upon mesh refinement.</li>
<li>Tell the triangulation object that you want this object to be used for all boundaries with boundary indicates equal to a particular value (for more information on boundary indicators, see the <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">glossary entry on this topic</a>.)</li>
<li>Mark those parts of the boundary of the domain for which you want the boundary to be so treated with the value of the boundary indicator used in the previous step. (The order of this step and the previous one does not matter.)</li>
</ul>
<p>To illustrate this process in more detail, let us consider an example created by Yuhan Zhou as part of a 2013 semester project at Texas A&amp;M University. The goal was to generate (and use) a geometry that describes a microstructured electric device. In a CAD program, the geometry looks like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.1.png"/>
</div>
<p>In the following, we will walk you through the entire process of creating a mesh for this geometry, including a number of common pitfalls by showing the things that can go wrong.</p>
<p>The first step in getting there was to create a coarse mesh, which was done by creating a 2d coarse mesh for each of the two cross section, extruding them into the third direction, and gluing them together. The following code does this, using the techniques previously described:</p>
<div class="fragment"><div class="line"><span class="comment">// Given a list of points and how vertices connect to cells,</span></div><div class="line"><span class="comment">// create a mesh. This is in the same way as we do in step 14.</span></div><div class="line"><span class="keywordtype">void</span> create_2d_grid (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> vertices_1[],</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vertices,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">int</span> cell_vertices[][4],</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells,</div><div class="line">                     <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;coarse_grid)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;2&gt; &gt; vertices (&amp;vertices_1[0],</div><div class="line">                                         &amp;vertices_1[n_vertices]);</div><div class="line"></div><div class="line">  std::vector&lt;CellData&lt;2&gt; &gt; cells (n_cells, <a class="code" href="structCellData.html">CellData&lt;2&gt;</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_cells; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;</div><div class="line">           j&lt;GeometryInfo&lt;2&gt;::vertices_per_cell;</div><div class="line">           ++j)</div><div class="line">        cells[i].vertices[j] = cell_vertices[i][j];</div><div class="line">    }</div><div class="line"></div><div class="line">  coarse_grid.<a class="code" href="classTriangulation.html#ab926104144af9f9f5ca8c0798308c68c">create_triangulation</a> (vertices,</div><div class="line">                                    cells,</div><div class="line">                                    <a class="code" href="structSubCellData.html">SubCellData</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Create a triangulation that covers the entire volume</span></div><div class="line"><span class="keywordtype">void</span> create_3d_grid (<a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="comment">// Generate first cross section</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> vertices_1[]</div><div class="line">    = {  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.5,   0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.5,   0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.5,   0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 1.5,   0.),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.5,  1.5),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.5,  1.5),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.5,  1.5),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 1.5,  1.5),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.5,   3.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.5,   3.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.5,   3.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 1.5,   3.),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.5,   3+0.5*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3)),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.5,   3+0.5*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3)),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.75,  3+0.75*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3)),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.75,  3+0.75*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3))</div><div class="line">  };</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> cell_vertices_1[][<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;2&gt;::vertices_per_cell</a>]</div><div class="line">    = {{0, 1, 4, 5},</div><div class="line">       {1, 2, 5, 6},</div><div class="line">       {3, 7, 2, 6},</div><div class="line">       {4, 5, 8, 9},</div><div class="line">       {5, 6, 9, 10},</div><div class="line">       {7,11, 6,10},</div><div class="line">       {8, 9, 14,12},</div><div class="line">       {9, 10,12,13},</div><div class="line">       {11,15,10,13},</div><div class="line">       {14,12,15,13}</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Copy vertices into a 2d triangulation</span></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_1;</div><div class="line">  create_2d_grid (vertices_1,</div><div class="line">                  <span class="keyword">sizeof</span>(vertices_1)/<span class="keyword">sizeof</span>(vertices_1[0]),</div><div class="line">                  cell_vertices_1,</div><div class="line">                  <span class="keyword">sizeof</span>(cell_vertices_1)/<span class="keyword">sizeof</span>(cell_vertices_1[0]),</div><div class="line">                  triangulation_2d_1);</div><div class="line"></div><div class="line">  <span class="comment">// Then extrude it into a 3d piece</span></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">GridGenerator::extrude_triangulation</a> (triangulation_2d_1,</div><div class="line">                                        5, 2.5,</div><div class="line">                                        triangulation_3d_1);</div><div class="line"></div><div class="line">  <span class="comment">// Now do the same with the second volume</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> vertices_2[]</div><div class="line">    = {  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-2.5,   0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.5,   0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.5,   0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.5,   0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 1.5,   0.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 2.5,   0.),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-2.5,  1.5),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.5,  1.5),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.5,  1.5),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.5,  1.5),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 1.5,  1.5),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 2.5,  1.5),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-2.5,  3.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.5,  3.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.5,  3.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.5,  3.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 1.5,  3.),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 2.5,  3.),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.5,   3.+0.5*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3)),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.5,   3.+0.5*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3)),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-0.75,  3.+0.75*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3)),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 0.75,  3.+0.75*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3)),</div><div class="line"></div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (-1.25,  3.+1.25*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3)),</div><div class="line">         <a class="code" href="classPoint.html">Point&lt;2&gt;</a> ( 1.25,  3.+1.25*<a class="code" href="classVectorizedArray.html#a2196d592fb6a9ed64530d4336bf3a4c2">sqrt</a>(3))</div><div class="line">  };</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> cell_vertices_2[][<a class="code" href="structGeometryInfo.html">GeometryInfo&lt;2&gt;::vertices_per_cell</a>]</div><div class="line">    = {{0, 1, 6, 7},</div><div class="line">       {1, 2, 7, 8},</div><div class="line">       {2, 3, 8, 9},</div><div class="line">       {4, 10, 3, 9},</div><div class="line">       {5, 11, 4, 10},</div><div class="line">       {6, 7, 12, 13},</div><div class="line">       {7, 8, 13, 14},</div><div class="line">       {8, 9, 14, 15},</div><div class="line">       {10, 16, 9, 15},</div><div class="line">       {11, 17, 10, 16},</div><div class="line">       {12, 13, 22, 20},</div><div class="line">       {13, 14, 20, 18},</div><div class="line">       {14, 15, 18, 19},</div><div class="line">       {16, 21, 15, 19},</div><div class="line">       {17, 23, 16, 21},</div><div class="line">       {20, 18, 21, 19},</div><div class="line">       {22, 20, 23, 21}</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_2;</div><div class="line">  create_2d_grid (vertices_2,</div><div class="line">                  <span class="keyword">sizeof</span>(vertices_2)/<span class="keyword">sizeof</span>(vertices_2[0]),</div><div class="line">                  cell_vertices_2,</div><div class="line">                  <span class="keyword">sizeof</span>(cell_vertices_2)/<span class="keyword">sizeof</span>(cell_vertices_2[0]),</div><div class="line">                  triangulation_2d_2);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">GridGenerator::extrude_triangulation</a> (triangulation_2d_2,</div><div class="line">                                        5, 2.5,</div><div class="line">                                        triangulation_3d_2);</div><div class="line"></div><div class="line">  <span class="comment">// Also shift this triangulation in the z-direction so</span></div><div class="line">  <span class="comment">// that it matches the end face of the first part</span></div><div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> (<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0,0,2.5),</div><div class="line">                    triangulation_3d_2);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Now first merge these two pieces, then shift the</span></div><div class="line">  <span class="comment">// first piece in z-direction beyond the second, and</span></div><div class="line">  <span class="comment">// merge the shifted piece with the two previously</span></div><div class="line">  <span class="comment">// merged one into the final one:</span></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_tmp;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations</a> (triangulation_3d_1,</div><div class="line">                                       triangulation_3d_2,</div><div class="line">                                       triangulation_3d_tmp);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> (<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0,0,5),</div><div class="line">                    triangulation_3d_1);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations</a> (triangulation_3d_tmp,</div><div class="line">                                       triangulation_3d_1,</div><div class="line">                                       triangulation);</div><div class="line">}</div></div><!-- fragment --><p>With this code, you get a mesh that looks like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.2.png"/>
</div>
<p>The next step is to teach each of the top surfaces that they should be curved. We can do this by creating <a class="el" href="classCylinderBoundary.html">CylinderBoundary</a> objects that describe this. A first attempt looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation;</div><div class="line">create_3d_grid (triangulation);</div><div class="line"></div><div class="line"><span class="comment">// Create the objects that describe the boundaries and attach them</span></div><div class="line"><span class="comment">// to the triangulation as the ones to use on boundaries marked</span></div><div class="line"><span class="comment">// with boundary indicators 8 and 9</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 1.5;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> outer_radius = 2.5;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCylinderBoundary.html">CylinderBoundary&lt;3&gt;</a> inner_cylinder(inner_radius, 2);</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCylinderBoundary.html">CylinderBoundary&lt;3&gt;</a> outer_cylinder(outer_radius, 2);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (8, inner_cylinder);</div><div class="line">triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (9, outer_cylinder);</div><div class="line"></div><div class="line"><span class="comment">// Then loop over all faces of the domain and, if for the position</span></div><div class="line"><span class="comment">// of the center of a face the following holds then set boundary</span></div><div class="line"><span class="comment">// indicators:</span></div><div class="line"><span class="comment">// - if y&gt;3 and z&lt;=2.5 or z&gt;=5 then use boundary indicator 8</span></div><div class="line"><span class="comment">// - if y&gt;3 and 2.5&lt;=z&lt;=5 then use boundary indicator 9</span></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;3&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0;</div><div class="line">       f &lt; GeometryInfo&lt;3&gt;::faces_per_cell;</div><div class="line">       ++f)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> face_center = cell-&gt;face(f)-&gt;center();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((face_center[2] &lt;= 2.5 || face_center[2] &gt;= 5) &amp;&amp;</div><div class="line">              face_center[1] &gt;= 3)</div><div class="line">            cell-&gt;face(f)-&gt;set_boundary_id(8);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (face_center[2] &gt;= 2.5 &amp;&amp;</div><div class="line">              face_center[2] &lt;= 5</div><div class="line">              &amp;&amp; face_center[1] &gt;= 3)</div><div class="line">            cell-&gt;face(f)-&gt;set_boundary_id(9);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// Then refine the mesh once</span></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (1);</div></div><!-- fragment --><p>With this code, we get a mesh that looks like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.3.png"/>
</div>
<p>This is clearly not correct: The new vertices that have been entered at mid-edge and mid-face points are not where they should have been. Upon some reflection, it turns out that while the radii of the cylinders are correct, the axes of the two cylinder objects should not have been along coordinate axes but shifted. This can be corrected by creating them as follows, the two points given as arguments indicating the direction and a point on the axis:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCylinderBoundary.html">CylinderBoundary&lt;3&gt;</a> inner_cylinder (inner_radius,</div><div class="line">                                                 <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0,0,1),</div><div class="line">                                                 <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0,3,0));</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classCylinderBoundary.html">CylinderBoundary&lt;3&gt;</a> outer_cylinder (outer_radius,</div><div class="line">                                                 <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0,0,1),</div><div class="line">                                                 <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0,3,0));</div><div class="line">triangulation.<a class="code" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">set_boundary</a> (9, outer_cylinder);</div></div><!-- fragment --><p>This yields an improvement, though it is still not quite correct:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.4.png"/>
</div>
<p>Looking closely at this mesh, we realize that the new points on mid-face vertices are where they should be, though the new vertices inserted at mid-edge points are in the wrong place (you see this by comparing the picture with the one of the coarse mesh). What is happening is that we are only telling the triangulation to use these geometry objects for the <em>faces</em> but not for the adjacent <em>edges</em> as well. This is easily fixed by using the function <a class="el" href="group__boundary.html#gaa0304fb253839c45e64b60460ab040ae">TriaAccessor::set_all_boundary_ids()</a> instead of <a class="el" href="group__boundary.html#ga654de9ccd776b524a27cd64bded48e14">TriaAccessor::set_boundary_id()</a> used above. With this change, the grid now looks like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.5.png"/>
</div>
<p>This is already better. However, something is still going wrong on the front left face. On second look, we can also see that the faces where the geometry widens have been refined at the bottom, that there is one transition face that looks wrong because it has a triangle rather than a quadrilateral, and that finally the transition faces in the cylindrical region appear not to have been refined at all in radial direction.</p>
<p>This due to the fact that we have (erroneously) marked all boundary faces between <img class="formulaInl" alt="$0\le z\le 2.5$" src="form_3886.png"/> with the boundary indicator for the small cylinder and similarly for the other regions. This condition includes the faces parallel to the x-y plane. To fix it, we need to exclude faces whose center points have <img class="formulaInl" alt="$z$" src="form_11.png"/> values equal to (or at least close to, since we should not compare for equality in floating point arithmetic) 0, 2.5, 5 or 7.5. This replacement code does the trick:</p>
<div class="fragment"><div class="line">  <span class="comment">// Then loop over all faces of the domain and, if for the position</span></div><div class="line">  <span class="comment">// of the center of a face the following holds then set boundary</span></div><div class="line">  <span class="comment">// indicators:</span></div><div class="line">  <span class="comment">// - if y&gt;3 and z&lt;2.5 or z&gt;5 then use boundary indicator 8</span></div><div class="line">  <span class="comment">// - if y&gt;3 and 2.5&lt;z&lt;5 then use boundary indicator 9</span></div><div class="line">  <span class="comment">// In this process, exclude faces whose z-coordinates are</span></div><div class="line">  <span class="comment">// within a small distance of z=0, z=2.5, z=5 or z=7.5.</span></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;3&gt;::active_cell_iterator</a></div><div class="line">    cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">    endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0;</div><div class="line">         f &lt; GeometryInfo&lt;3&gt;::faces_per_cell;</div><div class="line">         ++f)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> face_center = cell-&gt;face(f)-&gt;center();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary())</div><div class="line">          <span class="keywordflow">if</span> ((face_center[2]&gt;1e-6) &amp;&amp;</div><div class="line">              (face_center[2]&lt;7.5-1e-6) &amp;&amp;</div><div class="line">              (std::fabs(face_center[2]-2.5)&gt;1e-6) &amp;&amp;</div><div class="line">              (std::fabs(face_center[2]-5.0)&gt;1e-6))</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> ((face_center[2] &lt; 2.5 || face_center[2] &gt; 5)</div><div class="line">                  &amp;&amp; face_center[1] &gt;= 3)</div><div class="line">                cell-&gt;face(f)-&gt;set_all_boundary_ids(8);</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (face_center[2] &gt; 2.5 &amp;&amp; face_center[2] &lt; 5</div><div class="line">                  &amp;&amp; face_center[1] &gt;= 3)</div><div class="line">                cell-&gt;face(f)-&gt;set_all_boundary_ids(9);</div><div class="line">            }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p>With this, we finally get a mesh that looks good:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.6.png"/>
</div>
<p>We can then refine the mesh two more times to see in more detail what happens to the curved part of the boundary:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.7.png"/>
</div>
<p>So, yes!, this is finally what we were looking for! <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2013 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Timo Heister, Texas A&amp;M University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> print_mesh_info(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation,</div><div class="line">                     <span class="keyword">const</span> std::string        &amp;filename)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh info:&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; dimension: &quot;</span> &lt;&lt; dim &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; no. of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    std::map&lt;unsigned int, unsigned int&gt; boundary_count;</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">    endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary())</div><div class="line">              boundary_count[cell-&gt;face(face)-&gt;boundary_id()]++;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; boundary indicators: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (std::map&lt;unsigned int, unsigned int&gt;::iterator it=boundary_count.begin();</div><div class="line">         it!=boundary_count.end();</div><div class="line">         ++it)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="stringliteral">&quot; times) &quot;</span>;</div><div class="line">      }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream out (filename.c_str());</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a7e31485bb55254bfa5cd3ab55f8d1748">write_eps</a> (triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; written to &quot;</span> &lt;&lt; filename</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_1 ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"></div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a> gridin;</div><div class="line">  gridin.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(triangulation);</div><div class="line">  std::ifstream f(<span class="stringliteral">&quot;untitled.msh&quot;</span>);</div><div class="line">  gridin.<a class="code" href="classGridIn.html#a83872db02e04f52ac52d578912f6da5e">read_msh</a>(f);</div><div class="line"></div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-1.eps&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_2 ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> (tria1, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria2;</div><div class="line">  std::vector&lt; unsigned int &gt; repetitions(2);</div><div class="line">  repetitions[0]=3;</div><div class="line">  repetitions[1]=2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (tria2, repetitions,</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0,-1.0),</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(4.0,1.0));</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a0dace8884c1510160d7b6cbb313523e9">GridGenerator::merge_triangulations</a> (tria1, tria2, triangulation);</div><div class="line"></div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-2.eps&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_3 ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> (triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a></div><div class="line">  cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(),</div><div class="line">  endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;GeometryInfo&lt;2&gt;::vertices_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = cell-&gt;vertex(i);</div><div class="line">          <span class="keywordflow">if</span> (std::abs(v(1)-1.0)&lt;1e-5)</div><div class="line">            v(1) += 0.5;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="group__manifold.html#ga2ea00d3c65f290a020a268df8fb50c19">GridTools::copy_boundary_to_manifold_id</a>(triangulation);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> boundary_description(<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0,0));</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (1, boundary_description);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line"></div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-3.eps&quot;</span>);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (1);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_4()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> out;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> (triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add67475b53b365d65a3fe3eb6f156fa9">GridGenerator::extrude_triangulation</a> (triangulation, 3, 2.0, out);</div><div class="line">  print_mesh_info (out, <span class="stringliteral">&quot;grid-4.eps&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> grid_5_transform (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(in(0),</div><div class="line">                  in(1) + std::sin(in(0)/5.0*3.14159));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_5()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 14;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation,</div><div class="line">                                             repetitions,</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0,0.0),</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(10.0,1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a> (&amp;grid_5_transform, triangulation);</div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-5.eps&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Grid6Func</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> trans(<span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> std::tanh(2*y)/tanh(2);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> operator() (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> (in(0),</div><div class="line">                     trans(in(1)));</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_6()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  std::vector&lt; unsigned int &gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 40;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation,</div><div class="line">                                             repetitions,</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0,0.0),</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0,1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(Grid6Func(), triangulation);</div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-6.eps&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_7()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 16;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> (triangulation, repetitions,</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0,0.0),</div><div class="line">                                             <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0,1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#aec039d544c93a6e810427ad45ba0c84f">GridTools::distort_random</a> (0.3, triangulation, <span class="keyword">true</span>);</div><div class="line">  print_mesh_info (triangulation, <span class="stringliteral">&quot;grid-7.eps&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      grid_1 ();</div><div class="line">      grid_2 ();</div><div class="line">      grid_3 ();</div><div class="line">      grid_4 ();</div><div class="line">      grid_5 ();</div><div class="line">      grid_6 ();</div><div class="line">      grid_7 ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
