<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-32 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-32 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Usingtherightpressure"> Using the "right" pressure </a>
        <li><a href="#Thescalingofdiscretizedequations"> The scaling of discretized equations </a>
        <li><a href="#ChangestotheStokespreconditionerandsolver"> Changes to the Stokes preconditioner and solver </a>
        <li><a href="#Changestotheartificialviscositystabilization"> Changes to the artificial viscosity stabilization </a>
        <li><a href="#LocallyconservativeStokesdiscretization"> Locally conservative Stokes discretization </a>
        <li><a href="#Higherordermappingsforcurvedboundaries"> Higher order mappings for curved boundaries </a>
        <li><a href="#Parallelizationonclusters"> Parallelization on clusters </a>
        <li><a href="#Parallelizationwithinindividualnodesofacluster"> Parallelization within individual nodes of a cluster </a>
        <li><a href="#Thetestcase"> The testcase </a>
        <li><a href="#Implementationdetails"> Implementation details </a>
        <li><a href="#Outlook"> Outlook </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#PreconditioningtheStokessystem">Preconditioning the Stokes system</a>
        <li><a href="#Definitionofassemblydatastructures">Definition of assembly data structures</a>
        <li><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The <code>BoussinesqFlowProblem</code> class template</a>
        <li><a href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem class implementation</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemParameters">BoussinesqFlowProblem::Parameters</a>
        <li><a href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a>
        <li><a href="#TheBoussinesqFlowProblemhelperfunctions">The BoussinesqFlowProblem helper functions</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a>
        <li><a href="#BoussinesqFlowProblemget_cfl_number">BoussinesqFlowProblem::get_cfl_number</a>
        <li><a href="#BoussinesqFlowProblemget_entropy_variation">BoussinesqFlowProblem::get_entropy_variation</a>
        <li><a href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a>
        <li><a href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a>
        <li><a href="#BoussinesqFlowProblemproject_temperature_field">BoussinesqFlowProblem::project_temperature_field</a>
      </ul>
        <li><a href="#TheBoussinesqFlowProblemsetupfunctions">The BoussinesqFlowProblem setup functions</a>
        <li><a href="#TheBoussinesqFlowProblemassemblyfunctions">The BoussinesqFlowProblem assembly functions</a>
      <ul>
        <li><a href="#Stokespreconditionerassembly">Stokes preconditioner assembly</a>
        <li><a href="#Stokessystemassembly">Stokes system assembly</a>
        <li><a href="#Temperaturematrixassembly">Temperature matrix assembly</a>
        <li><a href="#Temperaturerighthandsideassembly">Temperature right hand side assembly</a>
      </ul>
        <li><a href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a>
        <li><a href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a>
        <li><a href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a>
        <li><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Comparisonofresultswithstep31">Comparison of results with step-31</a>
        <li><a href="#Resultsfora2dcircularshelltestcase">Results for a 2d circular shell testcase</a>
        <li><a href="#Resultsfora3dsphericalshelltestcase">Results for a 3d spherical shell testcase</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Martin Kronbichler, Wolfgang Bangerth, and Timo Heister.</em></p>
<p><em>This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology; and in a continuation by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation, The California Institute of Technology, or of The University of California &ndash; Davis.</em></p>
<p><em>The work discussed here is also presented in the following publication: <b> M. Kronbichler, T. Heister, W. Bangerth: <em>High Accuracy Mantle Convection Simulation through Modern Numerical Methods</em>, Geophysical Journal International, 2012, 191, 12-29. <a href="http://dx.doi.org/10.1111/j.1365-246X.2012.05609.x">[DOI]</a> </b></em></p>
<p><em>The continuation of development of this program has led to the much larger open source code Aspect (see <a href="http://aspect.dealii.org/">http://aspect.dealii.org/</a> ) which is much more flexible in solving many kinds of related problems. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program does pretty much exactly what <a class="el" href="step_31.html">step-31</a> already does: it solves the Boussinesq equations that describe the motion of a fluid whose temperature is not in equilibrium. As such, all the equations we have described in <a class="el" href="step_31.html">step-31</a> still hold: we solve the same general partial differential equation (with only minor modifications to adjust for more realism in the problem setting), using the same finite element scheme, the same time stepping algorithm, and more or less the same stabilization method for the temperature advection-diffusion equation. As a consequence, you may first want to understand that program &mdash; and its implementation &mdash; before you work on the current one.</p>
<p>The difference between <a class="el" href="step_31.html">step-31</a> and the current program is that here we want to do things in parallel, using both the availability of many machines in a cluster (with parallelization based on MPI) as well as many processor cores within a single machine (with parallelization based on threads). This program's main job is therefore to introduce the changes that are necessary to utilize the availability of these parallel compute resources. In this regard, it builds on the <a class="el" href="step_40.html">step-40</a> program that first introduces the necessary classes for much of the parallel functionality, and on <a class="el" href="step_55.html">step-55</a> that shows how this is done for a vector-valued problem.</p>
<p>In addition to these changes, we also use a slightly different preconditioner, and we will have to make a number of changes that have to do with the fact that we want to solve a <em>realistic</em> problem here, not a model problem. The latter, in particular, will require that we think about scaling issues as well as what all those parameters and coefficients in the equations under consideration actually mean. We will discuss first the issues that affect changes in the mathematical formulation and solver structure, then how to parallelize things, and finally the actual testcase we will consider.</p>
<p><a class="anchor" id="Usingtherightpressure"></a></p><h3>Using the "right" pressure </h3>
<p>In <a class="el" href="step_31.html">step-31</a>, we used the following Stokes model for the velocity and pressure field: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho \; \beta \; T \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}" src="form_2670.png"/>
</p>
<p> The right hand side of the first equation appears a wee bit unmotivated. Here's how things should really be. We need the external forces that act on the fluid, which we assume are given by gravity only. In the current case, we assume that the fluid does expand slightly for the purposes of this gravity force, but not enough that we need to modify the incompressibility condition (the second equation). What this means is that for the purpose of the right hand side, we can assume that <img class="formulaInl" alt="$\rho=\rho(T)$" src="form_2671.png"/>. An assumption that may not be entirely justified is that we can assume that the changes of density as a function of temperature are small, leading to an expression of the form <img class="formulaInl" alt="$\rho(T) = \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})]$" src="form_2672.png"/>, i.e. the density equals <img class="formulaInl" alt="$\rho_{\text{ref}}$" src="form_2673.png"/> at reference temperature and decreases linearly as the temperature increases (as the material expands). The force balance equation then looks properly written like this: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})] \mathbf{g}. \end{eqnarray*}" src="form_2674.png"/>
</p>
<p> Now note that the gravity force results from a gravity potential as <img class="formulaInl" alt="$\mathbf g=-\nabla \varphi$" src="form_2675.png"/>, so that we can re-write this as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho_{\text{ref}} \; \beta\; T\; \mathbf{g} -\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \nabla\varphi. \end{eqnarray*}" src="form_2676.png"/>
</p>
<p> The second term on the right is time independent, and so we could introduce a new "dynamic" pressure <img class="formulaInl" alt="$p_{\text{dyn}}=p+\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi=p_{\text{total}}-p_{\text{static}}$" src="form_2677.png"/> with which the Stokes equations would read: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p_{\text{dyn}} &amp;=&amp; -\rho_{\text{ref}} \; \beta \; T \; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}" src="form_2678.png"/>
</p>
<p> This is exactly the form we used in <a class="el" href="step_31.html">step-31</a>, and it was appropriate to do so because all changes in the fluid flow are only driven by the dynamic pressure that results from temperature differences. (In other words: Any contribution to the right hand side that results from taking the gradient of a scalar field have no effect on the velocity field.)</p>
<p>On the other hand, we will here use the form of the Stokes equations that considers the total pressure instead: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T)\; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}" src="form_2679.png"/>
</p>
<p> There are several advantages to this:</p>
<ul>
<li>This way we can plot the pressure in our program in such a way that it actually shows the total pressure that includes the effects of temperature differences as well as the static pressure of the overlying rocks. Since the pressure does not appear any further in any of the other equations, whether to use one or the other is more a matter of taste than of correctness. The flow field is exactly the same, but we get a pressure that we can now compare with values that are given in geophysical books as those that hold at the bottom of the earth mantle, for example.</li>
<li>If we wanted to make the model even more realistic, we would have to take into account that many of the material parameters (e.g. the viscosity, the density, etc) not only depend on the temperature but also the <em>total</em> pressure.</li>
<li>The model above assumed a linear dependence <img class="formulaInl" alt="$\rho(T) = \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})]$" src="form_2672.png"/> and assumed that <img class="formulaInl" alt="$\beta$" src="form_414.png"/> is small. In practice, this may not be so. In fact, realistic models are certainly not linear, and <img class="formulaInl" alt="$\beta$" src="form_414.png"/> may also not be small for at least part of the temperature range because the density's behavior is substantially dependent not only on thermal expansion but by phase changes.</li>
<li>A final reason to do this is discussed in the results section and concerns possible extensions to the model we use here. It has to do with the fact that the temperature equation (see below) we use here does not include a term that contains the pressure. It should, however: rock, like gas, heats up as you compress it. Consequently, material that rises up cools adiabatically, and cold material that sinks down heats adiabatically. We discuss this further below.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>There is, however, a downside to this procedure. In the earth, the dynamic pressure is several orders of magnitude smaller than the total pressure. If we use the equations above and solve all variables to, say, 4 digits of accuracy, then we may be able to get the velocity and the total pressure right, but we will have no accuracy at all if we compute the dynamic pressure by subtracting from the total pressure the static part <img class="formulaInl" alt="$p_\text{static}=\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi$" src="form_2680.png"/>. If, for example, the dynamic pressure is six orders of magnitude smaller than the static pressure, then we need to solve the overall pressure to at least seven digits of accuracy to get anything remotely accurate. That said, in practice this turns out not to be a limiting factor.</dd></dl>
<p><a class="anchor" id="Thescalingofdiscretizedequations"></a></p><h3>The scaling of discretized equations </h3>
<p>Remember that we want to solve the following set of equations: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T) \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma, \end{eqnarray*}" src="form_2681.png"/>
</p>
<p> augmented by appropriate boundary and initial conditions. As discussed in <a class="el" href="step_31.html">step-31</a>, we will solve this set of equations by solving for a Stokes problem first in each time step, and then moving the temperature equation forward by one time interval.</p>
<p>The problem under consideration in this current section is with the Stokes problem: if we discretize it as usual, we get a linear system </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} M \; X = \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{c} U \\ P \end{array}\right) = \left(\begin{array}{c} F_U \\ 0 \end{array}\right) = F \end{eqnarray*}" src="form_2682.png"/>
</p>
<p> which in this program we will solve with a FGMRES solver. This solver iterates until the residual of these linear equations is below a certain tolerance, i.e. until </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left\| \left(\begin{array}{c} F_U - A U^{(k)} - B P^{(k)} \\ B^T U^{(k)} \end{array}\right) \right\| &lt; \text{Tol}. \]" src="form_2683.png"/>
</p>
<p> This does not make any sense from the viewpoint of physical units: the quantities involved here have physical units so that the first part of the residual has units <img class="formulaInl" alt="$\frac{\text{Pa}}{\text{m}} \text{m}^{\text{dim}}$" src="form_2684.png"/> (most easily established by considering the term <img class="formulaInl" alt="$(\nabla \cdot \mathbf v, p)_{\Omega}$" src="form_2685.png"/> and considering that the pressure has units <img class="formulaInl" alt="$\text{Pa}=\frac{\text{kg}}{\text{m\; s}^2}$" src="form_2686.png"/> and the integration yields a factor of <img class="formulaInl" alt="$\text{m}^{\text{dim}}$" src="form_2687.png"/>), whereas the second part of the residual has units <img class="formulaInl" alt="$\frac{\text{m}^{\text{dim}}}{\text{s}}$" src="form_2688.png"/>. Taking the norm of this residual vector would yield a quantity with units <img class="formulaInl" alt="$\text{m}^{\text{dim}-1} \sqrt{\left(\text{Pa}\right)^2 + \left(\frac{\text{m}}{\text{s}}\right)^2}$" src="form_2689.png"/>. This, quite obviously, does not make sense, and we should not be surprised that doing so is eventually going to come back hurting us.</p>
<p>So why is this an issue here, but not in <a class="el" href="step_31.html">step-31</a>? The reason back there is that everything was nicely balanced: velocities were on the order of one, the pressure likewise, the viscosity was one, and the domain had a diameter of <img class="formulaInl" alt="$\sqrt{2}$" src="form_2690.png"/>. As a result, while nonsensical, nothing bad happened. On the other hand, as we will explain below, things here will not be that simply scaled: <img class="formulaInl" alt="$\eta$" src="form_1145.png"/> will be around <img class="formulaInl" alt="$10^{21}$" src="form_2691.png"/>, velocities on the order of <img class="formulaInl" alt="$10^{-8}$" src="form_2692.png"/>, pressure around <img class="formulaInl" alt="$10^8$" src="form_123.png"/>, and the diameter of the domain is <img class="formulaInl" alt="$10^7$" src="form_2693.png"/>. In other words, the order of magnitude for the first equation is going to be <img class="formulaInl" alt="$\eta\text{div}\varepsilon(\mathbf u) \approx 10^{21} \frac{10^{-8}}{(10^7)^2} \approx 10^{-1}$" src="form_2694.png"/>, whereas the second equation will be around <img class="formulaInl" alt="$\text{div}{\mathbf u}\approx \frac{10^{-8}}{10^7} \approx 10^{-15}$" src="form_2695.png"/>. Well, so what this will lead to is this: if the solver wants to make the residual small, it will almost entirely focus on the first set of equations because they are so much bigger, and ignore the divergence equation that describes mass conservation. That's exactly what happens: unless we set the tolerance to extremely small values, the resulting flow field is definitely not divergence free. As an auxiliary problem, it turns out that it is difficult to find a tolerance that always works; in practice, one often ends up with a tolerance that requires 30 or 40 iterations for most time steps, and 10,000 for some others.</p>
<p>So what's a numerical analyst to do in a case like this? The answer is to start at the root and first make sure that everything is mathematically consistent first. In our case, this means that if we want to solve the system of Stokes equations jointly, we have to scale them so that they all have the same physical dimensions. In our case, this means multiplying the second equation by something that has units <img class="formulaInl" alt="$\frac{\text{Pa\; s}}{\text{m}}$" src="form_2696.png"/>; one choice is to multiply with <img class="formulaInl" alt="$\frac{\eta}{L}$" src="form_2697.png"/> where <img class="formulaInl" alt="$L$" src="form_2323.png"/> is a typical lengthscale in our domain (which experiments show is best chosen to be the diameter of plumes &mdash; around 10 km &mdash; rather than the diameter of the domain). Using these numbers for <img class="formulaInl" alt="$\eta$" src="form_1145.png"/> and <img class="formulaInl" alt="$L$" src="form_2323.png"/>, this factor is around <img class="formulaInl" alt="$10^{17}$" src="form_2698.png"/>. So, we now get this for the Stokes system: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T) \; \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}" src="form_2699.png"/>
</p>
<p> The trouble with this is that the result is not symmetric any more (we have <img class="formulaInl" alt="$\frac{\eta}{L} \nabla \cdot$" src="form_2700.png"/> at the bottom left, but not its transpose operator at the top right). This, however, can be cured by introducing a scaled pressure <img class="formulaInl" alt="$\hat p = \frac{L}{\eta}p$" src="form_2701.png"/>, and we get the scaled equations </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla \left(\frac{\eta}{L} \hat p\right) &amp;=&amp; \rho(T) \; \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}" src="form_2702.png"/>
</p>
<p> This is now symmetric. Obviously, we can easily recover the original pressure <img class="formulaInl" alt="$p$" src="form_202.png"/> from the scaled pressure <img class="formulaInl" alt="$\hat p$" src="form_2703.png"/> that we compute as a result of this procedure.</p>
<p>In the program below, we will introduce a factor <code>EquationData::pressure_scaling</code> that corresponds to <img class="formulaInl" alt="$\frac{\eta}{L}$" src="form_2697.png"/>, and we will use this factor in the assembly of the system matrix and preconditioner. Because it is annoying and error prone, we will recover the unscaled pressure immediately following the solution of the linear system, i.e., the solution vector's pressure component will immediately be unscaled to retrieve the physical pressure. Since the solver uses the fact that we can use a good initial guess by extrapolating the previous solutions, we also have to scale the pressure immediately <em>before</em> solving.</p>
<p><a class="anchor" id="ChangestotheStokespreconditionerandsolver"></a></p><h3>Changes to the Stokes preconditioner and solver </h3>
<p>In this tutorial program, we apply a variant of the preconditioner used in <a class="el" href="step_31.html">step-31</a>. That preconditioner was built to operate on the system matrix <em>M</em> in block form such that the product matrix </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} P^{-1} M = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}" src="form_2704.png"/>
</p>
<p> is of a form that Krylov-based iterative solvers like GMRES can solve in a few iterations. We then replaced the exact inverse of <em>A</em> by the action of an AMG preconditioner <img class="formulaInl" alt="$\tilde{A}$" src="form_2705.png"/> based on a vector Laplace matrix, approximated the Schur complement <img class="formulaInl" alt="$S = B A^{-1} B^T$" src="form_1908.png"/> by a mass matrix <img class="formulaInl" alt="$M_p$" src="form_1881.png"/> on the pressure space and wrote an <code>InverseMatrix</code> class for implementing the action of <img class="formulaInl" alt="$M_p^{-1}\approx S^{-1}$" src="form_2706.png"/> on vectors. In the InverseMatrix class, we used a CG solve with an incomplete Cholesky (IC) preconditioner for performing the inner solves.</p>
<p>An observation one can make is that we use just the action of a preconditioner for approximating the velocity inverse <img class="formulaInl" alt="$A^{-1}$" src="form_1098.png"/> (and the outer GMRES iteration takes care of the approximate character of the inverse), whereas we use a more or less <em>exact</em> inverse for <img class="formulaInl" alt="$M_p^{-1}$" src="form_1880.png"/>, realized by a fully converged CG solve. This appears unbalanced, but there's system to this madness: almost all the effort goes into the upper left block to which we apply the AMG preconditioner, whereas even an exact inversion of the pressure mass matrix costs basically nothing. Consequently, if it helps us reduce the overall number of iterations somewhat, then this effort is well spent.</p>
<p>That said, even though the solver worked well for <a class="el" href="step_31.html">step-31</a>, we have a problem here that is a bit more complicated (cells are deformed, the pressure varies by orders of magnitude, and we want to plan ahead for more complicated physics), and so we'll change a few things slightly:</p>
<ul>
<li>For more complex problems, it turns out that using just a single AMG V-cycle as preconditioner is not always sufficient. The outer solver converges just fine most of the time in a reasonable number of iterations (say, less than 50) but there are the occasional time step where it suddenly takes 700 or so. What exactly is going on there is hard to determine, but the problem can be avoided by using a more accurate solver for the top left block. Consequently, we'll want to use a CG iteration to invert the top left block of the preconditioner matrix, and use the AMG as a preconditioner for the CG solver.</li>
<li>The downside of this is that, of course, the Stokes preconditioner becomes much more expensive (approximately 10 times more expensive than when we just use a single V-cycle). Our strategy then is this: let's do up to 30 GMRES iterations with just the V-cycle as a preconditioner and if that doesn't yield convergence, then take the best approximation of the Stokes solution obtained after this first round of iterations and use that as the starting guess for iterations where we use the full inner solver with a rather lenient tolerance as preconditioner. In all our experiments this leads to convergence in only a few additional iterations.</li>
<li>One thing we need to pay attention to is that when using a CG with a lenient tolerance in the preconditioner, then <img class="formulaInl" alt="$y = \tilde A^{-1} r$" src="form_2707.png"/> is no longer a linear function of <img class="formulaInl" alt="$r$" src="form_267.png"/> (it is, of course, if we have a very stringent tolerance in our solver, or if we only apply a single V-cycle). This is a problem since now our preconditioner is no longer a linear operator; in other words, every time GMRES uses it the preconditioner looks different. The standard GMRES solver can't deal with this, leading to slow convergence or even breakdown, but the F-GMRES variant is designed to deal with exactly this kind of situation and we consequently use it.</li>
<li>On the other hand, once we have settled on using F-GMRES we can relax the tolerance used in inverting the preconditioner for <img class="formulaInl" alt="$S$" src="form_731.png"/>. In <a class="el" href="step_31.html">step-31</a>, we ran a preconditioned CG method on <img class="formulaInl" alt="$\tilde S$" src="form_1710.png"/> until the residual had been reduced by 7 orders of magnitude. Here, we can again be more lenient because we know that the outer preconditioner doesn't suffer.</li>
<li>In <a class="el" href="step_31.html">step-31</a>, we used a left preconditioner in which we first invert the top left block of the preconditioner matrix, then apply the bottom left (divergence) one, and then invert the bottom right. In other words, the application of the preconditioner acts as a lower left block triangular matrix. Another option is to use a right preconditioner that here would be upper right block triangulation, i.e., we first invert the bottom right Schur complement, apply the top right (gradient) operator and then invert the elliptic top left block. To a degree, which one to choose is a matter of taste. That said, there is one significant advantage to a right preconditioner in GMRES-type solvers: the residual with which we determine whether we should stop the iteration is the true residual, not the norm of the preconditioned equations. Consequently, it is much simpler to compare it to the stopping criterion we typically use, namely the norm of the right hand side vector. In writing this code we found that the scaling issues we discussed above also made it difficult to determine suitable stopping criteria for left-preconditioned linear systems, and consequently this program uses a right preconditioner.</li>
<li>In <a class="el" href="step_31.html">step-31</a>, we used an IC (incomplete Cholesky) preconditioner for the pressure mass matrix in the Schur complement preconditioner and for the solution of the temperature system. Here, we could in principle do the same, but we do choose an even simpler preconditioner, namely a Jacobi preconditioner for both systems. This is because here we target at massively parallel computations, where the decompositions for IC/ILU would have to be performed block-wise for the locally owned degrees of freedom on each processor. This means, that the preconditioner gets more like a Jacobi preconditioner anyway, so we rather start from that variant straight away. Note that we only use the Jacobi preconditioners for CG solvers with mass matrices, where they give optimal (<em>h</em>-independent) convergence anyway, even though they usually require about twice as many iterations as an IC preconditioner.</li>
</ul>
<p>As a final note, let us remark that in <a class="el" href="step_31.html">step-31</a> we computed the Schur complement <img class="formulaInl" alt="$S=B A^{-1} B^T$" src="form_2708.png"/> by approximating <img class="formulaInl" alt="$-\text{div}(-\eta\Delta)^{-1}\nabla \approx \frac 1{\eta} \mathbf{1}$" src="form_2709.png"/>. Now, however, we have re-scaled the <img class="formulaInl" alt="$B$" src="form_65.png"/> and <img class="formulaInl" alt="$B^T$" src="form_66.png"/> operators. So <img class="formulaInl" alt="$S$" src="form_731.png"/> should now approximate <img class="formulaInl" alt="$-\frac{\eta}{L}\text{div}(-\eta\Delta)^{-1}\nabla \frac{\eta}{L} \approx \left(\frac{\eta}{L}\right)^2 \frac 1{\eta} \mathbf{1}$" src="form_2710.png"/>. We use the discrete form of the right hand side of this as our approximation <img class="formulaInl" alt="$\tilde S$" src="form_1710.png"/> to <img class="formulaInl" alt="$S$" src="form_731.png"/>.</p>
<p><a class="anchor" id="Changestotheartificialviscositystabilization"></a></p><h3>Changes to the artificial viscosity stabilization </h3>
<p>Similarly to <a class="el" href="step_31.html">step-31</a>, we will use an artificial viscosity for stabilization based on a residual of the equation. As a difference to <a class="el" href="step_31.html">step-31</a>, we will provide two slightly different definitions of the stabilization parameter. For <img class="formulaInl" alt="$\alpha=1$" src="form_1557.png"/>, we use the same definition as in <a class="el" href="step_31.html">step-31</a>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \nu_\alpha(T)|_K = \nu_1(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K \min\left\{ 1, \frac{\|R_1(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\} \end{eqnarray*}" src="form_2711.png"/>
</p>
<p> where we compute the viscosity from a residual <img class="formulaInl" alt="$\|R_1(T)\|_{L^\infty(K)}$" src="form_2712.png"/> of the equation, limited by a diffusion proportional to the mesh size <img class="formulaInl" alt="$h_K$" src="form_1178.png"/> in regions where the residual is large (around steep gradients). This definition has been shown to work well for the given case, <img class="formulaInl" alt="$\alpha = 1$" src="form_2713.png"/> in <a class="el" href="step_31.html">step-31</a>, but it is usually less effective as the diffusion for <img class="formulaInl" alt="$\alpha=2$" src="form_2553.png"/>. For that case, we choose a slightly more readable definition of the viscosity, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \nu_2(T)|_K = \min (\nu_h^\mathrm{max}|_K,\nu_h^\mathrm{E}|_K) \end{eqnarray*}" src="form_2714.png"/>
</p>
<p> where the first term gives again the maximum dissipation (similarly to a first order upwind scheme), </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \nu^\mathrm{max}_h|_K = \beta h_K \|\mathbf {u}\|_{L^\infty(K)} \end{eqnarray*}" src="form_2715.png"/>
</p>
<p> and the entropy viscosity is defined as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \nu^\mathrm{E}_h|_K = c_R \frac{h_K^2 \|R_\mathrm{2,E}(T)\|_{L^\infty(K)}} {\|E(T) - \bar{E}(T)\|_{L^\infty(\Omega)} }. \end{eqnarray*}" src="form_2716.png"/>
</p>
<p>This formula is described in the article <em>J.-L. Guermond, R. Pasquetti, &amp; B. Popov, 2011. Entropy viscosity method for nonlinear conservation laws, J. Comput. Phys., 230, 4248&ndash;4267.</em> Compared to the case <img class="formulaInl" alt="$\alpha = 1$" src="form_2713.png"/>, the residual is computed from the temperature entropy, <img class="formulaInl" alt="$E(T) = \frac12 (T-T_m)^2$" src="form_2717.png"/> with <img class="formulaInl" alt="$T_m$" src="form_2718.png"/> an average temperature (we choose the mean between the maximum and minimum temperature in the computation), which gives the following formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} R_\mathrm{E}(T) = \frac{\partial E(T)}{\partial t} + (T-T_\mathrm{m}) \left(\mathbf{u} \cdot \nabla T - \kappa \nabla^2 T - \gamma\right). \end{eqnarray*}" src="form_2719.png"/>
</p>
<p> The denominator in the formula for <img class="formulaInl" alt="$\nu^\mathrm{E}_h|_K$" src="form_2720.png"/> is computed as the global deviation of the entropy from the space-averaged entropy <img class="formulaInl" alt="$\bar{E}(T) = \int_\Omega E(T) d\mathbf{x}/\int_\Omega d\mathbf{x}$" src="form_2721.png"/>. As in <a class="el" href="step_31.html">step-31</a>, we evaluate the artificial viscosity from the temperature and velocity at two previous time levels, in order to avoid a nonlinearity in its definition.</p>
<p>The above definitions of the viscosity are simple, but depend on two parameters, namely <img class="formulaInl" alt="$\beta$" src="form_414.png"/> and <img class="formulaInl" alt="$c_R$" src="form_2548.png"/>. For the current program, we want to go about this issue a bit more systematically for both parameters in the case <img class="formulaInl" alt="$\alpha =1$" src="form_2722.png"/>, using the same line of reasoning with which we chose two other parameters in our discretization, <img class="formulaInl" alt="$c_k$" src="form_2626.png"/> and <img class="formulaInl" alt="$\beta$" src="form_414.png"/>, in the results section of <a class="el" href="step_31.html">step-31</a>. In particular, remember that we would like to make the artificial viscosity as small as possible while keeping it as large as necessary. In the following, let us describe the general strategy one may follow. The computations shown here were done with an earlier version of the program and so the actual numerical values you get when running the program may no longer match those shown here; that said, the general approach remains valid and has been used to find the values of the parameters actually used in the program.</p>
<p>To see what is happening, note that below we will impose boundary conditions for the temperature between 973 and 4273 Kelvin, and initial conditions are also chosen in this range; for these considerations, we run the program without internal heat sources or sinks, and consequently the temperature should always be in this range, barring any internal oscillations. If the minimal temperature drops below 973 Kelvin, then we need to add stabilization by either increasing <img class="formulaInl" alt="$\beta$" src="form_414.png"/> or decreasing <img class="formulaInl" alt="$c_R$" src="form_2548.png"/>.</p>
<p>As we did in <a class="el" href="step_31.html">step-31</a>, we first determine an optimal value of <img class="formulaInl" alt="$\beta$" src="form_414.png"/> by using the "traditional" formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K, \end{eqnarray*}" src="form_2723.png"/>
</p>
<p> which we know to be stable if only <img class="formulaInl" alt="$\beta$" src="form_414.png"/> is large enough. Doing a couple hundred time steps (on a coarser mesh than the one shown in the program, and with a different viscosity that affects transport velocities and therefore time step sizes) in 2d will produce the following graph:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.beta.2d.png"/>
</div>
<p>As can be seen, values <img class="formulaInl" alt="$\beta \le 0.05$" src="form_2724.png"/> are too small whereas <img class="formulaInl" alt="$\beta=0.052$" src="form_2725.png"/> appears to work, at least to the time horizon shown here. As a remark on the side, there are at least two questions one may wonder here: First, what happens at the time when the solution becomes unstable? Looking at the graphical output, we can see that with the unreasonably coarse mesh chosen for these experiments, around time <img class="formulaInl" alt="$t=10^{15}$" src="form_2726.png"/> seconds the plumes of hot material that have been rising towards the cold outer boundary and have then spread sideways are starting to get close to each other, squeezing out the cold material in-between. This creates a layer of cells into which fluids flows from two opposite sides and flows out toward a third, apparently a scenario that then produce these instabilities without sufficient stabilization. Second: In <a class="el" href="step_31.html">step-31</a>, we used <img class="formulaInl" alt="$\beta=0.015\cdot\text{dim}$" src="form_2727.png"/>; why does this not work here? The answer to this is not entirely clear &ndash; stabilization parameters are certainly known to depend on things like the shape of cells, for which we had squares in <a class="el" href="step_31.html">step-31</a> but have trapezoids in the current program. Whatever the exact cause, we at least have a value of <img class="formulaInl" alt="$\beta$" src="form_414.png"/>, namely 0.052 for 2d, that works for the current program. A similar set of experiments can be made in 3d where we find that <img class="formulaInl" alt="$\beta=0.078$" src="form_2728.png"/> is a good choice &mdash; neatly leading to the formula <img class="formulaInl" alt="$\beta=0.026 \cdot \textrm{dim}$" src="form_2729.png"/>.</p>
<p>With this value fixed, we can go back to the original formula for the viscosity <img class="formulaInl" alt="$\nu$" src="form_1655.png"/> and play with the constant <img class="formulaInl" alt="$c_R$" src="form_2548.png"/>, making it as large as possible in order to make <img class="formulaInl" alt="$\nu$" src="form_1655.png"/> as small as possible. This gives us a picture like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.beta_cr.2d.png"/>
</div>
<p>Consequently, <img class="formulaInl" alt="$c_R=0.1$" src="form_2730.png"/> would appear to be the right value here. While this graph has been obtained for an exponent <img class="formulaInl" alt="$\alpha=1$" src="form_1557.png"/>, in the program we use <img class="formulaInl" alt="$\alpha=2$" src="form_2553.png"/> instead, and in that case one has to re-tune the parameter (and observe that <img class="formulaInl" alt="$c_R$" src="form_2548.png"/> appears in the numerator and not in the denominator). It turns out that <img class="formulaInl" alt="$c_R=1$" src="form_2731.png"/> works with <img class="formulaInl" alt="$\alpha=2$" src="form_2553.png"/>.</p>
<p><a class="anchor" id="LocallyconservativeStokesdiscretization"></a></p><h3>Locally conservative Stokes discretization </h3>
<p>The standard Taylor-Hood discretization for Stokes, using the <img class="formulaInl" alt="$Q_{k+1}^d \times Q_k$" src="form_2732.png"/> element, is globally conservative, i.e. <img class="formulaInl" alt="$\int_{\partial\Omega} \mathbf n \cdot \mathbf u_h = 0$" src="form_2733.png"/>. This can easily be seen: the weak form of the divergence equation reads <img class="formulaInl" alt="$(q_h, \textrm{div}\; \mathbf u_h)=0, \forall q_h\in Q_h$" src="form_2734.png"/>. Because the pressure space does contain the function <img class="formulaInl" alt="$q_h=1$" src="form_2735.png"/>, we get </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} 0 = (1, \textrm{div}\; \mathbf u_h)_\Omega = \int_\Omega \textrm{div}\; \mathbf u_h = \int_{\partial\Omega} \mathbf n \cdot \mathbf u_h \end{align*}" src="form_2736.png"/>
</p>
<p> by the divergence theorem. This property is important: if we want to use the velocity field <img class="formulaInl" alt="$u_h$" src="form_722.png"/> to transport along other quantities (such as the temperature in the current equations, but it could also be concentrations of chemical substances or entirely artificial tracer quantities) then the conservation property guarantees that the amount of the quantity advected remains constant.</p>
<p>That said, there are applications where this <em>global</em> property is not enough. Rather, we would like that it holds <em>locally</em>, on every cell. This can be achieved by using the space <img class="formulaInl" alt="$Q_{k+1}^d \times DGP_k$" src="form_2737.png"/> for discretization, where we have replaced the <em>continuous</em> space of tensor product polynomials of degree <img class="formulaInl" alt="$k$" src="form_44.png"/> for the pressure by the <em>discontinuous</em> space of the complete polynomials of the same degree. (Note that tensor product polynomials in 2d contain the functions <img class="formulaInl" alt="$1, x, y, xy$" src="form_2738.png"/>, whereas the complete polynomials only have the functions <img class="formulaInl" alt="$1,x,y$" src="form_2739.png"/>.) This space turns out to be stable for the Stokes equation.</p>
<p>Because the space is discontinuous, we can now in particular choose the test function <img class="formulaInl" alt="$q_h(\mathbf x)=\chi_K(\mathbf x)$" src="form_2740.png"/>, i.e. the characteristic function of cell <img class="formulaInl" alt="$K$" src="form_57.png"/>. We then get in a similar fashion as above </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} 0 = (q_h, \textrm{div}\; \mathbf u_h)_\Omega = (1, \textrm{div}\; \mathbf u_h)_K = \int_K \textrm{div}\; \mathbf u_h = \int_{\partial K} \mathbf n \cdot \mathbf u_h, \end{align*}" src="form_2741.png"/>
</p>
<p> showing the conservation property for cell <img class="formulaInl" alt="$K$" src="form_57.png"/>. This clearly holds for each cell individually.</p>
<p>There are good reasons to use this discretization. As mentioned above, this element guarantees conservation of advected quantities on each cell individually. A second advantage is that the pressure mass matrix we use as a preconditioner in place of the Schur complement becomes block diagonal and consequently very easy to invert. However, there are also downsides. For one, there are now more pressure variables, increasing the overall size of the problem, although this doesn't seem to cause much harm in practice. More importantly, though, the fact that now the divergence integrated over each cell is zero when it wasn't before does not guarantee that the divergence is pointwise smaller. In fact, as one can easily verify, the <img class="formulaInl" alt="$L_2$" src="form_608.png"/> norm of the divergence is <em>larger</em> for this than for the standard Taylor-Hood discretization. (However, both converge at the same rate to zero, since it is easy to see that <img class="formulaInl" alt="$\|\textrm{div}\; u_h\|= \|\textrm{div}\; (u-u_h)\|= \|\textrm{trace}\; \nabla (u-u_h)\|\le \|\nabla (u-u_h)\|={\cal O}(h^{k+2})$" src="form_2742.png"/>.) It is therefore not a priori clear that the error is indeed smaller just because we now have more degrees of freedom.</p>
<p>Given these considerations, it remains unclear which discretization one should prefer. Consequently, we leave that up to the user and make it a parameter in the input file which one to use.</p>
<p><a class="anchor" id="Higherordermappingsforcurvedboundaries"></a></p><h3>Higher order mappings for curved boundaries </h3>
<p>In the program, we will use a spherical shell as domain. This means that the inner and outer boundary of the domain are no longer "straight" (by which we usually mean that they are bilinear surfaces that can be represented by the <a class="el" href="classStraightBoundary.html">StraightBoundary</a> class). Rather, they are curved and it seems prudent to use a curved approximation in the program if we are already using higher order finite elements for the velocity. Consequently, we will introduce a member variable of type <a class="el" href="classMappingQ.html">MappingQ</a> that denotes such a mapping (<a class="el" href="step_10.html">step-10</a> and <a class="el" href="step_11.html">step-11</a> introduce such mappings for the first time) and that we will use in all computations on cells that are adjacent to the boundary. Since this only affects a relatively small fraction of cells, the additional effort is not very large and we will take the luxury of using a quartic mapping for these cells.</p>
<p><a class="anchor" id="Parallelizationonclusters"></a></p><h3>Parallelization on clusters </h3>
<p>Running convection codes in 3d with significant Rayleigh numbers requires a lot of computations &mdash; in the case of whole earth simulations on the order of one or several hundred million unknowns. This can obviously not be done with a single machine any more (at least not in 2010 when we started writing this code). Consequently, we need to parallelize it. Parallelization of scientific codes across multiple machines in a cluster of computers is almost always done using the Message Passing Interface (MPI). This program is no exception to that, and it follows the general spirit of the <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> programs in this though in practice it borrows more from <a class="el" href="step_40.html">step-40</a> in which we first introduced the classes and strategies we use when we want to <em>completely</em> distribute all computations, and <a class="el" href="step_55.html">step-55</a> that shows how to do that for <a class="el" href="group__vector__valued.html">vector-valued problems</a>: including, for example, splitting the mesh up into a number of parts so that each processor only stores its own share plus some ghost cells, and using strategies where no processor potentially has enough memory to hold the entries of the combined solution vector locally. The goal is to run this code on hundreds or maybe even thousands of processors, at reasonable scalability.</p>
<dl class="section note"><dt>Note</dt><dd>Even though it has a larger number, <a class="el" href="step_40.html">step-40</a> comes logically before the current program. The same is true for <a class="el" href="step_55.html">step-55</a>. You will probably want to look at these programs before you try to understand what we do here.</dd></dl>
<p>MPI is a rather awkward interface to program with. It is a semi-object oriented set of functions, and while one uses it to send data around a network, one needs to explicitly describe the data types because the MPI functions insist on getting the address of the data as <code>void*</code> objects rather than deducing the data type automatically through overloading or templates. We've already seen in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> how to avoid almost all of MPI by putting all the communication necessary into either the deal.II library or, in those programs, into PETSc. We'll do something similar here: like in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_55.html">step-55</a>, deal.II and the underlying p4est library are responsible for all the communication necessary for distributing the mesh, and we will let the Trilinos library (along with the wrappers in namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a>) deal with parallelizing the linear algebra components. We have already used Trilinos in <a class="el" href="step_31.html">step-31</a>, and will do so again here, with the difference that we will use its parallel capabilities.</p>
<p>Trilinos consists of a significant number of packages, implementing basic parallel linear algebra operations (the Epetra package), different solver and preconditioner packages, and on to things that are of less importance to deal.II (e.g., optimization, uncertainty quantification, etc). deal.II's Trilinos interfaces encapsulate many of the things Trilinos offers that are of relevance to PDE solvers, and provides wrapper classes (in namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a>) that make the Trilinos matrix, vector, solver and preconditioner classes look very much the same as deal.II's own implementations of this functionality. However, as opposed to deal.II's classes, they can be used in parallel if we give them the necessary information. As a consequence, there are two Trilinos classes that we have to deal with directly (rather than through wrappers), both of which are part of Trilinos' Epetra library of basic linear algebra and tool classes: </p><ul>
<li>
<p class="startli">The Epetra_Comm class is an abstraction of an MPI "communicator", i.e. it describes how many and which machines can communicate with each other. Each distributed object, such as a sparse matrix or a vector for which we may want to store parts on different machines, needs to have a communicator object to know how many parts there are, where they can be found, and how they can be accessed.</p>
<p>In this program, we only really use one communicator object &ndash; based on the MPI variable <code>MPI_COMM_WORLD</code> &ndash; that encompasses <em>all</em> processes that work together. It would be perfectly legitimate to start a process on <img class="formulaInl" alt="$N$" src="form_104.png"/> machines but only store vectors on a subset of these by producing a communicator object that only encompasses this subset of machines; there is really no compelling reason to do so here, however.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <a class="el" href="classIndexSet.html">IndexSet</a> class is used to describe which elements of a vector or which rows of a matrix should reside on the current machine that is part of a communicator. To create such an object, you need to know (i) the total number of elements or rows, (ii) the indices of the elements you want to store locally. We will set up these <code>partitioners</code> in the <code>BoussinesqFlowProblem::setup_dofs</code> function below and then hand it to every parallel object we create.</p>
<p class="endli">Unlike PETSc, Trilinos makes no assumption that the elements of a vector need to be partitioned into contiguous chunks. At least in principle, we could store all elements with even indices on one processor and all odd ones on another. That's not very efficient, of course, but it's possible. Furthermore, the elements of these partitionings do not necessarily be mutually exclusive. This is important because when postprocessing solutions, we need access to all locally relevant or at least the locally active degrees of freedom (see the module on <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> for a definition, as well as the discussion in <a class="el" href="step_40.html">step-40</a>). Which elements the Trilinos vector considers as locally owned is not important to us then. All we care about is that it stores those elements locally that we need. </p>
</li>
</ul>
<p>There are a number of other concepts relevant to distributing the mesh to a number of processors; you may want to take a look at the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module and <a class="el" href="step_40.html">step-40</a> or <a class="el" href="step_55.html">step-55</a> before trying to understand this program. The rest of the program is almost completely agnostic about the fact that we don't store all objects completely locally. There will be a few points where we have to limit loops over all cells to those that are locally owned, or where we need to distinguish between vectors that store only locally owned elements and those that store everything that is locally relevant (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">this glossary entry</a>), but by and large the amount of heavy lifting necessary to make the program run in parallel is well hidden in the libraries upon which this program builds. In any case, we will comment on these locations as we get to them in the program code.</p>
<p><a class="anchor" id="Parallelizationwithinindividualnodesofacluster"></a></p><h3>Parallelization within individual nodes of a cluster </h3>
<p>The second strategy to parallelize a program is to make use of the fact that most computers today have more than one processor that all have access to the same memory. In other words, in this model, we don't explicitly have to say which pieces of data reside where &ndash; all of the data we need is directly accessible and all we have to do is split <em>processing</em> this data between the available processors. We will then couple this with the MPI parallelization outlined above, i.e. we will have all the processors on a machine work together to, for example, assemble the local contributions to the global matrix for the cells that this machine actually "owns" but not for those cells that are owned by other machines. We will use this strategy for four kinds of operations we frequently do in this program: assembly of the Stokes and temperature matrices, assembly of the matrix that forms the Stokes preconditioner, and assembly of the right hand side of the temperature system.</p>
<p>All of these operations essentially look as follows: we need to loop over all cells for which <code>cell-&gt;subdomain_id()</code> equals the index our machine has within the communicator object used for all communication (i.e. <code>MPI_COMM_WORLD</code>, as explained above). The test we are actually going to use for this, and which describes in a concise way why we test this condition, is <code>cell-&gt;is_locally_owned()</code>. On each such cell we need to assemble the local contributions to the global matrix or vector, and then we have to copy each cell's contribution into the global matrix or vector. Note that the first part of this (the loop) defines a range of iterators on which something has to happen. The second part, assembly of local contributions is something that takes the majority of CPU time in this sequence of steps, and is a typical example of things that can be done in parallel: each cell's contribution is entirely independent of all other cells' contributions. The third part, copying into the global matrix, must not happen in parallel since we are modifying one object and so several threads can not at the same time read an existing matrix element, add their contribution, and write the sum back into memory without danger of producing a <a href="http://en.wikipedia.org/wiki/Race_condition">race condition</a>.</p>
<p>deal.II has a class that is made for exactly this workflow: <a class="el" href="namespaceWorkStream.html">WorkStream</a>, first discussed in <a class="el" href="step_9.html">step-9</a> and <a class="el" href="step_13.html">step-13</a>. Its use is also extensively documented in the module on <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> (in the section on <a class="el" href="group__threads.html#MTWorkStream">the WorkStream class</a>) and we won't repeat here the rationale and detailed instructions laid out there, though you will want to read through this module to understand the distinction between scratch space and per-cell data. Suffice it to mention that we need the following:</p>
<ul>
<li>An iterator range for those cells on which we are supposed to work. This is provided by the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> class which acts just like every other cell iterator in deal.II with the exception that it skips all cells that do not satisfy a particular predicate (i.e. a criterion that evaluates to true or false). In our case, the predicate is whether a cell has the correct subdomain id.</li>
<li>A function that does the work on each cell for each of the tasks identified above, i.e. functions that assemble the local contributions to Stokes matrix and preconditioner, temperature matrix, and temperature right hand side. These are the <code>BoussinesqFlowProblem::local_assemble_stokes_system</code>, <code>BoussinesqFlowProblem::local_assemble_stokes_preconditioner</code>, <code>BoussinesqFlowProblem::local_assemble_temperature_matrix</code>, and <code>BoussinesqFlowProblem::local_assemble_temperature_rhs</code> functions in the code below. These four functions can all have several instances running in parallel at the same time.</li>
<li>Functions that copy the result of the previous ones into the global object and that run sequentially to avoid race conditions. These are the <code>BoussinesqFlowProblem::copy_local_to_global_stokes_system</code>, <code>BoussinesqFlowProblem::copy_local_to_global_stokes_preconditioner</code>, <code>BoussinesqFlowProblem::copy_local_to_global_temperature_matrix</code>, and <code>BoussinesqFlowProblem::copy_local_to_global_temperature_rhs</code> functions.</li>
</ul>
<p>We will comment on a few more points in the actual code, but in general their structure should be clear from the discussion in <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a>.</p>
<p>The underlying technology for <a class="el" href="namespaceWorkStream.html">WorkStream</a> identifies "tasks" that need to be worked on (e.g. assembling local contributions on a cell) and schedules these tasks automatically to available processors. <a class="el" href="namespaceWorkStream.html">WorkStream</a> creates these tasks automatically, by splitting the iterator range into suitable chunks.</p>
<dl class="section note"><dt>Note</dt><dd>Using multiple threads within each MPI process only makes sense if you have fewer MPI processes running on each node of your cluster than there are processor cores on this machine. Otherwise, MPI will already keep your processors busy and you won't get any additional speedup from using threads. For example, if your cluster nodes have 8 cores as they often have at the time of writing this, and if your batch scheduler puts 8 MPI processes on each node, then using threads doesn't make the program any faster. Consequently, you probably want to either configure your deal.II without threads, or set the number of threads in <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> to 1 (third argument), or "export DEAL_II_NUM_THREADS=1" before running. That said, at the time of writing this, we only use the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class for assembling (parts of) linear systems, while 75% or more of the run time of the program is spent in the linear solvers that are not parallelized &mdash; in other words, the best we could hope is to parallelize the remaining 25%.</dd></dl>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase </h3>
<p>The setup for this program is mildly reminiscent of the problem we wanted to solve in the first place (see the introduction of <a class="el" href="step_31.html">step-31</a>): convection in the earth mantle. As a consequence, we choose the following data, all of which appears in the program in units of meters and seconds (the SI system) even if we list them here in other units. We do note, however, that these choices are essentially still only exemplary, and not meant to result in a completely realistic description of convection in the earth mantle: for that, more and more difficult physics would have to be implemented, and several other aspects are currently missing from this program as well. We will come back to this issue in the results section again, but state for now that providing a realistic description is a goal of the <em>Aspect</em> code in development at the time of writing this.</p>
<p>As a reminder, let us again state the equations we want to solve are these: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla \left( \frac{\eta}{L} \hat p\right) &amp;=&amp; \rho(T) \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma, \end{eqnarray*}" src="form_2743.png"/>
</p>
<p> augmented by boundary and initial conditions. We then have to choose data for the following quantities: </p><ul>
<li>
<p class="startli">The domain is an annulus (in 2d) or a spherical shell (in 3d) with inner and outer radii that match that of the earth: the total radius of the earth is 6371km, with the mantle starting at a depth of around 35km (just under the solid earth <a href="http://en.wikipedia.org/wiki/Crust_(geology)" target="_top">crust</a> composed of <a href="http://en.wikipedia.org/wiki/Continental_crust" target="_top">continental</a> and <a href="http://en.wikipedia.org/wiki/Oceanic_crust" target="_top">oceanic plates</a>) to a depth of 2890km (where the <a href="http://en.wikipedia.org/wiki/Outer_core" target="_top">outer earth core</a> starts). The radii are therefore <img class="formulaInl" alt="$R_0=(6371-2890)\text{km}, R_1=(6371-35)\text{km}$" src="form_2744.png"/>. This domain is conveniently generated using the <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> function, and we use a <a class="el" href="classHyperShellBoundary.html">HyperShellBoundary</a> objects for the inner and outer boundary.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">At the interface between crust and mantle, the temperature is between 500 and 900 degrees Celsius, whereas at its bottom it is around 4000 degrees Celsius (see, for example, <a href="http://en.wikipedia.org/wiki/Mantle_(geology)" target="_top">this Wikipedia entry</a>). In Kelvin, we therefore choose <img class="formulaInl" alt="$T_0=(4000+273)\text{K}$" src="form_2745.png"/>, <img class="formulaInl" alt="$T_1=(500+273)\text{K}$" src="form_2746.png"/> as boundary conditions at the inner and outer edge.</p>
<p>In addition to this, we also have to specify some initial conditions for the temperature field. The real temperature field of the earth is quite complicated as a consequence of the convection that has been going on for more than four billion years &ndash; in fact, it is the properties of this temperature distribution that we want to explore with programs like this. As a consequence, we don't really have anything useful to offer here, but we can hope that if we start with something and let things run for a while that the exact initial conditions don't matter that much any more &mdash; as is in fact suggested by looking at the pictures shown in the <a href="#Results">results section below</a>. The initial temperature field we use here is given in terms of the radius by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} s &amp;= \frac{\|\mathbf x\|-R_0}{R_1-R_0}, \\ \varphi &amp;= \arctan \frac{y}{x}, \\ \tau &amp;= s + \frac 15 s(1-s) \sin(6\varphi) q(z), \\ T(\mathbf x) &amp;= T_0(1-\tau) + T_1\tau, \end{align*}" src="form_2747.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} q(z) = \left\{ \begin{array}{ll} 1 &amp; \text{in 2d} \\ \max\{0, \cos(\pi |z/R_1|)\} &amp; \text{in 3d} \end{array} \right. . \end{align*}" src="form_2748.png"/>
</p>
<p> This complicated function is essentially a perturbation of a linear profile between the inner and outer temperatures. In 2d, the function <img class="formulaInl" alt="$\tau=\tau(\mathbf x)$" src="form_2749.png"/> looks like this (I got the picture from <a href="http://www.wolframalpha.com/input/?i=plot+%28sqrt%28x^2%2By^2%29%2B0.2*%28sqrt%28x^2%2By^2%29*%281-sqrt%28x^2%2By^2%29%29*sin%286*atan2%28x%2Cy%29%29%29%2C+x%3D-1+to+1%2C+y%3D-1+to+1">this page</a>):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d-initial.png"/>
</div>
<p>The point of this profile is that if we had used <img class="formulaInl" alt="$s$" src="form_308.png"/> instead of <img class="formulaInl" alt="$\tau$" src="form_1599.png"/> in the definition of <img class="formulaInl" alt="$T(\mathbf x)$" src="form_2750.png"/> then it would simply be a linear interpolation. <img class="formulaInl" alt="$\tau$" src="form_1599.png"/> has the same function values as <img class="formulaInl" alt="$s$" src="form_308.png"/> on the inner and outer boundaries (zero and one, respectively), but it stretches the temperature profile a bit depending on the angle and the <img class="formulaInl" alt="$z$" src="form_11.png"/> value in 3d, producing an angle-dependent perturbation of the linearly interpolating field. We will see in the results section that this is an entirely unphysical temperature field (though it will make for interesting images) as the equilibrium state for the temperature will be an almost constant temperature with boundary layers at the inner and outer boundary.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The right hand side of the temperature equation contains the rate of internal heating <img class="formulaInl" alt="$\gamma$" src="form_932.png"/>. The earth does heat naturally through several mechanisms: radioactive decay, chemical separation (heavier elements sink to the bottom, lighter ones rise to the top; the countercurrents dissipate energy equal to the loss of potential energy by this separation process); heat release by crystallization of liquid metal as the solid inner core of the earth grows; and heat dissipation from viscous friction as the fluid moves.</p>
<p>Chemical separation is difficult to model since it requires modeling mantle material as multiple phases; it is also a relatively small effect. Crystallization heat is even more difficult since it is confined to areas where temperature and pressure allow for phase changes, i.e. a discontinuous process. Given the difficulties in modeling these two phenomena, we will neglect them.</p>
<p>The other two are readily handled and, given the way we scaled the temperature equation, lead to the equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma(\mathbf x) = \frac{\rho q+2\eta \varepsilon(\mathbf u):\varepsilon(\mathbf u)} {\rho c_p}, \]" src="form_2751.png"/>
</p>
<p> where <img class="formulaInl" alt="$q$" src="form_171.png"/> is the radiogenic heating in <img class="formulaInl" alt="$\frac{W}{kg}$" src="form_2752.png"/>, and the second term in the enumerator is viscous friction heating. <img class="formulaInl" alt="$\rho$" src="form_1591.png"/> is the density and <img class="formulaInl" alt="$c_p$" src="form_2753.png"/> is the specific heat. The literature provides the following approximate values: <img class="formulaInl" alt="$c_p=1250 \frac{J}{kg\; K}, q=7.4\cdot 10^{-12}\frac{W}{kg}$" src="form_2754.png"/>. The other parameters are discussed elsewhere in this section.</p>
<p>We neglect one internal heat source, namely adiabatic heating here, which will lead to a surprising temperature field. This point is commented on in detail in the results section below.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For the velocity we choose as boundary conditions <img class="formulaInl" alt="$\mathbf{v}=0$" src="form_2755.png"/> at the inner radius (i.e. the fluid sticks to the earth core) and <img class="formulaInl" alt="$\mathbf{n}\cdot\mathbf{v}=0$" src="form_2756.png"/> at the outer radius (i.e. the fluid flows tangentially along the bottom of the earth crust). Neither of these is physically overly correct: certainly, on both boundaries, fluids can flow tangentially, but they will incur a shear stress through friction against the medium at the other side of the interface (the metallic core and the crust, respectively). Such a situation could be modeled by a Robin-type boundary condition for the tangential velocity; in either case, the normal (vertical) velocity would be zero, although even that is not entirely correct since continental plates also have vertical motion (see, for example, the phenomenon of <a href="http://en.wikipedia.org/wiki/Postglacial_rebound">post-glacial rebound</a>). But to already make things worse for the tangential velocity, the medium on the other side is in motion as well, so the shear stress would, in the simplest case, be proportional to the <em>velocity difference</em>, leading to a boundary condition of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathbf{n}\cdot [2\eta \varepsilon(\mathbf v)] &amp;= s \mathbf{n} \times [\mathbf v - \mathbf v_0], \\ \mathbf{n} \cdot \mathbf v &amp;= 0, \end{align*}" src="form_2757.png"/>
</p>
<p> with a proportionality constant <img class="formulaInl" alt="$s$" src="form_308.png"/>. Rather than going down this route, however, we go with the choice of zero (stick) and tangential flow boundary conditions.</p>
<p>As a side note of interest, we may also have chosen tangential flow conditions on both inner and outer boundary. That has a significant drawback, however: it leaves the velocity not uniquely defined. The reason is that all velocity fields <img class="formulaInl" alt="$\hat{\mathbf v}$" src="form_2758.png"/> that correspond to a solid body rotation around the center of the domain satisfy <img class="formulaInl" alt="$\mathrm{div}\; \varepsilon(\hat{\mathbf v})=0, \mathrm{div} \;\hat{\mathbf v} = 0$" src="form_2759.png"/>, and <img class="formulaInl" alt="$\mathbf{n} \cdot \hat{\mathbf v} = 0$" src="form_2760.png"/>. As a consequence, if <img class="formulaInl" alt="$\mathbf v$" src="form_221.png"/> satisfies equations and boundary conditions, then so does <img class="formulaInl" alt="$\mathbf v + \hat{\mathbf v}$" src="form_2761.png"/>. That's certainly not a good situation that we would like to avoid. The traditional way to work around this is to pick an arbitrary point on the boundary and call this your fixed point by choosing the velocity to be zero in all components there. (In 3d one has to choose two points.) Since this program isn't meant to be too realistic to begin with, we avoid this complication by simply fixing the velocity along the entire interior boundary.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">To first order, the gravity vector always points downward. The question for a body as big as the earth is just: where is "up". The naive answer of course is "radially inward, towards the center of the earth". So at the surface of the earth, we have </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf g = -9.81 \frac{\text{m}}{\text{s}^2} \frac{\mathbf x}{\|\mathbf x\|}, \]" src="form_2762.png"/>
</p>
<p> where <img class="formulaInl" alt="$9.81 \frac{\text{m}}{\text{s}^2}$" src="form_2763.png"/> happens to be the average gravity acceleration at the earth surface. But in the earth interior, the question becomes a bit more complicated: at the (bary-)center of the earth, for example, you have matter pulling equally hard in all directions, and so <img class="formulaInl" alt="$\mathbf g=0$" src="form_2764.png"/>. In between, the net force is described as follows: let us define the <a href="http://en.wikipedia.org/wiki/Potential_energy#Gravitational_potential_energy" target="_top">gravity potential</a> by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \varphi(\mathbf x) = \int_{\text{earth}} -G \frac{\rho(\mathbf y)}{\|\mathbf x-\mathbf y\|} \ \text{d}y, \]" src="form_2765.png"/>
</p>
<p> then <img class="formulaInl" alt="$\mathbf g(\mathbf x) = -\nabla \varphi(\mathbf x)$" src="form_2766.png"/>. If we assume that the density <img class="formulaInl" alt="$\rho$" src="form_1591.png"/> is constant throughout the earth, we can produce an analytical expression for the gravity vector (don't try to integrate above equation somehow &ndash; it leads to elliptic integrals; a simpler way is to notice that <img class="formulaInl" alt="$-\Delta\varphi(\mathbf x) = -4\pi G \rho \chi_{\text{earth}}(\mathbf x)$" src="form_2767.png"/> and solving this partial differential equation in all of <img class="formulaInl" alt="${\mathbb R}^3$" src="form_865.png"/> exploiting the radial symmetry): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf g(\mathbf x) = \left\{ \begin{array}{ll} -\frac{4}{3}\pi G \rho \|\mathbf x\| \frac{\mathbf x}{\|\mathbf x\|} &amp; \text{for} \ \|\mathbf x\|&lt;R_1, \\ -\frac{4}{3}\pi G \rho R^3 \frac{1}{\|\mathbf x\|^2} \frac{\mathbf x}{\|\mathbf x\|} &amp; \text{for} \ \|\mathbf x\|\ge R_1. \end{array} \right. \]" src="form_2768.png"/>
</p>
<p> The factor <img class="formulaInl" alt="$-\frac{\mathbf x}{\|\mathbf x\|}$" src="form_2769.png"/> is the unit vector pointing radially inward. Of course, within this problem, we are only interested in the branch that pertains to within the earth, i.e. <img class="formulaInl" alt="$\|\mathbf x\|&lt;R_1$" src="form_2770.png"/>. We would therefore only consider the expression </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf g(\mathbf x) = -\frac{4}{3}\pi G \rho \|\mathbf x\| \frac{\mathbf x}{\|\mathbf x\|} = -\frac{4}{3}\pi G \rho \mathbf x = - 9.81 \frac{\mathbf x}{R_1} \frac{\text{m}}{\text{s}^2}, \]" src="form_2771.png"/>
</p>
<p> where we can infer the last expression because we know Earth's gravity at the surface (where <img class="formulaInl" alt="$\|x\|=R_1$" src="form_2772.png"/>).</p>
<p>One can derive a more general expression by integrating the differential equation for <img class="formulaInl" alt="$\varphi(r)$" src="form_2773.png"/> in the case that the density distribution is radially symmetric, i.e. <img class="formulaInl" alt="$\rho(\mathbf x)=\rho(\|\mathbf x\|)=\rho(r)$" src="form_2774.png"/>. In that case, one would get </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \varphi(r) = 4\pi G \int_0^r \frac 1{s^2} \int_0^s t^2 \rho(t) \; dt \; ds. \]" src="form_2775.png"/>
</p>
<p>There are two problems with this, however: (i) The Earth is not homogeneous, i.e. the density <img class="formulaInl" alt="$\rho$" src="form_1591.png"/> depends on <img class="formulaInl" alt="$\mathbf x$" src="form_751.png"/>; in fact it is not even a function that only depends on the radius <img class="formulaInl" alt="$r=\|\mathbf x\|$" src="form_2776.png"/>. In reality, gravity therefore does not always decrease as we get deeper: because the earth core is so much denser than the mantle, gravity actually peaks at around <img class="formulaInl" alt="$10.7 \frac{\text{m}}{\text{s}^2}$" src="form_2777.png"/> at the core mantle boundary (see <a href="http://en.wikipedia.org/wiki/Earth&apos;s_gravity" target="_top">this article</a>). (ii) The density, and by consequence the gravity vector, is not even constant in time: after all, the problem we want to solve is the time dependent upwelling of hot, less dense material and the downwelling of cold dense material. This leads to a gravity vector that varies with space and time, and does not always point straight down.</p>
<p>In order to not make the situation more complicated than necessary, we could use the approximation that at the inner boundary of the mantle, gravity is <img class="formulaInl" alt="$10.7 \frac{\text{m}}{\text{s}^2}$" src="form_2777.png"/> and at the outer boundary it is <img class="formulaInl" alt="$9.81 \frac{\text{m}}{\text{s}^2}$" src="form_2763.png"/>, in each case pointing radially inward, and that in between gravity varies linearly with the radial distance from the earth center. That said, it isn't that hard to actually be slightly more realistic and assume (as we do below) that the earth mantle has constant density. In that case, the equation above can be integrated and we get an expression for <img class="formulaInl" alt="$\|\mathbf{g}\|$" src="form_2778.png"/> where we can fit constants to match the gravity at the top and bottom of the earth mantle to obtain </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \|\mathbf{g}\| = 1.245\cdot 10^{-6} \frac{1}{\textrm{s}^2} r + 7.714\cdot 10^{13} \frac{\textrm{m}^3}{\textrm{s}^2}\frac{1}{r^2}. \]" src="form_2779.png"/>
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The density of the earth mantle varies spatially, but not by very much. <img class="formulaInl" alt="$\rho_{\text{ref}}=3300 \frac{\text{kg}}{\text{m}^3}$" src="form_2780.png"/> is a relatively good average value for the density at reference temperature <img class="formulaInl" alt="$T_{\text{ref}}=293$" src="form_2781.png"/> Kelvin.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The thermal expansion coefficient <img class="formulaInl" alt="$\beta$" src="form_414.png"/> also varies with depth (through its dependence on temperature and pressure). Close to the surface, it appears to be on the order of <img class="formulaInl" alt="$\beta=45\cdot 10^{-6} \frac 1{\text{K}}$" src="form_2782.png"/>, whereas at the core mantle boundary, it may be closer to <img class="formulaInl" alt="$\beta=10\cdot 10^{-6} \frac 1{\text{K}}$" src="form_2783.png"/>. As a reasonable value, let us choose <img class="formulaInl" alt="$\beta=2\cdot 10^{-5} \frac 1{\text{K}}$" src="form_2784.png"/>. The density as a function of temperature is then <img class="formulaInl" alt="$\rho(T)=[1-\beta(T-T_{\text{ref}})]\rho_{\text{ref}}$" src="form_2785.png"/>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The second to last parameter we need to specify is the viscosity <img class="formulaInl" alt="$\eta$" src="form_1145.png"/>. This is a tough one, because rocks at the temperatures and pressure typical for the earth mantle flow so slowly that the viscosity can not be determined accurately in the laboratory. So how do we know about the viscosity of the mantle? The most commonly used route is to consider that during and after ice ages, ice shields form and disappear on time scales that are shorter than the time scale of flow in the mantle. As a consequence, continents slowly sink into the earth mantle under the added weight of an ice shield, and they rise up again slowly after the ice shield has disappeared again (this is called <a href="http://en.wikipedia.org/wiki/Postglacial_rebound" target="_top"><em>postglacial rebound</em></a>). By measuring the speed of this rebound, we can infer the viscosity of the material that flows into the area vacated under the rebounding continental plates.</p>
<p>Using this technique, values around <img class="formulaInl" alt="$\eta=10^{21} \text{Pa\; s} = 10^{21} \frac{\text{N\; s}}{\text{m}^2} = 10^{21} \frac{\text{kg}}{\text{m\; s}}$" src="form_2786.png"/> have been found as the most likely, though the error bar on this is at least one order of magnitude.</p>
<p>While we will use this value, we again have to caution that there are many physical reasons to assume that this is not the correct value. First, it should really be made dependent on temperature: hotter material is most likely to be less viscous than colder material. In reality, however, the situation is even more complex. Most rocks in the mantle undergo phase changes as temperature and pressure change: depending on temperature and pressure, different crystal configurations are thermodynamically favored over others, even if the chemical composition of the mantle were homogeneous. For example, the common mantle material MgSiO<sub>3</sub> exists in its <a href="http://en.wikipedia.org/wiki/Perovskite_(structure)" target="_top">perovskite structure</a> throughout most of the mantle, but in the lower mantle the same substance is stable only as <a href="http://en.wikipedia.org/wiki/Postperovskite" targe="_top">post-perovskite</a>. Clearly, to compute realistic viscosities, we would not only need to know the exact chemical composition of the mantle and the viscosities of all materials, but we would also have to compute the thermodynamically most stable configurations for all materials at each quadrature point. This is at the time of writing this program not a feasible suggestion.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Our last material parameter is the thermal diffusivity <img class="formulaInl" alt="$\kappa$" src="form_2495.png"/>, which is defined as <img class="formulaInl" alt="$\kappa=\frac{k}{\rho c_p}$" src="form_2787.png"/> where <img class="formulaInl" alt="$k$" src="form_44.png"/> is the thermal conductivity, <img class="formulaInl" alt="$\rho$" src="form_1591.png"/> the density, and <img class="formulaInl" alt="$c_p$" src="form_2753.png"/> the specific heat. For this, the literature indicates that it increases from around <img class="formulaInl" alt="$0.7$" src="form_2788.png"/> in the upper mantle to around <img class="formulaInl" alt="$1.7 \frac{\text{mm}^2}{\text{s}}$" src="form_2789.png"/> in the lower mantle, though the exact value is not really all that important: heat transport through convection is several orders of magnitude more important than through thermal conduction. It may be of interest to know that perovskite, the most abundant material in the earth mantle, appears to become transparent at pressures above around 120 GPa (see, for example, J. Badro et al., Science 305, 383-386 (2004)); in the lower mantle, it may therefore be that heat transport through radiative transfer is more efficient than through thermal conduction.</p>
<p class="endli">In view of these considerations, let us choose <img class="formulaInl" alt="$\kappa=1 \frac{\text{mm}^2}{\text{s}} =10^{-6} \frac{\text{m}^2}{\text{s}}$" src="form_2790.png"/> for the purpose of this program. </p>
</li>
</ul>
<p>All of these pieces of equation data are defined in the program in the <code>EquationData</code> namespace. When run, the program produces long-term maximal velocities around 10-40 centimeters per year (see the results section below), approximately the physically correct order of magnitude. We will set the end time to 1 billion years.</p>
<dl class="section note"><dt>Note</dt><dd>The choice of the constants and material parameters above follows in large part the comprehensive book "Mantle Convection in the Earth and Planets,
Part 1" by G. Schubert and D. L. Turcotte and P. Olson (Cambridge, 2001). It contains extensive discussion of ways to make the program more realistic.</dd></dl>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details </h3>
<p>Compared to <a class="el" href="step_31.html">step-31</a>, this program has a number of noteworthy differences:</p>
<ul>
<li>The <code>EquationData</code> namespace is significantly larger, reflecting the fact that we now have much more physics to deal with. That said, most of this additional physical detail is rather self-contained in functions in this one namespace, and does not proliferate throughout the rest of the program.</li>
<li>Of more obvious visibility is the fact that we have put a good number of parameters into an input file handled by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class (see, for example, <a class="el" href="step_29.html">step-29</a>, for ways to set up run-time parameter files with this class). This often makes sense when one wants to avoid re-compiling the program just because one wants to play with a single parameter (think, for example, of parameter studies determining the best values of the stabilization constants discussed above), in particular given that it takes a nontrivial amount of time to re-compile programs of the current size. To just give an overview of the kinds of parameters we have moved from fixed values into the input file, here is a listing of a typical <code>step-32.prm</code> file : <div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line"><span class="preprocessor"># The end time of the simulation in years.</span></div><div class="line"><span class="keyword">set</span> End time                            = 1e8</div><div class="line"></div><div class="line"><span class="preprocessor"># Whether graphical output is to be generated or not. You may not want to get</span></div><div class="line"><span class="preprocessor"># graphical output if the number of processors is large.</span></div><div class="line"><span class="keyword">set</span> Generate graphical output           = <span class="keyword">false</span></div><div class="line"></div><div class="line"><span class="preprocessor"># The number of adaptive refinement steps performed after initial global</span></div><div class="line"><span class="preprocessor"># refinement.</span></div><div class="line"><span class="keyword">set</span> Initial adaptive refinement         = 1</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of global refinement steps performed on the initial coarse mesh,</span></div><div class="line"><span class="preprocessor"># before the problem is first solved there.</span></div><div class="line"><span class="keyword">set</span> Initial global refinement           = 1</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of time steps between each generation of graphical output files.</span></div><div class="line"><span class="keyword">set</span> Time steps between graphical output = 50</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of time steps after which the mesh is to be adapted based on</span></div><div class="line"><span class="preprocessor"># computed error indicators.</span></div><div class="line"><span class="keyword">set</span> Time steps between mesh refinement  = 10</div><div class="line"></div><div class="line"></div><div class="line">subsection Discretization</div><div class="line"><span class="preprocessor">  # The polynomial degree to use for the velocity variables in the Stokes</span></div><div class="line"><span class="preprocessor">  # system.</span></div><div class="line">  <span class="keyword">set</span> Stokes velocity polynomial degree       = 2</div><div class="line"></div><div class="line"><span class="preprocessor">  # The polynomial degree to use for the temperature variable.</span></div><div class="line">  <span class="keyword">set</span> Temperature polynomial degree           = 2</div><div class="line"></div><div class="line"><span class="preprocessor">  # Whether to use a Stokes discretization that is locally conservative at the</span></div><div class="line"><span class="preprocessor">  # expense of a larger number of degrees of freedom, or to go with a cheaper</span></div><div class="line"><span class="preprocessor">  # discretization that does not locally conserve mass (although it is</span></div><div class="line"><span class="preprocessor">  # globally conservative.</span></div><div class="line">  <span class="keyword">set</span> Use locally conservative discretization = <span class="keyword">true</span></div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line">subsection Stabilization parameters</div><div class="line"><span class="preprocessor">  # The exponent in the entropy viscosity stabilization.</span></div><div class="line">  <span class="keyword">set</span> alpha = 2</div><div class="line"></div><div class="line"><span class="preprocessor">  # The beta factor in the artificial viscosity stabilization. An appropriate</span></div><div class="line"><span class="preprocessor">  # value for 2d is 0.052 and 0.078 for 3d.</span></div><div class="line">  <span class="keyword">set</span> beta  = 0.078</div><div class="line"></div><div class="line">  # The c_R factor in the entropy viscosity stabilization.</div><div class="line">  <span class="keyword">set</span> c_R   = 0.5</div><div class="line">end</div></div><!-- fragment --></li>
<li>There are, obviously, a good number of changes that have to do with the fact that we want to run our program on a possibly very large number of machines. Although one may suspect that this requires us to completely re-structure our code, that isn't in fact the case (although the classes that implement much of this functionality in deal.II certainly look very different from an implementation viewpoint, but this doesn't reflect in their public interface). Rather, the changes are mostly subtle, and the overall structure of the main class is pretty much unchanged. That said, the devil is in the detail: getting parallel computing right, without deadlocks, ensuring that the right data is available at the right place (see, for example, the discussion on fully distributed vectors vs. vectors with ghost elements), and avoiding bottlenecks is difficult and discussions on this topic will appear in a good number of places in this program.</li>
</ul>
<p><a class="anchor" id="Outlook"></a></p><h3>Outlook </h3>
<p>This is a tutorial program. That means that at least most of its focus needs to lie on demonstrating ways of using deal.II and associated libraries, and not diluting this teaching lesson by focusing overly much on physical details. Despite the lengthy section above on the choice of physical parameters, the part of the program devoted to this is actually quite short and self contained.</p>
<p>That said, both <a class="el" href="step_31.html">step-31</a> and the current <a class="el" href="step_32.html">step-32</a> have not come about by chance but are certainly meant as wayposts along the path to a more comprehensive program that will simulate convection in the earth mantle. We call this code <em>Aspect</em> (short for <em>Advanced Solver for Problems in Earth's ConvecTion</em>); its development is funded by the <a href="http://www.geodynamics.org">Computational Infrastructure in Geodynamics</a> initiative with support from the National Science Foundation. We hope to release this code not long after this tutorial program will officially be released as part of deal.II 7.1. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first task as usual is to include the functionality of these well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/work_stream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_bicgstab.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_gmres.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_solver.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/filtered_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgp.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/solution_transfer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;locale&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div></div><!-- fragment --><p>This is the only include file that is new: It introduces the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> equivalent of the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class to take a solution from on mesh to the next one upon mesh refinement, but in the case of parallel distributed triangulations:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/solution_transfer.h&gt;</span></div></div><!-- fragment --><p>The following classes are used in parallel distributed computations and have all already been introduced in <a class="el" href="step_40.html">step-40</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div></div><!-- fragment --><p>The next step is like in all previous tutorial programs: We put everything into a namespace of its own and then import the deal.II classes and functions into it:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step32</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>In the following namespace, we define the various pieces of equation data that describe the problem. This corresponds to the various aspects of making the problem at least slightly realistic and that were exhaustively discussed in the description of the testcase in the introduction.</p>
<p>We start with a few coefficients that have constant values (the comment after the value indicates its physical units):</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> eta                   = 1e21;    / * Pa s       * /</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> kappa                 = 1e-6;    / * m^2 / s    * /</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> reference_density     = 3300;    / * kg / m^3   * /</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> reference_temperature = 293;     / * K          * /</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> expansion_coefficient = 2e-5;    / * 1/K        * /</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> specific_heat         = 1250;    / * J / K / kg * /</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> radiogenic_heating    = 7.4e-12; / * W / kg     * /</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R0      = 6371000.-2890000.;     / * m          * /</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R1      = 6371000.-  35000.;     / * m          * /</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> T0      = 4000+273;              / * K          * /</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> T1      =  700+273;              / * K          * /</div></div><!-- fragment --><p>The next set of definitions are for functions that encode the density as a function of temperature, the gravity vector, and the initial values for the temperature. Again, all of these (along with the values they compute) are discussed in the introduction:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> density (<span class="keyword">const</span> <span class="keywordtype">double</span> temperature)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (reference_density *</div><div class="line">          (1 - expansion_coefficient * (temperature -</div><div class="line">                                        reference_temperature)));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> gravity_vector (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div><div class="line">  <span class="keywordflow">return</span> -(1.245e-6 * r + 7.714e13/r/r) * p / r;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TemperatureInitialValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">TemperatureInitialValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h = R1-R0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> s = (r-R0)/h;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> q = (dim==3)?std::max(0.0,cos(<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*abs(p(2)/R1))):1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> phi   = std::atan2(p(0),p(1));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> tau = s</div><div class="line">                     +</div><div class="line">                     0.2 * s * (1-s) * std::sin(6*phi) * q;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> T0*(1.0-tau) + T1*tau;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">TemperatureInitialValues&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;this-&gt;<a class="code" href="classFunction.html#aa568b98591fc2bda09b28539789aef7d">n_components</a>; ++c)</div><div class="line">    values(c) = TemperatureInitialValues&lt;dim&gt;::value (p, c);</div><div class="line">}</div></div><!-- fragment --><p>As mentioned in the introduction we need to rescale the pressure to avoid the relative ill-conditioning of the momentum and mass conservation equations. The scaling factor is <img class="formulaInl" alt="$\frac{\eta}{L}$" src="form_2697.png"/> where <img class="formulaInl" alt="$L$" src="form_2323.png"/> was a typical length scale. By experimenting it turns out that a good length scale is the diameter of plumes, which is around 10 km:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> pressure_scaling = eta / 10000;</div></div><!-- fragment --><p>The final number in this namespace is a constant that denotes the number of seconds per (average, tropical) year. We use this only when generating screen output: internally, all computations of this program happen in SI units (kilogram, meter, seconds) but writing geological times in seconds yields numbers that one can't relate to reality, and so we convert to years using the factor defined here:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> year_in_seconds  = 60*60*24*365.2425;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PreconditioningtheStokessystem"></a> </p><h3>Preconditioning the Stokes system</h3>
<p>This namespace implements the preconditioner. As discussed in the introduction, this preconditioner differs in a number of key portions from the one used in <a class="el" href="step_31.html">step-31</a>. Specifically, it is a right preconditioner, implementing the matrix </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \left(\begin{array}{cc}A^{-1} &amp; B^T \\0 &amp; S^{-1} \end{array}\right) \end{align*}" src="form_2791.png"/>
</p>
<p> where the two inverse matrix operations are approximated by linear solvers or, if the right flag is given to the constructor of this class, by a single AMG V-cycle for the velocity block. The three code blocks of the <code>vmult</code> function implement the multiplications with the three blocks of this preconditioner matrix and should be self explanatory if you have read through <a class="el" href="step_31.html">step-31</a> or the discussion of composing solvers in <a class="el" href="step_20.html">step-20</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">                              <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;Spre,</div><div class="line">                              <span class="keyword">const</span> PreconditionerTypeMp                &amp;Mppreconditioner,</div><div class="line">                              <span class="keyword">const</span> PreconditionerTypeA                 &amp;Apreconditioner,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">bool</span>                                 do_solve_A)</div><div class="line">      :</div><div class="line">      stokes_matrix     (&amp;S),</div><div class="line">      stokes_preconditioner_matrix     (&amp;Spre),</div><div class="line">      mp_preconditioner (Mppreconditioner),</div><div class="line">      a_preconditioner  (Apreconditioner),</div><div class="line">      do_solve_A        (do_solve_A)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult (<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>       &amp;dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> utmp(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, 1e-6 * src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line"></div><div class="line">        <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">        solver.solve(stokes_preconditioner_matrix-&gt;block(1,1),</div><div class="line">                     dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                     mp_preconditioner);</div><div class="line"></div><div class="line">        dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1) *= -1.0;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        stokes_matrix-&gt;block(0,1).vmult(utmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">        utmp*=-1.0;</div><div class="line">        utmp.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (do_solve_A == <span class="keyword">true</span>)</div><div class="line">        {</div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, utmp.l2_norm()*1e-2);</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1SolverCG.html">TrilinosWrappers::SolverCG</a> solver(solver_control);</div><div class="line">          solver.solve(stokes_matrix-&gt;block(0,0), dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp,</div><div class="line">                       a_preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        a_preconditioner.vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a> stokes_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a> stokes_preconditioner_matrix;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeMp &amp;mp_preconditioner;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA  &amp;a_preconditioner;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> do_solve_A;</div><div class="line">  };</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Definitionofassemblydatastructures"></a> </p><h3>Definition of assembly data structures</h3>
<p>As described in the introduction, we will use the <a class="el" href="namespaceWorkStream.html">WorkStream</a> mechanism discussed in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> module to parallelize operations among the processors of a single machine. The <a class="el" href="namespaceWorkStream.html">WorkStream</a> class requires that data is passed around in two kinds of data structures, one for scratch data and one to pass data from the assembly function to the function that copies local contributions into global objects.</p>
<p>The following namespace (and the two sub-namespaces) contains a collection of data structures that serve this purpose, one pair for each of the four operations discussed in the introduction that we will want to parallelize. Each assembly routine gets two sets of data: a Scratch array that collects all the classes and arrays that are used for the calculation of the cell contribution, and a CopyData array that keeps local matrices and vectors which will be written into the global matrix. Whereas CopyData is a container for the final data that is written into the global matrices and vector (and, thus, absolutely necessary), the Scratch arrays are merely there for performance reasons &mdash; it would be much more expensive to set up a <a class="el" href="classFEValues.html">FEValues</a> object on each cell, than creating it only once and updating some derivative data.</p>
<p><a class="el" href="step_31.html">step-31</a> had four assembly routines: One for the preconditioner matrix of the Stokes system, one for the Stokes matrix and right hand side, one for the temperature matrices and one for the right hand side of the temperature equation. We here organize the scratch arrays and CopyData objects for each of those four assembly components using a <code>struct</code> environment (since we consider these as temporary objects we pass around, rather than classes that implement functionality of their own, though this is a more subjective point of view to distinguish between <code>struct</code>s and <code>class</code>es).</p>
<p>Regarding the Scratch objects, each struct is equipped with a constructor that creates an <a class="el" href="classFEValues.html">FEValues</a> object using the <a class="el" href="classFiniteElement.html">FiniteElement</a>, <a class="el" href="classQuadrature.html">Quadrature</a>, <a class="el" href="classMapping.html">Mapping</a> (which describes the interpolation of curved boundaries), and <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> instances. Moreover, we manually implement a copy constructor (since the <a class="el" href="classFEValues.html">FEValues</a> class is not copyable by itself), and provide some additional vector fields that are used to hold intermediate data during the computation of local contributions.</p>
<p>Let us start with the scratch arrays and, specifically, the one used for assembly of the Stokes preconditioner:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Assembly</div><div class="line">{</div><div class="line">  <span class="keyword">namespace </span>Scratch</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">    {</div><div class="line">      StokesPreconditioner (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;stokes_quadrature,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags);</div><div class="line"></div><div class="line">      StokesPreconditioner (<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               stokes_fe_values;</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;2,dim&gt; &gt; grad_phi_u;</div><div class="line">      std::vector&lt;double&gt;         phi_p;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::</div><div class="line">    StokesPreconditioner (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;stokes_quadrature,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">      :</div><div class="line">      stokes_fe_values (mapping, stokes_fe, stokes_quadrature,</div><div class="line">                        update_flags),</div><div class="line">      grad_phi_u (stokes_fe.dofs_per_cell),</div><div class="line">      phi_p (stokes_fe.dofs_per_cell)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::</div><div class="line">    StokesPreconditioner (<span class="keyword">const</span> StokesPreconditioner &amp;scratch)</div><div class="line">      :</div><div class="line">      stokes_fe_values (scratch.stokes_fe_values.get_mapping(),</div><div class="line">                        scratch.stokes_fe_values.get_fe(),</div><div class="line">                        scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                        scratch.stokes_fe_values.get_update_flags()),</div><div class="line">      grad_phi_u (scratch.grad_phi_u),</div><div class="line">      phi_p (scratch.phi_p)</div><div class="line">    {}</div></div><!-- fragment --><p>The next one is the scratch object used for the assembly of the full Stokes system. Observe that we derive the StokesSystem scratch class from the StokesPreconditioner class above. We do this because all the objects that are necessary for the assembly of the preconditioner are also needed for the actual matrix system and right hand side, plus some extra data. This makes the program more compact. Note also that the assembly of the Stokes system and the temperature right hand side further down requires data from temperature and velocity, respectively, so we actually need two <a class="el" href="classFEValues.html">FEValues</a> objects for those two cases.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">{</div><div class="line">  StokesSystem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;stokes_quadrature,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags);</div><div class="line"></div><div class="line">  StokesSystem (<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                        temperature_fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt;          phi_u;</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2,dim&gt; &gt; grads_phi_u;</div><div class="line">  std::vector&lt;double&gt;                  div_phi_u;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;                  old_temperature_values;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesSystem&lt;dim&gt;::</div><div class="line">StokesSystem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;stokes_quadrature,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags)</div><div class="line">  :</div><div class="line">  StokesPreconditioner&lt;dim&gt; (stokes_fe, stokes_quadrature,</div><div class="line">                             mapping,</div><div class="line">                             stokes_update_flags),</div><div class="line">  temperature_fe_values (mapping, temperature_fe, stokes_quadrature,</div><div class="line">                         temperature_update_flags),</div><div class="line">  phi_u (stokes_fe.dofs_per_cell),</div><div class="line">  grads_phi_u (stokes_fe.dofs_per_cell),</div><div class="line">  div_phi_u (stokes_fe.dofs_per_cell),</div><div class="line">  old_temperature_values (stokes_quadrature.size())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesSystem&lt;dim&gt;::</div><div class="line">StokesSystem (<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;scratch)</div><div class="line">  :</div><div class="line">  StokesPreconditioner&lt;dim&gt; (scratch),</div><div class="line">  temperature_fe_values (scratch.temperature_fe_values.get_mapping(),</div><div class="line">                         scratch.temperature_fe_values.get_fe(),</div><div class="line">                         scratch.temperature_fe_values.get_quadrature(),</div><div class="line">                         scratch.temperature_fe_values.get_update_flags()),</div><div class="line">  phi_u (scratch.phi_u),</div><div class="line">  grads_phi_u (scratch.grads_phi_u),</div><div class="line">  div_phi_u (scratch.div_phi_u),</div><div class="line">  old_temperature_values (scratch.old_temperature_values)</div><div class="line">{}</div></div><!-- fragment --><p>After defining the objects used in the assembly of the Stokes system, we do the same for the assembly of the matrices necessary for the temperature system. The general structure is very similar:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>TemperatureMatrix</div><div class="line">{</div><div class="line">  TemperatureMatrix (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;temperature_quadrature);</div><div class="line"></div><div class="line">  TemperatureMatrix (<span class="keyword">const</span> TemperatureMatrix &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               temperature_fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         phi_T;</div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; grad_phi_T;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TemperatureMatrix&lt;dim&gt;::</div><div class="line">TemperatureMatrix (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;temperature_quadrature)</div><div class="line">  :</div><div class="line">  temperature_fe_values (mapping,</div><div class="line">                         temperature_fe, temperature_quadrature,</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>),</div><div class="line">  phi_T (temperature_fe.dofs_per_cell),</div><div class="line">  grad_phi_T (temperature_fe.dofs_per_cell)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TemperatureMatrix&lt;dim&gt;::</div><div class="line">TemperatureMatrix (<span class="keyword">const</span> TemperatureMatrix &amp;scratch)</div><div class="line">  :</div><div class="line">  temperature_fe_values (scratch.temperature_fe_values.get_mapping(),</div><div class="line">                         scratch.temperature_fe_values.get_fe(),</div><div class="line">                         scratch.temperature_fe_values.get_quadrature(),</div><div class="line">                         scratch.temperature_fe_values.get_update_flags()),</div><div class="line">  phi_T (scratch.phi_T),</div><div class="line">  grad_phi_T (scratch.grad_phi_T)</div><div class="line">{}</div></div><!-- fragment --><p>The final scratch object is used in the assembly of the right hand side of the temperature system. This object is significantly larger than the ones above because a lot more quantities enter the computation of the right hand side of the temperature equation. In particular, the temperature values and gradients of the previous two time steps need to be evaluated at the quadrature points, as well as the velocities and the strain rates (i.e. the symmetric gradients of the velocity) that enter the right hand side as friction heating terms. Despite the number of terms, the following should be rather self explanatory:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>TemperatureRHS</div><div class="line">  {</div><div class="line">    TemperatureRHS (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;quadrature);</div><div class="line"></div><div class="line">    TemperatureRHS (<span class="keyword">const</span> TemperatureRHS &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                        temperature_fe_values;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                        stokes_fe_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  phi_T;</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt;          grad_phi_T;</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt;          old_velocity_values;</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt;          old_old_velocity_values;</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2,dim&gt; &gt; old_strain_rates;</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2,dim&gt; &gt; old_old_strain_rates;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;                  old_temperature_values;</div><div class="line">    std::vector&lt;double&gt;                  old_old_temperature_values;</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt;          old_temperature_grads;</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt;          old_old_temperature_grads;</div><div class="line">    std::vector&lt;double&gt;                  old_temperature_laplacians;</div><div class="line">    std::vector&lt;double&gt;                  old_old_temperature_laplacians;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TemperatureRHS&lt;dim&gt;::</div><div class="line">  TemperatureRHS (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;quadrature)</div><div class="line">    :</div><div class="line">    temperature_fe_values (mapping,</div><div class="line">                           temperature_fe, quadrature,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>  |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>),</div><div class="line">    stokes_fe_values (mapping,</div><div class="line">                      stokes_fe, quadrature,</div><div class="line">                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>),</div><div class="line">    phi_T (temperature_fe.dofs_per_cell),</div><div class="line">    grad_phi_T (temperature_fe.dofs_per_cell),</div><div class="line"></div><div class="line">    old_velocity_values (quadrature.size()),</div><div class="line">    old_old_velocity_values (quadrature.size()),</div><div class="line">    old_strain_rates (quadrature.size()),</div><div class="line">    old_old_strain_rates (quadrature.size()),</div><div class="line"></div><div class="line">    old_temperature_values (quadrature.size()),</div><div class="line">    old_old_temperature_values(quadrature.size()),</div><div class="line">    old_temperature_grads(quadrature.size()),</div><div class="line">    old_old_temperature_grads(quadrature.size()),</div><div class="line">    old_temperature_laplacians(quadrature.size()),</div><div class="line">    old_old_temperature_laplacians(quadrature.size())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TemperatureRHS&lt;dim&gt;::</div><div class="line">  TemperatureRHS (<span class="keyword">const</span> TemperatureRHS &amp;scratch)</div><div class="line">    :</div><div class="line">    temperature_fe_values (scratch.temperature_fe_values.get_mapping(),</div><div class="line">                           scratch.temperature_fe_values.get_fe(),</div><div class="line">                           scratch.temperature_fe_values.get_quadrature(),</div><div class="line">                           scratch.temperature_fe_values.get_update_flags()),</div><div class="line">    stokes_fe_values (scratch.stokes_fe_values.get_mapping(),</div><div class="line">                      scratch.stokes_fe_values.get_fe(),</div><div class="line">                      scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                      scratch.stokes_fe_values.get_update_flags()),</div><div class="line">    phi_T (scratch.phi_T),</div><div class="line">    grad_phi_T (scratch.grad_phi_T),</div><div class="line"></div><div class="line">    old_velocity_values (scratch.old_velocity_values),</div><div class="line">    old_old_velocity_values (scratch.old_old_velocity_values),</div><div class="line">    old_strain_rates (scratch.old_strain_rates),</div><div class="line">    old_old_strain_rates (scratch.old_old_strain_rates),</div><div class="line"></div><div class="line">    old_temperature_values (scratch.old_temperature_values),</div><div class="line">    old_old_temperature_values (scratch.old_old_temperature_values),</div><div class="line">    old_temperature_grads (scratch.old_temperature_grads),</div><div class="line">    old_old_temperature_grads (scratch.old_old_temperature_grads),</div><div class="line">    old_temperature_laplacians (scratch.old_temperature_laplacians),</div><div class="line">    old_old_temperature_laplacians (scratch.old_old_temperature_laplacians)</div><div class="line">  {}</div><div class="line">}</div></div><!-- fragment --><p>The CopyData objects are even simpler than the Scratch objects as all they have to do is to store the results of local computations until they can be copied into the global matrix or vector objects. These structures therefore only need to provide a constructor, a copy operation, and some arrays for local matrix, local vectors and the relation between local and global degrees of freedom (a.k.a. <code>local_dof_indices</code>). Again, we have one such structure for each of the four operations we will parallelize using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class:</p>
<div class="fragment"><div class="line">  <span class="keyword">namespace </span>CopyData</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">    {</div><div class="line">      StokesPreconditioner (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line">      StokesPreconditioner (<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          local_matrix;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::</div><div class="line">    StokesPreconditioner (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">      :</div><div class="line">      local_matrix (stokes_fe.dofs_per_cell,</div><div class="line">                    stokes_fe.dofs_per_cell),</div><div class="line">      local_dof_indices (stokes_fe.dofs_per_cell)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::</div><div class="line">    StokesPreconditioner (<span class="keyword">const</span> StokesPreconditioner &amp;data)</div><div class="line">      :</div><div class="line">      local_matrix (data.local_matrix),</div><div class="line">      local_dof_indices (data.local_dof_indices)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">    {</div><div class="line">      StokesSystem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line">      StokesSystem (<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesSystem&lt;dim&gt;::</div><div class="line">    StokesSystem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">      :</div><div class="line">      StokesPreconditioner&lt;dim&gt; (stokes_fe),</div><div class="line">      local_rhs (stokes_fe.dofs_per_cell)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesSystem&lt;dim&gt;::</div><div class="line">    StokesSystem (<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">      :</div><div class="line">      StokesPreconditioner&lt;dim&gt; (data),</div><div class="line">      local_rhs (data.local_rhs)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>TemperatureMatrix</div><div class="line">    {</div><div class="line">      TemperatureMatrix (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line">      TemperatureMatrix (<span class="keyword">const</span> TemperatureMatrix &amp;data);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          local_mass_matrix;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          local_stiffness_matrix;</div><div class="line">      std::vector&lt;types::global_dof_index&gt;   local_dof_indices;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureMatrix&lt;dim&gt;::</div><div class="line">    TemperatureMatrix (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">      :</div><div class="line">      local_mass_matrix (temperature_fe.dofs_per_cell,</div><div class="line">                         temperature_fe.dofs_per_cell),</div><div class="line">      local_stiffness_matrix (temperature_fe.dofs_per_cell,</div><div class="line">                              temperature_fe.dofs_per_cell),</div><div class="line">      local_dof_indices (temperature_fe.dofs_per_cell)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureMatrix&lt;dim&gt;::</div><div class="line">    TemperatureMatrix (<span class="keyword">const</span> TemperatureMatrix &amp;data)</div><div class="line">      :</div><div class="line">      local_mass_matrix (data.local_mass_matrix),</div><div class="line">      local_stiffness_matrix (data.local_stiffness_matrix),</div><div class="line">      local_dof_indices (data.local_dof_indices)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>TemperatureRHS</div><div class="line">    {</div><div class="line">      TemperatureRHS (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line">      TemperatureRHS (<span class="keyword">const</span> TemperatureRHS &amp;data);</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>              local_rhs;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          matrix_for_bc;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureRHS&lt;dim&gt;::</div><div class="line">    TemperatureRHS (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">      :</div><div class="line">      local_rhs (temperature_fe.dofs_per_cell),</div><div class="line">      local_dof_indices (temperature_fe.dofs_per_cell),</div><div class="line">      matrix_for_bc (temperature_fe.dofs_per_cell,</div><div class="line">                     temperature_fe.dofs_per_cell)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureRHS&lt;dim&gt;::</div><div class="line">    TemperatureRHS (<span class="keyword">const</span> TemperatureRHS &amp;data)</div><div class="line">      :</div><div class="line">      local_rhs (data.local_rhs),</div><div class="line">      local_dof_indices (data.local_dof_indices),</div><div class="line">      matrix_for_bc (data.matrix_for_bc)</div><div class="line">    {}</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeBoussinesqFlowProblemcodeclasstemplate"></a> </p><h3>The <code>BoussinesqFlowProblem</code> class template</h3>
<p>This is the declaration of the main class. It is very similar to <a class="el" href="step_31.html">step-31</a> but there are a number differences we will comment on below.</p>
<p>The top of the class is essentially the same as in <a class="el" href="step_31.html">step-31</a>, listing the public methods and a set of private functions that do the heavy lifting. Compared to <a class="el" href="step_31.html">step-31</a> there are only two additions to this section: the function <code>get_cfl_number()</code> that computes the maximum CFL number over all cells which we then compute the global time step from, and the function <code>get_entropy_variation()</code> that is used in the computation of the entropy stabilization. It is akin to the <code>get_extrapolated_temperature_range()</code> we have used in <a class="el" href="step_31.html">step-31</a> for this purpose, but works on the entropy instead of the temperature instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">struct </span>Parameters;</div><div class="line">  BoussinesqFlowProblem (Parameters &amp;parameters);</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_dofs ();</div><div class="line">  <span class="keywordtype">void</span> assemble_stokes_preconditioner ();</div><div class="line">  <span class="keywordtype">void</span> build_stokes_preconditioner ();</div><div class="line">  <span class="keywordtype">void</span> assemble_stokes_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_temperature_matrix ();</div><div class="line">  <span class="keywordtype">void</span> assemble_temperature_system (<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">  <span class="keywordtype">void</span> project_temperature_field ();</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity () <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_cfl_number () <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_entropy_variation (<span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature) <span class="keyword">const</span>;</div><div class="line">  std::pair&lt;double,double&gt; get_extrapolated_temperature_range () <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results ();</div><div class="line">  <span class="keywordtype">void</span> refine_mesh (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  compute_viscosity(<span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_temperature,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_old_temperature,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_temperature_grads,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_old_temperature_grads,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_temperature_laplacians,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_old_temperature_laplacians,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_velocity_values,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_old_velocity_values,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt;  &amp;old_strain_rates,</div><div class="line">                    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt;  &amp;old_old_strain_rates,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_u_infty,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_T_variation,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span>                        average_temperature,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_entropy_variation,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span>                        cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --><p>The first significant new component is the definition of a struct for the parameters according to the discussion in the introduction. This structure is initialized by reading from a parameter file during construction of this object.</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>Parameters</div><div class="line">  {</div><div class="line">    Parameters (<span class="keyword">const</span> std::string &amp;parameter_filename);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    <span class="keywordtype">void</span> parse_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       end_time;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_global_refinement;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_adaptive_refinement;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span>         generate_graphical_output;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> graphical_output_interval;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> adaptive_refinement_interval;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       stabilization_alpha;</div><div class="line">    <span class="keywordtype">double</span>       stabilization_c_R;</div><div class="line">    <span class="keywordtype">double</span>       stabilization_beta;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_velocity_degree;</div><div class="line">    <span class="keywordtype">bool</span>         use_locally_conservative_discretization;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temperature_degree;</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Parameters                               &amp;parameters;</div></div><!-- fragment --><p>The <code>pcout</code> (for <em>parallel <code>std::cout</code></em>) object is used to simplify writing output: each MPI process can use this to generate output as usual, but since each of these processes will (hopefully) produce the same output it will just be replicated many times over; with the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> class, only the output generated by one MPI process will actually be printed to screen, whereas the output by all the other threads will simply be forgotten.</p>
<div class="fragment"><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a>                        pcout;</div></div><!-- fragment --><p>The following member variables will then again be similar to those in <a class="el" href="step_31.html">step-31</a> (and to other tutorial programs). As mentioned in the introduction, we fully distribute computations, so we will have to use the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class (see <a class="el" href="step_40.html">step-40</a>) but the remainder of these variables is rather standard with two exceptions:</p>
<ul>
<li>The <code>mapping</code> variable is used to denote a higher-order polynomial mapping. As mentioned in the introduction, we use this mapping when forming integrals through quadrature for all cells that are adjacent to either the inner or outer boundaries of our domain where the boundary is curved.</li>
<li>In a bit of naming confusion, you will notice below that some of the variables from namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> are taken from namespace <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">TrilinosWrappers::MPI</a> (such as the right hand side vectors) whereas others are not (such as the various matrices). This is due to legacy reasons. We will frequently have to query velocities and temperatures at arbitrary quadrature points; consequently, rather than importing ghost information of a vector whenever we need access to degrees of freedom that are relevant locally but owned by another processor, we solve linear systems in parallel but then immediately initialize a vector including ghost entries of the solution for further processing. The various <code>*_solution</code> vectors are therefore filled immediately after solving their respective linear system in parallel and will always contain values for all <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant degrees of freedom</a>; the fully distributed vectors that we obtain from the solution process and that only ever contain the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned degrees of freedom</a> are destroyed immediately after the solution process and after we have copied the relevant values into the member variable vectors.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> triangulation;</div><div class="line"><span class="keywordtype">double</span>                                    global_Omega_diameter;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a>                       mapping;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>                       stokes_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                           stokes_dof_handler;</div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                          stokes_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a>       stokes_matrix;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a>       stokes_preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>        stokes_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>        old_stokes_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>        stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                                 temperature_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                           temperature_dof_handler;</div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                          temperature_constraints;</div><div class="line"></div><div class="line">TrilinosWrappers::SparseMatrix            temperature_mass_matrix;</div><div class="line">TrilinosWrappers::SparseMatrix            temperature_stiffness_matrix;</div><div class="line">TrilinosWrappers::SparseMatrix            temperature_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>             temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>             old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>             old_old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>             temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span>                                    time_step;</div><div class="line"><span class="keywordtype">double</span>                                    old_time_step;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                              timestep_number;</div><div class="line"></div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt;    Amg_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; Mp_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; T_preconditioner;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span>                                      rebuild_stokes_matrix;</div><div class="line"><span class="keywordtype">bool</span>                                      rebuild_stokes_preconditioner;</div><div class="line"><span class="keywordtype">bool</span>                                      rebuild_temperature_matrices;</div><div class="line"><span class="keywordtype">bool</span>                                      rebuild_temperature_preconditioner;</div></div><!-- fragment --><p>The next member variable, <code>computing_timer</code> is used to conveniently account for compute time spent in certain "sections" of the code that are repeatedly entered. For example, we will enter (and leave) sections for Stokes matrix assembly and would like to accumulate the run time spent in this section over all time steps. Every so many time steps as well as at the end of the program (through the destructor of the <a class="el" href="classTimerOutput.html">TimerOutput</a> class) we will then produce a nice summary of the times spent in the different sections into which we categorize the run-time of this program.</p>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a>                               computing_timer;</div></div><!-- fragment --><p>After these member variables we have a number of auxiliary functions that have been broken out of the ones listed above. Specifically, there are first three functions that we call from <code>setup_dofs</code> and then the ones that do the assembling of linear systems:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_stokes_matrix (<span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">                          <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line"><span class="keywordtype">void</span> setup_stokes_preconditioner (<span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">                                  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line"><span class="keywordtype">void</span> setup_temperature_matrices (<span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioning,</div><div class="line">                                 <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioning);</div></div><!-- fragment --><p>Following the <a class="el" href="group__threads.html#MTWorkStream">task-based parallelization</a> paradigm, we split all the assembly routines into two parts: a first part that can do all the calculations on a certain cell without taking care of other threads, and a second part (which is writing the local data into the global matrices and vectors) which can be entered by only one thread at a time. In order to implement that, we provide functions for each of those two steps for all the four assembly routines that we use in this program. The following eight functions do exactly this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">local_assemble_stokes_preconditioner (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                      Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;scratch,</div><div class="line">                                      Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_stokes_preconditioner (<span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">local_assemble_stokes_system (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                              Assembly::Scratch::StokesSystem&lt;dim&gt;  &amp;scratch,</div><div class="line">                              Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_stokes_system (<span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">local_assemble_temperature_matrix (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                   Assembly::Scratch::TemperatureMatrix&lt;dim&gt;  &amp;scratch,</div><div class="line">                                   Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_temperature_matrix (<span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">local_assemble_temperature_rhs (<span class="keyword">const</span> std::pair&lt;double,double&gt; global_T_range,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>                   global_max_velocity,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>                   global_entropy_variation,</div><div class="line">                                <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;scratch,</div><div class="line">                                Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_temperature_rhs (<span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data);</div></div><!-- fragment --><p>Finally, we forward declare a member class that we will define later on and that will be used to compute a number of quantities from our solution vectors that we'd like to put into the output files for visualization.</p>
<div class="fragment"><div class="line">  <span class="keyword">class </span>Postprocessor;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemclassimplementation"></a> </p><h3>BoussinesqFlowProblem class implementation</h3>
<p><a class="anchor" id="BoussinesqFlowProblemParameters"></a> </p><h4>BoussinesqFlowProblem::Parameters</h4>
<p>Here comes the definition of the parameters for the Stokes problem. We allow to set the end time for the simulation, the level of refinements (both global and adaptive, which in the sum specify what maximum level the cells are allowed to have), and the interval between refinements in the time stepping.</p>
<p>Then, we let the user specify constants for the stabilization parameters (as discussed in the introduction), the polynomial degree for the Stokes velocity space, whether to use the locally conservative discretization based on <a class="el" href="classFE__DGP.html">FE_DGP</a> elements for the pressure or not (<a class="el" href="classFE__Q.html">FE_Q</a> elements for pressure), and the polynomial degree for the temperature interpolation.</p>
<p>The constructor checks for a valid input file (if not, a file with default parameters for the quantities is written), and eventually parses the parameters.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Parameters::Parameters (<span class="keyword">const</span> std::string &amp;parameter_filename)</div><div class="line">  :</div><div class="line">  end_time (1e8),</div><div class="line">  initial_global_refinement (2),</div><div class="line">  initial_adaptive_refinement (2),</div><div class="line">  adaptive_refinement_interval (10),</div><div class="line">  stabilization_alpha (2),</div><div class="line">  stabilization_c_R (0.11),</div><div class="line">  stabilization_beta (0.078),</div><div class="line">  stokes_velocity_degree (2),</div><div class="line">  use_locally_conservative_discretization (true),</div><div class="line">  temperature_degree (2)</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters (prm);</div><div class="line"></div><div class="line">  std::ifstream parameter_file (parameter_filename.c_str());</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!parameter_file)</div><div class="line">    {</div><div class="line">      parameter_file.close ();</div><div class="line"></div><div class="line">      std::ostringstream message;</div><div class="line">      message &lt;&lt; <span class="stringliteral">&quot;Input parameter file &lt;&quot;</span></div><div class="line">              &lt;&lt; parameter_filename &lt;&lt; <span class="stringliteral">&quot;&gt; not found. Creating a&quot;</span></div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;template file of the same name.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::ofstream parameter_out (parameter_filename.c_str());</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters</a> (parameter_out,</div><div class="line">                            <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a> (message.str().c_str()));</div><div class="line">    }</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (parameter_file);</div><div class="line">  parse_parameters (prm);</div><div class="line">}</div></div><!-- fragment --><p>Next we have a function that declares the parameters that we expect in the input file, together with their data types, default values and a description:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Parameters::</div><div class="line">declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;End time&quot;</span>, <span class="stringliteral">&quot;1e8&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0),</div><div class="line">                     <span class="stringliteral">&quot;The end time of the simulation in years.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Initial global refinement&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (0),</div><div class="line">                     <span class="stringliteral">&quot;The number of global refinement steps performed on &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;the initial coarse mesh, before the problem is first &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;solved there.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (0),</div><div class="line">                     <span class="stringliteral">&quot;The number of adaptive refinement steps performed after &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;initial global refinement.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1),</div><div class="line">                     <span class="stringliteral">&quot;The number of time steps after which the mesh is to be &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;adapted based on computed error indicators.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Generate graphical output&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a> (),</div><div class="line">                     <span class="stringliteral">&quot;Whether graphical output is to be generated or not. &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;You may not want to get graphical output if the number &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;of processors is large.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>, <span class="stringliteral">&quot;50&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1),</div><div class="line">                     <span class="stringliteral">&quot;The number of time steps between each generation of &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;graphical output files.&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;alpha&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (1, 2),</div><div class="line">                       <span class="stringliteral">&quot;The exponent in the entropy viscosity stabilization.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;c_R&quot;</span>, <span class="stringliteral">&quot;0.11&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0),</div><div class="line">                       <span class="stringliteral">&quot;The c_R factor in the entropy viscosity &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;stabilization.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;beta&quot;</span>, <span class="stringliteral">&quot;0.078&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0),</div><div class="line">                       <span class="stringliteral">&quot;The beta factor in the artificial viscosity &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;stabilization. An appropriate value for 2d is 0.052 &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;and 0.078 for 3d.&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1),</div><div class="line">                       <span class="stringliteral">&quot;The polynomial degree to use for the velocity variables &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;in the Stokes system.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1),</div><div class="line">                       <span class="stringliteral">&quot;The polynomial degree to use for the temperature variable.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a> (),</div><div class="line">                       <span class="stringliteral">&quot;Whether to use a Stokes discretization that is locally &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;conservative at the expense of a larger number of degrees &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;of freedom, or to go with a cheaper discretization &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;that does not locally conserve mass (although it is &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;globally conservative.&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p>And then we need a function that reads the contents of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object we get by reading the input file and puts the results into variables that store the values of the parameters we have previously declared:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Parameters::</div><div class="line">parse_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  end_time                    = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line">  initial_global_refinement   = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Initial global refinement&quot;</span>);</div><div class="line">  initial_adaptive_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>);</div><div class="line"></div><div class="line">  adaptive_refinement_interval= prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>);</div><div class="line"></div><div class="line">  generate_graphical_output   = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a> (<span class="stringliteral">&quot;Generate graphical output&quot;</span>);</div><div class="line">  graphical_output_interval   = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">  {</div><div class="line">    stabilization_alpha = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;alpha&quot;</span>);</div><div class="line">    stabilization_c_R   = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;c_R&quot;</span>);</div><div class="line">    stabilization_beta  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;beta&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">  {</div><div class="line">    stokes_velocity_degree = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>);</div><div class="line">    temperature_degree     = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>);</div><div class="line">    use_locally_conservative_discretization</div><div class="line">      = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a> (<span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemBoussinesqFlowProblem"></a> </p><h4>BoussinesqFlowProblem::BoussinesqFlowProblem</h4>
<p>The constructor of the problem is very similar to the constructor in <a class="el" href="step_31.html">step-31</a>. What is different is the parallel communication: Trilinos uses a message passing interface (MPI) for data distribution. When entering the BoussinesqFlowProblem class, we have to decide how the parallization is to be done. We choose a rather simple strategy and let all processors that are running the program work together, specified by the communicator <code>MPI_COMM_WORLD</code>. Next, we create the output stream (as we already did in <a class="el" href="step_18.html">step-18</a>) that only generates output on the first MPI process and is completely forgetful on all others. The implementation of this idea is to check the process number when <code>pcout</code> gets a true argument, and it uses the <code>std::cout</code> stream for output. If we are one processor five, for instance, then we will give a <code>false</code> argument to <code>pcout</code>, which means that the output of that processor will not be printed. With the exception of the mapping object (for which we use polynomials of degree 4) all but the final member variable are exactly the same as in <a class="el" href="step_31.html">step-31</a>.</p>
<p>This final object, the <a class="el" href="classTimerOutput.html">TimerOutput</a> object, is then told to restrict output to the <code>pcout</code> stream (processor 0), and then we specify that we want to get a summary table at the end of the program which shows us wallclock times (as opposed to CPU times). We will manually also request intermediate summaries every so many time steps in the <code>run()</code> function below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem (Parameters &amp;parameters_)</div><div class="line">  :</div><div class="line">  parameters (parameters_),</div><div class="line">  pcout (<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">         (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD)</div><div class="line">          == 0)),</div><div class="line"></div><div class="line">  triangulation (MPI_COMM_WORLD,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing</div><div class="line">                 (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening)),</div><div class="line"></div><div class="line">  global_Omega_diameter(0.),</div><div class="line"></div><div class="line">  mapping (4),</div><div class="line"></div><div class="line">  stokes_fe (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree),</div><div class="line">             dim,</div><div class="line">             (parameters.use_locally_conservative_discretization</div><div class="line">              ?</div><div class="line">              static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;</div><div class="line">              (<a class="code" href="classFE__DGP.html">FE_DGP</a>&lt;dim&gt;(parameters.stokes_velocity_degree-1))</div><div class="line">              :</div><div class="line">              static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;</div><div class="line">              (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree-1))),</div><div class="line">             1),</div><div class="line"></div><div class="line">  stokes_dof_handler (triangulation),</div><div class="line"></div><div class="line">  temperature_fe (parameters.temperature_degree),</div><div class="line">  temperature_dof_handler (triangulation),</div><div class="line"></div><div class="line">  time_step (0),</div><div class="line">  old_time_step (0),</div><div class="line">  timestep_number (0),</div><div class="line">  rebuild_stokes_matrix (true),</div><div class="line">  rebuild_stokes_preconditioner (true),</div><div class="line">  rebuild_temperature_matrices (true),</div><div class="line">  rebuild_temperature_preconditioner (true),</div><div class="line"></div><div class="line">  computing_timer (MPI_COMM_WORLD,</div><div class="line">                   pcout,</div><div class="line">                   <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                   <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TheBoussinesqFlowProblemhelperfunctions"></a> </p><h4>The BoussinesqFlowProblem helper functions</h4>
<p><a class="anchor" id="BoussinesqFlowProblemget_maximal_velocity"></a> </p><h5>BoussinesqFlowProblem::get_maximal_velocity</h5>
<p>Except for two small details, the function to compute the global maximum of the velocity is the same as in <a class="el" href="step_31.html">step-31</a>. The first detail is actually common to all functions that implement loops over all cells in the triangulation: When operating in parallel, each processor can only work on a chunk of cells since each processor only has a certain part of the entire triangulation. This chunk of cells that we want to work on is identified via a so-called <code>subdomain_id</code>, as we also did in <a class="el" href="step_18.html">step-18</a>. All we need to change is hence to perform the cell-related operations only on cells that are owned by the current process (as opposed to ghost or artificial cells), i.e. for which the subdomain id equals the number of the process ID. Since this is a commonly used operation, there is a shortcut for this operation: we can ask whether the cell is owned by the current processor using <code>cell-&gt;is_locally_owned()</code>.</p>
<p>The second difference is the way we calculate the maximum value. Before, we could simply have a <code>double</code> variable that we checked against on each quadrature point for each cell. Now, we have to be a bit more careful since each processor only operates on a subset of cells. What we do is to first let each processor calculate the maximum among its cells, and then do a global communication operation <code><a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a></code> that computes the maximum value among all the maximum values of the individual processors. MPI provides such a call, but it's even simpler to use the respective function in namespace <a class="el" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a> using the MPI communicator object since that will do the right thing even if we work without MPI and on a single machine only. The call to <code><a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a></code> needs two arguments, namely the local maximum (input) and the MPI communicator, which is MPI_COMM_WORLD in this example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula (<a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>(),</div><div class="line">                                           parameters.stokes_velocity_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (mapping, stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_local_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = stokes_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = stokes_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (stokes_solution,</div><div class="line">                                                   velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          max_local_velocity = std::max (max_local_velocity,</div><div class="line">                                         velocity_values[q].norm());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (max_local_velocity, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_cfl_number"></a> </p><h5>BoussinesqFlowProblem::get_cfl_number</h5>
<p>The next function does something similar, but we now compute the CFL number, i.e., maximal velocity on a cell divided by the cell diameter. This number is necessary to determine the time step size, as we use a semi-explicit time stepping scheme for the temperature equation (see <a class="el" href="step_31.html">step-31</a> for a discussion). We compute it in the same way as above: Compute the local maximum over all locally owned cells, then exchange it via MPI to find the global maximum.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_cfl_number ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula (<a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>(),</div><div class="line">                                           parameters.stokes_velocity_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (mapping, stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1,dim&gt; &gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_local_cfl = 0;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = stokes_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = stokes_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (stokes_solution,</div><div class="line">                                                   velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> max_local_velocity = 1e-10;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          max_local_velocity = std::max (max_local_velocity,</div><div class="line">                                         velocity_values[q].norm());</div><div class="line">        max_local_cfl = std::max(max_local_cfl,</div><div class="line">                                 max_local_velocity / cell-&gt;diameter());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (max_local_cfl, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_entropy_variation"></a> </p><h5>BoussinesqFlowProblem::get_entropy_variation</h5>
<p>Next comes the computation of the global entropy variation <img class="formulaInl" alt="$\|E(T)-\bar{E}(T)\|_\infty$" src="form_2792.png"/> where the entropy <img class="formulaInl" alt="$E$" src="form_1205.png"/> is defined as discussed in the introduction. This is needed for the evaluation of the stabilization in the temperature equation as explained in the introduction. The entropy variation is actually only needed if we use <img class="formulaInl" alt="$\alpha=2$" src="form_2553.png"/> as a power in the residual computation. The infinity norm is computed by the maxima over quadrature points, as usual in discrete computations.</p>
<p>In order to compute this quantity, we first have to find the space-average <img class="formulaInl" alt="$\bar{E}(T)$" src="form_2793.png"/> and then evaluate the maximum. However, that means that we would need to perform two loops. We can avoid the overhead by noting that <img class="formulaInl" alt="$\|E(T)-\bar{E}(T)\|_\infty = \max\big(E_{\textrm{max}}(T)-\bar{E}(T), \bar{E}(T)-E_{\textrm{min}}(T)\big)$" src="form_2794.png"/>, i.e., the maximum out of the deviation from the average entropy in positive and negative directions. The four quantities we need for the latter formula (maximum entropy, minimum entropy, average entropy, area) can all be evaluated in the same loop over all cells, so we choose this simpler variant.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::get_entropy_variation (<span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (parameters.stabilization_alpha != 2)</div><div class="line">    <span class="keywordflow">return</span> 1.;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula (parameters.temperature_degree+1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (temperature_fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div></div><!-- fragment --><p>In the two functions above we computed the maximum of numbers that were all non-negative, so we knew that zero was certainly a lower bound. On the other hand, here we need to find the maximum deviation from the average value, i.e., we will need to know the maximal and minimal values of the entropy for which we don't a priori know the sign.</p>
<p>To compute it, we can therefore start with the largest and smallest possible values we can store in a double precision number: The minimum is initialized with a bigger and the maximum with a smaller number than any one that is going to appear. We are then guaranteed that these numbers will be overwritten in the loop on the first cell or, if this processor does not own any cells, in the communication step at the latest. The following loop then computes the minimum and maximum local entropy as well as keeps track of the area/volume of the part of the domain we locally own and the integral over the entropy on it:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> min_entropy = std::numeric_limits&lt;double&gt;::max(),</div><div class="line">       max_entropy = -std::numeric_limits&lt;double&gt;::max(),</div><div class="line">       area = 0,</div><div class="line">       entropy_integrated = 0;</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_temperature_solution,</div><div class="line">                                     old_temperature_values);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_old_temperature_solution,</div><div class="line">                                     old_old_temperature_values);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> T = (old_temperature_values[q] +</div><div class="line">                            old_old_temperature_values[q]) / 2;</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> entropy = ((T-average_temperature) *</div><div class="line">                                  (T-average_temperature));</div><div class="line"></div><div class="line">          min_entropy = std::min (min_entropy, entropy);</div><div class="line">          max_entropy = std::max (max_entropy, entropy);</div><div class="line">          area += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">          entropy_integrated += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) * entropy;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Now we only need to exchange data between processors: we need to sum the two integrals (<code>area</code>, <code>entropy_integrated</code>), and get the extrema for maximum and minimum. We could do this through four different data exchanges, but we can it with two: <a class="el" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a> also exists in a variant that takes an array of values that are all to be summed up. And we can also utilize the <a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> function by realizing that forming the minimum over the minimal entropies equals forming the negative of the maximum over the negative of the minimal entropies; this maximum can then be combined with forming the maximum over the maximal entropies.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> local_sums[2]   = { entropy_integrated, area },</div><div class="line">                               local_maxima[2] = { -min_entropy, max_entropy };</div><div class="line"><span class="keywordtype">double</span> global_sums[2], global_maxima[2];</div><div class="line"></div><div class="line"><a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a> (local_sums,   MPI_COMM_WORLD, global_sums);</div><div class="line"><a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (local_maxima, MPI_COMM_WORLD, global_maxima);</div></div><!-- fragment --><p>Having computed everything this way, we can then compute the average entropy and find the <img class="formulaInl" alt="$L^\infty$" src="form_2795.png"/> norm by taking the larger of the deviation of the maximum or minimum from the average:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_entropy = global_sums[0] / global_sums[1];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> entropy_diff = std::max(global_maxima[1] - average_entropy,</div><div class="line">                                       average_entropy - (-global_maxima[0]));</div><div class="line">  <span class="keywordflow">return</span> entropy_diff;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_extrapolated_temperature_range"></a> </p><h5>BoussinesqFlowProblem::get_extrapolated_temperature_range</h5>
<p>The next function computes the minimal and maximal value of the extrapolated temperature over the entire domain. Again, this is only a slightly modified version of the respective function in <a class="el" href="step_31.html">step-31</a>. As in the function above, we collect local minima and maxima and then compute the global extrema using the same trick as above.</p>
<p>As already discussed in <a class="el" href="step_31.html">step-31</a>, the function needs to distinguish between the first and all following time steps because it uses a higher order temperature extrapolation scheme when at least two previous time steps are available.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double,double&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula (<a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>(),</div><div class="line">                                           parameters.temperature_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (mapping, temperature_fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> min_local_temperature = std::numeric_limits&lt;double&gt;::max(),</div><div class="line">         max_local_temperature = -std::numeric_limits&lt;double&gt;::max();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">      endc = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">      <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_temperature_solution,</div><div class="line">                                           old_temperature_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_old_temperature_solution,</div><div class="line">                                           old_old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                  (1. + time_step/old_time_step) * old_temperature_values[q]-</div><div class="line">                  time_step/old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">                min_local_temperature = std::min (min_local_temperature,</div><div class="line">                                                  temperature);</div><div class="line">                max_local_temperature = std::max (max_local_temperature,</div><div class="line">                                                  temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">      endc = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">      <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_temperature_solution,</div><div class="line">                                           old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">                min_local_temperature = std::min (min_local_temperature,</div><div class="line">                                                  temperature);</div><div class="line">                max_local_temperature = std::max (max_local_temperature,</div><div class="line">                                                  temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> local_extrema[2] = { -min_local_temperature,</div><div class="line">                              max_local_temperature</div><div class="line">                            };</div><div class="line">  <span class="keywordtype">double</span> global_extrema[2];</div><div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (local_extrema, MPI_COMM_WORLD, global_extrema);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> std::make_pair(-global_extrema[0], global_extrema[1]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemcompute_viscosity"></a> </p><h5>BoussinesqFlowProblem::compute_viscosity</h5>
<p>The function that calculates the viscosity is purely local and so needs no communication at all. It is mostly the same as in <a class="el" href="step_31.html">step-31</a> but with an updated formulation of the viscosity if <img class="formulaInl" alt="$\alpha=2$" src="form_2553.png"/> is chosen:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">compute_viscosity (<span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_temperature,</div><div class="line">                   <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_old_temperature,</div><div class="line">                   <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_temperature_grads,</div><div class="line">                   <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_old_temperature_grads,</div><div class="line">                   <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_temperature_laplacians,</div><div class="line">                   <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_old_temperature_laplacians,</div><div class="line">                   <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_velocity_values,</div><div class="line">                   <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_old_velocity_values,</div><div class="line">                   <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt;  &amp;old_strain_rates,</div><div class="line">                   <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt;  &amp;old_old_strain_rates,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_u_infty,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_T_variation,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span>                        average_temperature,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_entropy_variation,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span>                        cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">    <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">  <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> u = (old_velocity_values[q] +</div><div class="line">                               old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> strain_rate = (old_strain_rates[q] +</div><div class="line">                                                  old_old_strain_rates[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> T = (old_temperature[q] + old_old_temperature[q]) / 2;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt = (old_temperature[q] - old_old_temperature[q])</div><div class="line">                           / old_time_step;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T = u * (old_temperature_grads[q] +</div><div class="line">                                   old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T = EquationData::kappa</div><div class="line">                                   * (old_temperature_laplacians[q] +</div><div class="line">                                      old_old_temperature_laplacians[q]) / 2;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma</div><div class="line">        = ((EquationData::radiogenic_heating * EquationData::density(T)</div><div class="line">            +</div><div class="line">            2 * EquationData::eta * strain_rate * strain_rate) /</div><div class="line">           (EquationData::density(T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> residual</div><div class="line">        = std::abs(dT_dt + u_grad_T - kappa_Delta_T - gamma);</div><div class="line">      <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">        residual *= std::abs(T - average_temperature);</div><div class="line"></div><div class="line">      max_residual = std::max (residual,        max_residual);</div><div class="line">      max_velocity = std::max (std::sqrt (u*u), max_velocity);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_viscosity = (parameters.stabilization_beta *</div><div class="line">                                max_velocity * cell_diameter);</div><div class="line">  <span class="keywordflow">if</span> (timestep_number == 0)</div><div class="line">    <span class="keywordflow">return</span> max_viscosity;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (old_time_step &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> entropy_viscosity;</div><div class="line">      <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">        entropy_viscosity = (parameters.stabilization_c_R *</div><div class="line">                             cell_diameter * cell_diameter *</div><div class="line">                             max_residual /</div><div class="line">                             global_entropy_variation);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        entropy_viscosity = (parameters.stabilization_c_R *</div><div class="line">                             cell_diameter * global_Omega_diameter *</div><div class="line">                             max_velocity * max_residual /</div><div class="line">                             (global_u_infty * global_T_variation));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> std::min (max_viscosity, entropy_viscosity);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemproject_temperature_field"></a> </p><h5>BoussinesqFlowProblem::project_temperature_field</h5>
<p>This function is new compared to <a class="el" href="step_31.html">step-31</a>. What is does is to re-implement the library function <code><a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project()</a></code> for an MPI-based parallelization, a function we used for generating an initial vector for temperature based on some initial function. The library function only works with shared memory but doesn't know how to utilize multiple machines coupled through MPI to compute the projected field. The details of a <code>project()</code> function are not very difficult. All we do is to use a mass matrix and put the evaluation of the initial value function on the right hand side. The mass matrix for temperature we can simply generate using the respective assembly function, so all we need to do here is to create the right hand side and do a CG solve. The assembly function does a loop over all cells and evaluates the function in the <code>EquationData</code> namespace, and does this only on cells owned by the respective processor. The implementation of this assembly differs from the assembly we do for the principal assembly functions further down (which include thread-based parallelization with the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept). Here we chose to keep things simple (keeping in mind that this function is also only called once at the beginning of the program, not in every time step), and generating the right hand side is cheap anyway so we won't even notice that this part is not parallized by threads.</p>
<p>Regarding the implementation of inhomogeneous Dirichlet boundary conditions: Since we use the temperature <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>, we could apply the boundary conditions directly when building the respective matrix and right hand side. In this case, the boundary conditions are inhomogeneous, which makes this procedure somewhat tricky since we get the matrix from some other function that uses its own integration and assembly loop. However, the correct imposition of boundary conditions needs the matrix data we work on plus the right hand side simultaneously, since the right hand side is created by Gaussian elimination on the matrix rows. In order to not introduce the matrix assembly at this place, but still having the matrix data available, we choose to create a dummy matrix <code>matrix_for_bc</code> that we only fill with data when we need it for imposing boundary conditions. These positions are exactly those where we have an inhomogeneous entry in the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a>. There are only a few such positions (on the boundary DoFs), so it is still much cheaper to use this function than to create the full matrix here. To implement this, we ask the constraint matrix whether the DoF under consideration is inhomogeneously constrained. In that case, we generate the respective matrix column that we need for creating the correct right hand side. Note that this (manually generated) matrix entry needs to be exactly the entry that we would fill the matrix with &mdash; otherwise, this will not work.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::project_temperature_field ()</div><div class="line">{</div><div class="line">  assemble_temperature_matrix ();</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(parameters.temperature_degree+2);</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (mapping, temperature_fe, quadrature, update_flags);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>,</div><div class="line">                     n_q_points    = fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_vector (dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> matrix_for_bc (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; rhs_values(n_q_points);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> row_temp_matrix_partitioning(temperature_mass_matrix.n());</div><div class="line">  row_temp_matrix_partitioning.<a class="code" href="classIndexSet.html#adf69c0bec3f1e748fec802e0dc0d2dd0">add_range</a>(temperature_mass_matrix.local_range().first,</div><div class="line">                                         temperature_mass_matrix.local_range().second);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> rhs (row_temp_matrix_partitioning),</div><div class="line">                   solution (row_temp_matrix_partitioning);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::TemperatureInitialValues&lt;dim&gt; initial_temperature;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        initial_temperature.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                        rhs_values);</div><div class="line"></div><div class="line">        cell_vector = 0;</div><div class="line">        matrix_for_bc = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              cell_vector(i) += rhs_values[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] *</div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,point) *</div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(point);</div><div class="line">              <span class="keywordflow">if</span> (temperature_constraints.is_inhomogeneously_constrained(local_dof_indices[i]))</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                    matrix_for_bc(j,i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(point);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        temperature_constraints.distribute_local_to_global (cell_vector,</div><div class="line">                                                            local_dof_indices,</div><div class="line">                                                            rhs,</div><div class="line">                                                            matrix_for_bc);</div><div class="line">      }</div><div class="line"></div><div class="line">  rhs.<a class="code" href="classVector.html#a8740c5534b6dbc31f4f1503a5e2a10a3">compress</a> (<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div></div><!-- fragment --><p>Now that we have the right linear system, we solve it using the CG method with a simple Jacobi preconditioner:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5*rhs.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), 1e-12*rhs.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a> preconditioner_mass;</div><div class="line">preconditioner_mass.<a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html#a89c6576dd9f2b29fc545f25f753d4579">initialize</a>(temperature_mass_matrix, 1.3);</div><div class="line"></div><div class="line">cg.solve (temperature_mass_matrix, solution, rhs, preconditioner_mass);</div><div class="line"></div><div class="line">temperature_constraints.distribute (solution);</div></div><!-- fragment --><p>Having so computed the current temperature field, let us set the member variable that holds the temperature nodes. Strictly speaking, we really only need to set <code>old_temperature_solution</code> since the first thing we will do is to compute the Stokes solution that only requires the previous time step's temperature field. That said, nothing good can come from not initializing the other vectors as well (especially since it's a relatively cheap operation and we only have to do it once at the beginning of the program) if we ever want to extend our numerical method or physical model, and so we initialize <code>temperature_solution</code> and <code>old_old_temperature_solution</code> as well. As a sidenote, while the <code>solution</code> vector is strictly distributed (i.e. each processor only stores a mutually exclusive subset of elements), the assignment makes sure that the vectors on the left hand side (which where initialized to contain ghost elements as well) also get the correct ghost elements. In other words, the assignment here requires communication between processors:</p>
<div class="fragment"><div class="line">  temperature_solution = solution;</div><div class="line">  old_temperature_solution = solution;</div><div class="line">  old_old_temperature_solution = solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheBoussinesqFlowProblemsetupfunctions"></a> </p><h4>The BoussinesqFlowProblem setup functions</h4>
<p>The following three functions set up the Stokes matrix, the matrix used for the Stokes preconditioner, and the temperature matrix. The code is mostly the same as in <a class="el" href="step_31.html">step-31</a>, but it has been broken out into three functions of their own for simplicity.</p>
<p>The main functional difference between the code here and that in <a class="el" href="step_31.html">step-31</a> is that the matrices we want to set up are distributed across multiple processors. Since we still want to build up the sparsity pattern first for efficiency reasons, we could continue to build the <em>entire</em> sparsity pattern as a <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a>, as we did in <a class="el" href="step_31.html">step-31</a>. However, that would be inefficient: every processor would build the same sparsity pattern, but only initialize a small part of the matrix using it. It also violates the principle that every processor should only work on those cells it owns (and, if necessary the layer of ghost cells around it).</p>
<p>Rather, we use an object of type <a class="el" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a>, which is (obviously) a wrapper around a sparsity pattern object provided by Trilinos. The advantage is that the Trilinos sparsity pattern class can communicate across multiple processors: if this processor fills in all the nonzero entries that result from the cells it owns, and every other processor does so as well, then at the end after some MPI communication initiated by the <code>compress()</code> call, we will have the globally assembled sparsity pattern available with which the global matrix can be initialized.</p>
<p>There is one important aspect when initializing Trilinos sparsity patterns in parallel: In addition to specifying the locally owned rows and columns of the matrices via the <code>stokes_partitioning</code> index set, we also supply information about all the rows we are possibly going to write into when assembling on a certain processor. The set of locally relevant rows contains all such rows (possibly also a few unnecessary ones, but it is difficult to find the exact row indices before actually getting indices on all cells and resolving constraints). This additional information allows to exactly determine the structure for the off-processor data found during assembly. While Trilinos matrices are able to collect this information on the fly as well (when initializing them from some other reinit method), it is less efficient and leads to problems when assembling matrices with multiple threads. In this program, we pessimistically assume that only one processor at a time can write into the matrix while assembly (whereas the computation is parallel), which is fine for Trilinos matrices. In practice, one can do better by hinting <a class="el" href="namespaceWorkStream.html">WorkStream</a> at cells that do not share vertices, allowing for parallelism among those cells (see the graph coloring algorithms and <a class="el" href="namespaceWorkStream.html">WorkStream</a> with colored iterators argument). However, that only works when only one MPI processor is present because Trilinos' internal data structures for accumulating off-processor data on the fly are not thread safe. With the initialization presented here, there is no such problem and one could safely introduce graph coloring for this algorithm.</p>
<p>The only other change we need to make is to tell the <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern()</a> function that it is only supposed to work on a subset of cells, namely the ones whose <code>subdomain_id</code> equals the number of the current processor, and to ignore all other cells.</p>
<p>This strategy is replicated across all three of the following functions.</p>
<p>Note that Trilinos matrices store the information contained in the sparsity patterns, so we can safely release the <code>sp</code> variable once the matrix has been given the sparsity structure.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">setup_stokes_matrix (<span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">{</div><div class="line">  stokes_matrix.clear ();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning, stokes_partitioning,</div><div class="line">                                            stokes_relevant_partitioning,</div><div class="line">                                            MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> coupling (dim+1, dim+1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;dim+1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim+1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (! ((c==dim) &amp;&amp; (d==dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (stokes_dof_handler,</div><div class="line">                                   coupling, sp,</div><div class="line">                                   stokes_constraints, <span class="keyword">false</span>,</div><div class="line">                                   <a class="code" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a>::</div><div class="line">                                   <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  stokes_matrix.reinit (sp);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">setup_stokes_preconditioner (<span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">                             <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">{</div><div class="line">  Amg_preconditioner.reset ();</div><div class="line">  Mp_preconditioner.reset ();</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.clear ();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning, stokes_partitioning,</div><div class="line">                                            stokes_relevant_partitioning,</div><div class="line">                                            MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> coupling (dim+1, dim+1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;dim+1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim+1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (c == d)</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (stokes_dof_handler,</div><div class="line">                                   coupling, sp,</div><div class="line">                                   stokes_constraints, <span class="keyword">false</span>,</div><div class="line">                                   <a class="code" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a>::</div><div class="line">                                   <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.reinit (sp);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">setup_temperature_matrices (<span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioner,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioner)</div><div class="line">{</div><div class="line">  T_preconditioner.reset ();</div><div class="line">  temperature_mass_matrix.clear ();</div><div class="line">  temperature_stiffness_matrix.clear ();</div><div class="line">  temperature_matrix.clear ();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(temperature_partitioner,</div><div class="line">                                       temperature_partitioner,</div><div class="line">                                       temperature_relevant_partitioner,</div><div class="line">                                       MPI_COMM_WORLD);</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (temperature_dof_handler, sp,</div><div class="line">                                   temperature_constraints, <span class="keyword">false</span>,</div><div class="line">                                   <a class="code" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a>::</div><div class="line">                                   <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  temperature_matrix.reinit (sp);</div><div class="line">  temperature_mass_matrix.reinit (sp);</div><div class="line">  temperature_stiffness_matrix.reinit (sp);</div><div class="line">}</div></div><!-- fragment --><p>The remainder of the setup function (after splitting out the three functions above) mostly has to deal with the things we need to do for parallelization across processors. Because setting all of this up is a significant compute time expense of the program, we put everything we do here into a timer group so that we can get summary information about the fraction of time spent in this part of the program at its end.</p>
<p>At the top as usual we enumerate degrees of freedom and sort them by component/block, followed by writing their numbers to the screen from processor zero. The DoFHandler::distributed_dofs() function, when applied to a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, sorts degrees of freedom in such a way that all degrees of freedom associated with subdomain zero come before all those associated with subdomain one, etc. For the Stokes part, this entails, however, that velocities and pressures become intermixed, but this is trivially solved by sorting again by blocks; it is worth noting that this latter operation leaves the relative ordering of all velocities and pressures alone, i.e. within the velocity block we will still have all those associated with subdomain zero before all velocities associated with subdomain one, etc. This is important since we store each of the blocks of this matrix distributed across all processors and want this to be done in such a way that each processor stores that part of the matrix that is roughly equal to the degrees of freedom located on those cells that it will actually work on.</p>
<p>When printing the numbers of degrees of freedom, note that these numbers are going to be large if we use many processors. Consequently, we let the stream put a comma separator in between every three digits. The state of the stream, using the locale, is saved from before to after this operation. While slightly opaque, the code works because the default locale (which we get using the constructor call <code>std::locale("")</code>) implies printing numbers with a comma separator for every third digit (i.e., thousands, millions, billions).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs ()</div><div class="line">{</div><div class="line">  computing_timer.enter_section(<span class="stringliteral">&quot;Setup dof systems&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks (dim+1,0);</div><div class="line">  stokes_sub_blocks[dim] = 1;</div><div class="line">  stokes_dof_handler.distribute_dofs (stokes_fe);</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> (stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  temperature_dof_handler.distribute_dofs (temperature_fe);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block (2);</div><div class="line">  <a class="code" href="namespaceDoFTools.html#abfd9796e22113e13b5802e384e56af4f">DoFTools::count_dofs_per_block</a> (stokes_dof_handler, stokes_dofs_per_block,</div><div class="line">                                  stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                     n_p = stokes_dofs_per_block[1],</div><div class="line">                     n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::locale s = pcout.get_stream().getloc();</div><div class="line">  pcout.get_stream().imbue(std::locale(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">        &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>()</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span></div><div class="line">        &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>()</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span></div><div class="line">        &lt;&lt; std::endl</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">        &lt;&lt; n_u + n_p + n_T</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span>&lt;&lt; n_T &lt;&lt;<span class="charliteral">&#39;)&#39;</span></div><div class="line">        &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">  pcout.get_stream().imbue(s);</div></div><!-- fragment --><p>After this, we have to set up the various partitioners (of type <code><a class="el" href="classIndexSet.html">IndexSet</a></code>, see the introduction) that describe which parts of each matrix or vector will be stored where, then call the functions that actually set up the matrices, and at the end also resize the various vectors we keep around in this program.</p>
<div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; stokes_partitioning, stokes_relevant_partitioning;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning (n_T), temperature_relevant_partitioning (n_T);</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> stokes_relevant_set;</div><div class="line">{</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> stokes_index_set = stokes_dof_handler.locally_owned_dofs();</div><div class="line">  stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0,n_u));</div><div class="line">  stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u,n_u+n_p));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (stokes_dof_handler,</div><div class="line">                                           stokes_relevant_set);</div><div class="line">  stokes_relevant_partitioning.push_back(stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0,n_u));</div><div class="line">  stokes_relevant_partitioning.push_back(stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u,n_u+n_p));</div><div class="line"></div><div class="line">  temperature_partitioning = temperature_dof_handler.locally_owned_dofs();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (temperature_dof_handler,</div><div class="line">                                           temperature_relevant_partitioning);</div><div class="line">}</div></div><!-- fragment --><p>Following this, we can compute constraints for the solution vectors, including hanging node constraints and homogeneous and inhomogeneous boundary values for the Stokes and temperature fields. Note that as for everything else, the constraint objects can not hold <em>all</em> constraints on every processor. Rather, each processor needs to store only those that are actually necessary for correctness given that it only assembles linear systems on cells it owns. As discussed in the <a class="el" href="DEALGlossary.html#distributed_paper">this paper</a>, the set of constraints we need to know about is exactly the set of constraints on all locally relevant degrees of freedom, so this is what we use to initialize the constraint objects.</p>
<div class="fragment"><div class="line">{</div><div class="line">  stokes_constraints.clear ();</div><div class="line">  stokes_constraints.reinit (stokes_relevant_set);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (stokes_dof_handler,</div><div class="line">                                           stokes_constraints);</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity_components(0);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (stokes_dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+1),</div><div class="line">                                            stokes_constraints,</div><div class="line">                                            stokes_fe.component_mask(velocity_components));</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">  no_normal_flux_boundaries.insert (1);</div><div class="line">  <a class="code" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">VectorTools::compute_no_normal_flux_constraints</a> (stokes_dof_handler, 0,</div><div class="line">                                                   no_normal_flux_boundaries,</div><div class="line">                                                   stokes_constraints,</div><div class="line">                                                   mapping);</div><div class="line">  stokes_constraints.close ();</div><div class="line">}</div><div class="line">{</div><div class="line">  temperature_constraints.clear ();</div><div class="line">  temperature_constraints.reinit (temperature_relevant_partitioning);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (temperature_dof_handler,</div><div class="line">                                           temperature_constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (temperature_dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                                            temperature_constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (temperature_dof_handler,</div><div class="line">                                            1,</div><div class="line">                                            EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                                            temperature_constraints);</div><div class="line">  temperature_constraints.close ();</div><div class="line">}</div></div><!-- fragment --><p>All this done, we can then initialize the various matrix and vector objects to their proper sizes. At the end, we also record that all matrices and preconditioners have to be re-computed at the beginning of the next time step. Note how we initialize the vectors for the Stokes and temperature right hand sides: These are writable vectors (last boolean argument set to <code>true</code>) that have the correct one-to-one partitioning of locally owned elements but are still given the relevant partitioning for means of figuring out the vector entries that are going to be set right away. As for matrices, this allows for writing local contributions into the vector with multiple threads (always assuming that the same vector entry is not accessed by multiple threads at the same time). The other vectors only allow for read access of individual elements, including ghosts, but are not suitable for solvers.</p>
<div class="fragment"><div class="line">  setup_stokes_matrix (stokes_partitioning, stokes_relevant_partitioning);</div><div class="line">  setup_stokes_preconditioner (stokes_partitioning,</div><div class="line">                               stokes_relevant_partitioning);</div><div class="line">  setup_temperature_matrices (temperature_partitioning,</div><div class="line">                              temperature_relevant_partitioning);</div><div class="line"></div><div class="line">  stokes_rhs.reinit (stokes_partitioning, stokes_relevant_partitioning,</div><div class="line">                     MPI_COMM_WORLD, <span class="keyword">true</span>);</div><div class="line">  stokes_solution.reinit (stokes_relevant_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_stokes_solution.reinit (stokes_solution);</div><div class="line"></div><div class="line">  temperature_rhs.reinit (temperature_partitioning,</div><div class="line">                          temperature_relevant_partitioning,</div><div class="line">                          MPI_COMM_WORLD, <span class="keyword">true</span>);</div><div class="line">  temperature_solution.reinit (temperature_relevant_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_temperature_solution.reinit (temperature_solution);</div><div class="line">  old_old_temperature_solution.reinit (temperature_solution);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix              = <span class="keyword">true</span>;</div><div class="line">  rebuild_stokes_preconditioner      = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_matrices       = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  computing_timer.exit_section();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheBoussinesqFlowProblemassemblyfunctions"></a> </p><h4>The BoussinesqFlowProblem assembly functions</h4>
<p>Following the discussion in the introduction and in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> module, we split the assembly functions into different parts:</p>
<ul>
<li>
<p class="startli">The local calculations of matrices and right hand sides, given a certain cell as input (these functions are named <code>local_assemble_*</code> below). The resulting function is, in other words, essentially the body of the loop over all cells in <a class="el" href="step_31.html">step-31</a>. Note, however, that these functions store the result from the local calculations in variables of classes from the CopyData namespace.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">These objects are then given to the second step which writes the local data into the global data structures (these functions are named <code>copy_local_to_global_*</code> below). These functions are pretty trivial.</p>
<p class="endli"></p>
</li>
<li>
These two subfunctions are then used in the respective assembly routine (called <code>assemble_*</code> below), where a <a class="el" href="namespaceWorkStream.html">WorkStream</a> object is set up and runs over all the cells that belong to the processor's subdomain. </li>
</ul>
<p><a class="anchor" id="Stokespreconditionerassembly"></a> </p><h5>Stokes preconditioner assembly</h5>
<p>Let us start with the functions that builds the Stokes preconditioner. The first two of these are pretty trivial, given the discussion above. Note in particular that the main point in using the scratch data object is that we want to avoid allocating any objects on the free space each time we visit a new cell. As a consequence, the assembly function below only has automatic local variables, and everything else is accessed through the scratch data object, which is allocated only once before we start the loop over all cells:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">local_assemble_stokes_preconditioner (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                      Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;scratch,</div><div class="line">                                      Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = stokes_fe.dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values.reinit (cell);</div><div class="line">  cell-&gt;get_dof_indices (data.local_dof_indices);</div><div class="line"></div><div class="line">  data.local_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.grad_phi_u[k] = scratch.stokes_fe_values[velocities].gradient(k,q);</div><div class="line">          scratch.phi_p[k]      = scratch.stokes_fe_values[pressure].value (k, q);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">          data.local_matrix(i,j) += (EquationData::eta *</div><div class="line">                                     <a class="code" href="classSymmetricTensor.html#a46543b446a9cef02b1aeaf2f9b5739ba">scalar_product</a> (scratch.grad_phi_u[i],</div><div class="line">                                                     scratch.grad_phi_u[j])</div><div class="line">                                     +</div><div class="line">                                     (1./EquationData::eta) *</div><div class="line">                                     EquationData::pressure_scaling *</div><div class="line">                                     EquationData::pressure_scaling *</div><div class="line">                                     (scratch.phi_p[i] * scratch.phi_p[j]))</div><div class="line">                                    * scratch.stokes_fe_values.JxW(q);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">copy_local_to_global_stokes_preconditioner (<span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  stokes_constraints.distribute_local_to_global (data.local_matrix,</div><div class="line">                                                 data.local_dof_indices,</div><div class="line">                                                 stokes_preconditioner_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Now for the function that actually puts things together, using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> functions. <a class="el" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a> needs a start and end iterator to enumerate the cells it is supposed to work on. Typically, one would use <a class="el" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">DoFHandler::begin_active()</a> and <a class="el" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">DoFHandler::end()</a> for that but here we actually only want the subset of cells that in fact are owned by the current processor. This is where the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> class comes into play: you give it a range of cells and it provides an iterator that only iterates over that subset of cells that satisfy a certain predicate (a predicate is a function of one argument that either returns true or false). The predicate we use here is <a class="el" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>, i.e., it returns true exactly if the cell is owned by the current processor. The resulting iterator range is then exactly what we need.</p>
<p>With this obstacle out of the way, we call the <a class="el" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a> function with this set of cells, scratch and copy objects, and with pointers to two functions: the local assembly and copy-local-to-global function. These functions need to have very specific signatures: three arguments in the first and one argument in the latter case (see the documentation of the <a class="el" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a> function for the meaning of these arguments). Note how we use the construct <code>std::bind</code> to create a function object that satisfies this requirement. It uses placeholders <code>std::placeholders::_1, std::placeholders::_2, std::placeholders::_3</code> for the local assembly function that specify cell, scratch data, and copy data, as well as the placeholder <code>std::placeholders::_1</code> for the copy function that expects the data to be written into the global matrix (for placeholder arguments, also see the discussion in <a class="el" href="step_13.html">step-13</a>'s <code>assemble_linear_system()</code> function). On the other hand, the implicit zeroth argument of member functions (namely the <code>this</code> pointer of the object on which that member function is to operate on) is <em>bound</em> to the <code>this</code> pointer of the current function. The <a class="el" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a> function, as a consequence, does not need to know anything about the object these functions work on.</p>
<p>When the <a class="el" href="namespaceWorkStream.html">WorkStream</a> is executed, it will create several local assembly routines of the first kind for several cells and let some available processors work on them. The function that needs to be synchronized, i.e., the write operation into the global matrix, however, is executed by only one thread at a time in the prescribed order. Of course, this only holds for the parallelization on a single MPI process. Different MPI processes will have their own <a class="el" href="namespaceWorkStream.html">WorkStream</a> objects and do that work completely independently (and in different memory spaces). In a distributed calculation, some data will accumulate at degrees of freedom that are not owned by the respective processor. It would be inefficient to send data around every time we encounter such a dof. What happens instead is that the Trilinos sparse matrix will keep that data and send it to the owner at the end of assembly, by calling the <code>compress()</code> command.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner ()</div><div class="line">{</div><div class="line">  stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree+1);</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span></div><div class="line">  <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  CellFilter;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::</a></div><div class="line"><a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">  run</a> (CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                   stokes_dof_handler.begin_active()),</div><div class="line">       CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                   stokes_dof_handler.end()),</div><div class="line">       std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                  local_assemble_stokes_preconditioner,</div><div class="line">                  <span class="keyword">this</span>,</div><div class="line">                  std::placeholders::_1,</div><div class="line">                  std::placeholders::_2,</div><div class="line">                  std::placeholders::_3),</div><div class="line">       std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                  copy_local_to_global_stokes_preconditioner,</div><div class="line">                  <span class="keyword">this</span>,</div><div class="line">                  std::placeholders::_1),</div><div class="line">       Assembly::Scratch::</div><div class="line">       StokesPreconditioner&lt;dim&gt; (stokes_fe, quadrature_formula,</div><div class="line">                                  mapping,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>),</div><div class="line">       Assembly::CopyData::</div><div class="line">       StokesPreconditioner&lt;dim&gt; (stokes_fe));</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>The final function in this block initiates assembly of the Stokes preconditioner matrix and then in fact builds the Stokes preconditioner. It is mostly the same as in the serial case. The only difference to <a class="el" href="step_31.html">step-31</a> is that we use a Jacobi preconditioner for the pressure mass matrix instead of IC, as discussed in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  computing_timer.enter_section (<span class="stringliteral">&quot;   Build Stokes preconditioner&quot;</span>);</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  assemble_stokes_preconditioner ();</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;bool&gt; &gt; constant_modes;</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity_components(0);</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a195771d57320e298e232e3b4aa922ff8">DoFTools::extract_constant_modes</a> (stokes_dof_handler,</div><div class="line">                                    stokes_fe.component_mask(velocity_components),</div><div class="line">                                    constant_modes);</div><div class="line"></div><div class="line">  Mp_preconditioner.reset  (<span class="keyword">new</span> <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>());</div><div class="line">  Amg_preconditioner.reset (<span class="keyword">new</span> TrilinosWrappers::PreconditionAMG());</div><div class="line"></div><div class="line">  <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> Amg_data;</div><div class="line">  Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div><div class="line">  Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a> = <span class="keyword">true</span>;</div><div class="line">  Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a8bb24e061826fbdfb49aeb24f80e02fd">higher_order_elements</a> = <span class="keyword">true</span>;</div><div class="line">  Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a> = 2;</div><div class="line">  Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 0.02;</div><div class="line"></div><div class="line">  Mp_preconditioner-&gt;initialize (stokes_preconditioner_matrix.block(1,1));</div><div class="line">  Amg_preconditioner-&gt;initialize (stokes_preconditioner_matrix.block(0,0),</div><div class="line">                                  Amg_data);</div><div class="line"></div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">  computing_timer.exit_section();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Stokessystemassembly"></a> </p><h5>Stokes system assembly</h5>
<p>The next three functions implement the assembly of the Stokes system, again split up into a part performing local calculations, one for writing the local data into the global matrix and vector, and one for actually running the loop over all cells with the help of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class. Note that the assembly of the Stokes matrix needs only to be done in case we have changed the mesh. Otherwise, just the (temperature-dependent) right hand side needs to be calculated here. Since we are working with distributed matrices and vectors, we have to call the respective <code>compress()</code> functions in the end of the assembly in order to send non-local data to the owner process.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">local_assemble_stokes_system (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                              Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;scratch,</div><div class="line">                              Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.stokes_fe_values.get_fe().dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values.reinit (cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  temperature_cell (&amp;triangulation,</div><div class="line">                    cell-&gt;level(),</div><div class="line">                    cell-&gt;index(),</div><div class="line">                    &amp;temperature_dof_handler);</div><div class="line">  scratch.temperature_fe_values.reinit (temperature_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">    data.local_matrix = 0;</div><div class="line">  data.local_rhs = 0;</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_values (old_temperature_solution,</div><div class="line">                                                     scratch.old_temperature_values);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = scratch.old_temperature_values[q];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.phi_u[k] = scratch.stokes_fe_values[velocities].value (k,q);</div><div class="line">          <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">            {</div><div class="line">              scratch.grads_phi_u[k] = scratch.stokes_fe_values[velocities].symmetric_gradient(k,q);</div><div class="line">              scratch.div_phi_u[k]   = scratch.stokes_fe_values[velocities].divergence (k, q);</div><div class="line">              scratch.phi_p[k]       = scratch.stokes_fe_values[pressure].value (k, q);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            data.local_matrix(i,j) += (EquationData::eta * 2 *</div><div class="line">                                       (scratch.grads_phi_u[i] * scratch.grads_phi_u[j])</div><div class="line">                                       - (EquationData::pressure_scaling *</div><div class="line">                                          scratch.div_phi_u[i] * scratch.phi_p[j])</div><div class="line">                                       - (EquationData::pressure_scaling *</div><div class="line">                                          scratch.phi_p[i] * scratch.div_phi_u[j]))</div><div class="line">                                      * scratch.stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a></div><div class="line">      gravity = EquationData::gravity_vector (scratch.stokes_fe_values</div><div class="line">                                              .quadrature_point(q));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        data.local_rhs(i) += (EquationData::density(old_temperature) *</div><div class="line">                              gravity  *</div><div class="line">                              scratch.phi_u[i]) *</div><div class="line">                             scratch.stokes_fe_values.JxW(q);</div><div class="line">    }</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices (data.local_dof_indices);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">copy_local_to_global_stokes_system (<span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_constraints.distribute_local_to_global (data.local_matrix,</div><div class="line">                                                   data.local_rhs,</div><div class="line">                                                   data.local_dof_indices,</div><div class="line">                                                   stokes_matrix,</div><div class="line">                                                   stokes_rhs);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    stokes_constraints.distribute_local_to_global (data.local_rhs,</div><div class="line">                                                   data.local_dof_indices,</div><div class="line">                                                   stokes_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system ()</div><div class="line">{</div><div class="line">  computing_timer.enter_section (<span class="stringliteral">&quot;   Assemble Stokes system&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix=0;</div><div class="line"></div><div class="line">  stokes_rhs=0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree+1);</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span></div><div class="line">  <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  CellFilter;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::</a></div><div class="line"><a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">  run</a> (CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                   stokes_dof_handler.begin_active()),</div><div class="line">       CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                   stokes_dof_handler.end()),</div><div class="line">       std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                  local_assemble_stokes_system,</div><div class="line">                  <span class="keyword">this</span>,</div><div class="line">                  std::placeholders::_1,</div><div class="line">                  std::placeholders::_2,</div><div class="line">                  std::placeholders::_3),</div><div class="line">       std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                  copy_local_to_global_stokes_system,</div><div class="line">                  <span class="keyword">this</span>,</div><div class="line">                  std::placeholders::_1),</div><div class="line">       Assembly::Scratch::</div><div class="line">       StokesSystem&lt;dim&gt; (stokes_fe, mapping, quadrature_formula,</div><div class="line">                          (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                           (rebuild_stokes_matrix == <span class="keyword">true</span></div><div class="line">                            ?</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="line">                            :</div><div class="line">                            <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0))),</div><div class="line">                          temperature_fe,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>),</div><div class="line">       Assembly::CopyData::</div><div class="line">       StokesSystem&lt;dim&gt; (stokes_fe));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  stokes_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">  computing_timer.exit_section();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Temperaturematrixassembly"></a> </p><h5>Temperature matrix assembly</h5>
<p>The task to be performed by the next three functions is to calculate a mass matrix and a Laplace matrix on the temperature system. These will be combined in order to yield the semi-implicit time stepping matrix that consists of the mass matrix plus a time step-dependent weight factor times the Laplace matrix. This function is again essentially the body of the loop over all cells from <a class="el" href="step_31.html">step-31</a>.</p>
<p>The two following functions perform similar services as the ones above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">local_assemble_temperature_matrix (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                   Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;scratch,</div><div class="line">                                   Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.temperature_fe_values.get_fe().dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.reinit (cell);</div><div class="line">  cell-&gt;get_dof_indices (data.local_dof_indices);</div><div class="line"></div><div class="line">  data.local_mass_matrix = 0;</div><div class="line">  data.local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.grad_phi_T[k] = scratch.temperature_fe_values.shape_grad (k,q);</div><div class="line">          scratch.phi_T[k]      = scratch.temperature_fe_values.shape_value (k, q);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">          {</div><div class="line">            data.local_mass_matrix(i,j)</div><div class="line">            += (scratch.phi_T[i] * scratch.phi_T[j]</div><div class="line">                *</div><div class="line">                scratch.temperature_fe_values.JxW(q));</div><div class="line">            data.local_stiffness_matrix(i,j)</div><div class="line">            += (EquationData::kappa * scratch.grad_phi_T[i] * scratch.grad_phi_T[j]</div><div class="line">                *</div><div class="line">                scratch.temperature_fe_values.JxW(q));</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">copy_local_to_global_temperature_matrix (<span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  temperature_constraints.distribute_local_to_global (data.local_mass_matrix,</div><div class="line">                                                      data.local_dof_indices,</div><div class="line">                                                      temperature_mass_matrix);</div><div class="line">  temperature_constraints.distribute_local_to_global (data.local_stiffness_matrix,</div><div class="line">                                                      data.local_dof_indices,</div><div class="line">                                                      temperature_stiffness_matrix);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  computing_timer.enter_section (<span class="stringliteral">&quot;   Assemble temperature matrices&quot;</span>);</div><div class="line">  temperature_mass_matrix = 0;</div><div class="line">  temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree+2);</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span></div><div class="line">  <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  CellFilter;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::</a></div><div class="line"><a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">  run</a> (CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                   temperature_dof_handler.begin_active()),</div><div class="line">       CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                   temperature_dof_handler.end()),</div><div class="line">       std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                  local_assemble_temperature_matrix,</div><div class="line">                  <span class="keyword">this</span>,</div><div class="line">                  std::placeholders::_1,</div><div class="line">                  std::placeholders::_2,</div><div class="line">                  std::placeholders::_3),</div><div class="line">       std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                  copy_local_to_global_temperature_matrix,</div><div class="line">                  <span class="keyword">this</span>,</div><div class="line">                  std::placeholders::_1),</div><div class="line">       Assembly::Scratch::</div><div class="line">       TemperatureMatrix&lt;dim&gt; (temperature_fe, mapping, quadrature_formula),</div><div class="line">       Assembly::CopyData::</div><div class="line">       TemperatureMatrix&lt;dim&gt; (temperature_fe));</div><div class="line"></div><div class="line">  temperature_mass_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  temperature_stiffness_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  rebuild_temperature_matrices = <span class="keyword">false</span>;</div><div class="line">  rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  computing_timer.exit_section();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Temperaturerighthandsideassembly"></a> </p><h5>Temperature right hand side assembly</h5>
<p>This is the last assembly function. It calculates the right hand side of the temperature system, which includes the convection and the stabilization terms. It includes a lot of evaluations of old solutions at the quadrature points (which are necessary for calculating the artificial viscosity of stabilization), but is otherwise similar to the other assembly functions. Notice, once again, how we resolve the dilemma of having inhomogeneous boundary conditions, by just making a right hand side at this point (compare the comments for the <code>project()</code> function above): We create some matrix columns with exactly the values that would be entered for the temperature stiffness matrix, in case we have inhomogeneously constrained dofs. That will account for the correct balance of the right hand side vector with the matrix system of temperature.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">local_assemble_temperature_rhs (<span class="keyword">const</span> std::pair&lt;double,double&gt; global_T_range,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>                   global_max_velocity,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>                   global_entropy_variation,</div><div class="line">                                <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;scratch,</div><div class="line">                                Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.temperature_fe_values.get_fe().dofs_per_cell;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"></div><div class="line">  data.local_rhs = 0;</div><div class="line">  data.matrix_for_bc = 0;</div><div class="line">  cell-&gt;get_dof_indices (data.local_dof_indices);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.reinit (cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  stokes_cell (&amp;triangulation,</div><div class="line">               cell-&gt;level(),</div><div class="line">               cell-&gt;index(),</div><div class="line">               &amp;stokes_dof_handler);</div><div class="line">  scratch.stokes_fe_values.reinit (stokes_cell);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_values (old_temperature_solution,</div><div class="line">                                                     scratch.old_temperature_values);</div><div class="line">  scratch.temperature_fe_values.get_function_values (old_old_temperature_solution,</div><div class="line">                                                     scratch.old_old_temperature_values);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_gradients (old_temperature_solution,</div><div class="line">                                                        scratch.old_temperature_grads);</div><div class="line">  scratch.temperature_fe_values.get_function_gradients (old_old_temperature_solution,</div><div class="line">                                                        scratch.old_old_temperature_grads);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_laplacians (old_temperature_solution,</div><div class="line">                                                         scratch.old_temperature_laplacians);</div><div class="line">  scratch.temperature_fe_values.get_function_laplacians (old_old_temperature_solution,</div><div class="line">                                                         scratch.old_old_temperature_laplacians);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values[velocities].get_function_values (stokes_solution,</div><div class="line">                                                            scratch.old_velocity_values);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_values (old_stokes_solution,</div><div class="line">                                                            scratch.old_old_velocity_values);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_symmetric_gradients (stokes_solution,</div><div class="line">      scratch.old_strain_rates);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_symmetric_gradients (old_stokes_solution,</div><div class="line">      scratch.old_old_strain_rates);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> nu</div><div class="line">    = compute_viscosity (scratch.old_temperature_values,</div><div class="line">                         scratch.old_old_temperature_values,</div><div class="line">                         scratch.old_temperature_grads,</div><div class="line">                         scratch.old_old_temperature_grads,</div><div class="line">                         scratch.old_temperature_laplacians,</div><div class="line">                         scratch.old_old_temperature_laplacians,</div><div class="line">                         scratch.old_velocity_values,</div><div class="line">                         scratch.old_old_velocity_values,</div><div class="line">                         scratch.old_strain_rates,</div><div class="line">                         scratch.old_old_strain_rates,</div><div class="line">                         global_max_velocity,</div><div class="line">                         global_T_range.second - global_T_range.first,</div><div class="line">                         0.5 * (global_T_range.second + global_T_range.first),</div><div class="line">                         global_entropy_variation,</div><div class="line">                         cell-&gt;diameter());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.phi_T[k]      = scratch.temperature_fe_values.shape_value (k, q);</div><div class="line">          scratch.grad_phi_T[k] = scratch.temperature_fe_values.shape_grad (k,q);</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs</div><div class="line">        = (use_bdf2_scheme ?</div><div class="line">           (scratch.old_temperature_values[q] *</div><div class="line">            (1 + time_step/old_time_step)</div><div class="line">            -</div><div class="line">            scratch.old_old_temperature_values[q] *</div><div class="line">            (time_step * time_step) /</div><div class="line">            (old_time_step * (time_step + old_time_step)))</div><div class="line">           :</div><div class="line">           scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> ext_T</div><div class="line">        = (use_bdf2_scheme ?</div><div class="line">           (scratch.old_temperature_values[q] *</div><div class="line">            (1 + time_step/old_time_step)</div><div class="line">            -</div><div class="line">            scratch.old_old_temperature_values[q] *</div><div class="line">            time_step/old_time_step)</div><div class="line">           :</div><div class="line">           scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> ext_grad_T</div><div class="line">        = (use_bdf2_scheme ?</div><div class="line">           (scratch.old_temperature_grads[q] *</div><div class="line">            (1 + time_step/old_time_step)</div><div class="line">            -</div><div class="line">            scratch.old_old_temperature_grads[q] *</div><div class="line">            time_step/old_time_step)</div><div class="line">           :</div><div class="line">           scratch.old_temperature_grads[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> extrapolated_u</div><div class="line">        = (use_bdf2_scheme ?</div><div class="line">           (scratch.old_velocity_values[q] *</div><div class="line">            (1 + time_step/old_time_step)</div><div class="line">            -</div><div class="line">            scratch.old_old_velocity_values[q] *</div><div class="line">            time_step/old_time_step)</div><div class="line">           :</div><div class="line">           scratch.old_velocity_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> extrapolated_strain_rate</div><div class="line">        = (use_bdf2_scheme ?</div><div class="line">           (scratch.old_strain_rates[q] *</div><div class="line">            (1 + time_step/old_time_step)</div><div class="line">            -</div><div class="line">            scratch.old_old_strain_rates[q] *</div><div class="line">            time_step/old_time_step)</div><div class="line">           :</div><div class="line">           scratch.old_strain_rates[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma</div><div class="line">        = ((EquationData::radiogenic_heating * EquationData::density(ext_T)</div><div class="line">            +</div><div class="line">            2 * EquationData::eta * extrapolated_strain_rate * extrapolated_strain_rate) /</div><div class="line">           (EquationData::density(ext_T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          data.local_rhs(i) += (T_term_for_rhs * scratch.phi_T[i]</div><div class="line">                                -</div><div class="line">                                time_step *</div><div class="line">                                extrapolated_u * ext_grad_T * scratch.phi_T[i]</div><div class="line">                                -</div><div class="line">                                time_step *</div><div class="line">                                nu * ext_grad_T * scratch.grad_phi_T[i]</div><div class="line">                                +</div><div class="line">                                time_step *</div><div class="line">                                gamma * scratch.phi_T[i])</div><div class="line">                               *</div><div class="line">                               scratch.temperature_fe_values.JxW(q);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (temperature_constraints.is_inhomogeneously_constrained(data.local_dof_indices[i]))</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                data.matrix_for_bc(j,i) += (scratch.phi_T[i] * scratch.phi_T[j] *</div><div class="line">                                            (use_bdf2_scheme ?</div><div class="line">                                             ((2*time_step + old_time_step) /</div><div class="line">                                              (time_step + old_time_step)) : 1.)</div><div class="line">                                            +</div><div class="line">                                            scratch.grad_phi_T[i] *</div><div class="line">                                            scratch.grad_phi_T[j] *</div><div class="line">                                            EquationData::kappa *</div><div class="line">                                            time_step)</div><div class="line">                                           *</div><div class="line">                                           scratch.temperature_fe_values.JxW(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">copy_local_to_global_temperature_rhs (<span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  temperature_constraints.distribute_local_to_global (data.local_rhs,</div><div class="line">                                                      data.local_dof_indices,</div><div class="line">                                                      temperature_rhs,</div><div class="line">                                                      data.matrix_for_bc);</div><div class="line">}</div></div><!-- fragment --><p>In the function that runs the <a class="el" href="namespaceWorkStream.html">WorkStream</a> for actually calculating the right hand side, we also generate the final matrix. As mentioned above, it is a sum of the mass matrix and the Laplace matrix, times some time step-dependent weight. This weight is specified by the BDF-2 time integration scheme, see the introduction in <a class="el" href="step_31.html">step-31</a>. What is new in this tutorial program (in addition to the use of MPI parallelization and the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class), is that we now precompute the temperature preconditioner as well. The reason is that the setup of the Jacobi preconditioner takes a noticeable time compared to the solver because we usually only need between 10 and 20 iterations for solving the temperature system (this might sound strange, as Jacobi really only consists of a diagonal, but in Trilinos it is derived from more general framework for point relaxation preconditioners which is a bit inefficient). Hence, it is more efficient to precompute the preconditioner, even though the matrix entries may slightly change because the time step might change. This is not too big a problem because we remesh every few time steps (and regenerate the preconditioner then).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system (<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from (temperature_mass_matrix);</div><div class="line">      temperature_matrix *= (2*time_step + old_time_step) /</div><div class="line">                            (time_step + old_time_step);</div><div class="line">      temperature_matrix.add (time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from (temperature_mass_matrix);</div><div class="line">      temperature_matrix.add (time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_preconditioner == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      T_preconditioner.reset (<span class="keyword">new</span> <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>());</div><div class="line">      T_preconditioner-&gt;initialize (temperature_matrix);</div><div class="line">      rebuild_temperature_preconditioner = <span class="keyword">false</span>;</div><div class="line">    }</div></div><!-- fragment --><p>The next part is computing the right hand side vectors. To do so, we first compute the average temperature <img class="formulaInl" alt="$T_m$" src="form_2718.png"/> that we use for evaluating the artificial viscosity stabilization through the residual <img class="formulaInl" alt="$E(T) = (T-T_m)^2$" src="form_2796.png"/>. We do this by defining the midpoint between maximum and minimum temperature as average temperature in the definition of the entropy viscosity. An alternative would be to use the integral average, but the results are not very sensitive to this choice. The rest then only requires calling <a class="el" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a> again, binding the arguments to the <code>local_assemble_temperature_rhs</code> function that are the same in every call to the correct values:</p>
<div class="fragment"><div class="line">  temperature_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree+2);</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double,double&gt;</div><div class="line">  global_T_range = get_extrapolated_temperature_range();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature = 0.5 * (global_T_range.first +</div><div class="line">                                            global_T_range.second);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_entropy_variation =</div><div class="line">    get_entropy_variation (average_temperature);</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span></div><div class="line">  <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  CellFilter;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::</a></div><div class="line"><a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">  run</a> (CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                   temperature_dof_handler.begin_active()),</div><div class="line">       CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                   temperature_dof_handler.end()),</div><div class="line">       std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                  local_assemble_temperature_rhs,</div><div class="line">                  <span class="keyword">this</span>,</div><div class="line">                  global_T_range,</div><div class="line">                  maximal_velocity,</div><div class="line">                  global_entropy_variation,</div><div class="line">                  std::placeholders::_1,</div><div class="line">                  std::placeholders::_2,</div><div class="line">                  std::placeholders::_3),</div><div class="line">       std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                  copy_local_to_global_temperature_rhs,</div><div class="line">                  <span class="keyword">this</span>,</div><div class="line">                  std::placeholders::_1),</div><div class="line">       Assembly::Scratch::</div><div class="line">       TemperatureRHS&lt;dim&gt; (temperature_fe, stokes_fe, mapping,</div><div class="line">                            quadrature_formula),</div><div class="line">       Assembly::CopyData::</div><div class="line">       TemperatureRHS&lt;dim&gt; (temperature_fe));</div><div class="line"></div><div class="line">  temperature_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemsolve"></a> </p><h4>BoussinesqFlowProblem::solve</h4>
<p>This function solves the linear systems in each time step of the Boussinesq problem. First, we work on the Stokes system and then on the temperature system. In essence, it does the same things as the respective function in <a class="el" href="step_31.html">step-31</a>. However, there are a few changes here.</p>
<p>The first change is related to the way we store our solution: we keep the vectors with locally owned degrees of freedom plus ghost nodes on each MPI node. When we enter a solver which is supposed to perform matrix-vector products with a distributed matrix, this is not the appropriate form, though. There, we will want to have the solution vector to be distributed in the same way as the matrix, i.e. without any ghosts. So what we do first is to generate a distributed vector called <code>distributed_stokes_solution</code> and put only the locally owned dofs into that, which is neatly done by the <code>operator=</code> of the Trilinos vector.</p>
<p>Next, we scale the pressure solution (or rather, the initial guess) for the solver so that it matches with the length scales in the matrices, as discussed in the introduction. We also immediately scale the pressure solution back to the correct units after the solution is completed. We also need to set the pressure values at hanging nodes to zero. This we also did in <a class="el" href="step_31.html">step-31</a> in order not to disturb the Schur complement by some vector entries that actually are irrelevant during the solve stage. As a difference to <a class="el" href="step_31.html">step-31</a>, here we do it only for the locally owned pressure dofs. After solving for the Stokes solution, each processor copies the distributed solution back into the solution vector that also includes ghost elements.</p>
<p>The third and most obvious change is that we have two variants for the Stokes solver: A fast solver that sometimes breaks down, and a robust solver that is slower. This is what we already discussed in the introduction. Here is how we realize it: First, we perform 30 iterations with the fast solver based on the simple preconditioner based on the AMG V-cycle instead of an approximate solve (this is indicated by the <code>false</code> argument to the <code>LinearSolvers::BlockSchurPreconditioner</code> object). If we converge, everything is fine. If we do not converge, the solver control object will throw an exception <a class="el" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a>. Usually, this would abort the program because we don't catch them in our usual <code>solve()</code> functions. This is certainly not what we want to happen here. Rather, we want to switch to the strong solver and continue the solution process with whatever vector we got so far. Hence, we catch the exception with the C++ try/catch mechanism. We then simply go through the same solver sequence again in the <code>catch</code> clause, this time passing the <code>true</code> flag to the preconditioner for the strong solver, signaling an approximate CG solve.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  computing_timer.enter_section (<span class="stringliteral">&quot;   Solve Stokes system&quot;</span>);</div><div class="line"></div><div class="line">  {</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solving Stokes system... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a></div><div class="line">    distributed_stokes_solution (stokes_rhs);</div><div class="line">    distributed_stokes_solution = stokes_solution;</div><div class="line"></div><div class="line">    distributed_stokes_solution.block(1) /= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    start = (distributed_stokes_solution.block(0).size() +</div><div class="line">             distributed_stokes_solution.block(1).local_range().first),</div><div class="line">            end   = (distributed_stokes_solution.block(0).size() +</div><div class="line">                     distributed_stokes_solution.block(1).local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=start; i&lt;end; ++i)</div><div class="line">      <span class="keywordflow">if</span> (stokes_constraints.is_constrained (i))</div><div class="line">        distributed_stokes_solution(i) = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classPrimitiveVectorMemory.html">PrimitiveVectorMemory&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> mem;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> solver_tolerance = 1e-8 * stokes_rhs.l2_norm();</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (30, solver_tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;TrilinosWrappers::PreconditionAMG,</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">              preconditioner (stokes_matrix, stokes_preconditioner_matrix,</div><div class="line">                              *Mp_preconditioner, *Amg_preconditioner,</div><div class="line">                              <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a></div><div class="line">        solver(solver_control, mem,</div><div class="line">               <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a>::</div><div class="line">               AdditionalData(30, <span class="keyword">true</span>));</div><div class="line">        solver.solve(stokes_matrix, distributed_stokes_solution, stokes_rhs,</div><div class="line">                     preconditioner);</div><div class="line"></div><div class="line">        n_iterations = solver_control.last_step();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">catch</span> (<a class="code" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a> &amp;)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;TrilinosWrappers::PreconditionAMG,</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">              preconditioner (stokes_matrix, stokes_preconditioner_matrix,</div><div class="line">                              *Mp_preconditioner, *Amg_preconditioner,</div><div class="line">                              <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control_refined (stokes_matrix.m(), solver_tolerance);</div><div class="line">        <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a></div><div class="line">        solver(solver_control_refined, mem,</div><div class="line">               <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a>::</div><div class="line">               AdditionalData(50, <span class="keyword">true</span>));</div><div class="line">        solver.solve(stokes_matrix, distributed_stokes_solution, stokes_rhs,</div><div class="line">                     preconditioner);</div><div class="line"></div><div class="line">        n_iterations = (solver_control.last_step() +</div><div class="line">                        solver_control_refined.last_step());</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    stokes_constraints.distribute (distributed_stokes_solution);</div><div class="line"></div><div class="line">    distributed_stokes_solution.block(1) *= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">    stokes_solution = distributed_stokes_solution;</div><div class="line">    pcout &lt;&lt; n_iterations  &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  computing_timer.exit_section();</div></div><!-- fragment --><p>Now let's turn to the temperature part: First, we compute the time step size. We found that we need smaller time steps for 3D than for 2D for the shell geometry. This is because the cells are more distorted in that case (it is the smallest edge length that determines the CFL number). Instead of computing the time step from maximum velocity and minimal mesh size as in <a class="el" href="step_31.html">step-31</a>, we compute local CFL numbers, i.e., on each cell we compute the maximum velocity times the mesh size, and compute the maximum of them. Hence, we need to choose the factor in front of the time step slightly smaller.</p>
<p>After temperature right hand side assembly, we solve the linear system for temperature (with fully distributed vectors without any ghosts), apply constraints and copy the vector back to one with ghosts.</p>
<p>In the end, we extract the temperature range similarly to <a class="el" href="step_31.html">step-31</a> to produce some output (for example in order to help us choose the stabilization constants, as discussed in the introduction). The only difference is that we need to exchange maxima over all processors.</p>
<div class="fragment"><div class="line">  computing_timer.enter_section (<span class="stringliteral">&quot;   Assemble temperature rhs&quot;</span>);</div><div class="line">  {</div><div class="line">    old_time_step = time_step;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> scaling = (dim==3 ? 0.25 : 1.0);</div><div class="line">    time_step = (scaling/(2.1*dim*std::sqrt(1.*dim)) /</div><div class="line">                 (parameters.temperature_degree *</div><div class="line">                  get_cfl_number()));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Maximal velocity: &quot;</span></div><div class="line">          &lt;&lt; maximal_velocity *EquationData::year_in_seconds * 100</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; cm/year&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span></div><div class="line">          &lt;&lt; time_step/EquationData::year_in_seconds</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; years&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    temperature_solution = old_temperature_solution;</div><div class="line">    assemble_temperature_system (maximal_velocity);</div><div class="line">  }</div><div class="line">  computing_timer.exit_section ();</div><div class="line"></div><div class="line">  computing_timer.enter_section (<span class="stringliteral">&quot;   Solve temperature system&quot;</span>);</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (temperature_matrix.m(),</div><div class="line">                                  1e-12*temperature_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a>   cg (solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="line">    distributed_temperature_solution (temperature_rhs);</div><div class="line">    distributed_temperature_solution = temperature_solution;</div><div class="line"></div><div class="line">    cg.solve (temperature_matrix, distributed_temperature_solution,</div><div class="line">              temperature_rhs, *T_preconditioner);</div><div class="line"></div><div class="line">    temperature_constraints.distribute (distributed_temperature_solution);</div><div class="line">    temperature_solution = distributed_temperature_solution;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_step()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature&quot;</span> &lt;&lt; std::endl;</div><div class="line">    computing_timer.exit_section();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> temperature[2] = { std::numeric_limits&lt;double&gt;::max(),</div><div class="line">                              -std::numeric_limits&lt;double&gt;::max()</div><div class="line">                            };</div><div class="line">    <span class="keywordtype">double</span> global_temperature[2];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=distributed_temperature_solution.local_range().first;</div><div class="line">         i &lt; distributed_temperature_solution.local_range().second; ++i)</div><div class="line">      {</div><div class="line">        temperature[0] = std::min&lt;double&gt; (temperature[0],</div><div class="line">                                           distributed_temperature_solution(i));</div><div class="line">        temperature[1] = std::max&lt;double&gt; (temperature[1],</div><div class="line">                                           distributed_temperature_solution(i));</div><div class="line">      }</div><div class="line"></div><div class="line">    temperature[0] *= -1.0;</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (temperature, MPI_COMM_WORLD, global_temperature);</div><div class="line">    global_temperature[0] *= -1.0;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span></div><div class="line">          &lt;&lt; global_temperature[0] &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; global_temperature[1]</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemoutput_results"></a> </p><h4>BoussinesqFlowProblem::output_results</h4>
<p>Next comes the function that generates the output. The quantities to output could be introduced manually like we did in <a class="el" href="step_31.html">step-31</a>. An alternative is to hand this task over to a class PostProcessor that inherits from the class <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>, which can be attached to <a class="el" href="classDataOut.html">DataOut</a>. This allows us to output derived quantities from the solution, like the friction heating included in this example. It overloads the virtual function <a class="el" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">DataPostprocessor::evaluate_vector_field()</a>, which is then internally called from <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches()</a>. We have to give it values of the numerical solution, its derivatives, normals to the cell, the actual evaluation points and any additional quantities. This follows the same procedure as discussed in <a class="el" href="step_29.html">step-29</a> and other programs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem&lt;dim&gt;::Postprocessor : <span class="keyword">public</span> <a class="code" href="classDataPostprocessor.html">DataPostprocessor</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Postprocessor (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partition,</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">evaluate_vector_field</a></div><div class="line">  (<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;               &amp;computed_quantities) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::vector&lt;std::string&gt; <a class="code" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names</a> () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  <a class="code" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">get_data_component_interpretation</a> () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="code" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags</a> () <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a4673bdd5ed26b4492008ac8366754f9d">partition</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::</div><div class="line">Postprocessor (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partition,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure)</div><div class="line">  :</div><div class="line">  partition (partition),</div><div class="line">  minimal_pressure (minimal_pressure)</div><div class="line">{}</div></div><!-- fragment --><p>Here we define the names for the variables we want to output. These are the actual solution values for velocity, pressure, and temperature, as well as the friction heating and to each cell the number of the processor that owns it. This allows us to visualize the partitioning of the domain among the processors. Except for the velocity, which is vector-valued, all other quantities are scalar.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;std::string&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_names()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names (dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.push_back (<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">  solution_names.push_back (<span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">  solution_names.push_back (<span class="stringliteral">&quot;friction_heating&quot;</span>);</div><div class="line">  solution_names.push_back (<span class="stringliteral">&quot;partition&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> solution_names;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::</div><div class="line">get_data_component_interpretation ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  interpretation (dim,</div><div class="line">                  <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">  interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> interpretation;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_needed_update_flags()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa49a49d892021457f921318905c408e25">update_q_points</a>;</div><div class="line">}</div></div><!-- fragment --><p>Now we implement the function that computes the derived quantities. As we also did for the output, we rescale the velocity from its SI units to something more readable, namely cm/year. Next, the pressure is scaled to be between 0 and the maximum pressure. This makes it more easily comparable &ndash; in essence making all pressure variables positive or zero. Temperature is taken as is, and the friction heating is computed as <img class="formulaInl" alt="$2 \eta \varepsilon(\mathbf{u}) \cdot \varepsilon(\mathbf{u})$" src="form_2797.png"/>.</p>
<p>The quantities we output here are more for illustration, rather than for actual scientific value. We come back to this briefly in the results section of this program and explain what one may in fact be interested in.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::</div><div class="line">evaluate_vector_field</div><div class="line">(<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line"> std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;               &amp;computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_quadrature_points = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size();</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>.size() == n_quadrature_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (computed_quantities.size() == n_quadrature_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[0].size() == dim+2,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_quadrature_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        computed_quantities[q](d)</div><div class="line">          = (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) *  EquationData::year_in_seconds * 100);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> pressure = (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim)-minimal_pressure);</div><div class="line">      computed_quantities[q](dim) = pressure;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim+1);</div><div class="line">      computed_quantities[q](dim+1) = temperature;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> grad_u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        grad_u[d] = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>[q][d];</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> strain_rate = <a class="code" href="classSymmetricTensor.html#a4acdda923e9b04d2d70308f3c095e12f">symmetrize</a> (grad_u);</div><div class="line">      computed_quantities[q](dim+2) = 2 * EquationData::eta *</div><div class="line">                                      strain_rate * strain_rate;</div><div class="line"></div><div class="line">      computed_quantities[q](dim+3) = partition;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The <code>output_results()</code> function has a similar task to the one in <a class="el" href="step_31.html">step-31</a>. However, here we are going to demonstrate a different technique on how to merge output from different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The way we're going to achieve this recombination is to create a joint <a class="el" href="classDoFHandler.html">DoFHandler</a> that collects both components, the Stokes solution and the temperature solution. This can be nicely done by combining the finite elements from the two systems to form one <a class="el" href="classFESystem.html">FESystem</a>, and let this collective system define a new <a class="el" href="classDoFHandler.html">DoFHandler</a> object. To be sure that everything was done correctly, we perform a sanity check that ensures that we got all the dofs from both Stokes and temperature even in the combined system. We then combine the data vectors. Unfortunately, there is no straight-forward relation that tells us how to sort Stokes and temperature vector into the joint vector. The way we can get around this trouble is to rely on the information collected in the <a class="el" href="classFESystem.html">FESystem</a>. For each dof on a cell, the joint finite element knows to which equation component (velocity component, pressure, or temperature) it belongs – that's the information we need! So we step through all cells (with iterators into all three DoFHandlers moving in sync), and for each joint cell dof, we read out that component using the <a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">FiniteElement::system_to_base_index</a> function (see there for a description of what the various parts of its return value contain). We also need to keep track whether we're on a Stokes dof or a temperature dof, which is contained in joint_fe.system_to_base_index(i).first.first. Eventually, the dof_indices data structures on either of the three systems tell us how the relation between global vector and local dofs looks like on the present cell, which concludes this tedious work. We make sure that each processor only works on the subdomain it owns locally (and not on ghost or artificial cells) when building the joint solution vector. The same will then have to be done in <a class="el" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">DataOut::build_patches()</a>, but that function does so automatically.</p>
<p>What we end up with is a set of patches that we can write using the functions in <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> in a variety of output formats. Here, we then have to pay attention that what each processor writes is really only its own part of the domain, i.e. we will want to write each processor's contribution into a separate file. This we do by adding an additional number to the filename when we write the solution. This is not really new, we did it similarly in <a class="el" href="step_40.html">step-40</a>. Note that we write in the compressed format <code></code>.vtu instead of plain vtk files, which saves quite some storage.</p>
<p>All the rest of the work is done in the PostProcessor class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results ()</div><div class="line">{</div><div class="line">  computing_timer.enter_section (<span class="stringliteral">&quot;Postprocessing&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe (stokes_fe, 1,</div><div class="line">                                temperature_fe, 1);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> joint_dof_handler (triangulation);</div><div class="line">  joint_dof_handler.distribute_dofs (joint_fe);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (joint_dof_handler.n_dofs() ==</div><div class="line">          stokes_dof_handler.n_dofs() + temperature_dof_handler.n_dofs(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> joint_solution;</div><div class="line">  joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a27a757b55f969defc53c7be563c819b0">reinit</a> (joint_dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices (joint_fe.dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_stokes_dof_indices (stokes_fe.dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_temperature_dof_indices (temperature_fe.dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    joint_cell       = joint_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    joint_endc       = joint_dof_handler.end(),</div><div class="line">    stokes_cell      = stokes_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    temperature_cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keywordflow">for</span> (; joint_cell!=joint_endc;</div><div class="line">         ++joint_cell, ++stokes_cell, ++temperature_cell)</div><div class="line">      <span class="keywordflow">if</span> (joint_cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          joint_cell-&gt;get_dof_indices (local_joint_dof_indices);</div><div class="line">          stokes_cell-&gt;get_dof_indices (local_stokes_dof_indices);</div><div class="line">          temperature_cell-&gt;get_dof_indices (local_temperature_dof_indices);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;joint_fe.dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (joint_fe.system_to_base_index(i).second</div><div class="line">                        &lt;</div><div class="line">                        local_stokes_dof_indices.size(),</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">                joint_solution(local_joint_dof_indices[i])</div><div class="line">                  = stokes_solution(local_stokes_dof_indices</div><div class="line">                                    [joint_fe.system_to_base_index(i).second]);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (joint_fe.system_to_base_index(i).second</div><div class="line">                        &lt;</div><div class="line">                        local_temperature_dof_indices.size(),</div><div class="line">                        <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i])</div><div class="line">                  = temperature_solution(local_temperature_dof_indices</div><div class="line">                                         [joint_fe.system_to_base_index(i).second]);</div><div class="line">              }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">  joint_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_joint_dofs(joint_dof_handler.n_dofs());</div><div class="line">  <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (joint_dof_handler, locally_relevant_joint_dofs);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_joint_solution;</div><div class="line">  locally_relevant_joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a27a757b55f969defc53c7be563c819b0">reinit</a> (locally_relevant_joint_dofs, MPI_COMM_WORLD);</div><div class="line">  locally_relevant_joint_solution = joint_solution;</div><div class="line"></div><div class="line">  Postprocessor postprocessor (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD),</div><div class="line">                               stokes_solution.block(1).min());</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (joint_dof_handler);</div><div class="line">  data_out.add_data_vector (locally_relevant_joint_solution, postprocessor);</div><div class="line">  data_out.build_patches ();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> out_index=0;</div><div class="line">  <span class="keyword">const</span> std::string filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (out_index, 5) +</div><div class="line">                                <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="line">                                (triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4) +</div><div class="line">                                <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  std::ofstream output (filename.c_str());</div><div class="line">  data_out.write_vtu (output);</div></div><!-- fragment --><p>At this point, all processors have written their own files to disk. We could visualize them individually in Visit or Paraview, but in reality we of course want to visualize the whole set of files at once. To this end, we create a master file in each of the formats understood by Visit (<code>.visit</code>) and Paraview (<code>.pvtu</code>) on the zeroth processor that describes how the individual files are defining the global data set.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;std::string&gt; filenames;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD); ++i)</div><div class="line">        filenames.push_back (std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (out_index, 5) +</div><div class="line">                             <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i, 4) +</div><div class="line">                             <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">      <span class="keyword">const</span> std::string</div><div class="line">      pvtu_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                              <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (out_index, 5) +</div><div class="line">                              <span class="stringliteral">&quot;.pvtu&quot;</span>);</div><div class="line">      std::ofstream pvtu_master (pvtu_master_filename.c_str());</div><div class="line">      data_out.write_pvtu_record (pvtu_master, filenames);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string</div><div class="line">      visit_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (out_index, 5) +</div><div class="line">                               <span class="stringliteral">&quot;.visit&quot;</span>);</div><div class="line">      std::ofstream visit_master (visit_master_filename.c_str());</div><div class="line">      <a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a> (visit_master, filenames);</div><div class="line">    }</div><div class="line"></div><div class="line">  computing_timer.exit_section ();</div><div class="line">  out_index++;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrefine_mesh"></a> </p><h4>BoussinesqFlowProblem::refine_mesh</h4>
<p>This function isn't really new either. Since the <code>setup_dofs</code> function that we call in the middle has its own timer section, we split timing this function into two sections. It will also allow us to easily identify which of the two is more expensive.</p>
<p>One thing of note, however, is that we only want to compute error indicators on the locally owned subdomain. In order to achieve this, we pass one additional argument to the <a class="el" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator::estimate</a> function. Note that the vector for error estimates is resized to the number of active cells present on the current process, which is less than the total number of active cells on all processors (but more than the number of locally owned active cells); each processor only has a few coarse cells around the locally owned ones, as also explained in <a class="el" href="step_40.html">step-40</a>.</p>
<p>The local error estimates are then handed to a parallel version of <a class="el" href="namespaceGridRefinement.html">GridRefinement</a> (in namespace <a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html">parallel::distributed::GridRefinement</a>, see also <a class="el" href="step_40.html">step-40</a>) which looks at the errors and finds the cells that need refinement by comparing the error values across processors. As in <a class="el" href="step_31.html">step-31</a>, we want to limit the maximum grid level. So in case some cells have been marked that are already at the finest level, we simply clear the refine flags.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::refine_mesh (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">{</div><div class="line">  computing_timer.enter_section (<span class="stringliteral">&quot;Refine mesh structure, part 1&quot;</span>);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (temperature_dof_handler,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(parameters.temperature_degree+1),</div><div class="line">                                      <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                      temperature_solution,</div><div class="line">                                      estimated_error_per_cell,</div><div class="line">                                      <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                      <span class="keyword">nullptr</span>,</div><div class="line">                                      0,</div><div class="line">                                      triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#a8fe97b1fc8f61b09d6a7c398a8b975ff">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#a8fe97b1fc8f61b09d6a7c398a8b975ff">  refine_and_coarsen_fixed_fraction</a> (triangulation,</div><div class="line">                                     estimated_error_per_cell,</div><div class="line">                                     0.3, 0.1);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(max_grid_level);</div><div class="line">         cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">      cell-&gt;clear_refine_flag ();</div></div><!-- fragment --><p>With all flags marked as necessary, we set up the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> object to transfer the solutions for the current time level and the next older one. The syntax is similar to the non-parallel solution transfer (with the exception that here a pointer to the vector entries is enough). The remainder of the function is concerned with setting up the data structures again after mesh refinement and restoring the solution vectors on the new mesh.</p>
<div class="fragment"><div class="line">std::vector&lt;const TrilinosWrappers::MPI::Vector *&gt; x_temperature (2);</div><div class="line">x_temperature[0] = &amp;temperature_solution;</div><div class="line">x_temperature[1] = &amp;old_temperature_solution;</div><div class="line">std::vector&lt;const TrilinosWrappers::MPI::BlockVector *&gt; x_stokes (2);</div><div class="line">x_stokes[0] = &amp;stokes_solution;</div><div class="line">x_stokes[1] = &amp;old_stokes_solution;</div><div class="line"></div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim,TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">temperature_trans(temperature_dof_handler);</div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim,TrilinosWrappers::MPI::BlockVector&gt;</a></div><div class="line">stokes_trans(stokes_dof_handler);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">computing_timer.exit_section();</div><div class="line"></div><div class="line">setup_dofs ();</div><div class="line"></div><div class="line">computing_timer.enter_section (<span class="stringliteral">&quot;Refine mesh structure, part 2&quot;</span>);</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp1 (temperature_rhs);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp2 (temperature_rhs);</div><div class="line"></div><div class="line">  std::vector&lt;TrilinosWrappers::MPI::Vector *&gt; tmp (2);</div><div class="line">  tmp[0] = &amp;(distributed_temp1);</div><div class="line">  tmp[1] = &amp;(distributed_temp2);</div><div class="line">  temperature_trans.interpolate(tmp);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">  temperature_constraints.distribute(distributed_temp1);</div><div class="line">  temperature_constraints.distribute(distributed_temp2);</div><div class="line"></div><div class="line">  temperature_solution     = distributed_temp1;</div><div class="line">  old_temperature_solution = distributed_temp2;</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes (stokes_rhs);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_distributed_stokes (stokes_rhs);</div><div class="line"></div><div class="line">  std::vector&lt;TrilinosWrappers::MPI::BlockVector *&gt; stokes_tmp (2);</div><div class="line">  stokes_tmp[0] = &amp;(distributed_stokes);</div><div class="line">  stokes_tmp[1] = &amp;(old_distributed_stokes);</div><div class="line"></div><div class="line">  stokes_trans.interpolate (stokes_tmp);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">    stokes_constraints.distribute(distributed_stokes);</div><div class="line">    stokes_constraints.distribute(old_distributed_stokes);</div><div class="line"></div><div class="line">    stokes_solution     = distributed_stokes;</div><div class="line">    old_stokes_solution = old_distributed_stokes;</div><div class="line">  }</div><div class="line"></div><div class="line">  computing_timer.exit_section();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrun"></a> </p><h4>BoussinesqFlowProblem::run</h4>
<p>This is the final and controlling function in this class. It, in fact, runs the entire rest of the program and is, once more, very similar to <a class="el" href="step_31.html">step-31</a>. We use a different mesh now (a <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> instead of a simple cube geometry), and use the <code>project_temperature_field()</code> function instead of the library function <code><a class="el" href="namespaceVectorTools.html#ac68694d99266fa35e252f424f35d9f95">VectorTools::project</a></code>. In this example, however, we define both a <a class="el" href="classSphericalManifold.html">SphericalManifold()</a> and a <a class="el" href="classHyperShellBoundary.html">HyperShellBoundary()</a> object to describe the geometry of the domain. The reason we do so here, is because we want to impose no normal flux boundary conditions, and they require knowledge of the normals to a boundary, which a <a class="el" href="classSphericalManifold.html">SphericalManifold()</a> alone cannot compute. Consequently, we set all manifold indicators of cells and adjacent edges to zero, then overwrite the manifold indicators of all boundary objects by one. We then associate a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object with the former, and the <a class="el" href="classHyperShellBoundary.html">HyperShellBoundary</a> object that can also provide normal vectors with the latter.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(),</div><div class="line">                                EquationData::R0,</div><div class="line">                                EquationData::R1,</div><div class="line">                                (dim==3) ? 96 : 12,</div><div class="line">                                <span class="keyword">true</span>);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(1);</div><div class="line">    <span class="keyword">static</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold;</div><div class="line">    <span class="keyword">static</span> <a class="code" href="classHyperShellBoundary.html">HyperShellBoundary&lt;dim&gt;</a> boundary;</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, manifold);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (1, boundary);</div><div class="line"></div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a> (triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (parameters.initial_global_refinement);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">start_time_iteration:</div><div class="line"></div><div class="line">    project_temperature_field ();</div><div class="line"></div><div class="line">    timestep_number           = 0;</div><div class="line">    time_step = old_time_step = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time/EquationData::year_in_seconds</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; years&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_stokes_system ();</div><div class="line">        build_stokes_preconditioner ();</div><div class="line">        assemble_temperature_matrix ();</div><div class="line"></div><div class="line">        solve ();</div><div class="line"></div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; parameters.initial_adaptive_refinement))</div><div class="line">          {</div><div class="line">            refine_mesh (parameters.initial_global_refinement +</div><div class="line">                         parameters.initial_adaptive_refinement);</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0)</div><div class="line">                 &amp;&amp;</div><div class="line">                 (timestep_number % parameters.adaptive_refinement_interval == 0))</div><div class="line">          refine_mesh (parameters.initial_global_refinement +</div><div class="line">                       parameters.initial_adaptive_refinement);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>)</div><div class="line">            &amp;&amp;</div><div class="line">            (timestep_number % parameters.graphical_output_interval == 0))</div><div class="line">          output_results ();</div></div><!-- fragment --><p>In order to speed up linear solvers, we extrapolate the solutions from the old time levels to the new one. This gives a very good initial guess, cutting the number of iterations needed in solvers by more than one half. We do not need to extrapolate in the last iteration, so if we reached the final time, we stop here.</p>
<p>As the last thing during a time step (before actually bumping up the number of the time step), we check whether the current time step number is divisible by 100, and if so we let the computing timer print a summary of CPU times spent so far.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (time &gt; parameters.end_time * EquationData::year_in_seconds)</div><div class="line">  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_old_stokes_solution;</div><div class="line">old_old_stokes_solution      = old_stokes_solution;</div><div class="line">old_stokes_solution          = stokes_solution;</div><div class="line">old_old_temperature_solution = old_temperature_solution;</div><div class="line">old_temperature_solution     = temperature_solution;</div><div class="line"><span class="keywordflow">if</span> (old_time_step &gt; 0)</div><div class="line">  {</div></div><!-- fragment --><p>Trilinos sadd does not like ghost vectors even as input. Copy into distributed vectors for now:</p>
<div class="fragment"><div class="line">        {</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_solution (stokes_rhs);</div><div class="line">          distr_solution = stokes_solution;</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_old_solution (stokes_rhs);</div><div class="line">          distr_old_solution = old_old_stokes_solution;</div><div class="line">          distr_solution .<a class="code" href="classBlockVectorBase.html#a71b0ab8295e98caf3dfe1ef14ae6b6c1">sadd</a> (1.+time_step/old_time_step, -time_step/old_time_step,</div><div class="line">                                distr_old_solution);</div><div class="line">          stokes_solution = distr_solution;</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_solution (temperature_rhs);</div><div class="line">          distr_solution = temperature_solution;</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_old_solution (temperature_rhs);</div><div class="line">          distr_old_solution = old_old_temperature_solution;</div><div class="line">          distr_solution .sadd (1.+time_step/old_time_step, -time_step/old_time_step,</div><div class="line">                                distr_old_solution);</div><div class="line">          temperature_solution = distr_solution;</div><div class="line">        }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 100 == 0))</div><div class="line">      computing_timer.print_summary ();</div><div class="line"></div><div class="line">    time += time_step;</div><div class="line">    ++timestep_number;</div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>);</div></div><!-- fragment --><p>If we are generating graphical output, do so also for the last time step unless we had just done so before we left the do-while loop</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>)</div><div class="line">        &amp;&amp;</div><div class="line">        !((timestep_number-1) % parameters.graphical_output_interval == 0))</div><div class="line">      output_results ();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>The main function is short as usual and very similar to the one in <a class="el" href="step_31.html">step-31</a>. Since we use a parameter file which is specified as an argument in the command line, we have to read it in here and pass it on to the Parameters class for parsing. If no filename is given in the command line, we simply use the <code>step-32.prm</code> file which is distributed together with the program.</p>
<p>Because 3d computations are simply very slow unless you throw a lot of processors at them, the program defaults to 2d. You can get the 3d version by changing the constant dimension below to 3.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>Step32;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv,</div><div class="line">                                                      <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      std::string parameter_filename;</div><div class="line">      <span class="keywordflow">if</span> (argc&gt;=2)</div><div class="line">        parameter_filename = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_filename = <span class="stringliteral">&quot;step-32.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt;::Parameters  parameters(parameter_filename);</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt; flow_problem (parameters);</div><div class="line">      flow_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When run, the program simulates convection in 3d in much the same way as <a class="el" href="step_31.html">step-31</a> did, though with an entirely different testcase.</p>
<p><a class="anchor" id="Comparisonofresultswithstep31"></a></p><h3>Comparison of results with step-31</h3>
<p>Before we go to this testcase, however, let us show a few results from a slightly earlier version of this program that was solving exactly the testcase we used in <a class="el" href="step_31.html">step-31</a>, just that we now solve it in parallel and with much higher resolution. We show these results mainly for comparison.</p>
<p>Here are two images that show this higher resolution if we choose a 3d computation in <code>main()</code> and if we set <code>initial_refinement=3</code> and <code>n_pre_refinement_steps=4</code>. At the time steps shown, the meshes had around 72,000 and 236,000 cells, for a total of 2,680,000 and 8,250,000 degrees of freedom, respectively, more than an order of magnitude more than we had available in <a class="el" href="step_31.html">step-31</a>:</p>
<table align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d.cube.0.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d.cube.1.png"/>
</div>
   </td></tr>
</table>
<p>The computation was done on a subset of 50 processors of the Brazos cluster at Texas A&amp;M University.</p>
<p><a class="anchor" id="Resultsfora2dcircularshelltestcase"></a></p><h3>Results for a 2d circular shell testcase</h3>
<p>Next, we will run <a class="el" href="step_32.html">step-32</a> with the parameter file in the directory. Here we are using 50 processors. The command to launch is (note that <a class="el" href="step_32.html">step-32</a>.prm is the default):</p>
<p><code> </p><pre>
$ mpirun -np 50 ./step-32
</pre><p> </code></p>
<p>Note that running a job on a cluster typically requires going through a job scheduler, which we won't discuss here. The output will look roughly like this:</p>
<p><code> </p><pre>
Number of active cells: 12,288 (on 6 levels)
Number of degrees of freedom: 186,624 (99,840+36,864+49,920)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0 years</pre><p></code></p>
<p><code></p><pre>   Rebuilding Stokes preconditioner...
   Solving Stokes system... 40 iterations.
   Maximal velocity: 60.4935 cm/year
   Time step: 18166.9 years
   17 CG iterations for temperature
   Temperature range: 973 4273.16</pre><p></code></p>
<p><code></p><pre>Number of active cells: 16,389 (on 7 levels)
Number of degrees of freedom: 259,617 (140,300+49,167+70,150)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0 years</pre><p></code></p>
<p><code></p><pre>   Rebuilding Stokes preconditioner...
   Solving Stokes system... 49 iterations.
   Maximal velocity: 60.5202 cm/year
   Time step: 10619.2 years
   19 CG iterations for temperature
   Temperature range: 973 4273.16</pre><p></code></p>
<p><code></p><pre>Number of active cells: 20,124 (on 8 levels)
Number of degrees of freedom: 323,145 (175,182+60,372+87,591)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0 years</pre><p></code></p>
<p><code></p><pre>   Rebuilding Stokes preconditioner...
   Solving Stokes system... 51 iterations.
   Maximal velocity: 59.9101 cm/year
   Time step: 5334.14 years
   18 CG iterations for temperature
   Temperature range: 973 4273.43</pre><p></code></p>
<p><code></p><pre>Timestep 1:  t=5334.14 years</pre><p></code></p>
<p><code></p><pre>   Solving Stokes system... 49 iterations.
   Maximal velocity: 61.0837 cm/year
   Time step: 5232.24 years
   18 CG iterations for temperature
   Temperature range: 973 4273.43</pre><p></code></p>
<p><code></p><pre>Timestep 2:  t=10566.4 years</pre><p></code></p>
<p><code></p><pre>   Solving Stokes system... 24 iterations.
   Maximal velocity: 62.265 cm/year
   Time step: 5133.56 years
   18 CG iterations for temperature
   Temperature range: 973 4273.43</pre><p></code></p>
<p><code></p><pre>[...]</pre><p></code></p>
<p><code></p><pre>Timestep 100:  t=270918 years</pre><p></code></p>
<p><code></p><pre>   Solving Stokes system... 22 iterations.
   Maximal velocity: 161.391 cm/year
   Time step: 1683.55 years
   17 CG iterations for temperature
   Temperature range: 973 4282.45</pre><p></code></p>
<p><code></p><pre>Number of active cells: 54,717 (on 8 levels)
Number of degrees of freedom: 880,626 (477,650+164,151+238,825)</pre><p></code></p>
<p><code></p><pre>+---------------------------------------------+------------+------------+
| Total wallclock time elapsed since start    |       170s |            |
|                                             |            |            |
| Section                         | no. calls |  wall time | % of total |
+---------------------------------+-----------+------------+------------+
| Assemble Stokes system          |       103 |      2.25s |       1.3% |
| Assemble temperature matrices   |        12 |     0.296s |      0.17% |
| Assemble temperature rhs        |       103 |      9.66s |       5.7% |
| Build Stokes preconditioner     |        12 |      1.78s |         1% |
| Solve Stokes system             |       103 |       149s |        88% |
| Solve temperature system        |       103 |      1.84s |       1.1% |
| Postprocessing                  |         3 |     0.398s |      0.23% |
| Refine mesh structure, part 1   |        12 |     0.599s |      0.35% |
| Refine mesh structure, part 2   |        12 |     0.216s |      0.13% |
| Setup dof systems               |        13 |      2.15s |       1.3% |
+---------------------------------+-----------+------------+------------+</pre><p></code></p>
<p><code></p><pre>[...]</pre><p></code></p>
<p><code></p><pre>Timestep 6946:  t=1.00001e+08 years</pre><p></code></p>
<p><code></p><pre>   Solving Stokes system... 12 iterations.
   Maximal velocity: 8.94391 cm/year
   Time step: 31505.4 years
   18 CG iterations for temperature
   Temperature range: 973 4273.04</pre><p></code></p>
<p><code></p><pre>+---------------------------------------------+------------+------------+
| Total wallclock time elapsed since start    |  8.86e+03s |            |
|                                             |            |            |
| Section                         | no. calls |  wall time | % of total |
+---------------------------------+-----------+------------+------------+
| Assemble Stokes system          |      6949 |       153s |       1.7% |
| Assemble temperature matrices   |       697 |      18.2s |       0.2% |
| Assemble temperature rhs        |      6949 |       600s |       6.8% |
| Build Stokes preconditioner     |       697 |       115s |       1.3% |
| Solve Stokes system             |      6949 |  7.56e+03s |        85% |
| Solve temperature system        |      6949 |       123s |       1.4% |
| Postprocessing                  |       140 |      18.1s |       0.2% |
| Refine mesh structure, part 1   |       696 |      34.6s |      0.39% |
| Refine mesh structure, part 2   |       696 |      12.6s |      0.14% |
| Setup dof systems               |       697 |       130s |       1.5% |
+---------------------------------+-----------+------------+------------+
</pre><p> </code></p>
<p>The simulation terminates when the time reaches the 100 million years selected in the input file. You can extrapolate from this how long a simulation would take for a different final time (the time step size ultimately settles on somewhere around 20,000 years, so computing for one billion years will take 50,000 time steps, give or take 20%). As can be seen here, we spend most of the compute time in assembling linear systems and &mdash; above all &mdash; in solving Stokes systems.</p>
<p>We can clearly not show all output files produced by this program when run for a longer period of time, so let us only show the output from every 2500th time step here (these figures are from a version of this tutorial program before the introduction of manifolds, when it was not yet possible to arrange vertices along circles; the figures may therefore look slightly different if you run the current version): </p><table class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0000.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0100.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0200.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0300.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0400.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0500.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0600.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0700.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0800.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.0900.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1000.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1100.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1200.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1300.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1400.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1500.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1600.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1700.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1800.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.1900.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.2000.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.temperature.2100.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.grid.2100.png"/>
</div>
 <p class="endtd"></p>
</td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.partition.2100.png"/>
</div>
   </td></tr>
</table>
<p>The last two images show the grid as well as the partitioning of the mesh for a computation with 10 subdomains on 10 processors. The full dynamics of this simulation are really only visible by looking at an animation, for example the one <a href="http://www.math.colostate.edu/~bangerth/images/pictures/convection-outward/step-32.2d.convection.gif">shown on this site</a>. Beware that this animation is about 20MB large, though it is well worth watching due to its almost artistic quality.</p>
<p>If you watch the movie, you'll see that the convection pattern goes through several stages: First, it gets rid of the instable temperature layering with the hot material overlain by the dense cold material. After this great driver is removed and we have a sort of stable situation, a few blobs start to separate from the hot boundary layer at the inner ring and rise up, with a few cold fingers also dropping down from the outer boundary layer. During this phase, the solution remains mostly symmetric, reflecting the 12-fold symmetry of the original mesh. In a final phase, the fluid enters vigorous chaotic stirring in which all symmetries are lost. This is a pattern that then continues to dominate flow.</p>
<p>These different phases can also be identified if we look at the maximal velocity as a function of time in the simulation:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.t_vs_vmax.png"/>
</div>
<p>Here, the velocity (shown in centimeters per year) becomes very large, to the order of several meters per year) at the beginning when the temperature layering is instable. It then calms down to relatively small values before picking up again in the chaotic stirring regime. There, it remains in the range of 10-40 centimeters per year, quite within the physically expected region.</p>
<p><a class="anchor" id="Resultsfora3dsphericalshelltestcase"></a></p><h3>Results for a 3d spherical shell testcase</h3>
<p>3d computations are very expensive computationally. Furthermore, as seen above, interesting behavior only starts after quite a long time requiring more CPU hours than is available on a typical cluster. Consequently, rather than showing a complete simulation here, let us simply show a couple of pictures we have obtained using the successor to this program, called <em>Aspect</em> (short for <em>Advanced Solver for Problems in Earth's ConvecTion</em>), that is being developed independently of deal.II and that already incorporates some of the extensions discussed below. The following two pictures show isocontours of the temperature and the partition of the domain (along with the mesh) onto 512 processors:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d-sphere.solution.png"/>
</div>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d-sphere.partition.png"/>
</div>
 <p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>There are many directions in which this program could be extended. As mentioned at the end of the introduction, most of these are under active development in the <em>Aspect</em> (short for <em>Advanced Solver for Problems in Earth's ConvecTion</em>) code at the time this tutorial program is being finished. Specifically, the following are certainly topics that one should address to make the program more useful:</p>
<ul>
<li>
<p class="startli"><b>Adiabatic heating/cooling:</b> The temperature field we get in our simulations after a while is mostly constant with boundary layers at the inner and outer boundary, and streamers of cold and hot material mixing everything. Yet, this doesn't match our expectation that things closer to the earth core should be hotter than closer to the surface. The reason is that the energy equation we have used does not include a term that describes adiabatic cooling and heating: rock, like gas, heats up as you compress it. Consequently, material that rises up cools adiabatically, and cold material that sinks down heats adiabatically. The correct temperature equation would therefore look somewhat like this: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{D T}{Dt} - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma + \tau\frac{Dp}{Dt}, \end{eqnarray*}" src="form_2798.png"/>
</p>
<p> or, expanding the advected derivative <img class="formulaInl" alt="$\frac{D}{Dt} = \frac{\partial}{\partial t} + \mathbf u \cdot \nabla$" src="form_2799.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma + \tau\left\{\frac{\partial p}{\partial t} + \mathbf u \cdot \nabla p \right\}. \end{eqnarray*}" src="form_2800.png"/>
</p>
<p> In other words, as pressure increases in a rock volume ( <img class="formulaInl" alt="$\frac{Dp}{Dt}&gt;0$" src="form_2801.png"/>) we get an additional heat source, and vice versa.</p>
<p>The time derivative of the pressure is a bit awkward to implement. If necessary, one could approximate using the fact outlined in the introduction that the pressure can be decomposed into a dynamic component due to temperature differences and the resulting flow, and a static component that results solely from the static pressure of the overlying rock. Since the latter is much bigger, one may approximate <img class="formulaInl" alt="$p\approx p_{\text{static}}=-\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi$" src="form_2802.png"/>, and consequently <img class="formulaInl" alt="$\frac{Dp}{Dt} \approx \left\{- \mathbf u \cdot \nabla \rho_{\text{ref}} [1+\beta T_{\text{ref}}]\varphi\right\} = \rho_{\text{ref}} [1+\beta T_{\text{ref}}] \mathbf u \cdot \mathbf g$" src="form_2803.png"/>. In other words, if the fluid is moving in the direction of gravity (downward) it will be compressed and because in that case <img class="formulaInl" alt="$\mathbf u \cdot \mathbf g &gt; 0$" src="form_2804.png"/> we get a positive heat source. Conversely, the fluid will cool down if it moves against the direction of gravity.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Compressibility:</b> As already hinted at in the temperature model above, mantle rocks are not incompressible. Rather, given the enormous pressures in the earth mantle (at the core-mantle boundary, the pressure is approximately 140 GPa, equivalent to 1,400,000 times atmospheric pressure), rock actually does compress to something around 1.5 times the density it would have at surface pressure. Modeling this presents any number of difficulties. Primarily, the mass conservation equation is no longer <img class="formulaInl" alt="$\textrm{div}\;\mathbf u=0$" src="form_2805.png"/> but should read <img class="formulaInl" alt="$\textrm{div}(\rho\mathbf u)=0$" src="form_2806.png"/> where the density <img class="formulaInl" alt="$\rho$" src="form_1591.png"/> is now no longer spatially constant but depends on temperature and pressure. A consequence is that the model is now no longer linear; a linearized version of the Stokes equation is also no longer symmetric requiring us to rethink preconditioners and, possibly, even the discretization. We won't go into detail here as to how this can be resolved.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Nonlinear material models:</b> As already hinted at in various places, material parameters such as the density, the viscosity, and the various thermal parameters are not constant throughout the earth mantle. Rather, they nonlinearly depend on the pressure and temperature, and in the case of the viscosity on the strain rate <img class="formulaInl" alt="$\varepsilon(\mathbf u)$" src="form_2807.png"/>. For complicated models, the only way to solve such models accurately may be to actually iterate this dependence out in each time step, rather than simply freezing coefficients at values extrapolated from the previous time step(s).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Checkpoint/restart:</b> Running this program in 2d on a number of processors allows solving realistic models in a day or two. However, in 3d, compute times are so large that one runs into two typical problems: (i) On most compute clusters, the queuing system limits run times for individual jobs are to 2 or 3 days; (ii) losing the results of a computation due to hardware failures, misconfigurations, or power outages is a shame when running on hundreds of processors for a couple of days. Both of these problems can be addressed by periodically saving the state of the program and, if necessary, restarting the program at this point. This technique is commonly called <em>checkpoint/restart</em> and it requires that the entire state of the program is written to a permanent storage location (e.g. a hard drive). Given the complexity of the data structures of this program, this is not entirely trivial (it may also involve writing gigabytes or more of data), but it can be made easier by realizing that one can save the state between two time steps where it essentially only consists of the mesh and solution vectors; during restart one would then first re-enumerate degrees of freedom in the same way as done before and then re-assemble matrices. Nevertheless, given the distributed nature of the data structures involved here, saving and restoring the state of a program is not trivial. An additional complexity is introduced by the fact that one may want to change the number of processors between runs, for example because one may wish to continue computing on a mesh that is finer than the one used to precompute a starting temperature field at an intermediate time.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Predictive postprocessing:</b> The point of computations like this is not simply to solve the equations. Rather, it is typically the exploration of different physical models and their comparison with things that we can measure at the earth surface, in order to find which models are realistic and which are contradicted by reality. To this end, we need to compute quantities from our solution vectors that are related to what we can observe. Among these are, for example, heatfluxes at the surface of the earth, as well as seismic velocities throughout the mantle as these affect earthquake waves that are recorded by seismographs.</p>
<p class="endli"></p>
</li>
<li>
<b>Better refinement criteria:</b> As can be seen above for the 3d case, the mesh in 3d is primarily refined along the inner boundary. This is because the boundary layer there is stronger than any other transition in the domain, leading us to refine there almost exclusively and basically not at all following the plumes. One certainly needs better refinement criteria to track the parts of the solution we are really interested in better than the criterion used here, namely the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> applied to the temperature, is able to. </li>
</ul>
<p>There are many other ways to extend the current program. However, rather than discussing them here, let us point to the much larger open source code Aspect (see <a href="http://aspect.dealii.org/">http://aspect.dealii.org/</a> ) that constitutes the further development of <a class="el" href="step_32.html">step-32</a> and that already includes many such possible extensions. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2008 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Martin Kronbichler, Uppsala University,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University,</span></div><div class="line"><span class="comment"> *          Timo Heister, University of Goettingen, 2008-2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/work_stream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_bicgstab.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_gmres.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_solver.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/filtered_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgq.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgp.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/solution_transfer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;locale&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/solution_transfer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step32</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>EquationData</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> eta                   = 1e21;    <span class="comment">/* Pa s       */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> kappa                 = 1e-6;    <span class="comment">/* m^2 / s    */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> reference_density     = 3300;    <span class="comment">/* kg / m^3   */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> reference_temperature = 293;     <span class="comment">/* K          */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> expansion_coefficient = 2e-5;    <span class="comment">/* 1/K        */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> specific_heat         = 1250;    <span class="comment">/* J / K / kg */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> radiogenic_heating    = 7.4e-12; <span class="comment">/* W / kg     */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R0      = 6371000.-2890000.;     <span class="comment">/* m          */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R1      = 6371000.-  35000.;     <span class="comment">/* m          */</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> T0      = 4000+273;              <span class="comment">/* K          */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> T1      =  700+273;              <span class="comment">/* K          */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> density (<span class="keyword">const</span> <span class="keywordtype">double</span> temperature)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> (reference_density *</div><div class="line">              (1 - expansion_coefficient * (temperature -</div><div class="line">                                            reference_temperature)));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> gravity_vector (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div><div class="line">      <span class="keywordflow">return</span> -(1.245e-6 * r + 7.714e13/r/r) * p / r;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      TemperatureInitialValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    TemperatureInitialValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#a4df6cb10807fbe5fb432a19b5ef9aeb6">norm</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> h = R1-R0;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> s = (r-R0)/h;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> q = (dim==3)?std::max(0.0,cos(<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*abs(p(2)/R1))):1.0;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi   = std::atan2(p(0),p(1));</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> tau = s</div><div class="line">                         +</div><div class="line">                         0.2 * s * (1-s) * std::sin(6*phi) * q;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> T0*(1.0-tau) + T1*tau;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    TemperatureInitialValues&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                 <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;this-&gt;n_components; ++c)</div><div class="line">        values(c) = TemperatureInitialValues&lt;dim&gt;::value (p, c);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> pressure_scaling = eta / 10000;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> year_in_seconds  = 60*60*24*365.2425;</div><div class="line"></div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LinearSolvers</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BlockSchurPreconditioner (<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;Spre,</div><div class="line">                                <span class="keyword">const</span> PreconditionerTypeMp                &amp;Mppreconditioner,</div><div class="line">                                <span class="keyword">const</span> PreconditionerTypeA                 &amp;Apreconditioner,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">bool</span>                                 do_solve_A)</div><div class="line">        :</div><div class="line">        stokes_matrix     (&amp;S),</div><div class="line">        stokes_preconditioner_matrix     (&amp;Spre),</div><div class="line">        mp_preconditioner (Mppreconditioner),</div><div class="line">        a_preconditioner  (Apreconditioner),</div><div class="line">        do_solve_A        (do_solve_A)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> vmult (<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>       &amp;dst,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> utmp(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line"></div><div class="line">        {</div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, 1e-6 * src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line"></div><div class="line">          <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">          solver.solve(stokes_preconditioner_matrix-&gt;block(1,1),</div><div class="line">                       dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                       mp_preconditioner);</div><div class="line"></div><div class="line">          dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1) *= -1.0;</div><div class="line">        }</div><div class="line"></div><div class="line">        {</div><div class="line">          stokes_matrix-&gt;block(0,1).vmult(utmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">          utmp*=-1.0;</div><div class="line">          utmp.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (do_solve_A == <span class="keyword">true</span>)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, utmp.l2_norm()*1e-2);</div><div class="line">            <a class="code" href="classTrilinosWrappers_1_1SolverCG.html">TrilinosWrappers::SolverCG</a> solver(solver_control);</div><div class="line">            solver.solve(stokes_matrix-&gt;block(0,0), dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp,</div><div class="line">                         a_preconditioner);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          a_preconditioner.vmult (dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a> stokes_matrix;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a> stokes_preconditioner_matrix;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeMp &amp;mp_preconditioner;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA  &amp;a_preconditioner;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> do_solve_A;</div><div class="line">    };</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>Assembly</div><div class="line">  {</div><div class="line">    <span class="keyword">namespace </span>Scratch</div><div class="line">    {</div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">      {</div><div class="line">        StokesPreconditioner (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;stokes_quadrature,</div><div class="line">                              <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags);</div><div class="line"></div><div class="line">        StokesPreconditioner (<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               stokes_fe_values;</div><div class="line"></div><div class="line">        std::vector&lt;Tensor&lt;2,dim&gt; &gt; grad_phi_u;</div><div class="line">        std::vector&lt;double&gt;         phi_p;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesPreconditioner&lt;dim&gt;::</div><div class="line">      StokesPreconditioner (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;stokes_quadrature,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">        :</div><div class="line">        stokes_fe_values (mapping, stokes_fe, stokes_quadrature,</div><div class="line">                          update_flags),</div><div class="line">        grad_phi_u (stokes_fe.dofs_per_cell),</div><div class="line">        phi_p (stokes_fe.dofs_per_cell)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesPreconditioner&lt;dim&gt;::</div><div class="line">      StokesPreconditioner (<span class="keyword">const</span> StokesPreconditioner &amp;scratch)</div><div class="line">        :</div><div class="line">        stokes_fe_values (scratch.stokes_fe_values.get_mapping(),</div><div class="line">                          scratch.stokes_fe_values.get_fe(),</div><div class="line">                          scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                          scratch.stokes_fe_values.get_update_flags()),</div><div class="line">        grad_phi_u (scratch.grad_phi_u),</div><div class="line">        phi_p (scratch.phi_p)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">      {</div><div class="line">        StokesSystem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;stokes_quadrature,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags);</div><div class="line"></div><div class="line">        StokesSystem (<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                        temperature_fe_values;</div><div class="line"></div><div class="line">        std::vector&lt;Tensor&lt;1,dim&gt; &gt;          phi_u;</div><div class="line">        std::vector&lt;SymmetricTensor&lt;2,dim&gt; &gt; grads_phi_u;</div><div class="line">        std::vector&lt;double&gt;                  div_phi_u;</div><div class="line"></div><div class="line">        std::vector&lt;double&gt;                  old_temperature_values;</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesSystem&lt;dim&gt;::</div><div class="line">      StokesSystem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;stokes_quadrature,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags)</div><div class="line">        :</div><div class="line">        StokesPreconditioner&lt;dim&gt; (stokes_fe, stokes_quadrature,</div><div class="line">                                   mapping,</div><div class="line">                                   stokes_update_flags),</div><div class="line">        temperature_fe_values (mapping, temperature_fe, stokes_quadrature,</div><div class="line">                               temperature_update_flags),</div><div class="line">        phi_u (stokes_fe.dofs_per_cell),</div><div class="line">        grads_phi_u (stokes_fe.dofs_per_cell),</div><div class="line">        div_phi_u (stokes_fe.dofs_per_cell),</div><div class="line">        old_temperature_values (stokes_quadrature.size())</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesSystem&lt;dim&gt;::</div><div class="line">      StokesSystem (<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;scratch)</div><div class="line">        :</div><div class="line">        StokesPreconditioner&lt;dim&gt; (scratch),</div><div class="line">        temperature_fe_values (scratch.temperature_fe_values.get_mapping(),</div><div class="line">                               scratch.temperature_fe_values.get_fe(),</div><div class="line">                               scratch.temperature_fe_values.get_quadrature(),</div><div class="line">                               scratch.temperature_fe_values.get_update_flags()),</div><div class="line">        phi_u (scratch.phi_u),</div><div class="line">        grads_phi_u (scratch.grads_phi_u),</div><div class="line">        div_phi_u (scratch.div_phi_u),</div><div class="line">        old_temperature_values (scratch.old_temperature_values)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>TemperatureMatrix</div><div class="line">      {</div><div class="line">        TemperatureMatrix (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;temperature_quadrature);</div><div class="line"></div><div class="line">        TemperatureMatrix (<span class="keyword">const</span> TemperatureMatrix &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               temperature_fe_values;</div><div class="line"></div><div class="line">        std::vector&lt;double&gt;         phi_T;</div><div class="line">        std::vector&lt;Tensor&lt;1,dim&gt; &gt; grad_phi_T;</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureMatrix&lt;dim&gt;::</div><div class="line">      TemperatureMatrix (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;temperature_quadrature)</div><div class="line">        :</div><div class="line">        temperature_fe_values (mapping,</div><div class="line">                               temperature_fe, temperature_quadrature,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>),</div><div class="line">        phi_T (temperature_fe.dofs_per_cell),</div><div class="line">        grad_phi_T (temperature_fe.dofs_per_cell)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureMatrix&lt;dim&gt;::</div><div class="line">      TemperatureMatrix (<span class="keyword">const</span> TemperatureMatrix &amp;scratch)</div><div class="line">        :</div><div class="line">        temperature_fe_values (scratch.temperature_fe_values.get_mapping(),</div><div class="line">                               scratch.temperature_fe_values.get_fe(),</div><div class="line">                               scratch.temperature_fe_values.get_quadrature(),</div><div class="line">                               scratch.temperature_fe_values.get_update_flags()),</div><div class="line">        phi_T (scratch.phi_T),</div><div class="line">        grad_phi_T (scratch.grad_phi_T)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>TemperatureRHS</div><div class="line">      {</div><div class="line">        TemperatureRHS (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;quadrature);</div><div class="line"></div><div class="line">        TemperatureRHS (<span class="keyword">const</span> TemperatureRHS &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                        temperature_fe_values;</div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                        stokes_fe_values;</div><div class="line"></div><div class="line">        std::vector&lt;double&gt;                  phi_T;</div><div class="line">        std::vector&lt;Tensor&lt;1,dim&gt; &gt;          grad_phi_T;</div><div class="line"></div><div class="line">        std::vector&lt;Tensor&lt;1,dim&gt; &gt;          old_velocity_values;</div><div class="line">        std::vector&lt;Tensor&lt;1,dim&gt; &gt;          old_old_velocity_values;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2,dim&gt; &gt; old_strain_rates;</div><div class="line">        std::vector&lt;SymmetricTensor&lt;2,dim&gt; &gt; old_old_strain_rates;</div><div class="line"></div><div class="line">        std::vector&lt;double&gt;                  old_temperature_values;</div><div class="line">        std::vector&lt;double&gt;                  old_old_temperature_values;</div><div class="line">        std::vector&lt;Tensor&lt;1,dim&gt; &gt;          old_temperature_grads;</div><div class="line">        std::vector&lt;Tensor&lt;1,dim&gt; &gt;          old_old_temperature_grads;</div><div class="line">        std::vector&lt;double&gt;                  old_temperature_laplacians;</div><div class="line">        std::vector&lt;double&gt;                  old_old_temperature_laplacians;</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureRHS&lt;dim&gt;::</div><div class="line">      TemperatureRHS (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a>       &amp;mapping,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a>    &amp;quadrature)</div><div class="line">        :</div><div class="line">        temperature_fe_values (mapping,</div><div class="line">                               temperature_fe, quadrature,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>  |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>),</div><div class="line">        stokes_fe_values (mapping,</div><div class="line">                          stokes_fe, quadrature,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>),</div><div class="line">        phi_T (temperature_fe.dofs_per_cell),</div><div class="line">        grad_phi_T (temperature_fe.dofs_per_cell),</div><div class="line"></div><div class="line">        old_velocity_values (quadrature.size()),</div><div class="line">        old_old_velocity_values (quadrature.size()),</div><div class="line">        old_strain_rates (quadrature.size()),</div><div class="line">        old_old_strain_rates (quadrature.size()),</div><div class="line"></div><div class="line">        old_temperature_values (quadrature.size()),</div><div class="line">        old_old_temperature_values(quadrature.size()),</div><div class="line">        old_temperature_grads(quadrature.size()),</div><div class="line">        old_old_temperature_grads(quadrature.size()),</div><div class="line">        old_temperature_laplacians(quadrature.size()),</div><div class="line">        old_old_temperature_laplacians(quadrature.size())</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureRHS&lt;dim&gt;::</div><div class="line">      TemperatureRHS (<span class="keyword">const</span> TemperatureRHS &amp;scratch)</div><div class="line">        :</div><div class="line">        temperature_fe_values (scratch.temperature_fe_values.get_mapping(),</div><div class="line">                               scratch.temperature_fe_values.get_fe(),</div><div class="line">                               scratch.temperature_fe_values.get_quadrature(),</div><div class="line">                               scratch.temperature_fe_values.get_update_flags()),</div><div class="line">        stokes_fe_values (scratch.stokes_fe_values.get_mapping(),</div><div class="line">                          scratch.stokes_fe_values.get_fe(),</div><div class="line">                          scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                          scratch.stokes_fe_values.get_update_flags()),</div><div class="line">        phi_T (scratch.phi_T),</div><div class="line">        grad_phi_T (scratch.grad_phi_T),</div><div class="line"></div><div class="line">        old_velocity_values (scratch.old_velocity_values),</div><div class="line">        old_old_velocity_values (scratch.old_old_velocity_values),</div><div class="line">        old_strain_rates (scratch.old_strain_rates),</div><div class="line">        old_old_strain_rates (scratch.old_old_strain_rates),</div><div class="line"></div><div class="line">        old_temperature_values (scratch.old_temperature_values),</div><div class="line">        old_old_temperature_values (scratch.old_old_temperature_values),</div><div class="line">        old_temperature_grads (scratch.old_temperature_grads),</div><div class="line">        old_old_temperature_grads (scratch.old_old_temperature_grads),</div><div class="line">        old_temperature_laplacians (scratch.old_temperature_laplacians),</div><div class="line">        old_old_temperature_laplacians (scratch.old_old_temperature_laplacians)</div><div class="line">      {}</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">namespace </span>CopyData</div><div class="line">    {</div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">      {</div><div class="line">        StokesPreconditioner (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line">        StokesPreconditioner (<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line"></div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          local_matrix;</div><div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesPreconditioner&lt;dim&gt;::</div><div class="line">      StokesPreconditioner (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">        :</div><div class="line">        local_matrix (stokes_fe.dofs_per_cell,</div><div class="line">                      stokes_fe.dofs_per_cell),</div><div class="line">        local_dof_indices (stokes_fe.dofs_per_cell)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesPreconditioner&lt;dim&gt;::</div><div class="line">      StokesPreconditioner (<span class="keyword">const</span> StokesPreconditioner &amp;data)</div><div class="line">        :</div><div class="line">        local_matrix (data.local_matrix),</div><div class="line">        local_dof_indices (data.local_dof_indices)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">      {</div><div class="line">        StokesSystem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line">        StokesSystem (<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesSystem&lt;dim&gt;::</div><div class="line">      StokesSystem (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">        :</div><div class="line">        StokesPreconditioner&lt;dim&gt; (stokes_fe),</div><div class="line">        local_rhs (stokes_fe.dofs_per_cell)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesSystem&lt;dim&gt;::</div><div class="line">      StokesSystem (<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">        :</div><div class="line">        StokesPreconditioner&lt;dim&gt; (data),</div><div class="line">        local_rhs (data.local_rhs)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>TemperatureMatrix</div><div class="line">      {</div><div class="line">        TemperatureMatrix (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line">        TemperatureMatrix (<span class="keyword">const</span> TemperatureMatrix &amp;data);</div><div class="line"></div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          local_mass_matrix;</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          local_stiffness_matrix;</div><div class="line">        std::vector&lt;types::global_dof_index&gt;   local_dof_indices;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureMatrix&lt;dim&gt;::</div><div class="line">      TemperatureMatrix (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">        :</div><div class="line">        local_mass_matrix (temperature_fe.dofs_per_cell,</div><div class="line">                           temperature_fe.dofs_per_cell),</div><div class="line">        local_stiffness_matrix (temperature_fe.dofs_per_cell,</div><div class="line">                                temperature_fe.dofs_per_cell),</div><div class="line">        local_dof_indices (temperature_fe.dofs_per_cell)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureMatrix&lt;dim&gt;::</div><div class="line">      TemperatureMatrix (<span class="keyword">const</span> TemperatureMatrix &amp;data)</div><div class="line">        :</div><div class="line">        local_mass_matrix (data.local_mass_matrix),</div><div class="line">        local_stiffness_matrix (data.local_stiffness_matrix),</div><div class="line">        local_dof_indices (data.local_dof_indices)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>TemperatureRHS</div><div class="line">      {</div><div class="line">        TemperatureRHS (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line">        TemperatureRHS (<span class="keyword">const</span> TemperatureRHS &amp;data);</div><div class="line"></div><div class="line">        <a class="code" href="classVector.html">Vector&lt;double&gt;</a>              local_rhs;</div><div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>          matrix_for_bc;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureRHS&lt;dim&gt;::</div><div class="line">      TemperatureRHS (<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">        :</div><div class="line">        local_rhs (temperature_fe.dofs_per_cell),</div><div class="line">        local_dof_indices (temperature_fe.dofs_per_cell),</div><div class="line">        matrix_for_bc (temperature_fe.dofs_per_cell,</div><div class="line">                       temperature_fe.dofs_per_cell)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureRHS&lt;dim&gt;::</div><div class="line">      TemperatureRHS (<span class="keyword">const</span> TemperatureRHS &amp;data)</div><div class="line">        :</div><div class="line">        local_rhs (data.local_rhs),</div><div class="line">        local_dof_indices (data.local_dof_indices),</div><div class="line">        matrix_for_bc (data.matrix_for_bc)</div><div class="line">      {}</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">struct </span>Parameters;</div><div class="line">    BoussinesqFlowProblem (Parameters &amp;parameters);</div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_dofs ();</div><div class="line">    <span class="keywordtype">void</span> assemble_stokes_preconditioner ();</div><div class="line">    <span class="keywordtype">void</span> build_stokes_preconditioner ();</div><div class="line">    <span class="keywordtype">void</span> assemble_stokes_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_temperature_matrix ();</div><div class="line">    <span class="keywordtype">void</span> assemble_temperature_system (<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">    <span class="keywordtype">void</span> project_temperature_field ();</div><div class="line">    <span class="keywordtype">double</span> get_maximal_velocity () <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> get_cfl_number () <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> get_entropy_variation (<span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature) <span class="keyword">const</span>;</div><div class="line">    std::pair&lt;double,double&gt; get_extrapolated_temperature_range () <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> output_results ();</div><div class="line">    <span class="keywordtype">void</span> refine_mesh (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    compute_viscosity(<span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_temperature,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_old_temperature,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_temperature_grads,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_old_temperature_grads,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_temperature_laplacians,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_old_temperature_laplacians,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_velocity_values,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_old_velocity_values,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt;  &amp;old_strain_rates,</div><div class="line">                      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt;  &amp;old_old_strain_rates,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_u_infty,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_T_variation,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span>                        average_temperature,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_entropy_variation,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span>                        cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>Parameters</div><div class="line">    {</div><div class="line">      Parameters (<span class="keyword">const</span> std::string &amp;parameter_filename);</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">      <span class="keywordtype">void</span> parse_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>       end_time;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_global_refinement;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_adaptive_refinement;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span>         generate_graphical_output;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> graphical_output_interval;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> adaptive_refinement_interval;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>       stabilization_alpha;</div><div class="line">      <span class="keywordtype">double</span>       stabilization_c_R;</div><div class="line">      <span class="keywordtype">double</span>       stabilization_beta;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_velocity_degree;</div><div class="line">      <span class="keywordtype">bool</span>         use_locally_conservative_discretization;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temperature_degree;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    Parameters                               &amp;parameters;</div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a>                        pcout;</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> triangulation;</div><div class="line">    <span class="keywordtype">double</span>                                    global_Omega_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a>                       mapping;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>                       stokes_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                           stokes_dof_handler;</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                          stokes_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a>       stokes_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a>       stokes_preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>        stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>        old_stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>        stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                                 temperature_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                           temperature_dof_handler;</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                          temperature_constraints;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix            temperature_mass_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix            temperature_stiffness_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix            temperature_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>             temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>             old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>             old_old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>             temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>                                    time_step;</div><div class="line">    <span class="keywordtype">double</span>                                    old_time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                              timestep_number;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt;    Amg_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; Mp_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; T_preconditioner;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span>                                      rebuild_stokes_matrix;</div><div class="line">    <span class="keywordtype">bool</span>                                      rebuild_stokes_preconditioner;</div><div class="line">    <span class="keywordtype">bool</span>                                      rebuild_temperature_matrices;</div><div class="line">    <span class="keywordtype">bool</span>                                      rebuild_temperature_preconditioner;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a>                               computing_timer;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_stokes_matrix (<span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">                              <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line">    <span class="keywordtype">void</span> setup_stokes_preconditioner (<span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">                                      <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line">    <span class="keywordtype">void</span> setup_temperature_matrices (<span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioning,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioning);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_assemble_stokes_preconditioner (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                          Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;scratch,</div><div class="line">                                          Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    copy_local_to_global_stokes_preconditioner (<span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_assemble_stokes_system (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                  Assembly::Scratch::StokesSystem&lt;dim&gt;  &amp;scratch,</div><div class="line">                                  Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    copy_local_to_global_stokes_system (<span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_assemble_temperature_matrix (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                       Assembly::Scratch::TemperatureMatrix&lt;dim&gt;  &amp;scratch,</div><div class="line">                                       Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    copy_local_to_global_temperature_matrix (<span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_assemble_temperature_rhs (<span class="keyword">const</span> std::pair&lt;double,double&gt; global_T_range,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">double</span>                   global_max_velocity,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">double</span>                   global_entropy_variation,</div><div class="line">                                    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                    Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;scratch,</div><div class="line">                                    Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    copy_local_to_global_temperature_rhs (<span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line">    <span class="keyword">class </span>Postprocessor;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Parameters::Parameters (<span class="keyword">const</span> std::string &amp;parameter_filename)</div><div class="line">    :</div><div class="line">    end_time (1e8),</div><div class="line">    initial_global_refinement (2),</div><div class="line">    initial_adaptive_refinement (2),</div><div class="line">    adaptive_refinement_interval (10),</div><div class="line">    stabilization_alpha (2),</div><div class="line">    stabilization_c_R (0.11),</div><div class="line">    stabilization_beta (0.078),</div><div class="line">    stokes_velocity_degree (2),</div><div class="line">    use_locally_conservative_discretization (true),</div><div class="line">    temperature_degree (2)</div><div class="line">  {</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">    BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters (prm);</div><div class="line"></div><div class="line">    std::ifstream parameter_file (parameter_filename.c_str());</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!parameter_file)</div><div class="line">      {</div><div class="line">        parameter_file.close ();</div><div class="line"></div><div class="line">        std::ostringstream message;</div><div class="line">        message &lt;&lt; <span class="stringliteral">&quot;Input parameter file &lt;&quot;</span></div><div class="line">                &lt;&lt; parameter_filename &lt;&lt; <span class="stringliteral">&quot;&gt; not found. Creating a&quot;</span></div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;template file of the same name.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        std::ofstream parameter_out (parameter_filename.c_str());</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters</a> (parameter_out,</div><div class="line">                              <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a> (message.str().c_str()));</div><div class="line">      }</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (parameter_file);</div><div class="line">    parse_parameters (prm);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Parameters::</div><div class="line">  declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;End time&quot;</span>, <span class="stringliteral">&quot;1e8&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0),</div><div class="line">                       <span class="stringliteral">&quot;The end time of the simulation in years.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Initial global refinement&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (0),</div><div class="line">                       <span class="stringliteral">&quot;The number of global refinement steps performed on &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;the initial coarse mesh, before the problem is first &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;solved there.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (0),</div><div class="line">                       <span class="stringliteral">&quot;The number of adaptive refinement steps performed after &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;initial global refinement.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1),</div><div class="line">                       <span class="stringliteral">&quot;The number of time steps after which the mesh is to be &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;adapted based on computed error indicators.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Generate graphical output&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a> (),</div><div class="line">                       <span class="stringliteral">&quot;Whether graphical output is to be generated or not. &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;You may not want to get graphical output if the number &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;of processors is large.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>, <span class="stringliteral">&quot;50&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1),</div><div class="line">                       <span class="stringliteral">&quot;The number of time steps between each generation of &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;graphical output files.&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;alpha&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                         <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (1, 2),</div><div class="line">                         <span class="stringliteral">&quot;The exponent in the entropy viscosity stabilization.&quot;</span>);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;c_R&quot;</span>, <span class="stringliteral">&quot;0.11&quot;</span>,</div><div class="line">                         <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0),</div><div class="line">                         <span class="stringliteral">&quot;The c_R factor in the entropy viscosity &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;stabilization.&quot;</span>);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;beta&quot;</span>, <span class="stringliteral">&quot;0.078&quot;</span>,</div><div class="line">                         <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0),</div><div class="line">                         <span class="stringliteral">&quot;The beta factor in the artificial viscosity &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;stabilization. An appropriate value for 2d is 0.052 &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;and 0.078 for 3d.&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                         <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1),</div><div class="line">                         <span class="stringliteral">&quot;The polynomial degree to use for the velocity variables &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;in the Stokes system.&quot;</span>);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                         <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1),</div><div class="line">                         <span class="stringliteral">&quot;The polynomial degree to use for the temperature variable.&quot;</span>);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                         <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a> (),</div><div class="line">                         <span class="stringliteral">&quot;Whether to use a Stokes discretization that is locally &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;conservative at the expense of a larger number of degrees &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;of freedom, or to go with a cheaper discretization &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;that does not locally conserve mass (although it is &quot;</span></div><div class="line">                         <span class="stringliteral">&quot;globally conservative.&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Parameters::</div><div class="line">  parse_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    end_time                    = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line">    initial_global_refinement   = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Initial global refinement&quot;</span>);</div><div class="line">    initial_adaptive_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>);</div><div class="line"></div><div class="line">    adaptive_refinement_interval= prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>);</div><div class="line"></div><div class="line">    generate_graphical_output   = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a> (<span class="stringliteral">&quot;Generate graphical output&quot;</span>);</div><div class="line">    graphical_output_interval   = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      stabilization_alpha = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;alpha&quot;</span>);</div><div class="line">      stabilization_c_R   = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;c_R&quot;</span>);</div><div class="line">      stabilization_beta  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (<span class="stringliteral">&quot;beta&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">    {</div><div class="line">      stokes_velocity_degree = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>);</div><div class="line">      temperature_degree     = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>);</div><div class="line">      use_locally_conservative_discretization</div><div class="line">        = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a> (<span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem (Parameters &amp;parameters_)</div><div class="line">    :</div><div class="line">    parameters (parameters_),</div><div class="line">    pcout (<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">           (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD)</div><div class="line">            == 0)),</div><div class="line"></div><div class="line">    triangulation (MPI_COMM_WORLD,</div><div class="line">                   typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing</div><div class="line">                   (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                    <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening)),</div><div class="line"></div><div class="line">    global_Omega_diameter(0.),</div><div class="line"></div><div class="line">    mapping (4),</div><div class="line"></div><div class="line">    stokes_fe (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree),</div><div class="line">               dim,</div><div class="line">               (parameters.use_locally_conservative_discretization</div><div class="line">                ?</div><div class="line">                static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;</div><div class="line">                (<a class="code" href="classFE__DGP.html">FE_DGP</a>&lt;dim&gt;(parameters.stokes_velocity_degree-1))</div><div class="line">                :</div><div class="line">                static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;</div><div class="line">                (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree-1))),</div><div class="line">               1),</div><div class="line"></div><div class="line">    stokes_dof_handler (triangulation),</div><div class="line"></div><div class="line">    temperature_fe (parameters.temperature_degree),</div><div class="line">    temperature_dof_handler (triangulation),</div><div class="line"></div><div class="line">    time_step (0),</div><div class="line">    old_time_step (0),</div><div class="line">    timestep_number (0),</div><div class="line">    rebuild_stokes_matrix (true),</div><div class="line">    rebuild_stokes_preconditioner (true),</div><div class="line">    rebuild_temperature_matrices (true),</div><div class="line">    rebuild_temperature_preconditioner (true),</div><div class="line"></div><div class="line">    computing_timer (MPI_COMM_WORLD,</div><div class="line">                     pcout,</div><div class="line">                     <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                     <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula (<a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>(),</div><div class="line">                                             parameters.stokes_velocity_degree);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (mapping, stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_local_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = stokes_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = stokes_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">          fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (stokes_solution,</div><div class="line">                                                     velocity_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">            max_local_velocity = std::max (max_local_velocity,</div><div class="line">                                           velocity_values[q].norm());</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (max_local_velocity, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_cfl_number ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula (<a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>(),</div><div class="line">                                             parameters.stokes_velocity_degree);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (mapping, stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_local_cfl = 0;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = stokes_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = stokes_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">          fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (stokes_solution,</div><div class="line">                                                     velocity_values);</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> max_local_velocity = 1e-10;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">            max_local_velocity = std::max (max_local_velocity,</div><div class="line">                                           velocity_values[q].norm());</div><div class="line">          max_local_cfl = std::max(max_local_cfl,</div><div class="line">                                   max_local_velocity / cell-&gt;diameter());</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (max_local_cfl, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::get_entropy_variation (<span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (parameters.stabilization_alpha != 2)</div><div class="line">      <span class="keywordflow">return</span> 1.;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula (parameters.temperature_degree+1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (temperature_fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> min_entropy = std::numeric_limits&lt;double&gt;::max(),</div><div class="line">           max_entropy = -std::numeric_limits&lt;double&gt;::max(),</div><div class="line">           area = 0,</div><div class="line">           entropy_integrated = 0;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_temperature_solution,</div><div class="line">                                         old_temperature_values);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_old_temperature_solution,</div><div class="line">                                         old_old_temperature_values);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> T = (old_temperature_values[q] +</div><div class="line">                                old_old_temperature_values[q]) / 2;</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> entropy = ((T-average_temperature) *</div><div class="line">                                      (T-average_temperature));</div><div class="line"></div><div class="line">              min_entropy = std::min (min_entropy, entropy);</div><div class="line">              max_entropy = std::max (max_entropy, entropy);</div><div class="line">              area += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              entropy_integrated += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) * entropy;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> local_sums[2]   = { entropy_integrated, area },</div><div class="line">                                   local_maxima[2] = { -min_entropy, max_entropy };</div><div class="line">    <span class="keywordtype">double</span> global_sums[2], global_maxima[2];</div><div class="line"></div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a> (local_sums,   MPI_COMM_WORLD, global_sums);</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (local_maxima, MPI_COMM_WORLD, global_maxima);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> average_entropy = global_sums[0] / global_sums[1];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> entropy_diff = std::max(global_maxima[1] - average_entropy,</div><div class="line">                                         average_entropy - (-global_maxima[0]));</div><div class="line">    <span class="keywordflow">return</span> entropy_diff;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double,double&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula (<a class="code" href="classQTrapez.html">QTrapez&lt;1&gt;</a>(),</div><div class="line">                                             parameters.temperature_degree);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (mapping, temperature_fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> min_local_temperature = std::numeric_limits&lt;double&gt;::max(),</div><div class="line">           max_local_temperature = -std::numeric_limits&lt;double&gt;::max();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">        cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">        endc = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">        <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">            {</div><div class="line">              fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_temperature_solution,</div><div class="line">                                             old_temperature_values);</div><div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_old_temperature_solution,</div><div class="line">                                             old_old_temperature_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                    (1. + time_step/old_time_step) * old_temperature_values[q]-</div><div class="line">                    time_step/old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">                  min_local_temperature = std::min (min_local_temperature,</div><div class="line">                                                    temperature);</div><div class="line">                  max_local_temperature = std::max (max_local_temperature,</div><div class="line">                                                    temperature);</div><div class="line">                }</div><div class="line">            }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">        cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">        endc = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">        <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">            {</div><div class="line">              fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (old_temperature_solution,</div><div class="line">                                             old_temperature_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">                  min_local_temperature = std::min (min_local_temperature,</div><div class="line">                                                    temperature);</div><div class="line">                  max_local_temperature = std::max (max_local_temperature,</div><div class="line">                                                    temperature);</div><div class="line">                }</div><div class="line">            }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> local_extrema[2] = { -min_local_temperature,</div><div class="line">                                max_local_temperature</div><div class="line">                              };</div><div class="line">    <span class="keywordtype">double</span> global_extrema[2];</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (local_extrema, MPI_COMM_WORLD, global_extrema);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> std::make_pair(-global_extrema[0], global_extrema[1]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  compute_viscosity (<span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_temperature,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_old_temperature,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_temperature_grads,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_old_temperature_grads,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_temperature_laplacians,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;double&gt;          &amp;old_old_temperature_laplacians,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_velocity_values,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;  &amp;old_old_velocity_values,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt;  &amp;old_strain_rates,</div><div class="line">                     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt;  &amp;old_old_strain_rates,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_u_infty,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_T_variation,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">double</span>                        average_temperature,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">double</span>                        global_entropy_variation,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">double</span>                        cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">      <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">    <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> u = (old_velocity_values[q] +</div><div class="line">                                 old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> strain_rate = (old_strain_rates[q] +</div><div class="line">                                                    old_old_strain_rates[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> T = (old_temperature[q] + old_old_temperature[q]) / 2;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt = (old_temperature[q] - old_old_temperature[q])</div><div class="line">                             / old_time_step;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T = u * (old_temperature_grads[q] +</div><div class="line">                                     old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T = EquationData::kappa</div><div class="line">                                     * (old_temperature_laplacians[q] +</div><div class="line">                                        old_old_temperature_laplacians[q]) / 2;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> gamma</div><div class="line">          = ((EquationData::radiogenic_heating * EquationData::density(T)</div><div class="line">              +</div><div class="line">              2 * EquationData::eta * strain_rate * strain_rate) /</div><div class="line">             (EquationData::density(T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> residual</div><div class="line">          = std::abs(dT_dt + u_grad_T - kappa_Delta_T - gamma);</div><div class="line">        <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">          residual *= std::abs(T - average_temperature);</div><div class="line"></div><div class="line">        max_residual = std::max (residual,        max_residual);</div><div class="line">        max_velocity = std::max (std::sqrt (u*u), max_velocity);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_viscosity = (parameters.stabilization_beta *</div><div class="line">                                  max_velocity * cell_diameter);</div><div class="line">    <span class="keywordflow">if</span> (timestep_number == 0)</div><div class="line">      <span class="keywordflow">return</span> max_viscosity;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (old_time_step &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> entropy_viscosity;</div><div class="line">        <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">          entropy_viscosity = (parameters.stabilization_c_R *</div><div class="line">                               cell_diameter * cell_diameter *</div><div class="line">                               max_residual /</div><div class="line">                               global_entropy_variation);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          entropy_viscosity = (parameters.stabilization_c_R *</div><div class="line">                               cell_diameter * global_Omega_diameter *</div><div class="line">                               max_velocity * max_residual /</div><div class="line">                               (global_u_infty * global_T_variation));</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::min (max_viscosity, entropy_viscosity);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::project_temperature_field ()</div><div class="line">  {</div><div class="line">    assemble_temperature_matrix ();</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(parameters.temperature_degree+2);</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags = <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   |</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (mapping, temperature_fe, quadrature, update_flags);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>,</div><div class="line">                       n_q_points    = fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_vector (dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> matrix_for_bc (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; rhs_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> row_temp_matrix_partitioning(temperature_mass_matrix.n());</div><div class="line">    row_temp_matrix_partitioning.<a class="code" href="classIndexSet.html#adf69c0bec3f1e748fec802e0dc0d2dd0">add_range</a>(temperature_mass_matrix.local_range().first,</div><div class="line">                                           temperature_mass_matrix.local_range().second);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> rhs (row_temp_matrix_partitioning),</div><div class="line">                     solution (row_temp_matrix_partitioning);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> EquationData::TemperatureInitialValues&lt;dim&gt; initial_temperature;</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">          initial_temperature.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                          rhs_values);</div><div class="line"></div><div class="line">          cell_vector = 0;</div><div class="line">          matrix_for_bc = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>=0; <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>&lt;n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                cell_vector(i) += rhs_values[<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>] *</div><div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>);</div><div class="line">                <span class="keywordflow">if</span> (temperature_constraints.is_inhomogeneously_constrained(local_dof_indices[i]))</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                      matrix_for_bc(j,i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                            fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>) *</div><div class="line">                                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(<a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a>);</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">          temperature_constraints.distribute_local_to_global (cell_vector,</div><div class="line">                                                              local_dof_indices,</div><div class="line">                                                              rhs,</div><div class="line">                                                              matrix_for_bc);</div><div class="line">        }</div><div class="line"></div><div class="line">    rhs.<a class="code" href="classVector.html#a8740c5534b6dbc31f4f1503a5e2a10a3">compress</a> (<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5*rhs.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), 1e-12*rhs.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a> preconditioner_mass;</div><div class="line">    preconditioner_mass.<a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html#a89c6576dd9f2b29fc545f25f753d4579">initialize</a>(temperature_mass_matrix, 1.3);</div><div class="line"></div><div class="line">    cg.solve (temperature_mass_matrix, solution, rhs, preconditioner_mass);</div><div class="line"></div><div class="line">    temperature_constraints.distribute (solution);</div><div class="line"></div><div class="line">    temperature_solution = solution;</div><div class="line">    old_temperature_solution = solution;</div><div class="line">    old_old_temperature_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  setup_stokes_matrix (<span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">                       <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">  {</div><div class="line">    stokes_matrix.clear ();</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning, stokes_partitioning,</div><div class="line">                                              stokes_relevant_partitioning,</div><div class="line">                                              MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> coupling (dim+1, dim+1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;dim+1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim+1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (! ((c==dim) &amp;&amp; (d==dim)))</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (stokes_dof_handler,</div><div class="line">                                     coupling, sp,</div><div class="line">                                     stokes_constraints, <span class="keyword">false</span>,</div><div class="line">                                     <a class="code" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a>::</div><div class="line">                                     <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD));</div><div class="line">    sp.compress();</div><div class="line"></div><div class="line">    stokes_matrix.reinit (sp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  setup_stokes_preconditioner (<span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">                               <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">  {</div><div class="line">    Amg_preconditioner.reset ();</div><div class="line">    Mp_preconditioner.reset ();</div><div class="line"></div><div class="line">    stokes_preconditioner_matrix.clear ();</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning, stokes_partitioning,</div><div class="line">                                              stokes_relevant_partitioning,</div><div class="line">                                              MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> coupling (dim+1, dim+1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;dim+1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim+1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == d)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (stokes_dof_handler,</div><div class="line">                                     coupling, sp,</div><div class="line">                                     stokes_constraints, <span class="keyword">false</span>,</div><div class="line">                                     <a class="code" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a>::</div><div class="line">                                     <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD));</div><div class="line">    sp.compress();</div><div class="line"></div><div class="line">    stokes_preconditioner_matrix.reinit (sp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  setup_temperature_matrices (<span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioner,</div><div class="line">                              <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioner)</div><div class="line">  {</div><div class="line">    T_preconditioner.reset ();</div><div class="line">    temperature_mass_matrix.clear ();</div><div class="line">    temperature_stiffness_matrix.clear ();</div><div class="line">    temperature_matrix.clear ();</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(temperature_partitioner,</div><div class="line">                                         temperature_partitioner,</div><div class="line">                                         temperature_relevant_partitioner,</div><div class="line">                                         MPI_COMM_WORLD);</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (temperature_dof_handler, sp,</div><div class="line">                                     temperature_constraints, <span class="keyword">false</span>,</div><div class="line">                                     <a class="code" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a>::</div><div class="line">                                     <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD));</div><div class="line">    sp.compress();</div><div class="line"></div><div class="line">    temperature_matrix.reinit (sp);</div><div class="line">    temperature_mass_matrix.reinit (sp);</div><div class="line">    temperature_stiffness_matrix.reinit (sp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs ()</div><div class="line">  {</div><div class="line">    computing_timer.enter_section(<span class="stringliteral">&quot;Setup dof systems&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks (dim+1,0);</div><div class="line">    stokes_sub_blocks[dim] = 1;</div><div class="line">    stokes_dof_handler.distribute_dofs (stokes_fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> (stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">    temperature_dof_handler.distribute_dofs (temperature_fe);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block (2);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#abfd9796e22113e13b5802e384e56af4f">DoFTools::count_dofs_per_block</a> (stokes_dof_handler, stokes_dofs_per_block,</div><div class="line">                                    stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                       n_p = stokes_dofs_per_block[1],</div><div class="line">                       n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">    std::locale s = pcout.get_stream().getloc();</div><div class="line">    pcout.get_stream().imbue(std::locale(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span></div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">          &lt;&lt; n_u + n_p + n_T</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span>&lt;&lt; n_T &lt;&lt;<span class="charliteral">&#39;)&#39;</span></div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">    pcout.get_stream().imbue(s);</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; stokes_partitioning, stokes_relevant_partitioning;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning (n_T), temperature_relevant_partitioning (n_T);</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> stokes_relevant_set;</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> stokes_index_set = stokes_dof_handler.locally_owned_dofs();</div><div class="line">      stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0,n_u));</div><div class="line">      stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u,n_u+n_p));</div><div class="line"></div><div class="line">      <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (stokes_dof_handler,</div><div class="line">                                               stokes_relevant_set);</div><div class="line">      stokes_relevant_partitioning.push_back(stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0,n_u));</div><div class="line">      stokes_relevant_partitioning.push_back(stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u,n_u+n_p));</div><div class="line"></div><div class="line">      temperature_partitioning = temperature_dof_handler.locally_owned_dofs();</div><div class="line">      <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (temperature_dof_handler,</div><div class="line">                                               temperature_relevant_partitioning);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      stokes_constraints.clear ();</div><div class="line">      stokes_constraints.reinit (stokes_relevant_set);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (stokes_dof_handler,</div><div class="line">                                               stokes_constraints);</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity_components(0);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (stokes_dof_handler,</div><div class="line">                                                0,</div><div class="line">                                                <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+1),</div><div class="line">                                                stokes_constraints,</div><div class="line">                                                stokes_fe.component_mask(velocity_components));</div><div class="line"></div><div class="line">      std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">      no_normal_flux_boundaries.insert (1);</div><div class="line">      <a class="code" href="group__constraints.html#ga0e8d8c017ac654e24e71ad3fd7e76310">VectorTools::compute_no_normal_flux_constraints</a> (stokes_dof_handler, 0,</div><div class="line">                                                       no_normal_flux_boundaries,</div><div class="line">                                                       stokes_constraints,</div><div class="line">                                                       mapping);</div><div class="line">      stokes_constraints.close ();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      temperature_constraints.clear ();</div><div class="line">      temperature_constraints.reinit (temperature_relevant_partitioning);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (temperature_dof_handler,</div><div class="line">                                               temperature_constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (temperature_dof_handler,</div><div class="line">                                                0,</div><div class="line">                                                EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                                                temperature_constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (temperature_dof_handler,</div><div class="line">                                                1,</div><div class="line">                                                EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                                                temperature_constraints);</div><div class="line">      temperature_constraints.close ();</div><div class="line">    }</div><div class="line"></div><div class="line">    setup_stokes_matrix (stokes_partitioning, stokes_relevant_partitioning);</div><div class="line">    setup_stokes_preconditioner (stokes_partitioning,</div><div class="line">                                 stokes_relevant_partitioning);</div><div class="line">    setup_temperature_matrices (temperature_partitioning,</div><div class="line">                                temperature_relevant_partitioning);</div><div class="line"></div><div class="line">    stokes_rhs.reinit (stokes_partitioning, stokes_relevant_partitioning,</div><div class="line">                       MPI_COMM_WORLD, <span class="keyword">true</span>);</div><div class="line">    stokes_solution.reinit (stokes_relevant_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_stokes_solution.reinit (stokes_solution);</div><div class="line"></div><div class="line">    temperature_rhs.reinit (temperature_partitioning,</div><div class="line">                            temperature_relevant_partitioning,</div><div class="line">                            MPI_COMM_WORLD, <span class="keyword">true</span>);</div><div class="line">    temperature_solution.reinit (temperature_relevant_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_temperature_solution.reinit (temperature_solution);</div><div class="line">    old_old_temperature_solution.reinit (temperature_solution);</div><div class="line"></div><div class="line">    rebuild_stokes_matrix              = <span class="keyword">true</span>;</div><div class="line">    rebuild_stokes_preconditioner      = <span class="keyword">true</span>;</div><div class="line">    rebuild_temperature_matrices       = <span class="keyword">true</span>;</div><div class="line">    rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    computing_timer.exit_section();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  local_assemble_stokes_preconditioner (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                        Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;scratch,</div><div class="line">                                        Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = stokes_fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line">    scratch.stokes_fe_values.reinit (cell);</div><div class="line">    cell-&gt;get_dof_indices (data.local_dof_indices);</div><div class="line"></div><div class="line">    data.local_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.grad_phi_u[k] = scratch.stokes_fe_values[velocities].gradient(k,q);</div><div class="line">            scratch.phi_p[k]      = scratch.stokes_fe_values[pressure].value (k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            data.local_matrix(i,j) += (EquationData::eta *</div><div class="line">                                       scalar_product (scratch.grad_phi_u[i],</div><div class="line">                                                       scratch.grad_phi_u[j])</div><div class="line">                                       +</div><div class="line">                                       (1./EquationData::eta) *</div><div class="line">                                       EquationData::pressure_scaling *</div><div class="line">                                       EquationData::pressure_scaling *</div><div class="line">                                       (scratch.phi_p[i] * scratch.phi_p[j]))</div><div class="line">                                      * scratch.stokes_fe_values.JxW(q);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  copy_local_to_global_stokes_preconditioner (<span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    stokes_constraints.distribute_local_to_global (data.local_matrix,</div><div class="line">                                                   data.local_dof_indices,</div><div class="line">                                                   stokes_preconditioner_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner ()</div><div class="line">  {</div><div class="line">    stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree+1);</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span></div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">    CellFilter;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::</a></div><div class="line"><a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">    run</a> (CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                     stokes_dof_handler.begin_active()),</div><div class="line">         CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                     stokes_dof_handler.end()),</div><div class="line">         std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                    local_assemble_stokes_preconditioner,</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    std::placeholders::_1,</div><div class="line">                    std::placeholders::_2,</div><div class="line">                    std::placeholders::_3),</div><div class="line">         std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                    copy_local_to_global_stokes_preconditioner,</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    std::placeholders::_1),</div><div class="line">         Assembly::Scratch::</div><div class="line">         StokesPreconditioner&lt;dim&gt; (stokes_fe, quadrature_formula,</div><div class="line">                                    mapping,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>),</div><div class="line">         Assembly::CopyData::</div><div class="line">         StokesPreconditioner&lt;dim&gt; (stokes_fe));</div><div class="line"></div><div class="line">    stokes_preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    computing_timer.enter_section (<span class="stringliteral">&quot;   Build Stokes preconditioner&quot;</span>);</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    assemble_stokes_preconditioner ();</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;bool&gt; &gt; constant_modes;</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity_components(0);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a195771d57320e298e232e3b4aa922ff8">DoFTools::extract_constant_modes</a> (stokes_dof_handler,</div><div class="line">                                      stokes_fe.component_mask(velocity_components),</div><div class="line">                                      constant_modes);</div><div class="line"></div><div class="line">    Mp_preconditioner.reset  (<span class="keyword">new</span> <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>());</div><div class="line">    Amg_preconditioner.reset (<span class="keyword">new</span> TrilinosWrappers::PreconditionAMG());</div><div class="line"></div><div class="line">    <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> Amg_data;</div><div class="line">    Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div><div class="line">    Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a> = <span class="keyword">true</span>;</div><div class="line">    Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a8bb24e061826fbdfb49aeb24f80e02fd">higher_order_elements</a> = <span class="keyword">true</span>;</div><div class="line">    Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a> = 2;</div><div class="line">    Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 0.02;</div><div class="line"></div><div class="line">    Mp_preconditioner-&gt;initialize (stokes_preconditioner_matrix.block(1,1));</div><div class="line">    Amg_preconditioner-&gt;initialize (stokes_preconditioner_matrix.block(0,0),</div><div class="line">                                    Amg_data);</div><div class="line"></div><div class="line">    rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line">    computing_timer.exit_section();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  local_assemble_stokes_system (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;scratch,</div><div class="line">                                Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.stokes_fe_values.get_fe().dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line">    scratch.stokes_fe_values.reinit (cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    temperature_cell (&amp;triangulation,</div><div class="line">                      cell-&gt;level(),</div><div class="line">                      cell-&gt;index(),</div><div class="line">                      &amp;temperature_dof_handler);</div><div class="line">    scratch.temperature_fe_values.reinit (temperature_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">      data.local_matrix = 0;</div><div class="line">    data.local_rhs = 0;</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.get_function_values (old_temperature_solution,</div><div class="line">                                                       scratch.old_temperature_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = scratch.old_temperature_values[q];</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.phi_u[k] = scratch.stokes_fe_values[velocities].value (k,q);</div><div class="line">            <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">              {</div><div class="line">                scratch.grads_phi_u[k] = scratch.stokes_fe_values[velocities].symmetric_gradient(k,q);</div><div class="line">                scratch.div_phi_u[k]   = scratch.stokes_fe_values[velocities].divergence (k, q);</div><div class="line">                scratch.phi_p[k]       = scratch.stokes_fe_values[pressure].value (k, q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              data.local_matrix(i,j) += (EquationData::eta * 2 *</div><div class="line">                                         (scratch.grads_phi_u[i] * scratch.grads_phi_u[j])</div><div class="line">                                         - (EquationData::pressure_scaling *</div><div class="line">                                            scratch.div_phi_u[i] * scratch.phi_p[j])</div><div class="line">                                         - (EquationData::pressure_scaling *</div><div class="line">                                            scratch.phi_p[i] * scratch.div_phi_u[j]))</div><div class="line">                                        * scratch.stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a></div><div class="line">        gravity = EquationData::gravity_vector (scratch.stokes_fe_values</div><div class="line">                                                .quadrature_point(q));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          data.local_rhs(i) += (EquationData::density(old_temperature) *</div><div class="line">                                gravity  *</div><div class="line">                                scratch.phi_u[i]) *</div><div class="line">                               scratch.stokes_fe_values.JxW(q);</div><div class="line">      }</div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices (data.local_dof_indices);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  copy_local_to_global_stokes_system (<span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">      stokes_constraints.distribute_local_to_global (data.local_matrix,</div><div class="line">                                                     data.local_rhs,</div><div class="line">                                                     data.local_dof_indices,</div><div class="line">                                                     stokes_matrix,</div><div class="line">                                                     stokes_rhs);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      stokes_constraints.distribute_local_to_global (data.local_rhs,</div><div class="line">                                                     data.local_dof_indices,</div><div class="line">                                                     stokes_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system ()</div><div class="line">  {</div><div class="line">    computing_timer.enter_section (<span class="stringliteral">&quot;   Assemble Stokes system&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">      stokes_matrix=0;</div><div class="line"></div><div class="line">    stokes_rhs=0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree+1);</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span></div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">    CellFilter;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::</a></div><div class="line"><a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">    run</a> (CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                     stokes_dof_handler.begin_active()),</div><div class="line">         CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                     stokes_dof_handler.end()),</div><div class="line">         std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                    local_assemble_stokes_system,</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    std::placeholders::_1,</div><div class="line">                    std::placeholders::_2,</div><div class="line">                    std::placeholders::_3),</div><div class="line">         std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                    copy_local_to_global_stokes_system,</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    std::placeholders::_1),</div><div class="line">         Assembly::Scratch::</div><div class="line">         StokesSystem&lt;dim&gt; (stokes_fe, mapping, quadrature_formula,</div><div class="line">                            (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                             (rebuild_stokes_matrix == <span class="keyword">true</span></div><div class="line">                              ?</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="line">                              :</div><div class="line">                              <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0))),</div><div class="line">                            temperature_fe,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>),</div><div class="line">         Assembly::CopyData::</div><div class="line">         StokesSystem&lt;dim&gt; (stokes_fe));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">      stokes_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    stokes_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">    rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line">    computing_timer.exit_section();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  local_assemble_temperature_matrix (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                     Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;scratch,</div><div class="line">                                     Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.temperature_fe_values.get_fe().dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.reinit (cell);</div><div class="line">    cell-&gt;get_dof_indices (data.local_dof_indices);</div><div class="line"></div><div class="line">    data.local_mass_matrix = 0;</div><div class="line">    data.local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.grad_phi_T[k] = scratch.temperature_fe_values.shape_grad (k,q);</div><div class="line">            scratch.phi_T[k]      = scratch.temperature_fe_values.shape_value (k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              data.local_mass_matrix(i,j)</div><div class="line">              += (scratch.phi_T[i] * scratch.phi_T[j]</div><div class="line">                  *</div><div class="line">                  scratch.temperature_fe_values.JxW(q));</div><div class="line">              data.local_stiffness_matrix(i,j)</div><div class="line">              += (EquationData::kappa * scratch.grad_phi_T[i] * scratch.grad_phi_T[j]</div><div class="line">                  *</div><div class="line">                  scratch.temperature_fe_values.JxW(q));</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  copy_local_to_global_temperature_matrix (<span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    temperature_constraints.distribute_local_to_global (data.local_mass_matrix,</div><div class="line">                                                        data.local_dof_indices,</div><div class="line">                                                        temperature_mass_matrix);</div><div class="line">    temperature_constraints.distribute_local_to_global (data.local_stiffness_matrix,</div><div class="line">                                                        data.local_dof_indices,</div><div class="line">                                                        temperature_stiffness_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    computing_timer.enter_section (<span class="stringliteral">&quot;   Assemble temperature matrices&quot;</span>);</div><div class="line">    temperature_mass_matrix = 0;</div><div class="line">    temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree+2);</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span></div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">    CellFilter;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::</a></div><div class="line"><a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">    run</a> (CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                     temperature_dof_handler.begin_active()),</div><div class="line">         CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                     temperature_dof_handler.end()),</div><div class="line">         std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                    local_assemble_temperature_matrix,</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    std::placeholders::_1,</div><div class="line">                    std::placeholders::_2,</div><div class="line">                    std::placeholders::_3),</div><div class="line">         std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                    copy_local_to_global_temperature_matrix,</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    std::placeholders::_1),</div><div class="line">         Assembly::Scratch::</div><div class="line">         TemperatureMatrix&lt;dim&gt; (temperature_fe, mapping, quadrature_formula),</div><div class="line">         Assembly::CopyData::</div><div class="line">         TemperatureMatrix&lt;dim&gt; (temperature_fe));</div><div class="line"></div><div class="line">    temperature_mass_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    temperature_stiffness_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">    rebuild_temperature_matrices = <span class="keyword">false</span>;</div><div class="line">    rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    computing_timer.exit_section();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  local_assemble_temperature_rhs (<span class="keyword">const</span> std::pair&lt;double,double&gt; global_T_range,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>                   global_max_velocity,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>                   global_entropy_variation,</div><div class="line">                                  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                  Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;scratch,</div><div class="line">                                  Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = scratch.temperature_fe_values.get_fe().dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"></div><div class="line">    data.local_rhs = 0;</div><div class="line">    data.matrix_for_bc = 0;</div><div class="line">    cell-&gt;get_dof_indices (data.local_dof_indices);</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.reinit (cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    stokes_cell (&amp;triangulation,</div><div class="line">                 cell-&gt;level(),</div><div class="line">                 cell-&gt;index(),</div><div class="line">                 &amp;stokes_dof_handler);</div><div class="line">    scratch.stokes_fe_values.reinit (stokes_cell);</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.get_function_values (old_temperature_solution,</div><div class="line">                                                       scratch.old_temperature_values);</div><div class="line">    scratch.temperature_fe_values.get_function_values (old_old_temperature_solution,</div><div class="line">                                                       scratch.old_old_temperature_values);</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.get_function_gradients (old_temperature_solution,</div><div class="line">                                                          scratch.old_temperature_grads);</div><div class="line">    scratch.temperature_fe_values.get_function_gradients (old_old_temperature_solution,</div><div class="line">                                                          scratch.old_old_temperature_grads);</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.get_function_laplacians (old_temperature_solution,</div><div class="line">                                                           scratch.old_temperature_laplacians);</div><div class="line">    scratch.temperature_fe_values.get_function_laplacians (old_old_temperature_solution,</div><div class="line">                                                           scratch.old_old_temperature_laplacians);</div><div class="line"></div><div class="line">    scratch.stokes_fe_values[velocities].get_function_values (stokes_solution,</div><div class="line">                                                              scratch.old_velocity_values);</div><div class="line">    scratch.stokes_fe_values[velocities].get_function_values (old_stokes_solution,</div><div class="line">                                                              scratch.old_old_velocity_values);</div><div class="line">    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients (stokes_solution,</div><div class="line">        scratch.old_strain_rates);</div><div class="line">    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients (old_stokes_solution,</div><div class="line">        scratch.old_old_strain_rates);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> nu</div><div class="line">      = compute_viscosity (scratch.old_temperature_values,</div><div class="line">                           scratch.old_old_temperature_values,</div><div class="line">                           scratch.old_temperature_grads,</div><div class="line">                           scratch.old_old_temperature_grads,</div><div class="line">                           scratch.old_temperature_laplacians,</div><div class="line">                           scratch.old_old_temperature_laplacians,</div><div class="line">                           scratch.old_velocity_values,</div><div class="line">                           scratch.old_old_velocity_values,</div><div class="line">                           scratch.old_strain_rates,</div><div class="line">                           scratch.old_old_strain_rates,</div><div class="line">                           global_max_velocity,</div><div class="line">                           global_T_range.second - global_T_range.first,</div><div class="line">                           0.5 * (global_T_range.second + global_T_range.first),</div><div class="line">                           global_entropy_variation,</div><div class="line">                           cell-&gt;diameter());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.phi_T[k]      = scratch.temperature_fe_values.shape_value (k, q);</div><div class="line">            scratch.grad_phi_T[k] = scratch.temperature_fe_values.shape_grad (k,q);</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs</div><div class="line">          = (use_bdf2_scheme ?</div><div class="line">             (scratch.old_temperature_values[q] *</div><div class="line">              (1 + time_step/old_time_step)</div><div class="line">              -</div><div class="line">              scratch.old_old_temperature_values[q] *</div><div class="line">              (time_step * time_step) /</div><div class="line">              (old_time_step * (time_step + old_time_step)))</div><div class="line">             :</div><div class="line">             scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ext_T</div><div class="line">          = (use_bdf2_scheme ?</div><div class="line">             (scratch.old_temperature_values[q] *</div><div class="line">              (1 + time_step/old_time_step)</div><div class="line">              -</div><div class="line">              scratch.old_old_temperature_values[q] *</div><div class="line">              time_step/old_time_step)</div><div class="line">             :</div><div class="line">             scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> ext_grad_T</div><div class="line">          = (use_bdf2_scheme ?</div><div class="line">             (scratch.old_temperature_grads[q] *</div><div class="line">              (1 + time_step/old_time_step)</div><div class="line">              -</div><div class="line">              scratch.old_old_temperature_grads[q] *</div><div class="line">              time_step/old_time_step)</div><div class="line">             :</div><div class="line">             scratch.old_temperature_grads[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> extrapolated_u</div><div class="line">          = (use_bdf2_scheme ?</div><div class="line">             (scratch.old_velocity_values[q] *</div><div class="line">              (1 + time_step/old_time_step)</div><div class="line">              -</div><div class="line">              scratch.old_old_velocity_values[q] *</div><div class="line">              time_step/old_time_step)</div><div class="line">             :</div><div class="line">             scratch.old_velocity_values[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> extrapolated_strain_rate</div><div class="line">          = (use_bdf2_scheme ?</div><div class="line">             (scratch.old_strain_rates[q] *</div><div class="line">              (1 + time_step/old_time_step)</div><div class="line">              -</div><div class="line">              scratch.old_old_strain_rates[q] *</div><div class="line">              time_step/old_time_step)</div><div class="line">             :</div><div class="line">             scratch.old_strain_rates[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> gamma</div><div class="line">          = ((EquationData::radiogenic_heating * EquationData::density(ext_T)</div><div class="line">              +</div><div class="line">              2 * EquationData::eta * extrapolated_strain_rate * extrapolated_strain_rate) /</div><div class="line">             (EquationData::density(ext_T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            data.local_rhs(i) += (T_term_for_rhs * scratch.phi_T[i]</div><div class="line">                                  -</div><div class="line">                                  time_step *</div><div class="line">                                  extrapolated_u * ext_grad_T * scratch.phi_T[i]</div><div class="line">                                  -</div><div class="line">                                  time_step *</div><div class="line">                                  nu * ext_grad_T * scratch.grad_phi_T[i]</div><div class="line">                                  +</div><div class="line">                                  time_step *</div><div class="line">                                  gamma * scratch.phi_T[i])</div><div class="line">                                 *</div><div class="line">                                 scratch.temperature_fe_values.JxW(q);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (temperature_constraints.is_inhomogeneously_constrained(data.local_dof_indices[i]))</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                  data.matrix_for_bc(j,i) += (scratch.phi_T[i] * scratch.phi_T[j] *</div><div class="line">                                              (use_bdf2_scheme ?</div><div class="line">                                               ((2*time_step + old_time_step) /</div><div class="line">                                                (time_step + old_time_step)) : 1.)</div><div class="line">                                              +</div><div class="line">                                              scratch.grad_phi_T[i] *</div><div class="line">                                              scratch.grad_phi_T[j] *</div><div class="line">                                              EquationData::kappa *</div><div class="line">                                              time_step)</div><div class="line">                                             *</div><div class="line">                                             scratch.temperature_fe_values.JxW(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">  copy_local_to_global_temperature_rhs (<span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    temperature_constraints.distribute_local_to_global (data.local_rhs,</div><div class="line">                                                        data.local_dof_indices,</div><div class="line">                                                        temperature_rhs,</div><div class="line">                                                        data.matrix_for_bc);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system (<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from (temperature_mass_matrix);</div><div class="line">        temperature_matrix *= (2*time_step + old_time_step) /</div><div class="line">                              (time_step + old_time_step);</div><div class="line">        temperature_matrix.add (time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from (temperature_mass_matrix);</div><div class="line">        temperature_matrix.add (time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_temperature_preconditioner == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        T_preconditioner.reset (<span class="keyword">new</span> <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>());</div><div class="line">        T_preconditioner-&gt;initialize (temperature_matrix);</div><div class="line">        rebuild_temperature_preconditioner = <span class="keyword">false</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    temperature_rhs = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree+2);</div><div class="line">    <span class="keyword">const</span> std::pair&lt;double,double&gt;</div><div class="line">    global_T_range = get_extrapolated_temperature_range();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature = 0.5 * (global_T_range.first +</div><div class="line">                                              global_T_range.second);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_entropy_variation =</div><div class="line">      get_entropy_variation (average_temperature);</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span></div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">    CellFilter;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::</a></div><div class="line"><a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">    run</a> (CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                     temperature_dof_handler.begin_active()),</div><div class="line">         CellFilter (<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                     temperature_dof_handler.end()),</div><div class="line">         std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                    local_assemble_temperature_rhs,</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    global_T_range,</div><div class="line">                    maximal_velocity,</div><div class="line">                    global_entropy_variation,</div><div class="line">                    std::placeholders::_1,</div><div class="line">                    std::placeholders::_2,</div><div class="line">                    std::placeholders::_3),</div><div class="line">         std::bind (&amp;BoussinesqFlowProblem&lt;dim&gt;::</div><div class="line">                    copy_local_to_global_temperature_rhs,</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    std::placeholders::_1),</div><div class="line">         Assembly::Scratch::</div><div class="line">         TemperatureRHS&lt;dim&gt; (temperature_fe, stokes_fe, mapping,</div><div class="line">                              quadrature_formula),</div><div class="line">         Assembly::CopyData::</div><div class="line">         TemperatureRHS&lt;dim&gt; (temperature_fe));</div><div class="line"></div><div class="line">    temperature_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    computing_timer.enter_section (<span class="stringliteral">&quot;   Solve Stokes system&quot;</span>);</div><div class="line"></div><div class="line">    {</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Solving Stokes system... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a></div><div class="line">      distributed_stokes_solution (stokes_rhs);</div><div class="line">      distributed_stokes_solution = stokes_solution;</div><div class="line"></div><div class="line">      distributed_stokes_solution.block(1) /= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">      start = (distributed_stokes_solution.block(0).size() +</div><div class="line">               distributed_stokes_solution.block(1).local_range().first),</div><div class="line">              end   = (distributed_stokes_solution.block(0).size() +</div><div class="line">                       distributed_stokes_solution.block(1).local_range().second);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=start; i&lt;end; ++i)</div><div class="line">        <span class="keywordflow">if</span> (stokes_constraints.is_constrained (i))</div><div class="line">          distributed_stokes_solution(i) = 0;</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classPrimitiveVectorMemory.html">PrimitiveVectorMemory&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> mem;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = 0;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> solver_tolerance = 1e-8 * stokes_rhs.l2_norm();</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (30, solver_tolerance);</div><div class="line"></div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;TrilinosWrappers::PreconditionAMG,</div><div class="line">                <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">                preconditioner (stokes_matrix, stokes_preconditioner_matrix,</div><div class="line">                                *Mp_preconditioner, *Amg_preconditioner,</div><div class="line">                                <span class="keyword">false</span>);</div><div class="line"></div><div class="line">          <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a></div><div class="line">          solver(solver_control, mem,</div><div class="line">                 <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a>::</div><div class="line">                 AdditionalData(30, <span class="keyword">true</span>));</div><div class="line">          solver.solve(stokes_matrix, distributed_stokes_solution, stokes_rhs,</div><div class="line">                       preconditioner);</div><div class="line"></div><div class="line">          n_iterations = solver_control.last_step();</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">catch</span> (<a class="code" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a> &amp;)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;TrilinosWrappers::PreconditionAMG,</div><div class="line">                <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">                preconditioner (stokes_matrix, stokes_preconditioner_matrix,</div><div class="line">                                *Mp_preconditioner, *Amg_preconditioner,</div><div class="line">                                <span class="keyword">true</span>);</div><div class="line"></div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control_refined (stokes_matrix.m(), solver_tolerance);</div><div class="line">          <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a></div><div class="line">          solver(solver_control_refined, mem,</div><div class="line">                 <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a>::</div><div class="line">                 AdditionalData(50, <span class="keyword">true</span>));</div><div class="line">          solver.solve(stokes_matrix, distributed_stokes_solution, stokes_rhs,</div><div class="line">                       preconditioner);</div><div class="line"></div><div class="line">          n_iterations = (solver_control.last_step() +</div><div class="line">                          solver_control_refined.last_step());</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      stokes_constraints.distribute (distributed_stokes_solution);</div><div class="line"></div><div class="line">      distributed_stokes_solution.block(1) *= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">      stokes_solution = distributed_stokes_solution;</div><div class="line">      pcout &lt;&lt; n_iterations  &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    computing_timer.exit_section();</div><div class="line"></div><div class="line"></div><div class="line">    computing_timer.enter_section (<span class="stringliteral">&quot;   Assemble temperature rhs&quot;</span>);</div><div class="line">    {</div><div class="line">      old_time_step = time_step;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> scaling = (dim==3 ? 0.25 : 1.0);</div><div class="line">      time_step = (scaling/(2.1*dim*std::sqrt(1.*dim)) /</div><div class="line">                   (parameters.temperature_degree *</div><div class="line">                    get_cfl_number()));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Maximal velocity: &quot;</span></div><div class="line">            &lt;&lt; maximal_velocity *EquationData::year_in_seconds * 100</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; cm/year&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span></div><div class="line">            &lt;&lt; time_step/EquationData::year_in_seconds</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; years&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      temperature_solution = old_temperature_solution;</div><div class="line">      assemble_temperature_system (maximal_velocity);</div><div class="line">    }</div><div class="line">    computing_timer.exit_section ();</div><div class="line"></div><div class="line">    computing_timer.enter_section (<span class="stringliteral">&quot;   Solve temperature system&quot;</span>);</div><div class="line">    {</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (temperature_matrix.m(),</div><div class="line">                                    1e-12*temperature_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a>   cg (solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="line">      distributed_temperature_solution (temperature_rhs);</div><div class="line">      distributed_temperature_solution = temperature_solution;</div><div class="line"></div><div class="line">      cg.solve (temperature_matrix, distributed_temperature_solution,</div><div class="line">                temperature_rhs, *T_preconditioner);</div><div class="line"></div><div class="line">      temperature_constraints.distribute (distributed_temperature_solution);</div><div class="line">      temperature_solution = distributed_temperature_solution;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature&quot;</span> &lt;&lt; std::endl;</div><div class="line">      computing_timer.exit_section();</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> temperature[2] = { std::numeric_limits&lt;double&gt;::max(),</div><div class="line">                                -std::numeric_limits&lt;double&gt;::max()</div><div class="line">                              };</div><div class="line">      <span class="keywordtype">double</span> global_temperature[2];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=distributed_temperature_solution.local_range().first;</div><div class="line">           i &lt; distributed_temperature_solution.local_range().second; ++i)</div><div class="line">        {</div><div class="line">          temperature[0] = std::min&lt;double&gt; (temperature[0],</div><div class="line">                                             distributed_temperature_solution(i));</div><div class="line">          temperature[1] = std::max&lt;double&gt; (temperature[1],</div><div class="line">                                             distributed_temperature_solution(i));</div><div class="line">        }</div><div class="line"></div><div class="line">      temperature[0] *= -1.0;</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> (temperature, MPI_COMM_WORLD, global_temperature);</div><div class="line">      global_temperature[0] *= -1.0;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span></div><div class="line">            &lt;&lt; global_temperature[0] &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; global_temperature[1]</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoussinesqFlowProblem&lt;dim&gt;::Postprocessor : <span class="keyword">public</span> <a class="code" href="classDataPostprocessor.html">DataPostprocessor</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Postprocessor (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partition,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    evaluate_vector_field</div><div class="line">    (<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;               &amp;computed_quantities) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::vector&lt;std::string&gt; get_names () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    get_data_component_interpretation () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> get_needed_update_flags () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a4673bdd5ed26b4492008ac8366754f9d">partition</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::</div><div class="line">  Postprocessor (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partition,</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure)</div><div class="line">    :</div><div class="line">    partition (partition),</div><div class="line">    minimal_pressure (minimal_pressure)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;std::string&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_names()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names (dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;friction_heating&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;partition&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> solution_names;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::</div><div class="line">  get_data_component_interpretation ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    interpretation (dim,</div><div class="line">                    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">    interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    interpretation.push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> interpretation;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_needed_update_flags()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa49a49d892021457f921318905c408e25">update_q_points</a>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::</div><div class="line">  evaluate_vector_field</div><div class="line">  (<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;               &amp;computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_quadrature_points = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size();</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>.size() == n_quadrature_points,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (computed_quantities.size() == n_quadrature_points,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[0].size() == dim+2,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_quadrature_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          computed_quantities[q](d)</div><div class="line">            = (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) *  EquationData::year_in_seconds * 100);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> pressure = (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim)-minimal_pressure);</div><div class="line">        computed_quantities[q](dim) = pressure;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim+1);</div><div class="line">        computed_quantities[q](dim+1) = temperature;</div><div class="line"></div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> grad_u;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          grad_u[d] = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>[q][d];</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> strain_rate = symmetrize (grad_u);</div><div class="line">        computed_quantities[q](dim+2) = 2 * EquationData::eta *</div><div class="line">                                        strain_rate * strain_rate;</div><div class="line"></div><div class="line">        computed_quantities[q](dim+3) = partition;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results ()</div><div class="line">  {</div><div class="line">    computing_timer.enter_section (<span class="stringliteral">&quot;Postprocessing&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe (stokes_fe, 1,</div><div class="line">                                  temperature_fe, 1);</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> joint_dof_handler (triangulation);</div><div class="line">    joint_dof_handler.distribute_dofs (joint_fe);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (joint_dof_handler.n_dofs() ==</div><div class="line">            stokes_dof_handler.n_dofs() + temperature_dof_handler.n_dofs(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> joint_solution;</div><div class="line">    joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a27a757b55f969defc53c7be563c819b0">reinit</a> (joint_dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices (joint_fe.dofs_per_cell);</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_stokes_dof_indices (stokes_fe.dofs_per_cell);</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_temperature_dof_indices (temperature_fe.dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      joint_cell       = joint_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">      joint_endc       = joint_dof_handler.end(),</div><div class="line">      stokes_cell      = stokes_dof_handler.begin_active(),</div><div class="line">      temperature_cell = temperature_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">      <span class="keywordflow">for</span> (; joint_cell!=joint_endc;</div><div class="line">           ++joint_cell, ++stokes_cell, ++temperature_cell)</div><div class="line">        <span class="keywordflow">if</span> (joint_cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            joint_cell-&gt;get_dof_indices (local_joint_dof_indices);</div><div class="line">            stokes_cell-&gt;get_dof_indices (local_stokes_dof_indices);</div><div class="line">            temperature_cell-&gt;get_dof_indices (local_temperature_dof_indices);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;joint_fe.dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">                {</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (joint_fe.system_to_base_index(i).second</div><div class="line">                          &lt;</div><div class="line">                          local_stokes_dof_indices.size(),</div><div class="line">                          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">                  joint_solution(local_joint_dof_indices[i])</div><div class="line">                    = stokes_solution(local_stokes_dof_indices</div><div class="line">                                      [joint_fe.system_to_base_index(i).second]);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (joint_fe.system_to_base_index(i).second</div><div class="line">                          &lt;</div><div class="line">                          local_temperature_dof_indices.size(),</div><div class="line">                          <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                  joint_solution(local_joint_dof_indices[i])</div><div class="line">                    = temperature_solution(local_temperature_dof_indices</div><div class="line">                                           [joint_fe.system_to_base_index(i).second]);</div><div class="line">                }</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">    joint_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_joint_dofs(joint_dof_handler.n_dofs());</div><div class="line">    <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (joint_dof_handler, locally_relevant_joint_dofs);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_joint_solution;</div><div class="line">    locally_relevant_joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a27a757b55f969defc53c7be563c819b0">reinit</a> (locally_relevant_joint_dofs, MPI_COMM_WORLD);</div><div class="line">    locally_relevant_joint_solution = joint_solution;</div><div class="line"></div><div class="line">    Postprocessor postprocessor (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD),</div><div class="line">                                 stokes_solution.block(1).min());</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (joint_dof_handler);</div><div class="line">    data_out.add_data_vector (locally_relevant_joint_solution, postprocessor);</div><div class="line">    data_out.build_patches ();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> out_index=0;</div><div class="line">    <span class="keyword">const</span> std::string filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                  <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (out_index, 5) +</div><div class="line">                                  <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                                  <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="line">                                  (triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4) +</div><div class="line">                                  <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    std::ofstream output (filename.c_str());</div><div class="line">    data_out.write_vtu (output);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">      {</div><div class="line">        std::vector&lt;std::string&gt; filenames;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD); ++i)</div><div class="line">          filenames.push_back (std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (out_index, 5) +</div><div class="line">                               <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i, 4) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">        <span class="keyword">const</span> std::string</div><div class="line">        pvtu_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (out_index, 5) +</div><div class="line">                                <span class="stringliteral">&quot;.pvtu&quot;</span>);</div><div class="line">        std::ofstream pvtu_master (pvtu_master_filename.c_str());</div><div class="line">        data_out.write_pvtu_record (pvtu_master, filenames);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::string</div><div class="line">        visit_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (out_index, 5) +</div><div class="line">                                 <span class="stringliteral">&quot;.visit&quot;</span>);</div><div class="line">        std::ofstream visit_master (visit_master_filename.c_str());</div><div class="line">        <a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a> (visit_master, filenames);</div><div class="line">      }</div><div class="line"></div><div class="line">    computing_timer.exit_section ();</div><div class="line">    out_index++;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::refine_mesh (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">  {</div><div class="line">    computing_timer.enter_section (<span class="stringliteral">&quot;Refine mesh structure, part 1&quot;</span>);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (temperature_dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(parameters.temperature_degree+1),</div><div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                        temperature_solution,</div><div class="line">                                        estimated_error_per_cell,</div><div class="line">                                        <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                        <span class="keyword">nullptr</span>,</div><div class="line">                                        0,</div><div class="line">                                        triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#a8fe97b1fc8f61b09d6a7c398a8b975ff">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#a8fe97b1fc8f61b09d6a7c398a8b975ff">    refine_and_coarsen_fixed_fraction</a> (triangulation,</div><div class="line">                                       estimated_error_per_cell,</div><div class="line">                                       0.3, 0.1);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">           cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(max_grid_level);</div><div class="line">           cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">        cell-&gt;clear_refine_flag ();</div><div class="line"></div><div class="line">    std::vector&lt;const TrilinosWrappers::MPI::Vector *&gt; x_temperature (2);</div><div class="line">    x_temperature[0] = &amp;temperature_solution;</div><div class="line">    x_temperature[1] = &amp;old_temperature_solution;</div><div class="line">    std::vector&lt;const TrilinosWrappers::MPI::BlockVector *&gt; x_stokes (2);</div><div class="line">    x_stokes[0] = &amp;stokes_solution;</div><div class="line">    x_stokes[1] = &amp;old_stokes_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim,TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">    temperature_trans(temperature_dof_handler);</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim,TrilinosWrappers::MPI::BlockVector&gt;</a></div><div class="line">    stokes_trans(stokes_dof_handler);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">    temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">    stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">    computing_timer.exit_section();</div><div class="line"></div><div class="line">    setup_dofs ();</div><div class="line"></div><div class="line">    computing_timer.enter_section (<span class="stringliteral">&quot;Refine mesh structure, part 2&quot;</span>);</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp1 (temperature_rhs);</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp2 (temperature_rhs);</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::Vector *&gt; tmp (2);</div><div class="line">      tmp[0] = &amp;(distributed_temp1);</div><div class="line">      tmp[1] = &amp;(distributed_temp2);</div><div class="line">      temperature_trans.interpolate(tmp);</div><div class="line"></div><div class="line">      temperature_constraints.distribute(distributed_temp1);</div><div class="line">      temperature_constraints.distribute(distributed_temp2);</div><div class="line"></div><div class="line">      temperature_solution     = distributed_temp1;</div><div class="line">      old_temperature_solution = distributed_temp2;</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes (stokes_rhs);</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_distributed_stokes (stokes_rhs);</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::BlockVector *&gt; stokes_tmp (2);</div><div class="line">      stokes_tmp[0] = &amp;(distributed_stokes);</div><div class="line">      stokes_tmp[1] = &amp;(old_distributed_stokes);</div><div class="line"></div><div class="line">      stokes_trans.interpolate (stokes_tmp);</div><div class="line"></div><div class="line">      stokes_constraints.distribute(distributed_stokes);</div><div class="line">      stokes_constraints.distribute(old_distributed_stokes);</div><div class="line"></div><div class="line">      stokes_solution     = distributed_stokes;</div><div class="line">      old_stokes_solution = old_distributed_stokes;</div><div class="line">    }</div><div class="line"></div><div class="line">    computing_timer.exit_section();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                                <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(),</div><div class="line">                                EquationData::R0,</div><div class="line">                                EquationData::R1,</div><div class="line">                                (dim==3) ? 96 : 12,</div><div class="line">                                <span class="keyword">true</span>);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(1);</div><div class="line">    <span class="keyword">static</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold;</div><div class="line">    <span class="keyword">static</span> <a class="code" href="classHyperShellBoundary.html">HyperShellBoundary&lt;dim&gt;</a> boundary;</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, manifold);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (1, boundary);</div><div class="line"></div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a> (triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (parameters.initial_global_refinement);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">start_time_iteration:</div><div class="line"></div><div class="line">    project_temperature_field ();</div><div class="line"></div><div class="line">    timestep_number           = 0;</div><div class="line">    time_step = old_time_step = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time/EquationData::year_in_seconds</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; years&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_stokes_system ();</div><div class="line">        build_stokes_preconditioner ();</div><div class="line">        assemble_temperature_matrix ();</div><div class="line"></div><div class="line">        solve ();</div><div class="line"></div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; parameters.initial_adaptive_refinement))</div><div class="line">          {</div><div class="line">            refine_mesh (parameters.initial_global_refinement +</div><div class="line">                         parameters.initial_adaptive_refinement);</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0)</div><div class="line">                 &amp;&amp;</div><div class="line">                 (timestep_number % parameters.adaptive_refinement_interval == 0))</div><div class="line">          refine_mesh (parameters.initial_global_refinement +</div><div class="line">                       parameters.initial_adaptive_refinement);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>)</div><div class="line">            &amp;&amp;</div><div class="line">            (timestep_number % parameters.graphical_output_interval == 0))</div><div class="line">          output_results ();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time &gt; parameters.end_time * EquationData::year_in_seconds)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_old_stokes_solution;</div><div class="line">        old_old_stokes_solution      = old_stokes_solution;</div><div class="line">        old_stokes_solution          = stokes_solution;</div><div class="line">        old_old_temperature_solution = old_temperature_solution;</div><div class="line">        old_temperature_solution     = temperature_solution;</div><div class="line">        <span class="keywordflow">if</span> (old_time_step &gt; 0)</div><div class="line">          {</div><div class="line">            {</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_solution (stokes_rhs);</div><div class="line">              distr_solution = stokes_solution;</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_old_solution (stokes_rhs);</div><div class="line">              distr_old_solution = old_old_stokes_solution;</div><div class="line">              distr_solution .<a class="code" href="classBlockVectorBase.html#a71b0ab8295e98caf3dfe1ef14ae6b6c1">sadd</a> (1.+time_step/old_time_step, -time_step/old_time_step,</div><div class="line">                                    distr_old_solution);</div><div class="line">              stokes_solution = distr_solution;</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_solution (temperature_rhs);</div><div class="line">              distr_solution = temperature_solution;</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_old_solution (temperature_rhs);</div><div class="line">              distr_old_solution = old_old_temperature_solution;</div><div class="line">              distr_solution .sadd (1.+time_step/old_time_step, -time_step/old_time_step,</div><div class="line">                                    distr_old_solution);</div><div class="line">              temperature_solution = distr_solution;</div><div class="line">            }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 100 == 0))</div><div class="line">          computing_timer.print_summary ();</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>)</div><div class="line">        &amp;&amp;</div><div class="line">        !((timestep_number-1) % parameters.graphical_output_interval == 0))</div><div class="line">      output_results ();</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>Step32;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv,</div><div class="line">                                                      <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      std::string parameter_filename;</div><div class="line">      <span class="keywordflow">if</span> (argc&gt;=2)</div><div class="line">        parameter_filename = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_filename = <span class="stringliteral">&quot;step-32.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt;::Parameters  parameters(parameter_filename);</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt; flow_problem (parameters);</div><div class="line">      flow_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
