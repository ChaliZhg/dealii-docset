<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Boundary and manifold description for triangulations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Boundary and manifold description for triangulations<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Boundary and manifold description for triangulations:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__boundary.svg" width="346" height="50"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoundary.html">Boundary&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStraightBoundary.html">StraightBoundary&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCylinderBoundary.html">CylinderBoundary&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHyperBallBoundary.html">HyperBallBoundary&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHalfHyperBallBoundary.html">HalfHyperBallBoundary&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHyperShellBoundary.html">HyperShellBoundary&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHalfHyperShellBoundary.html">HalfHyperShellBoundary&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga19accbef5edb5bb16a926d3db659cd5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">Triangulation&lt; dim, spacedim &gt;::set_boundary</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number, const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;boundary_object)</td></tr>
<tr class="separator:ga19accbef5edb5bb16a926d3db659cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga328685f4aaaf02eafbf62675641af1cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga328685f4aaaf02eafbf62675641af1cc">Triangulation&lt; dim, spacedim &gt;::set_boundary</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga328685f4aaaf02eafbf62675641af1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda05ab52a5ecc458f0a9a6746420a29"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gadda05ab52a5ecc458f0a9a6746420a29">Triangulation&lt; dim, spacedim &gt;::get_boundary</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a> number) const</td></tr>
<tr class="separator:gadda05ab52a5ecc458f0a9a6746420a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a0d3cc6653496e5bebf32220ac4160"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga63a0d3cc6653496e5bebf32220ac4160">Triangulation&lt; dim, spacedim &gt;::get_boundary_ids</a> () const</td></tr>
<tr class="separator:ga63a0d3cc6653496e5bebf32220ac4160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with boundary indicators</h2></td></tr>
<tr class="memitem:ga654de9ccd776b524a27cd64bded48e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga654de9ccd776b524a27cd64bded48e14">TriaAccessor&lt; structdim, dim, spacedim &gt;::set_boundary_id</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const</td></tr>
<tr class="separator:ga654de9ccd776b524a27cd64bded48e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0304fb253839c45e64b60460ab040ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa0304fb253839c45e64b60460ab040ae">TriaAccessor&lt; structdim, dim, spacedim &gt;::set_all_boundary_ids</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>) const</td></tr>
<tr class="separator:gaa0304fb253839c45e64b60460ab040ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with boundary indicators</h2></td></tr>
<tr class="memitem:gab1cd9b187b45f2099791a481b4b809d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab1cd9b187b45f2099791a481b4b809d0">TriaAccessor&lt; 0, 1, spacedim &gt;::set_boundary_id</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>)</td></tr>
<tr class="separator:gab1cd9b187b45f2099791a481b4b809d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634d41845eab9b88581b3fcea59a86d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga634d41845eab9b88581b3fcea59a86d4">TriaAccessor&lt; 0, 1, spacedim &gt;::set_all_boundary_ids</a> (const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>)</td></tr>
<tr class="separator:ga634d41845eab9b88581b3fcea59a86d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea37d3b925b8e6a2c02d9ef9c454ed54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaea37d3b925b8e6a2c02d9ef9c454ed54">TriaAccessor&lt; 0, 1, spacedim &gt;::set_manifold_id</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>)</td></tr>
<tr class="separator:gaea37d3b925b8e6a2c02d9ef9c454ed54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga853633832f20bf91d674749b9ae83827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga853633832f20bf91d674749b9ae83827">TriaAccessor&lt; 0, 1, spacedim &gt;::set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>)</td></tr>
<tr class="separator:ga853633832f20bf91d674749b9ae83827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The classes in this module are concerned with the description of the geometry of a domain in which a <a class="el" href="classTriangulation.html">Triangulation</a> lives. This geometry description is necessary in three contexts: </p><ul>
<li>
<p class="startli">Mesh refinement: Whenever a cell is refined, it is necessary to introduce at least one new vertex. In the simplest case, one assumes that the cells and their faces consists of straight line segments, bilinear surface or trilinear volumes between the vertices of the original, coarsest mesh, and the next vertex is simply put into the middle of the old ones. This is the default behavior of the <a class="el" href="classTriangulation.html">Triangulation</a> class, and is described by the <a class="el" href="classStraightBoundary.html">StraightBoundary</a> and <a class="el" href="classFlatManifold.html">FlatManifold</a> classes.</p>
<p>On the other hand, if one deals with curved geometries and boundaries, this is not the appropriate thing to do. The classes derived from the <a class="el" href="classManifold.html">Manifold</a> and <a class="el" href="classBoundary.html">Boundary</a> base classes describe the geometry of a domain. One can then attach an object of a class derived from this base classes to the <a class="el" href="classTriangulation.html">Triangulation</a> object using the <a class="el" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">Triangulation::set_boundary()</a> or <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> functions, and the <a class="el" href="classTriangulation.html">Triangulation</a> will ask the manifold object where a new vertex should be located upon mesh refinement. Several classes already exist to support the boundary of the most common geometries, e.g., <a class="el" href="classCylinderBoundary.html">CylinderBoundary</a>, <a class="el" href="classHyperBallBoundary.html">HyperBallBoundary</a>, or <a class="el" href="classHyperShellBoundary.html">HyperShellBoundary</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Integration: When using higher order finite element methods, it is often necessary to compute cell terms (like cell contributions to the matrix and right hand side of the linear system) using curved approximations of the geometry, rather than the straight line approximation. The actual implementation of such curved elements happens in the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class (see the <a class="el" href="group__mapping.html">Mappings between reference and real cell</a> module), which however obtains its information about the manifold description from the classes described here. The same is, of course, true when integrating boundary terms (e.g., inhomogenous Neumann boundary conditions).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">In cases where a <a class="el" href="classTriangulation.html">Triangulation</a> is embedded into a higher dimensional space, i.e., whenever the second template argument of the <a class="el" href="classTriangulation.html">Triangulation</a> class is explicitly specified and larger than the first (for an example, see <a class="el" href="step_34.html">step-34</a>), the manifold description objects serve as a tool to describe the geometry not only of the boundary of the domain but of the domain itself, in case the domain is a manifold that is in fact curved. In these cases, one can use the <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> function to indicate what manifold description to use when refining the curve, or when computing integrals using high order mappings.</p>
<p class="endli"></p>
</li>
</ul>
<p>In the context of triangulations, each object stores a number called <code>manifold_id</code>, and each face of a cell that is located at the boundary of the domain stores a number called <code>boundary_id</code> that uniquely identifies which part of the boundary this face is on. If nothing is specified at creation time, each boundary face has a zero boundary id and each triangulation object has an invalid manifold id. On the other hand, the boundary id of faces and the manifold id of objects can be set either at creation time or later by looping over all cells and querying their faces.</p>
<p>It is then possible to associate objects describing the geometry to certain boundary_id values used in a triangulation and to certain manifold_id values.</p>
<p>Before version 8.2, the library allowed only boundary faces to follow a curved geometric description. Since version 8.2 this has been introduced also for interior faces and cells, and the boundary_id has been separated from the manifold_id.</p>
<p>Although the old behavior is still supported, one should use the boundary indicator only for the physical meaning associated, for example, to boundary conditions, and revert to manifold_ids to describe the geometry of the triangulation.</p>
<p>The behavior of the <a class="el" href="classTriangulation.html">Triangulation</a> class w.r.t. geometry descriptions is the following: <a class="el" href="group__boundary.html#ga19accbef5edb5bb16a926d3db659cd5c">Triangulation::set_boundary()</a> and <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> do the exact same thing: they attach a manifold descriptor to the specified id. The first function expects a <a class="el" href="classBoundary.html">Boundary</a> descriptor (which is a specialization of a <a class="el" href="classManifold.html">Manifold</a> description) and is provided mainly for backward compatibility, while the second class expects a <a class="el" href="classManifold.html">Manifold</a> descriptor. Notice that the <a class="el" href="classTriangulation.html">Triangulation</a> class only uses the <a class="el" href="classManifold.html">Manifold</a> interface, and you could describe both the interior and the boundary of the domain using the same object. The additional information contained in the <a class="el" href="classBoundary.html">Boundary</a> interface is related to the computation of the exact normals.</p>
<p>Whenever a new vertex is needed in an object, the <a class="el" href="classTriangulation.html">Triangulation</a> queries the manifold_id of the object which needs refinement. If the manifold_id is set to <a class="el" href="namespacenumbers.html#a13049bc76f27e3b976d6b08d0736cb1b">numbers::invalid_manifold_id</a>, then the <a class="el" href="classTriangulation.html">Triangulation</a> queries the boundary_id (if the face is on the boundary) or the material_id (if the <a class="el" href="classTriangulation.html">Triangulation</a> is of codimension one and the object is a cell). If the previous queries resulted in a number different from <a class="el" href="namespacenumbers.html#a13049bc76f27e3b976d6b08d0736cb1b">numbers::invalid_manifold_id</a>, then the <a class="el" href="classTriangulation.html">Triangulation</a> looks whether a previous call to <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> (or set_boundary()) was performed with the given id, and if yes, it uses the stored object to obtain new vertices, otherwise it uses a <a class="el" href="classFlatManifold.html">FlatManifold</a> or <a class="el" href="classStraightBoundary.html">StraightBoundary</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>This behavior is backward compatible to that of deal.II versions prior to 8.2. If one ignores the manifold_id of an object (i.e., if it has never been set), by default it is and remains set to <a class="el" href="namespacenumbers.html#a13049bc76f27e3b976d6b08d0736cb1b">numbers::invalid_manifold_id</a>. In that case, the first query above will trigger a query to the old style boundary_id. This behavior will be maintained for a while, but might eventually be changed. The suggested strategy is to use manifold_ids to describe the geometry, and boundary_ids to describe boundary conditions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd>
<dd>
<a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Luca Heltai, 1998-2014 </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga19accbef5edb5bb16a926d3db659cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19accbef5edb5bb16a926d3db659cd5c">&#9670;&nbsp;</a></span>set_boundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>dim==spacedim</code>, assign a boundary object to a certain part of the boundary of a the triangulation. If a face with boundary number <code>number</code> is refined, this object is used to find the location of new vertices on the boundary (see the results section of <a class="el" href="step_49.html">step-49</a> for a more in-depth discussion of this, with examples). It is also used for non-linear (i.e.: non-Q1) transformations of cells to the unit cell in shape function calculations.</p>
<p>If <code>dim!=spacedim</code> the boundary object is in fact the exact manifold that the triangulation is approximating (for example a circle approximated by a polygon triangulation). As above, the refinement is made in such a way that the new points are located on the exact manifold.</p>
<p>Numbers of boundary objects correspond to material numbers of faces at the boundary, for instance the material id in a UCD input file. They are not necessarily consecutive but must be in the range 0-(<a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>-1). Material IDs on boundaries are also called boundary indicators and are accessed with accessor functions of that name.</p>
<p>The <code>boundary_object</code> is not copied and MUST persist until the triangulation is destroyed. This is also true for triangulations generated from this one by <code>copy_triangulation</code>.</p>
<p>It is possible to remove or replace the boundary object during the lifetime of a non-empty triangulation. Usually, this is done before the first refinement and is dangerous afterwards. Removal of a boundary object is done by <code>set_boundary(number)</code>, i.e. the function of same name but only one argument. This operation then replaces the boundary object given before by a straight boundary approximation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09110">9110</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga328685f4aaaf02eafbf62675641af1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga328685f4aaaf02eafbf62675641af1cc">&#9670;&nbsp;</a></span>set_boundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset those parts of the boundary with the given number to use a straight boundary approximation. This is the default state of a triangulation, and undoes assignment of a different boundary object by the function of same name and two arguments.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09130">9130</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="gadda05ab52a5ecc458f0a9a6746420a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda05ab52a5ecc458f0a9a6746420a29">&#9670;&nbsp;</a></span>get_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBoundary.html">Boundary</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to a boundary object used for this triangulation. Number is the same as in <code>set_boundary</code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09218">9218</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga63a0d3cc6653496e5bebf32220ac4160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63a0d3cc6653496e5bebf32220ac4160">&#9670;&nbsp;</a></span>get_boundary_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a> &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_boundary_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector containing all boundary indicators assigned to boundary faces of this <a class="el" href="classTriangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8cc_source.html#l09256">9256</a> of file <a class="el" href="grid_2tria_8cc_source.html">tria.cc</a>.</p>

</div>
</div>
<a id="ga654de9ccd776b524a27cd64bded48e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga654de9ccd776b524a27cd64bded48e14">&#9670;&nbsp;</a></span>set_boundary_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the boundary indicator of the current object. The same applies as for the <a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">boundary_id()</a> function.</p>
<p>This function only sets the boundary object of the current object itself, not the indicators of the ones that bound it. For example, in 3d, if this function is called on a face, then the boundary indicator of the 4 edges that bound the face remain unchanged. If you want to set the boundary indicators of face and edges at the same time, use the <a class="el" href="group__boundary.html#gaa0304fb253839c45e64b60460ab040ae">set_all_boundary_ids()</a> function. You can see the result of not using the correct function in the results section of <a class="el" href="step_49.html">step-49</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should never set the boundary indicator of an interior face (a face not at the boundary of the domain), or set set the boundary indicator of an exterior face to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> (this value is reserved for another purpose). <a class="el" href="namespaceAlgorithms.html">Algorithms</a> may not work or produce very confusing results if boundary cells have a boundary indicator of <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> or if interior cells have boundary indicators other than <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>. Unfortunately, the current object has no means of finding out whether it really is at the boundary of the domain and so cannot determine whether the value you are trying to set makes sense under the current circumstances.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="gaa0304fb253839c45e64b60460ab040ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0304fb253839c45e64b60460ab040ae">&#9670;&nbsp;</a></span>set_all_boundary_ids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_boundary_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do as <a class="el" href="group__boundary.html#ga654de9ccd776b524a27cd64bded48e14">set_boundary_id()</a> but also set the boundary indicators of the objects that bound the current object. For example, in 3d, if <a class="el" href="group__boundary.html#ga654de9ccd776b524a27cd64bded48e14">set_boundary_id()</a> is called on a face, then the boundary indicator of the 4 edges that bound the face remain unchanged. In contrast, if you call the current function, the boundary indicators of face and edges are all set to the given value.</p>
<p>This function is useful if you set boundary indicators of faces in 3d (in 2d, the function does the same as <a class="el" href="group__boundary.html#ga654de9ccd776b524a27cd64bded48e14">set_boundary_id()</a>) and you do so because you want a curved boundary object to represent the part of the boundary that corresponds to the current face. In that case, the <a class="el" href="classTriangulation.html">Triangulation</a> class needs to figure out where to put new vertices upon mesh refinement, and higher order <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> objects also need to figure out where new interpolation points for a curved boundary approximation should be. In either case, the two classes first determine where interpolation points on the edges of a boundary face should be, asking the boundary object, before asking the boundary object for the interpolation points corresponding to the interior of the boundary face. For this to work properly, it is not sufficient to have set the boundary indicator for the face alone, but you also need to set the boundary indicators of the edges that bound the face. This function does all of this at once. You can see the result of not using the correct function in the results section of <a class="el" href="step_49.html">step-49</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="gab1cd9b187b45f2099791a481b4b809d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1cd9b187b45f2099791a481b4b809d0">&#9670;&nbsp;</a></span>set_boundary_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, 1, spacedim &gt;::set_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the boundary indicator. The same applies as for the <code><a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html#a7c60ffad244e374cafb06c334c6ef1d8">boundary_id()</a></code> function.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should never set the boundary indicator of an interior face (a face not at the boundary of the domain), or set set the boundary indicator of an exterior face to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> (this value is reserved for another purpose). <a class="el" href="namespaceAlgorithms.html">Algorithms</a> may not work or produce very confusing results if boundary cells have a boundary indicator of <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> or if interior cells have boundary indicators other than <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>. Unfortunately, the current object has no means of finding out whether it really is at the boundary of the domain and so cannot determine whether the value you are trying to set makes sense under the current circumstances.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ga634d41845eab9b88581b3fcea59a86d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga634d41845eab9b88581b3fcea59a86d4">&#9670;&nbsp;</a></span>set_all_boundary_ids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, 1, spacedim &gt;::set_all_boundary_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a685c06c8ba84120df596d9e56f5510e2">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the boundary indicator of this object and all of its lower- dimensional sub-objects. Since this object only represents a single vertex, there are no lower-dimensional object and this function is equivalent to calling <a class="el" href="group__boundary.html#gab1cd9b187b45f2099791a481b4b809d0">set_boundary_id()</a> with the same argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="gaea37d3b925b8e6a2c02d9ef9c454ed54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea37d3b925b8e6a2c02d9ef9c454ed54">&#9670;&nbsp;</a></span>set_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, 1, spacedim &gt;::set_manifold_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold indicator of this vertex. This does nothing so far since manifolds are only used to refine and map objects, but vertices are not refined and the mapping is trivial. This function is here only to allow dimension independent programming. </p>

</div>
</div>
<a id="ga853633832f20bf91d674749b9ae83827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga853633832f20bf91d674749b9ae83827">&#9670;&nbsp;</a></span>set_all_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, 1, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a9f062a82e4dab1dd631a2c4fa8162bea">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold indicator of this object and all of its lower- dimensional sub-objects. Since this object only represents a single vertex, there are no lower-dimensional object and this function is equivalent to calling <a class="el" href="group__boundary.html#gaea37d3b925b8e6a2c02d9ef9c454ed54">set_manifold_id()</a> with the same argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
