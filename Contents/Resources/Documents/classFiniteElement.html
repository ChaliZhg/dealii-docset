<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FiniteElement&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFiniteElement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FiniteElement&lt; dim, spacedim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__febase.html">Base classes</a><a class="el" href="group__feall.html">Finite elements</a> &raquo;  &#124; <a class="el" href="group__fe.html">Finite element space descriptions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">deal.II/fe/fe.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FiniteElement&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFiniteElement__inherit__graph.svg" width="1767" height="1975"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a904941a97e1f4e87d2770c8e9fe455c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a904941a97e1f4e87d2770c8e9fe455c1">FiniteElement</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;fe_data, const std::vector&lt; bool &gt; &amp;<a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a>, const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;<a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a>)</td></tr>
<tr class="separator:a904941a97e1f4e87d2770c8e9fe455c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c542597d19c71026f84f8d9c87c999"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae5c542597d19c71026f84f8d9c87c999">~FiniteElement</a> ()</td></tr>
<tr class="separator:ae5c542597d19c71026f84f8d9c87c999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7631a5a3cc67eaf6f498f2bd6ef4151c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7631a5a3cc67eaf6f498f2bd6ef4151c">clone</a> () const =0</td></tr>
<tr class="separator:a7631a5a3cc67eaf6f498f2bd6ef4151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09655d1d2555af8dcd48caebd4039d29"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">get_name</a> () const =0</td></tr>
<tr class="separator:a09655d1d2555af8dcd48caebd4039d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623b0c5a085bc13c826f3d78459a407f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a623b0c5a085bc13c826f3d78459a407f">operator[]</a> (const unsigned int fe_index) const</td></tr>
<tr class="separator:a623b0c5a085bc13c826f3d78459a407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90af45f3ad54d9df3ce230084a2c205"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae90af45f3ad54d9df3ce230084a2c205">operator==</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;) const</td></tr>
<tr class="separator:ae90af45f3ad54d9df3ce230084a2c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d91517978ab8b107c6951cc4c63c10f"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5d91517978ab8b107c6951cc4c63c10f">memory_consumption</a> () const</td></tr>
<tr class="separator:a5d91517978ab8b107c6951cc4c63c10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shape function access</div></td></tr>
<tr class="memitem:a9889833bef170393b1281a1418596d70"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9889833bef170393b1281a1418596d70">shape_value</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a9889833bef170393b1281a1418596d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247fccbd72723a07fc8c17ac093d3156"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a247fccbd72723a07fc8c17ac093d3156">shape_value_component</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component) const</td></tr>
<tr class="separator:a247fccbd72723a07fc8c17ac093d3156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaafefdf45fc2a5e7db18acb64063f5d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aaaafefdf45fc2a5e7db18acb64063f5d">shape_grad</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:aaaafefdf45fc2a5e7db18acb64063f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f026ed19fcc589476f11d69de4a3419"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7f026ed19fcc589476f11d69de4a3419">shape_grad_component</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component) const</td></tr>
<tr class="separator:a7f026ed19fcc589476f11d69de4a3419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9735ea35b55b66b069cece0d5c55e9d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#af9735ea35b55b66b069cece0d5c55e9d">shape_grad_grad</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:af9735ea35b55b66b069cece0d5c55e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d74d669ee2e15eedea95d75889b9e3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a78d74d669ee2e15eedea95d75889b9e3">shape_grad_grad_component</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component) const</td></tr>
<tr class="separator:a78d74d669ee2e15eedea95d75889b9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9716de0908601e453e0b56935280eb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#af9716de0908601e453e0b56935280eb3">shape_3rd_derivative</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:af9716de0908601e453e0b56935280eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc9c5e6fff74957e68a7dc40ce9001c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4bc9c5e6fff74957e68a7dc40ce9001c">shape_3rd_derivative_component</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component) const</td></tr>
<tr class="separator:a4bc9c5e6fff74957e68a7dc40ce9001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca1cc51c17eefe7ae1b22d40739bb5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afca1cc51c17eefe7ae1b22d40739bb5b">shape_4th_derivative</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:afca1cc51c17eefe7ae1b22d40739bb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25664d01bbe39b68056379410dd916ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a25664d01bbe39b68056379410dd916ab">shape_4th_derivative_component</a> (const unsigned int i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned int component) const</td></tr>
<tr class="separator:a25664d01bbe39b68056379410dd916ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab275cbead21bb11b1208222b6d662357"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a> (const unsigned int shape_index, const unsigned int face_index) const</td></tr>
<tr class="separator:ab275cbead21bb11b1208222b6d662357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transfer and constraint matrices</div></td></tr>
<tr class="memitem:a9fbcedd86a33fd947de495e7bf6923dd"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix</a> (const unsigned int child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a9fbcedd86a33fd947de495e7bf6923dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4671144d9976b133c4f79c9aefdd7c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix</a> (const unsigned int child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a3a4671144d9976b133c4f79c9aefdd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ead2dba2770c63493a139bec677ccdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1ead2dba2770c63493a139bec677ccdb">prolongation_is_implemented</a> () const</td></tr>
<tr class="separator:a1ead2dba2770c63493a139bec677ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0849d6c4188612816934d5468ecf9e6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0849d6c4188612816934d5468ecf9e6b">isotropic_prolongation_is_implemented</a> () const</td></tr>
<tr class="separator:a0849d6c4188612816934d5468ecf9e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8539eac73f0305ba91e612ad5519250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab8539eac73f0305ba91e612ad5519250">restriction_is_implemented</a> () const</td></tr>
<tr class="separator:ab8539eac73f0305ba91e612ad5519250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645ff401ff38407d67a0785163939f87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a645ff401ff38407d67a0785163939f87">isotropic_restriction_is_implemented</a> () const</td></tr>
<tr class="separator:a645ff401ff38407d67a0785163939f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa81cef78859c726852a1ee1ef37210"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">restriction_is_additive</a> (const unsigned int index) const</td></tr>
<tr class="separator:a6aa81cef78859c726852a1ee1ef37210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3f9ca1fa6be8fa5afcb34d56028a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9da3f9ca1fa6be8fa5afcb34d56028a3">constraints</a> (const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case=::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;::case_isotropic) const</td></tr>
<tr class="separator:a9da3f9ca1fa6be8fa5afcb34d56028a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f5b5d1700cf820f8989f35418efbfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a01f5b5d1700cf820f8989f35418efbfc">constraints_are_implemented</a> (const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case=::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;::case_isotropic) const</td></tr>
<tr class="separator:a01f5b5d1700cf820f8989f35418efbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d64f4a56fb9fefc55a68fb7ac5e71a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae5d64f4a56fb9fefc55a68fb7ac5e71a">hp_constraints_are_implemented</a> () const</td></tr>
<tr class="separator:ae5d64f4a56fb9fefc55a68fb7ac5e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d590413e360eb10dbe4f9e247cb2bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a46d590413e360eb10dbe4f9e247cb2bb">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;matrix) const</td></tr>
<tr class="separator:a46d590413e360eb10dbe4f9e247cb2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to support hp</div></td></tr>
<tr class="memitem:a893c7dd826fce7d3e6838fdb44e3132d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a893c7dd826fce7d3e6838fdb44e3132d">get_face_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;matrix) const</td></tr>
<tr class="separator:a893c7dd826fce7d3e6838fdb44e3132d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fd529ffa0faaac061a56c957c63ded"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a50fd529ffa0faaac061a56c957c63ded">get_subface_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, const unsigned int subface, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;matrix) const</td></tr>
<tr class="separator:a50fd529ffa0faaac061a56c957c63ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c920830fe94b08cdf8754b6533e805"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a18c920830fe94b08cdf8754b6533e805">hp_vertex_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const</td></tr>
<tr class="separator:a18c920830fe94b08cdf8754b6533e805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0580b57287997a3aaa682d993bc952c1"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0580b57287997a3aaa682d993bc952c1">hp_line_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const</td></tr>
<tr class="separator:a0580b57287997a3aaa682d993bc952c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a3ec8120fbefb4d1a3ba5c2f4a0038"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac0a3ec8120fbefb4d1a3ba5c2f4a0038">hp_quad_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const</td></tr>
<tr class="separator:ac0a3ec8120fbefb4d1a3ba5c2f4a0038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abb893b2f67182684932757c8eb985d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1abb893b2f67182684932757c8eb985d">compare_for_face_domination</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const</td></tr>
<tr class="separator:a1abb893b2f67182684932757c8eb985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Index computations</div></td></tr>
<tr class="memitem:a86644fe67824373cd51e9ff7fca94f8c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a> (const unsigned int index) const</td></tr>
<tr class="separator:a86644fe67824373cd51e9ff7fca94f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ea16b60a6fc644a9bc7097703a53e8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae2ea16b60a6fc644a9bc7097703a53e8">component_to_system_index</a> (const unsigned int component, const unsigned int index) const</td></tr>
<tr class="separator:ae2ea16b60a6fc644a9bc7097703a53e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f9d46ef9521dc25cfa2be551391e1d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a29f9d46ef9521dc25cfa2be551391e1d">face_system_to_component_index</a> (const unsigned int index) const</td></tr>
<tr class="separator:a29f9d46ef9521dc25cfa2be551391e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e808ca035ce6c0e479025547d41910"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac3e808ca035ce6c0e479025547d41910">adjust_quad_dof_index_for_face_orientation</a> (const unsigned int index, const bool face_orientation, const bool face_flip, const bool face_rotation) const</td></tr>
<tr class="separator:ac3e808ca035ce6c0e479025547d41910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d22a08e0e3136f181d6098db19f8b93"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a8d22a08e0e3136f181d6098db19f8b93">face_to_cell_index</a> (const unsigned int face_dof_index, const unsigned int face, const bool face_orientation=true, const bool face_flip=false, const bool face_rotation=false) const</td></tr>
<tr class="separator:a8d22a08e0e3136f181d6098db19f8b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5859e4b85feaa0406c4aa571fc4dfa4f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5859e4b85feaa0406c4aa571fc4dfa4f">adjust_line_dof_index_for_line_orientation</a> (const unsigned int index, const bool line_orientation) const</td></tr>
<tr class="separator:a5859e4b85feaa0406c4aa571fc4dfa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aa649db6e1460a8d30b067af952fc4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a12aa649db6e1460a8d30b067af952fc4">get_nonzero_components</a> (const unsigned int i) const</td></tr>
<tr class="separator:a12aa649db6e1460a8d30b067af952fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac228df752c9c2462aabf284e862402d0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac228df752c9c2462aabf284e862402d0">n_nonzero_components</a> (const unsigned int i) const</td></tr>
<tr class="separator:ac228df752c9c2462aabf284e862402d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626abd282a25193db7f61b4ec53e7385"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a626abd282a25193db7f61b4ec53e7385">is_primitive</a> () const</td></tr>
<tr class="separator:a626abd282a25193db7f61b4ec53e7385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38241991825f67d635d53d25cb5a2fda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a38241991825f67d635d53d25cb5a2fda">is_primitive</a> (const unsigned int i) const</td></tr>
<tr class="separator:a38241991825f67d635d53d25cb5a2fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fbcc708737aa60fa272d4d3e22aea"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ad12fbcc708737aa60fa272d4d3e22aea">n_base_elements</a> () const</td></tr>
<tr class="separator:ad12fbcc708737aa60fa272d4d3e22aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c2ecc833033772889878116bd8a740"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a40c2ecc833033772889878116bd8a740">base_element</a> (const unsigned int index) const</td></tr>
<tr class="separator:a40c2ecc833033772889878116bd8a740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa009769e662e34081f60ff16327db1b1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa009769e662e34081f60ff16327db1b1">element_multiplicity</a> (const unsigned int index) const</td></tr>
<tr class="separator:aa009769e662e34081f60ff16327db1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac75dfc5b9f4e01c34d5865b4ca5a2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a> (const unsigned int index) const</td></tr>
<tr class="separator:a95ac75dfc5b9f4e01c34d5865b4ca5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae338ebce423fe2b85f4af2b425fbd70e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae338ebce423fe2b85f4af2b425fbd70e">face_system_to_base_index</a> (const unsigned int index) const</td></tr>
<tr class="separator:ae338ebce423fe2b85f4af2b425fbd70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc49f8114f396b20b9a7fe9a3c058568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afc49f8114f396b20b9a7fe9a3c058568">first_block_of_base</a> (const unsigned int b) const</td></tr>
<tr class="separator:afc49f8114f396b20b9a7fe9a3c058568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1ca2e63382a8fd20910ae0303f4f6c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a2e1ca2e63382a8fd20910ae0303f4f6c">component_to_base_index</a> (const unsigned int component) const</td></tr>
<tr class="separator:a2e1ca2e63382a8fd20910ae0303f4f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f95e7c9144846758b804a41405cd3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a656f95e7c9144846758b804a41405cd3">block_to_base_index</a> (const unsigned int block) const</td></tr>
<tr class="separator:a656f95e7c9144846758b804a41405cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0763dd6212313f0ff69f04c735b2a147"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned int, <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0763dd6212313f0ff69f04c735b2a147">system_to_block_index</a> (const unsigned int component) const</td></tr>
<tr class="separator:a0763dd6212313f0ff69f04c735b2a147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3dd1574cabab93b67e3fe47a103b6a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7b3dd1574cabab93b67e3fe47a103b6a">component_to_block_index</a> (const unsigned int component) const</td></tr>
<tr class="separator:a7b3dd1574cabab93b67e3fe47a103b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Component and block matrices</div></td></tr>
<tr class="memitem:a4409f54175f279ac24cc982cfcfcbd2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a4409f54175f279ac24cc982cfcfcbd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d11c23f6db2eca49ba470defb873c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a46d11c23f6db2eca49ba470defb873c0">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a46d11c23f6db2eca49ba470defb873c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0dcc1e76885ec0ddcaae340dcdcd62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a2c0dcc1e76885ec0ddcaae340dcdcd62">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:a2c0dcc1e76885ec0ddcaae340dcdcd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d2a54a95f43f0db77e74b1bfab21d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a24d2a54a95f43f0db77e74b1bfab21d2">component_mask</a> (const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;<a class="el" href="classFiniteElement.html#a7cc5ed75cad6792b8b21a3ac635a8860">block_mask</a>) const</td></tr>
<tr class="separator:a24d2a54a95f43f0db77e74b1bfab21d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc5ed75cad6792b8b21a3ac635a8860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7cc5ed75cad6792b8b21a3ac635a8860">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a7cc5ed75cad6792b8b21a3ac635a8860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9294bf84eec96ac31f29808a5aa87551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9294bf84eec96ac31f29808a5aa87551">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a9294bf84eec96ac31f29808a5aa87551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace95b8ef3a342bbb8f82cb17113be612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ace95b8ef3a342bbb8f82cb17113be612">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:ace95b8ef3a342bbb8f82cb17113be612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931d71caa9f14212b8dd89337e155fc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a931d71caa9f14212b8dd89337e155fc1">block_mask</a> (const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>) const</td></tr>
<tr class="separator:a931d71caa9f14212b8dd89337e155fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3584deb698371e24c78dcd27f962ede8"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt;, std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a3584deb698371e24c78dcd27f962ede8">get_constant_modes</a> () const</td></tr>
<tr class="separator:a3584deb698371e24c78dcd27f962ede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Support points and interpolation</div></td></tr>
<tr class="memitem:a5b35a290aa7dd7562911a92a13b11fee"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points</a> () const</td></tr>
<tr class="separator:a5b35a290aa7dd7562911a92a13b11fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f25ecdd4c356032bd44e3e6571d983"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">has_support_points</a> () const</td></tr>
<tr class="separator:a47f25ecdd4c356032bd44e3e6571d983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240719f4c467b178c7dea32040f8015e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a240719f4c467b178c7dea32040f8015e">unit_support_point</a> (const unsigned int index) const</td></tr>
<tr class="separator:a240719f4c467b178c7dea32040f8015e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a07be9f2b8fdd0715da23e6d97bb2c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a23a07be9f2b8fdd0715da23e6d97bb2c">get_unit_face_support_points</a> () const</td></tr>
<tr class="separator:a23a07be9f2b8fdd0715da23e6d97bb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1daff1756e17621edd8d10c535e4598d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1daff1756e17621edd8d10c535e4598d">has_face_support_points</a> () const</td></tr>
<tr class="separator:a1daff1756e17621edd8d10c535e4598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0367eebf4f24006facf5bfc2a60749c8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0367eebf4f24006facf5bfc2a60749c8">unit_face_support_point</a> (const unsigned int index) const</td></tr>
<tr class="separator:a0367eebf4f24006facf5bfc2a60749c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d4db3494e48ce40d49da6f2c7d4b2"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#acd7d4db3494e48ce40d49da6f2c7d4b2">get_generalized_support_points</a> () const</td></tr>
<tr class="separator:acd7d4db3494e48ce40d49da6f2c7d4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7a3e41b44869ce600ae0b3a98b5b4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4d7a3e41b44869ce600ae0b3a98b5b4e">has_generalized_support_points</a> () const</td></tr>
<tr class="separator:a4d7a3e41b44869ce600ae0b3a98b5b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393d5a5f81568ce0e9f831670e545af7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a393d5a5f81568ce0e9f831670e545af7">get_generalized_face_support_points</a> () const</td></tr>
<tr class="separator:a393d5a5f81568ce0e9f831670e545af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7bf62843bddc89eee39b464f21f2f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aef7bf62843bddc89eee39b464f21f2f8">has_generalized_face_support_points</a> () const</td></tr>
<tr class="separator:aef7bf62843bddc89eee39b464f21f2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ea3780c7d2e6140141a9afcbc421f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeometryPrimitive.html">GeometryPrimitive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae0ea3780c7d2e6140141a9afcbc421f4">get_associated_geometry_primitive</a> (const unsigned int cell_dof_index) const</td></tr>
<tr class="separator:ae0ea3780c7d2e6140141a9afcbc421f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69948e87907f6b146c6c8bdf0cabdf22"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a69948e87907f6b146c6c8bdf0cabdf22">convert_generalized_support_point_values_to_nodal_values</a> (const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;support_point_values, std::vector&lt; double &gt; &amp;nodal_values) const</td></tr>
<tr class="separator:a69948e87907f6b146c6c8bdf0cabdf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFiniteElementData"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFiniteElementData')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFiniteElementData.html">FiniteElementData&lt; dim &gt;</a></td></tr>
<tr class="memitem:af3b48f48a9b4f61b1f54b9845d2e766b inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#af3b48f48a9b4f61b1f54b9845d2e766b">FiniteElementData</a> (const std::vector&lt; unsigned int &gt; &amp;dofs_per_object, const unsigned int <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">n_components</a>, const unsigned int <a class="el" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>, const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a> conformity=<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1afbb5ba93aed087d17dd0224e65a1bddc">unknown</a>, const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;<a class="el" href="classFiniteElementData.html#ab6b11a9d43bf383bb38953fd50dba34b">block_indices</a>=<a class="el" href="classBlockIndices.html">BlockIndices</a>())</td></tr>
<tr class="separator:af3b48f48a9b4f61b1f54b9845d2e766b inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f06778f87a7606cc2e0d5338b41ab inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0d1f06778f87a7606cc2e0d5338b41ab">n_dofs_per_vertex</a> () const</td></tr>
<tr class="separator:a0d1f06778f87a7606cc2e0d5338b41ab inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384464e3b59fe91485f603dc32db7dd1 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a384464e3b59fe91485f603dc32db7dd1">n_dofs_per_line</a> () const</td></tr>
<tr class="separator:a384464e3b59fe91485f603dc32db7dd1 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e74281ea032afe31ef48e7664acab5 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a65e74281ea032afe31ef48e7664acab5">n_dofs_per_quad</a> () const</td></tr>
<tr class="separator:a65e74281ea032afe31ef48e7664acab5 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb7465f62a849481ae0bf5edc78ec7d inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aecb7465f62a849481ae0bf5edc78ec7d">n_dofs_per_hex</a> () const</td></tr>
<tr class="separator:aecb7465f62a849481ae0bf5edc78ec7d inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a547c0c4f2d06655ae30c68ad0a2fb inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a71a547c0c4f2d06655ae30c68ad0a2fb">n_dofs_per_face</a> () const</td></tr>
<tr class="separator:a71a547c0c4f2d06655ae30c68ad0a2fb inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b522422da89e5c080e7405ad49d7c7 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a> () const</td></tr>
<tr class="separator:a33b522422da89e5c080e7405ad49d7c7 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f2ef65cafc4d90e228d4c2d24696e2 inherit pub_methods_classFiniteElementData"><td class="memTemplParams" colspan="2">template&lt;int structdim&gt; </td></tr>
<tr class="memitem:ae1f2ef65cafc4d90e228d4c2d24696e2 inherit pub_methods_classFiniteElementData"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ae1f2ef65cafc4d90e228d4c2d24696e2">n_dofs_per_object</a> () const</td></tr>
<tr class="separator:ae1f2ef65cafc4d90e228d4c2d24696e2 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a698695065333035e493294ce92820e inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">n_components</a> () const</td></tr>
<tr class="separator:a5a698695065333035e493294ce92820e inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1c4ca934f26ff463caf35a574e9f14 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">n_blocks</a> () const</td></tr>
<tr class="separator:a4c1c4ca934f26ff463caf35a574e9f14 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b11a9d43bf383bb38953fd50dba34b inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ab6b11a9d43bf383bb38953fd50dba34b">block_indices</a> () const</td></tr>
<tr class="separator:ab6b11a9d43bf383bb38953fd50dba34b inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584a56a1611a86a04c8b9a26d0eb9f27 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a> () const</td></tr>
<tr class="separator:a584a56a1611a86a04c8b9a26d0eb9f27 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e928460be93a004559b841f35ad698 inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a18e928460be93a004559b841f35ad698">conforms</a> (const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>) const</td></tr>
<tr class="separator:a18e928460be93a004559b841f35ad698 inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439857c3106a765203a354723dfc7cac inherit pub_methods_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a439857c3106a765203a354723dfc7cac">operator==</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a> &amp;) const</td></tr>
<tr class="separator:a439857c3106a765203a354723dfc7cac inherit pub_methods_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gabbbf104f21a2e67374240210ea4c70ad"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabbbf104f21a2e67374240210ea4c70ad">ExcShapeFunctionNotPrimitive</a> (int arg1)</td></tr>
<tr class="separator:gabbbf104f21a2e67374240210ea4c70ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c1f2ebf922ca19c259b7589ad2eaf0"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad5c1f2ebf922ca19c259b7589ad2eaf0">ExcFENotPrimitive</a> ()</td></tr>
<tr class="separator:gad5c1f2ebf922ca19c259b7589ad2eaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fad747557ad2a734f747297f664a3cc"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3fad747557ad2a734f747297f664a3cc">ExcUnitShapeValuesDoNotExist</a> ()</td></tr>
<tr class="separator:ga3fad747557ad2a734f747297f664a3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0879d61e2e1c58fd30b79af35a25e101"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0879d61e2e1c58fd30b79af35a25e101">ExcFEHasNoSupportPoints</a> ()</td></tr>
<tr class="separator:ga0879d61e2e1c58fd30b79af35a25e101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416676a9802c3c02acff1847735547b9"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga416676a9802c3c02acff1847735547b9">ExcEmbeddingVoid</a> ()</td></tr>
<tr class="separator:ga416676a9802c3c02acff1847735547b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5805a8b6dbd4b6f6dbfa0842e3aa7cf"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae5805a8b6dbd4b6f6dbfa0842e3aa7cf">ExcProjectionVoid</a> ()</td></tr>
<tr class="separator:gae5805a8b6dbd4b6f6dbfa0842e3aa7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cceba905feec2c2f7b643ee85faee22"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1cceba905feec2c2f7b643ee85faee22">ExcWrongInterfaceMatrixSize</a> (int arg1, int arg2)</td></tr>
<tr class="separator:ga1cceba905feec2c2f7b643ee85faee22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d173bb705771cc1555a1d6c805202e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad7d173bb705771cc1555a1d6c805202e">ExcInterpolationNotImplemented</a> ()</td></tr>
<tr class="separator:gad7d173bb705771cc1555a1d6c805202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a577195e2fad97018b5dccb837952dad7"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a577195e2fad97018b5dccb837952dad7">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a577195e2fad97018b5dccb837952dad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classFiniteElementData"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classFiniteElementData')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classFiniteElementData.html">FiniteElementData&lt; dim &gt;</a></td></tr>
<tr class="memitem:af40fa679812dc4fcc76496aa9a139050 inherit pub_static_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#af40fa679812dc4fcc76496aa9a139050">dimension</a> = dim</td></tr>
<tr class="separator:af40fa679812dc4fcc76496aa9a139050 inherit pub_static_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a62838f7428ee56e34c4081ca6d03bc26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a62838f7428ee56e34c4081ca6d03bc26">reinit_restriction_and_prolongation_matrices</a> (const bool isotropic_restriction_only=false, const bool isotropic_prolongation_only=false)</td></tr>
<tr class="separator:a62838f7428ee56e34c4081ca6d03bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d72dc54ae8d760b3c9c4e5ce0f96c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab1d72dc54ae8d760b3c9c4e5ce0f96c4">interface_constraints_size</a> () const</td></tr>
<tr class="separator:ab1d72dc54ae8d760b3c9c4e5ce0f96c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9f47da3fcdfc8c1ca7c7a0feb1929"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7ee9f47da3fcdfc8c1ca7c7a0feb1929">requires_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const =0</td></tr>
<tr class="separator:a7ee9f47da3fcdfc8c1ca7c7a0feb1929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02bc483fe9b867cc9643501bd586811"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:af02bc483fe9b867cc9643501bd586811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b51a66318b7c2d03e9311a8c3e2aaa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a64b51a66318b7c2d03e9311a8c3e2aaa">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a64b51a66318b7c2d03e9311a8c3e2aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b7aabb6513cfc15a7db7242a5eaa55"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a43b7aabb6513cfc15a7db7242a5eaa55">get_subface_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a43b7aabb6513cfc15a7db7242a5eaa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bb7b495d2e578d58d6858430369fd2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:aa1bb7b495d2e578d58d6858430369fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace6650d4f9be28cf54df5df0a0aed46"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aace6650d4f9be28cf54df5df0a0aed46">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned int face_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:aace6650d4f9be28cf54df5df0a0aed46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26a9edae74018ed950df92574b2917a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac26a9edae74018ed950df92574b2917a">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned int face_no, const unsigned int sub_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:ac26a9edae74018ed950df92574b2917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac7b5101c0c081760e5402767aed14c0c"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac7b5101c0c081760e5402767aed14c0c">compute_n_nonzero_components</a> (const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;<a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a>)</td></tr>
<tr class="separator:ac7b5101c0c081760e5402767aed14c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4993707a4ec342560ff74e5d22401794"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a></td></tr>
<tr class="separator:a4993707a4ec342560ff74e5d22401794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc42f850096c429fd39cfcbde1b6b56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a></td></tr>
<tr class="separator:afbc42f850096c429fd39cfcbde1b6b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4cd5afce6a401892aeb5a40ccfa2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a></td></tr>
<tr class="separator:ac8d4cd5afce6a401892aeb5a40ccfa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f6e0c83686b918fbb92716ead92313"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab4f6e0c83686b918fbb92716ead92313">unit_support_points</a></td></tr>
<tr class="separator:ab4f6e0c83686b918fbb92716ead92313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae029888ebd5d91b261bf45aa2bf40b5c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae029888ebd5d91b261bf45aa2bf40b5c">unit_face_support_points</a></td></tr>
<tr class="separator:ae029888ebd5d91b261bf45aa2bf40b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2531d00b5c9e77e1e64981864c3b8cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae2531d00b5c9e77e1e64981864c3b8cc">generalized_support_points</a></td></tr>
<tr class="separator:ae2531d00b5c9e77e1e64981864c3b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b614baaf527c796af876c8807f5d7d7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a3b614baaf527c796af876c8807f5d7d7">generalized_face_support_points</a></td></tr>
<tr class="separator:a3b614baaf527c796af876c8807f5d7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46646bf5621c347e3cb3a637857b14b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a46646bf5621c347e3cb3a637857b14b5">adjust_quad_dof_index_for_face_orientation_table</a></td></tr>
<tr class="separator:a46646bf5621c347e3cb3a637857b14b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6659bb0dccc62e2d680c964e5035daf6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6659bb0dccc62e2d680c964e5035daf6">adjust_line_dof_index_for_line_orientation_table</a></td></tr>
<tr class="separator:a6659bb0dccc62e2d680c964e5035daf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af218ae93821b61054de7e88e1734aa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9af218ae93821b61054de7e88e1734aa">system_to_component_table</a></td></tr>
<tr class="separator:a9af218ae93821b61054de7e88e1734aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2b27e44cffcc480d6d8f0e1d053e73"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#abd2b27e44cffcc480d6d8f0e1d053e73">face_system_to_component_table</a></td></tr>
<tr class="separator:abd2b27e44cffcc480d6d8f0e1d053e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b487f5fe482180d2c856363ae39ab13"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4b487f5fe482180d2c856363ae39ab13">system_to_base_table</a></td></tr>
<tr class="separator:a4b487f5fe482180d2c856363ae39ab13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2b6095ae0093bb6c024853d65969e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0a2b6095ae0093bb6c024853d65969e4">face_system_to_base_table</a></td></tr>
<tr class="separator:a0a2b6095ae0093bb6c024853d65969e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f62f39ded99d6525f1c33f4227ee8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a61f62f39ded99d6525f1c33f4227ee8d">base_to_block_indices</a></td></tr>
<tr class="separator:a61f62f39ded99d6525f1c33f4227ee8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c44f3a207e0e11880820a29ac37a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aaf2c44f3a207e0e11880820a29ac37a8">component_to_base_table</a></td></tr>
<tr class="separator:aaf2c44f3a207e0e11880820a29ac37a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f4833a318127b42d2dc806bffe1c2c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a></td></tr>
<tr class="separator:aa8f4833a318127b42d2dc806bffe1c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fe073d1e3ce59791b142067482bd5b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a></td></tr>
<tr class="separator:ae6fe073d1e3ce59791b142067482bd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7cb6ef5342900727931ef983636502"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0b7cb6ef5342900727931ef983636502">n_nonzero_components_table</a></td></tr>
<tr class="separator:a0b7cb6ef5342900727931ef983636502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4124079b6443590608046d8f150574f6"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4124079b6443590608046d8f150574f6">cached_primitivity</a></td></tr>
<tr class="separator:a4124079b6443590608046d8f150574f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aaae1cf0eb77f09ffb83fe685445f8cd4"><td class="memItemLeft" align="right" valign="top"><a id="aaae1cf0eb77f09ffb83fe685445f8cd4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FEValuesBase&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:aaae1cf0eb77f09ffb83fe685445f8cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dfe2e490e255ed133bf6289e47f46f"><td class="memItemLeft" align="right" valign="top"><a id="a96dfe2e490e255ed133bf6289e47f46f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FEValues&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:a96dfe2e490e255ed133bf6289e47f46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a2ae7b2d193590c89e5a5f23d31f81"><td class="memItemLeft" align="right" valign="top"><a id="a65a2ae7b2d193590c89e5a5f23d31f81"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FEFaceValues&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:a65a2ae7b2d193590c89e5a5f23d31f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ff73a151c0885be1f554c91eb9668b"><td class="memItemLeft" align="right" valign="top"><a id="ad5ff73a151c0885be1f554c91eb9668b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FESubfaceValues&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:ad5ff73a151c0885be1f554c91eb9668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d578244440ca7f2c5a25e1161e96f80"><td class="memItemLeft" align="right" valign="top"><a id="a5d578244440ca7f2c5a25e1161e96f80"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FESystem&lt; dim, spacedim &gt;</b></td></tr>
<tr class="separator:a5d578244440ca7f2c5a25e1161e96f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classFiniteElementData"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classFiniteElementData')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classFiniteElementData.html">FiniteElementData&lt; dim &gt;</a></td></tr>
<tr class="memitem:a0cd5f34c3ab828fac31004f3b52921a1 inherit pub_types_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a> { <br />
&#160;&#160;<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1afbb5ba93aed087d17dd0224e65a1bddc">unknown</a> = 0x00, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a349c581c3d0e392c33cc41d917eb038c">L2</a> = 0x01, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a0787dd9aa05e57e4e6009dd73cb1d229">Hcurl</a> = 0x02, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a11a375871bcf4978f67ff6d7435f81ee">Hdiv</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a0e986c9c300b61774d25c92ae2a9d054">H1</a> = Hcurl | Hdiv, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a916ecb570449b2ad08281d708b39bae2">H2</a> = 0x0e
<br />
 }</td></tr>
<tr class="separator:a0cd5f34c3ab828fac31004f3b52921a1 inherit pub_types_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classFiniteElementData"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classFiniteElementData')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classFiniteElementData.html">FiniteElementData&lt; dim &gt;</a></td></tr>
<tr class="memitem:ad82fdeb0955b7d59f32d5371adaaadbc inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad82fdeb0955b7d59f32d5371adaaadbc">dofs_per_vertex</a></td></tr>
<tr class="separator:ad82fdeb0955b7d59f32d5371adaaadbc inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490e2ded19c0a8cad0846e07e57e3e76 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a490e2ded19c0a8cad0846e07e57e3e76">dofs_per_line</a></td></tr>
<tr class="separator:a490e2ded19c0a8cad0846e07e57e3e76 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ab27b2dfa5520f2aa56f9bb8223878 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a00ab27b2dfa5520f2aa56f9bb8223878">dofs_per_quad</a></td></tr>
<tr class="separator:a00ab27b2dfa5520f2aa56f9bb8223878 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9014d27be7564a42c962848db0d2fd75 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9014d27be7564a42c962848db0d2fd75">dofs_per_hex</a></td></tr>
<tr class="separator:a9014d27be7564a42c962848db0d2fd75 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c172e26b87c60b3f7e5e3ebf155b62e inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a8c172e26b87c60b3f7e5e3ebf155b62e">first_line_index</a></td></tr>
<tr class="separator:a8c172e26b87c60b3f7e5e3ebf155b62e inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9fc2a37fc1aa814ac73e93baca4bea inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aca9fc2a37fc1aa814ac73e93baca4bea">first_quad_index</a></td></tr>
<tr class="separator:aca9fc2a37fc1aa814ac73e93baca4bea inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649a135f376e3fba63ecf08c2b17cc64 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a649a135f376e3fba63ecf08c2b17cc64">first_hex_index</a></td></tr>
<tr class="separator:a649a135f376e3fba63ecf08c2b17cc64 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cf27d2dabe49e0c1f57954d7d08500 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a70cf27d2dabe49e0c1f57954d7d08500">first_face_line_index</a></td></tr>
<tr class="separator:a70cf27d2dabe49e0c1f57954d7d08500 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f85f3eae2daee423441fce5e87fa2e6 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0f85f3eae2daee423441fce5e87fa2e6">first_face_quad_index</a></td></tr>
<tr class="separator:a0f85f3eae2daee423441fce5e87fa2e6 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358bffed1fba59ef4df715469473fd36 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></td></tr>
<tr class="separator:a358bffed1fba59ef4df715469473fd36 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fa3b8d578ba488b4f37061bb0278bb inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a></td></tr>
<tr class="separator:ae2fa3b8d578ba488b4f37061bb0278bb inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccdb4fd2c40a3e3cd92cb0361cddaf8 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a1ccdb4fd2c40a3e3cd92cb0361cddaf8">components</a></td></tr>
<tr class="separator:a1ccdb4fd2c40a3e3cd92cb0361cddaf8 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbf5ad6b464871261dbd054bced18a8 inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a></td></tr>
<tr class="separator:a2cbf5ad6b464871261dbd054bced18a8 inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca702ba3af0ed17eaffcfbbccf82067f inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aca702ba3af0ed17eaffcfbbccf82067f">conforming_space</a></td></tr>
<tr class="separator:aca702ba3af0ed17eaffcfbbccf82067f inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9346e3aae3032545c8a94b78a365ffcb inherit pub_attribs_classFiniteElementData"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9346e3aae3032545c8a94b78a365ffcb">block_indices_data</a></td></tr>
<tr class="separator:a9346e3aae3032545c8a94b78a365ffcb inherit pub_attribs_classFiniteElementData"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class FiniteElement&lt; dim, spacedim &gt;</h3>

<p>This is the base class for finite elements in arbitrary dimensions. It declares the interface both in terms of member variables and public member functions through which properties of a concrete implementation of a finite element can be accessed. This interface generally consists of a number of groups of variables and functions that can roughly be delineated as follows:</p><ul>
<li>Basic information about the finite element, such as the number of degrees of freedom per vertex, edge, or cell. This kind of data is stored in the <a class="el" href="classFiniteElementData.html">FiniteElementData</a> base class. (Though the <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement::get_name()</a> member function also falls into this category.)</li>
<li>A description of the shape functions and their derivatives on the reference cell <img class="formulaInl" alt="$[0,1]^d$" src="form_496.png"/>, if an element is indeed defined by mapping shape functions from the reference cell to an actual cell.</li>
<li>Matrices (and functions that access them) that describe how an element's shape functions related to those on parent or child cells (restriction or prolongation) or neighboring cells (for hanging node constraints), as well as to other finite element spaces defined on the same cell (e.g., when doing <img class="formulaInl" alt="$p$" src="form_202.png"/> refinement).</li>
<li>Functions that describe the properties of individual shape functions, for example which <a class="el" href="DEALGlossary.html#GlossComponent">vector components</a> of a <a class="el" href="group__vector__valued.html">vector-valued finite element's</a> shape function is nonzero, or whether an element is <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a>.</li>
<li>For elements that are interpolatory, such as the common <img class="formulaInl" alt="$Q_p$" src="form_175.png"/> Lagrange elements, data that describes where their <a class="el" href="DEALGlossary.html#GlossSupport">support points</a> are located.</li>
<li>Functions that define the interface to the <a class="el" href="classFEValues.html">FEValues</a> class that is almost always used to access finite element shape functions from user code.</li>
</ul>
<p>The following sections discuss many of these concepts in more detail, and outline strategies by which concrete implementations of a finite element can provide the details necessary for a complete description of a finite element space.</p>
<p>As a general rule, there are three ways by which derived classes provide this information:</p><ul>
<li>A number of fields that are generally easy to compute and that are initialized by the constructor of this class (or the constructor of the <a class="el" href="classFiniteElementData.html">FiniteElementData</a> base class) and derived classes therefore have to compute in the process of calling this class's constructor. This is, specifically, the case for the basic information and parts of the descriptive information about shape functions mentioned above.</li>
<li>Some common matrices that are widely used in the library and for which this class provides protected member variables that the constructors of derived classes need to fill. The purpose of providing these matrices in this class is that (i) they are frequently used, and (ii) they are expensive to compute. Consequently, it makes sense to only compute them once, rather than every time they are used. In most cases, the constructor of the current class already sets them to their correct size, and derived classes therefore only have to fill them. Examples of this include the matrices that relate the shape functions on one cell to the shape functions on neighbors, children, and parents.</li>
<li>Uncommon information, or information that depends on specific input arguments, and that needs to be implemented by derived classes. For these, this base class only declares abstract virtual member functions and derived classes then have to implement them. Examples of this category would include the functions that compute values and derivatives of shape functions on the reference cell for which it is not possible to tabulate values because there are infinitely many points at which one may want to evaluate them. In some cases, derived classes may choose to simply not implement <em>all</em> possible interfaces (or may not <em>yet</em> have a complete implementation); for uncommon functions, there is then often a member function derived classes can overload that describes whether a particular feature is implemented. An example is whether an element implements the information necessary to use it in the <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite element context (see <a class="el" href="group__hp.html">hp finite element support</a>).</li>
</ul>
<h3>Nomenclature</h3>
<p>Finite element classes have to define a large number of different properties describing a finite element space. The following subsections describe some nomenclature that will be used in the documentation below.</p>
<h4>Components and blocks</h4>
<p><a class="el" href="group__vector__valued.html">Vector-valued finite element</a> are elements used for systems of partial differential equations. Oftentimes, they are composed via the <a class="el" href="classFESystem.html">FESystem</a> class (which is itself derived from the current class), but there are also non-composed elements that have multiple components (for example the <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> and <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> classes, among others). For any of these vector valued elements, individual shape functions may be nonzero in one or several <a class="el" href="DEALGlossary.html#GlossComponent">components</a> of the vector valued function. If the element is <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a>, there is indeed a single component with a nonzero entry for each shape function. This component can be determined using the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index()</a> function.</p>
<p>On the other hand, if there is at least one shape function that is nonzero in more than one vector component, then we call the entire element "non-
  primitive". The <a class="el" href="classFiniteElement.html#a12aa649db6e1460a8d30b067af952fc4">FiniteElement::get_nonzero_components()</a> can then be used to determine which vector components of a shape function are nonzero. The number of nonzero components of a shape function is returned by <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components()</a>. Whether a shape function is non-primitive can be queried by <a class="el" href="classFiniteElement.html#a626abd282a25193db7f61b4ec53e7385">FiniteElement::is_primitive()</a>.</p>
<p>Oftentimes, one may want to split linear system into blocks so that they reflect the structure of the underlying operator. This is typically not done based on vector components, but based on the use of <a class="el" href="DEALGlossary.html#GlossBlock">blocks</a>, and the result is then used to substructure objects of type <a class="el" href="classBlockVector.html">BlockVector</a>, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>, <a class="el" href="classBlockMatrixArray.html">BlockMatrixArray</a>, and so on. If you use non-primitive elements, you cannot determine the block number by <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index()</a>. Instead, you can use <a class="el" href="classFiniteElement.html#a0763dd6212313f0ff69f04c735b2a147">FiniteElement::system_to_block_index()</a>. The number of blocks of a finite element can be determined by <a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">FiniteElement::n_blocks()</a>.</p>
<h4>Support points</h4>
<p>Finite elements are frequently defined by defining a polynomial space and a set of dual functionals. If these functionals involve point evaluations, then the element is "interpolatory" and it is possible to interpolate an arbitrary (but sufficiently smooth) function onto the finite element space by evaluating it at these points. We call these points "support points".</p>
<p>Most finite elements are defined by mapping from the reference cell to a concrete cell. Consequently, the support points are then defined on the reference ("unit") cell, see <a class="el" href="DEALGlossary.html#GlossSupport">this glossary entry</a>. The support points on a concrete cell can then be computed by mapping the unit support points, using the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class interface and derived classes, typically via the <a class="el" href="classFEValues.html">FEValues</a> class.</p>
<p>A typical code snippet to do so would look as follows: </p><div class="fragment"><div class="line"><a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> dummy_quadrature (fe.get_unit_support_points());</div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>   fe_values (mapping, fe, dummy_quadrature,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">fe_values.reinit (cell);</div><div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> mapped_point = fe_values.quadrature_point (i);</div></div><!-- fragment --><p>Alternatively, the points can be transformed one-by-one: </p><div class="fragment"><div class="line"><span class="keyword">const</span> vector&lt;Point&lt;dim&gt; &gt; &amp;unit_points =</div><div class="line">   fe.get_unit_support_points();</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> mapped_point =</div><div class="line">   mapping.transform_unit_to_real_cell (cell, unit_points[i]);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Finite elements' implementation of the <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points()</a> function returns these points in the same order as shape functions. As a consequence, the quadrature points accessed above are also ordered in this way. The order of shape functions is typically documented in the class documentation of the various finite element classes.</dd></dl>
<h3>Implementing finite element spaces in derived classes</h3>
<p>The following sections provide some more guidance for implementing concrete finite element spaces in derived classes. This includes information that depends on the dimension for which you want to provide something, followed by a list of tools helping to generate information in concrete cases.</p>
<p>It is important to note that there is a number of intermediate classes that can do a lot of what is necessary for a complete description of finite element spaces. For example, the <a class="el" href="classFE__Poly.html">FE_Poly</a>, <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>, and <a class="el" href="classFE__PolyFace.html">FE_PolyFace</a> classes in essence build a complete finite element space if you only provide them with an abstract description of the polynomial space upon which you want to build an element. Using these intermediate classes typically makes implementing finite element descriptions vastly simpler.</p>
<p>As a general rule, if you want to implement an element, you will likely want to look at the implementation of other, similar elements first. Since many of the more complicated pieces of a finite element interface have to do with how they interact with mappings, quadrature, and the <a class="el" href="classFEValues.html">FEValues</a> class, you will also want to read through the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<h4>Interpolation matrices in one dimension</h4>
<p>In one space dimension (i.e., for <code>dim==1</code> and any value of <code>spacedim</code>), finite element classes implementing the interface of the current base class need only set the <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a> and <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a> matrices that describe the interpolation of the finite element space on one cell to that of its parent cell, and to that on its children, respectively. The constructor of the current class in one dimension presets the <a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a> matrix (used to describe hanging node constraints at the interface between cells of different refinement levels) to have size zero because there are no hanging nodes in 1d.</p>
<h4>Interpolation matrices in two dimensions</h4>
<p>In addition to the fields discussed above for 1D, a constraint matrix is needed to describe hanging node constraints if the finite element has degrees of freedom located on edges or vertices. These constraints are represented by an <img class="formulaInl" alt="$m\times n$" src="form_556.png"/>-matrix <a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a>, where <em>m</em> is the number of degrees of freedom on the refined side without the corner vertices (those dofs on the middle vertex plus those on the two lines), and <em>n</em> is that of the unrefined side (those dofs on the two vertices plus those on the line). The matrix is thus a rectangular one. The <img class="formulaInl" alt="$m\times n$" src="form_556.png"/> size of the <a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a> matrix can also be accessed through the <a class="el" href="classFiniteElement.html#ab1d72dc54ae8d760b3c9c4e5ce0f96c4">interface_constraints_size()</a> function.</p>
<p>The mapping of the dofs onto the indices of the matrix on the unrefined side is as follows: let <img class="formulaInl" alt="$d_v$" src="form_557.png"/> be the number of dofs on a vertex, <img class="formulaInl" alt="$d_l$" src="form_558.png"/> that on a line, then <img class="formulaInl" alt="$n=0...d_v-1$" src="form_559.png"/> refers to the dofs on vertex zero of the unrefined line, <img class="formulaInl" alt="$n=d_v...2d_v-1$" src="form_560.png"/> to those on vertex one, <img class="formulaInl" alt="$n=2d_v...2d_v+d_l-1$" src="form_561.png"/> to those on the line.</p>
<p>Similarly, <img class="formulaInl" alt="$m=0...d_v-1$" src="form_562.png"/> refers to the dofs on the middle vertex of the refined side (vertex one of child line zero, vertex zero of child line one), <img class="formulaInl" alt="$m=d_v...d_v+d_l-1$" src="form_563.png"/> refers to the dofs on child line zero, <img class="formulaInl" alt="$m=d_v+d_l...d_v+2d_l-1$" src="form_564.png"/> refers to the dofs on child line one. Please note that we do not need to reserve space for the dofs on the end vertices of the refined lines, since these must be mapped one-to-one to the appropriate dofs of the vertices of the unrefined line.</p>
<p>Through this construction, the degrees of freedom on the child faces are constrained to the degrees of freedom on the parent face. The information so provided is typically consumed by the <a class="el" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>The hanging node constraints described by these matrices are only relevant to the case where the same finite element space is used on neighboring (but differently refined) cells. The case that the finite element spaces on different sides of a face are different, i.e., the <img class="formulaInl" alt="$hp$" src="form_49.png"/> case (see <a class="el" href="group__hp.html">hp finite element support</a>) is handled by separate functions. See the <a class="el" href="classFiniteElement.html#a893c7dd826fce7d3e6838fdb44e3132d">FiniteElement::get_face_interpolation_matrix()</a> and <a class="el" href="classFiniteElement.html#a50fd529ffa0faaac061a56c957c63ded">FiniteElement::get_subface_interpolation_matrix()</a> functions.</dd></dl>
<h4>Interpolation matrices in three dimensions</h4>
<p>For the interface constraints, the 3d case is similar to the 2d case. The numbering for the indices <img class="formulaInl" alt="$n$" src="form_73.png"/> on the mother face is obvious and keeps to the usual numbering of degrees of freedom on quadrilaterals.</p>
<p>The numbering of the degrees of freedom on the interior of the refined faces for the index <img class="formulaInl" alt="$m$" src="form_253.png"/> is as follows: let <img class="formulaInl" alt="$d_v$" src="form_557.png"/> and <img class="formulaInl" alt="$d_l$" src="form_558.png"/> be as above, and <img class="formulaInl" alt="$d_q$" src="form_565.png"/> be the number of degrees of freedom per quadrilateral (and therefore per face), then <img class="formulaInl" alt="$m=0...d_v-1$" src="form_562.png"/> denote the dofs on the vertex at the center, <img class="formulaInl" alt="$m=d_v...5d_v-1$" src="form_566.png"/> for the dofs on the vertices at the center of the bounding lines of the quadrilateral, <img class="formulaInl" alt="$m=5d_v..5d_v+4*d_l-1$" src="form_567.png"/> are for the degrees of freedom on the four lines connecting the center vertex to the outer boundary of the mother face, <img class="formulaInl" alt="$m=5d_v+4*d_l...5d_v+4*d_l+8*d_l-1$" src="form_568.png"/> for the degrees of freedom on the small lines surrounding the quad, and <img class="formulaInl" alt="$m=5d_v+12*d_l...5d_v+12*d_l+4*d_q-1$" src="form_569.png"/> for the dofs on the four child faces. Note the direction of the lines at the boundary of the quads, as shown below.</p>
<p>The order of the twelve lines and the four child faces can be extracted from the following sketch, where the overall order of the different dof groups is depicted: </p><pre class="fragment">*    *--15--4--16--*
*    |      |      |
*    10 19  6  20  12
*    |      |      |
*    1--7---0--8---2
*    |      |      |
*    9  17  5  18  11
*    |      |      |
*    *--13--3--14--*
* </pre><p> The numbering of vertices and lines, as well as the numbering of children within a line is consistent with the one described in <a class="el" href="classTriangulation.html">Triangulation</a>. Therefore, this numbering is seen from the outside and inside, respectively, depending on the face.</p>
<p>The three-dimensional case has a few pitfalls available for derived classes that want to implement constraint matrices. Consider the following case: </p><pre class="fragment">*          *-------*
*         /       /|
*        /       / |
*       /       /  |
*      *-------*   |
*      |       |   *-------*
*      |       |  /       /|
*      |   1   | /       / |
*      |       |/       /  |
*      *-------*-------*   |
*      |       |       |   *
*      |       |       |  /
*      |   2   |   3   | /
*      |       |       |/
*      *-------*-------*
* </pre><p> Now assume that we want to refine cell 2. We will end up with two faces with hanging nodes, namely the faces between cells 1 and 2, as well as between cells 2 and 3. Constraints have to be applied to the degrees of freedom on both these faces. The problem is that there is now an edge (the top right one of cell 2) which is part of both faces. The hanging node(s) on this edge are therefore constrained twice, once from both faces. To be meaningful, these constraints of course have to be consistent: both faces have to constrain the hanging nodes on the edge to the same nodes on the coarse edge (and only on the edge, as there can then be no constraints to nodes on the rest of the face), and they have to do so with the same weights. This is sometimes tricky since the nodes on the edge may have different local numbers.</p>
<p>For the constraint matrix this means the following: if a degree of freedom on one edge of a face is constrained by some other nodes on the same edge with some weights, then the weights have to be exactly the same as those for constrained nodes on the three other edges with respect to the corresponding nodes on these edges. If this isn't the case, you will get into trouble with the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class that is the primary consumer of the constraint information: while that class is able to handle constraints that are entered more than once (as is necessary for the case above), it insists that the weights are exactly the same.</p>
<p>Using this scheme, child face degrees of freedom are constrained against parent face degrees of freedom that contain those on the edges of the parent face; it is possible that some of them are in turn constrained themselves, leading to longer chains of constraints that the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class will eventually have to sort out. (The constraints described above are used by the <a class="el" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints()</a> function that constructs a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object.) However, this is of no concern for the <a class="el" href="classFiniteElement.html">FiniteElement</a> and derived classes since they only act locally on one cell and its immediate neighbor, and do not see the bigger picture. The <a class="el" href="DEALGlossary.html#hp_paper">hp_paper</a> details how such chains are handled in practice.</p>
<h4>Helper functions</h4>
<p>Construction of a finite element and computation of the matrices described above is often a tedious task, in particular if it has to be performed for several dimensions. Most of this work can be avoided by using the intermediate classes already mentioned above (e.g., <a class="el" href="classFE__Poly.html">FE_Poly</a>, <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>, etc). Other tasks can be automated by some of the functions in namespace <a class="el" href="namespaceFETools.html">FETools</a>.</p>
<h5>Computing the correct basis from a set of linearly independent functions</h5>
<p>First, it may already be difficult to compute the basis of shape functions for arbitrary order and dimension. On the other hand, if the <a class="el" href="DEALGlossary.html#GlossNodes">node values</a> are given, then the duality relation between node functionals and basis functions defines the basis. As a result, the shape function space may be defined from a set of linearly independent functions, such that the actual finite element basis is computed from linear combinations of them. The coefficients of these combinations are determined by the duality of node values and form a matrix.</p>
<p>Using this matrix allows the construction of the basis of shape functions in two steps. </p><ol>
<li>
<p class="startli">Define the space of shape functions using an arbitrary basis <em>w<sub>j</sub></em> and compute the matrix <em>M</em> of node functionals <em>N<sub>i</sub></em> applied to these basis functions, such that its entries are <em>m<sub>ij</sub> = N<sub>i</sub>(w<sub>j</sub>)</em>.</p>
<p class="endli"></p>
</li>
<li>
Compute the basis <em>v<sub>j</sub></em> of the finite element shape function space by applying <em>M<sup>-1</sup></em> to the basis <em>w<sub>j</sub></em>. </li>
</ol>
<p>The matrix <em>M</em> may be computed using <a class="el" href="namespaceFETools.html#aec3d342cc4d853430f07ad49d8bf2eab">FETools::compute_node_matrix()</a>. This function relies on the existence of <a class="el" href="classFiniteElement.html#ae2531d00b5c9e77e1e64981864c3b8cc">generalized_support_points</a> and an implementation of the FiniteElement::interpolate() function with <a class="el" href="classVectorSlice.html">VectorSlice</a> argument. (See the <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">glossary entry on generalized support points</a> for more information.) With this, one can then use the following piece of code in the constructor of a class derived from FinitElement to compute the <img class="formulaInl" alt="$M$" src="form_64.png"/> matrix: </p><div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> M(this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"><a class="code" href="namespaceFETools.html#aec3d342cc4d853430f07ad49d8bf2eab">FETools::compute_node_matrix</a>(M, *<span class="keyword">this</span>);</div><div class="line">this-&gt;inverse_node_matrix.reinit(this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>, this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line">this-&gt;inverse_node_matrix.invert(M);</div></div><!-- fragment --><p> Don't forget to make sure that <a class="el" href="classFiniteElement.html#ab4f6e0c83686b918fbb92716ead92313">unit_support_points</a> or <a class="el" href="classFiniteElement.html#ae2531d00b5c9e77e1e64981864c3b8cc">generalized_support_points</a> are initialized before this!</p>
<h5>Computing prolongation matrices</h5>
<p>Once you have shape functions, you can define matrices that transfer data from one cell to its children or the other way around. This is a common operation in multigrid, of course, but is also used when interpolating the solution from one mesh to another after mesh refinement, as well as in the definition of some error estimators.</p>
<p>To define the prolongation matrices, i.e., those matrices that describe the transfer of a finite element field from one cell to its children, implementations of finite elements can either fill the <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a> array by hand, or can call <a class="el" href="namespaceFETools.html#ab655f76abed08ac8040373bea77ea419">FETools::compute_embedding_matrices()</a>.</p>
<p>In the latter case, all that is required is the following piece of code: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;GeometryInfo&lt;dim&gt;::max_children_per_cell; ++c)</div><div class="line">  this-&gt;<a class="code" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a>[c].reinit (this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>,</div><div class="line">                                this-&gt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>);</div><div class="line"><a class="code" href="namespaceFETools.html#ab655f76abed08ac8040373bea77ea419">FETools::compute_embedding_matrices</a> (*<span class="keyword">this</span>, this-&gt;<a class="code" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a>);</div></div><!-- fragment --><p> As in this example, prolongation is almost always implemented via embedding, i.e., the nodal values of the function on the children may be different from the nodal values of the function on the parent cell, but as a function of <img class="formulaInl" alt="$\mathbf x\in{\mathbb R}^\text{spacedim}$" src="form_570.png"/>, the finite element field on the child is the same as on the parent.</p>
<h5>Computing restriction matrices</h5>
<p>The opposite operation, restricting a finite element function defined on the children to the parent cell is typically implemented by interpolating the finite element function on the children to the nodal values of the parent cell. In deal.II, the restriction operation is implemented as a loop over the children of a cell that each apply a matrix to the vector of unknowns on that child cell (these matrices are stored in <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a> and are accessed by <a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix()</a>). The operation that then needs to be implemented turns out to be surprisingly difficult to describe, but is instructive to describe because it also defines the meaning of the <a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a> array (accessed via the <a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">restriction_is_additive()</a> function).</p>
<p>To give a concrete example, assume we use a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> element in 1d, and that on each of the parent and child cells degrees of freedom are (locally and globally) numbered as follows: </p><div class="fragment"><div class="line">meshes:             *-------*                        *---*---*</div><div class="line">local DoF <a class="code" href="namespacenumbers.html">numbers</a>:  0       1                        0  1|0  1</div><div class="line">global DoF <a class="code" href="namespacenumbers.html">numbers</a>: 0       1                        0   1   2</div></div><!-- fragment --><p> Then we want the restriction operation to take the value of the zeroth DoF on child 0 as the value of the zeroth DoF on the parent, and take the value of the first DoF on child 1 as the value of the first DoF on the parent. Ideally, we would like to write this follows </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ U^\text{coarse}|_\text{parent} = \sum_{\text{child}=0}^1 R_\text{child} U^\text{fine}|_\text{child} \]" src="form_571.png"/>
</p>
<p> where <img class="formulaInl" alt="$U^\text{fine}|_\text{child=0}=(U^\text{fine}_0,U^\text{fine}_1)^T$" src="form_572.png"/> and <img class="formulaInl" alt="$U^\text{fine}|_\text{child=1}=(U^\text{fine}_1,U^\text{fine}_2)^T$" src="form_573.png"/>. Writing the requested operation like this would here be possible by choosing </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_0 = \left(\begin{matrix}1 &amp; 0 \\ 0 &amp; 0\end{matrix}\right), \qquad\qquad R_1 = \left(\begin{matrix}0 &amp; 0 \\ 0 &amp; 1\end{matrix}\right). \]" src="form_574.png"/>
</p>
<p> However, this approach already fails if we go to a <img class="formulaInl" alt="$Q_2$" src="form_575.png"/> element with the following degrees of freedom: </p><div class="fragment"><div class="line">meshes:             *-------*                        *----*----*</div><div class="line">local DoF <a class="code" href="namespacenumbers.html">numbers</a>:  0   2   1                        0 2 1|0 2 1</div><div class="line">global DoF <a class="code" href="namespacenumbers.html">numbers</a>: 0   2   1                        0 2  1  4 3</div></div><!-- fragment --><p> Writing things as the sum over matrix operations as above would not easily work because we have to add nonzero values to <img class="formulaInl" alt="$U^\text{coarse}_2$" src="form_576.png"/> twice, once for each child.</p>
<p>Consequently, restriction is typically implemented as a <em>concatenation</em> operation. I.e., we first compute the individual restrictions from each child, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde U^\text{coarse}_\text{child} = R_\text{child} U^\text{fine}|_\text{child}, \]" src="form_577.png"/>
</p>
<p> and then compute the values of <img class="formulaInl" alt="$U^\text{coarse}|_\text{parent}$" src="form_578.png"/> with the following code: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> child=0; child&lt;cell-&gt;n_children(); ++child)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">    <span class="keywordflow">if</span> (U_tilde_coarse[child][i] != 0)</div><div class="line">      U_coarse_on_parent[i] = U_tilde_coarse[child][i];</div></div><!-- fragment --><p> In other words, each nonzero element of <img class="formulaInl" alt="$\tilde U^\text{coarse}_\text{child}$" src="form_579.png"/> <em>overwrites</em>, rather than adds to the corresponding element of <img class="formulaInl" alt="$U^\text{coarse}|_\text{parent}$" src="form_578.png"/>. This typically also implies that the restriction matrices from two different cells should agree on a value for coarse degrees of freedom that they both want to touch (otherwise the result would depend on the order in which we loop over children, which would be unreasonable because the order of children is an otherwise arbitrary convention). For example, in the example above, the restriction matrices will be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R_0 = \left(\begin{matrix}1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \end{matrix}\right), \qquad\qquad R_1 = \left(\begin{matrix}0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 \end{matrix}\right), \]" src="form_580.png"/>
</p>
<p> and the compatibility condition is the <img class="formulaInl" alt="$R_{0,21}=R_{1,20}$" src="form_581.png"/> because they both indicate that <img class="formulaInl" alt="$U^\text{coarse}|_\text{parent,2}$" src="form_582.png"/> should be set to one times <img class="formulaInl" alt="$U^\text{fine}|_\text{child=0,1}$" src="form_583.png"/> and <img class="formulaInl" alt="$U^\text{fine}|_\text{child=1,0}$" src="form_584.png"/>.</p>
<p>Unfortunately, not all finite elements allow to write the restriction operation in this way. For example, for the piecewise constant <a class="el" href="classFE__DGQ.html">FE_DGQ(0)</a> element, the value of the finite element field on the parent cell can not be determined by interpolation from the children. Rather, the only reasonable choice is to take it as the <em>average</em> value between the children &ndash; so we are back to the sum operation, rather than the concatenation. Further thought shows that whether restriction should be additive or not is a property of the individual shape function, not of the finite element as a whole. Consequently, the <a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">FiniteElement::restriction_is_additive()</a> function returns whether a particular shape function should act via concatenation (a return value of <code>false</code>) or via addition (return value of <code>true</code>), and the correct code for the overall operation is then as follows (and as, in fact, implemented in DoFAccessor::get_interpolated_dof_values()): </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> child=0; child&lt;cell-&gt;n_children(); ++child)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>; ++i)</div><div class="line">    <span class="keywordflow">if</span> (fe.restriction_is_additive(i) == <span class="keyword">true</span>)</div><div class="line">      U_coarse_on_parent[i] += U_tilde_coarse[child][i];</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">if</span> (U_tilde_coarse[child][i] != 0)</div><div class="line">        U_coarse_on_parent[i] = U_tilde_coarse[child][i];</div></div><!-- fragment --><h5>Computing <a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a></h5>
<p>Constraint matrices can be computed semi-automatically using <a class="el" href="namespaceFETools.html#ac0fe5c7f55db091a4477af7c3989b83c">FETools::compute_face_embedding_matrices()</a>. This function computes the representation of the coarse mesh functions by fine mesh functions for each child of a face separately. These matrices must be convoluted into a single rectangular constraint matrix, eliminating degrees of freedom on common vertices and edges as well as on the coarse grid vertices. See the discussion above for details of this numbering.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Guido Kanschat, Ralf Hartmann, 1998, 2000, 2001, 2005, 2015 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l00035">35</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a904941a97e1f4e87d2770c8e9fe455c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904941a97e1f4e87d2770c8e9fe455c1">&#9670;&nbsp;</a></span>FiniteElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement.html">FiniteElement</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>restriction_is_additive_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonzero_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor: initialize the fields of this base class of all finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_data</td><td>An object that stores identifying (typically integral) information about the element to be constructed. In particular, this object will contain data such as the number of degrees of freedom per cell (and per vertex, line, etc), the number of vector components, etc. This argument is used to initialize the base class of the current object under construction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restriction_is_additive_flags</td><td>A vector of size <code>dofs_per_cell</code> (or of size one, see below) that for each shape function states whether the shape function is additive or not. The meaning of these flags is described in the section on restriction matrices in the general documentation of this class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonzero_components</td><td>A vector of size <code>dofs_per_cell</code> (or of size one, see below) that for each shape function provides a <a class="el" href="classComponentMask.html">ComponentMask</a> (of size <code>fe_data.n_components()</code>) that indicates in which vector components this shape function is nonzero (after mapping the shape function to the real cell). For "primitive" shape functions, this component mask will have a single entry (see <a class="el" href="DEALGlossary.html#GlossPrimitive">GlossPrimitive</a> for more information about primitive elements). On the other hand, for elements such as the Raviart-Thomas or Nedelec elements, shape functions are nonzero in more than one vector component (after mapping to the real cell) and the given component mask will contain more than one entry. (For these two elements, all entries will in fact be set, but this would not be the case if you couple a <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> and a <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> together into a <a class="el" href="classFESystem.html">FESystem</a>.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>restriction_is_additive_flags.size() == dofs_per_cell</code>, or <code>restriction_is_additive_flags.size() == 1</code>. In the latter case, the array is simply interpreted as having size <code>dofs_per_cell</code> where each element has the same value as the single element given.</dd>
<dd>
<code>nonzero_components.size() == dofs_per_cell</code>, or <code>nonzero_components.size() == 1</code>. In the latter case, the array is simply interpreted as having size <code>dofs_per_cell</code> where each element equals the component mask provided in the single element given. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00061">61</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ae5c542597d19c71026f84f8d9c87c999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c542597d19c71026f84f8d9c87c999">&#9670;&nbsp;</a></span>~FiniteElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::~<a class="el" href="classFiniteElement.html">FiniteElement</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual destructor. Makes sure that pointers to this class are deleted properly. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00155">155</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7631a5a3cc67eaf6f498f2bd6ef4151c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7631a5a3cc67eaf6f498f2bd6ef4151c">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim,spacedim&gt;* <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sort of virtual copy constructor. Some places in the library, for example the constructors of <a class="el" href="classFESystem.html">FESystem</a> as well as the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> class, need to make copies of finite elements without knowing their exact type. They do so through this function. </p>

<p>Implemented in <a class="el" href="classFESystem.html#a533b3497523d291cf8d123557348ff5c">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a498edd9ce1ab967b400bfb741b1d8de2">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__Q.html#ad4305df8c6ef2962d4de6f9e15c97855">FE_Q&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#ad4305df8c6ef2962d4de6f9e15c97855">FE_Q&lt; dim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#afdcf4bc0f53696c4b7b5ab84f3531a9c">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQHermite.html#a0986ac539d33a935caa2f321103dc756">FE_DGQHermite&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQLegendre.html#a7a8329c810f215259734444e8c6e9f11">FE_DGQLegendre&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a8b1b2e706552339884def5ed4b577ffd">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#a6ba3a353b6516f2fce1ca866002a7d2d">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__DGQArbitraryNodes.html#a991f518eae8858ae0bf8ec9ccfe4222d">FE_DGQArbitraryNodes&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#ac44feb5c2382a63fd2072f29a5e4d13f">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a311d0f63d6ee546b4f6f9808398a7045">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a17443773adaeae2b1028ae6bb489670d">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#aac609b8840f08d5f13b181d403d48f54">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a6aa806fd3fb2b8005cb4f8bd24ed60bf">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__P1NC.html#a6e1adc5a60005b67f3d79336ed4ef185">FE_P1NC</a>, <a class="el" href="classFE__RaviartThomasNodal.html#a35de3b89381c7797274689699b9b9799">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__Bernstein.html#acfbfa49f8ff3fad5f018e62470f41e7e">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#a8f780ab6a042aaf11cfe1aafe0ccdf00">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#a0678c65d5f4c03e480f9c113ed5ec2f7">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a79d95d17eff895238c978861cacc9063">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a89121b81eea2fdd75edc15bbcf7288c2">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#ae96cbb868197fdf91aa46206e499d24a">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__Nothing.html#af8af3848b0c08f7940f88f6f894e0f5c">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#af8af3848b0c08f7940f88f6f894e0f5c">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__BDM.html#a87e1d7f46c18487066b87a262ac45ef2">FE_BDM&lt; dim &gt;</a>, <a class="el" href="classFE__RannacherTurek.html#a781d43a4d2827fef75b32b75d30dbf34">FE_RannacherTurek&lt; dim &gt;</a>, <a class="el" href="classFE__DGVector.html#a2ef668f84cbb6cec90d37f11f489a84b">FE_DGVector&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a2ef668f84cbb6cec90d37f11f489a84b">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a2ef668f84cbb6cec90d37f11f489a84b">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a2ef668f84cbb6cec90d37f11f489a84b">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a781fb81f160bedfdad147d32ecf7efe0">FE_FaceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__TraceQ.html#a69fc8e5203ff39a8f81fb5a041330876">FE_TraceQ&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a09655d1d2555af8dcd48caebd4039d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09655d1d2555af8dcd48caebd4039d29">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string that uniquely identifies a finite element. The general convention is that this is the class name, followed by the dimension in angle brackets, and the polynomial degree and whatever else is necessary in parentheses. For example, <code>FE_Q&lt;2&gt;(3)</code> is the value returned for a cubic element in 2d.</p>
<p>Systems of elements have their own naming convention, see the <a class="el" href="classFESystem.html">FESystem</a> class. </p>

<p>Implemented in <a class="el" href="classFE__Q.html#a0a49351b8d0ffe9d05ec7db9f6b8e10b">FE_Q&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#a0a49351b8d0ffe9d05ec7db9f6b8e10b">FE_Q&lt; dim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a42d7cdd70e0387a0134ef115124d14f8">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__DGQHermite.html#a25981e7ae017bf552ae84d4338d5af6e">FE_DGQHermite&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQLegendre.html#a660de788140a0c2177180832734aedfd">FE_DGQLegendre&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP_3_011_00_01spacedim_01_4.html#a945d88066faf3d5962221b96e0362a9b">FE_FaceP&lt; 1, spacedim &gt;</a>, <a class="el" href="classFESystem.html#a885ecbbd8dee5cc72dfa539c6f7b5e97">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQArbitraryNodes.html#adcfd762616d455542ae7b6d53f1ba7d7">FE_DGQArbitraryNodes&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a9656be0a8a7e8ac219fdabcefb828eb3">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#afe074b37de0eb561949fbc3100e7a3df">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#aa60c85ae43f734e194cc81683874c968">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__Enriched.html#a95b31f2a7362f0cfd1b7e999eb5e6649">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ad9430c81d1ab5e3af6fefbbeef3a7777">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__P1NC.html#a5503a7f591aa44fcea3fc46a0e2e3cfd">FE_P1NC</a>, <a class="el" href="classFE__Q__DG0.html#a4fbf81bcccacdd16ee09f9b5330130d3">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#af01449a1d5bfbbfeef0cdb640d04bb7a">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__DGBDM.html#abbca16a61804ec2df8f772278c741e6c">FE_DGBDM&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGRaviartThomas.html#a975f3f03ad46f716d28a753cd1cd4047">FE_DGRaviartThomas&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a374e9d5a953dc7d6c9e42abd75b64aed">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGNedelec.html#ab4f9df04b74e90d4a02dd4bcdf726a7a">FE_DGNedelec&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#addf1796f54cf75847ca873794852d782">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ_3_011_00_01spacedim_01_4.html#a8ebc6a4cb30467ec23b7d1685ab145fe">FE_TraceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a9ca9c8b7e3f5927396145c5a4c4b7fe5">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#ab9c0f03169aa6ade411afcb68f142395">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a1188330dd0e20fdb276f81bad04357f5">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a370b3fcd66df28136402bd35b0996ee7">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#a23662b0f7562c0ec6538719c6ca286f3">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__Nothing.html#ab6343175ef7d20401220d0e216cbbe9b">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#ab6343175ef7d20401220d0e216cbbe9b">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#aceb4494c011fb02a9eb5c3b12a26aac2">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__BDM.html#a7db75f3f75f9f062f2344cac5a4b6089">FE_BDM&lt; dim &gt;</a>, <a class="el" href="classFE__DGVector.html#a5de90b40a4a113977dedfbc49f8dfd3e">FE_DGVector&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a5de90b40a4a113977dedfbc49f8dfd3e">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a5de90b40a4a113977dedfbc49f8dfd3e">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a5de90b40a4a113977dedfbc49f8dfd3e">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#aa18ddef31ba7844a5e327e493f12a7e6">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RannacherTurek.html#a9c5ada19b89893f59d29fcb3434ea1a3">FE_RannacherTurek&lt; dim &gt;</a>, and <a class="el" href="classFE__TraceQ.html#ad4f22009361095c547026140b7646e02">FE_TraceQ&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a623b0c5a085bc13c826f3d78459a407f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623b0c5a085bc13c826f3d78459a407f">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator returns a reference to the present object if the argument given equals to zero. While this does not seem particularly useful, it is helpful in writing code that works with both <a class="el" href="classDoFHandler.html">DoFHandler</a> and the hp version <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>, since one can then write code like this: </p><div class="fragment"><div class="line">dofs_per_cell</div><div class="line">  = dof_handler-&gt;get_fe()[cell-&gt;active_fe_index()].dofs_per_cell;</div></div><!-- fragment --><p>This code doesn't work in both situations without the present operator because <a class="el" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">DoFHandler::get_fe()</a> returns a finite element, whereas <a class="el" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">hp::DoFHandler::get_fe()</a> returns a collection of finite elements that doesn't offer a <code>dofs_per_cell</code> member variable: one first has to select which finite element to work on, which is done using the operator[]. Fortunately, <code>cell-&gt;active_fe_index()</code> also works for non-hp classes and simply returns zero in that case. The present operator[] accepts this zero argument, by returning the finite element with index zero within its collection (that, of course, consists only of the present finite element anyway). </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02781">2781</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a9889833bef170393b1281a1418596d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9889833bef170393b1281a1418596d70">&#9670;&nbsp;</a></span>shape_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element. If the finite element is vector-valued, then return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#a247fccbd72723a07fc8c17ac093d3156">shape_value_component()</a> function.</p>
<p>Implementations of this function should throw an exception of type ExcUnitShapeValuesDoNotExist if the shape functions of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depend on the shape of the cell in real space, i.e., if the shape functions are not defined by mapping from the reference cell. Some non-conforming elements are defined this way, as is the <a class="el" href="classFE__DGPNonparametric.html">FE_DGPNonparametric</a> class, to name just one example.</p>
<p>The default implementation of this virtual function does exactly this, i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a72a4d122960a1c835114093e20164f69">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a883048276adb99ceab816cf52d775ebd">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a29b8e8edd26e5febd5c9da124c44c21f">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ac50ec91ec6494549eb7ffa0d5776a54c">FE_PolyTensor&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ac50ec91ec6494549eb7ffa0d5776a54c">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ac50ec91ec6494549eb7ffa0d5776a54c">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ac50ec91ec6494549eb7ffa0d5776a54c">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ac50ec91ec6494549eb7ffa0d5776a54c">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ac50ec91ec6494549eb7ffa0d5776a54c">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ac50ec91ec6494549eb7ffa0d5776a54c">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ac50ec91ec6494549eb7ffa0d5776a54c">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a2513b232e04025972673732b8c72c304">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a2513b232e04025972673732b8c72c304">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__Poly.html#ab0714144cc44d43dad31c328f9e4bb3c">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab0714144cc44d43dad31c328f9e4bb3c">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab0714144cc44d43dad31c328f9e4bb3c">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#ab0714144cc44d43dad31c328f9e4bb3c">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#ab0714144cc44d43dad31c328f9e4bb3c">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab0714144cc44d43dad31c328f9e4bb3c">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#ab0714144cc44d43dad31c328f9e4bb3c">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab0714144cc44d43dad31c328f9e4bb3c">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#ab0714144cc44d43dad31c328f9e4bb3c">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00163">163</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a247fccbd72723a07fc8c17ac093d3156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247fccbd72723a07fc8c17ac093d3156">&#9670;&nbsp;</a></span>shape_value_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#a9889833bef170393b1281a1418596d70">shape_value()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the value of the <code>component-th</code> vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a2e59adaac99b2a41e009158246943e21">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ac4b77bf20ad843e487d0f8aedf52b924">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad52066a7294bc70a688e464493e94ac5">FE_PolyTensor&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad52066a7294bc70a688e464493e94ac5">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad52066a7294bc70a688e464493e94ac5">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad52066a7294bc70a688e464493e94ac5">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad52066a7294bc70a688e464493e94ac5">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad52066a7294bc70a688e464493e94ac5">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad52066a7294bc70a688e464493e94ac5">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ad52066a7294bc70a688e464493e94ac5">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aeb0fd983481d379f955f18039d58cb34">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aeb0fd983481d379f955f18039d58cb34">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aeb0fd983481d379f955f18039d58cb34">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#aeb0fd983481d379f955f18039d58cb34">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#aeb0fd983481d379f955f18039d58cb34">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aeb0fd983481d379f955f18039d58cb34">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#aeb0fd983481d379f955f18039d58cb34">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aeb0fd983481d379f955f18039d58cb34">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#aeb0fd983481d379f955f18039d58cb34">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00174">174</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="aaaafefdf45fc2a5e7db18acb64063f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaafefdf45fc2a5e7db18acb64063f5d">&#9670;&nbsp;</a></span>shape_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the <code>ith</code> shape function at the point <code>p</code>. <code>p</code> is a point on the reference element, and likewise the gradient is the gradient on the unit cell with respect to unit cell coordinates. If the finite element is vector-valued, then return the value of the only non- zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non-primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#a7f026ed19fcc589476f11d69de4a3419">shape_grad_component()</a> function.</p>
<p>Implementations of this function should throw an exception of type ExcUnitShapeValuesDoNotExist if the shape functions of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depend on the shape of the cell in real space, i.e., if the shape functions are not defined by mapping from the reference cell. Some non-conforming elements are defined this way, as is the <a class="el" href="classFE__DGPNonparametric.html">FE_DGPNonparametric</a> class, to name just one example.</p>
<p>The default implementation of this virtual function does exactly this, i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#aff6d3423f42d2bf3f27aaba3ea665626">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a66f7244034f36d36107a34b63aa97771">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ae16a6f197dc667a8d6f21e65e792cc20">FE_PolyTensor&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ae16a6f197dc667a8d6f21e65e792cc20">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ae16a6f197dc667a8d6f21e65e792cc20">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ae16a6f197dc667a8d6f21e65e792cc20">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ae16a6f197dc667a8d6f21e65e792cc20">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ae16a6f197dc667a8d6f21e65e792cc20">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ae16a6f197dc667a8d6f21e65e792cc20">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#ae16a6f197dc667a8d6f21e65e792cc20">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a756963a66238e7ea11666820c6c57986">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a756963a66238e7ea11666820c6c57986">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a756963a66238e7ea11666820c6c57986">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a756963a66238e7ea11666820c6c57986">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a756963a66238e7ea11666820c6c57986">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a756963a66238e7ea11666820c6c57986">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a756963a66238e7ea11666820c6c57986">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a756963a66238e7ea11666820c6c57986">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a756963a66238e7ea11666820c6c57986">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00186">186</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a7f026ed19fcc589476f11d69de4a3419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f026ed19fcc589476f11d69de4a3419">&#9670;&nbsp;</a></span>shape_grad_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#aaaafefdf45fc2a5e7db18acb64063f5d">shape_grad()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-th</code> vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a0546a1ca29e2cc9df5f666e64de0af82">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a042cea5c79f3e6915a9aa72f1b2d8fe3">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a0d087b44184fdd76efdfeade8950dbe8">FE_PolyTensor&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a0d087b44184fdd76efdfeade8950dbe8">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a0d087b44184fdd76efdfeade8950dbe8">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a0d087b44184fdd76efdfeade8950dbe8">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a0d087b44184fdd76efdfeade8950dbe8">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a0d087b44184fdd76efdfeade8950dbe8">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a0d087b44184fdd76efdfeade8950dbe8">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a0d087b44184fdd76efdfeade8950dbe8">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a230d67121b14ebaea2cf013ba5e65209">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a230d67121b14ebaea2cf013ba5e65209">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a230d67121b14ebaea2cf013ba5e65209">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a230d67121b14ebaea2cf013ba5e65209">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a230d67121b14ebaea2cf013ba5e65209">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a230d67121b14ebaea2cf013ba5e65209">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a230d67121b14ebaea2cf013ba5e65209">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a230d67121b14ebaea2cf013ba5e65209">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a230d67121b14ebaea2cf013ba5e65209">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00197">197</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="af9735ea35b55b66b069cece0d5c55e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9735ea35b55b66b069cece0d5c55e9d">&#9670;&nbsp;</a></span>shape_grad_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of second derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. If the finite element is vector-valued, then return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#a78d74d669ee2e15eedea95d75889b9e3">shape_grad_grad_component()</a> function.</p>
<p>Implementations of this function should throw an exception of type ExcUnitShapeValuesDoNotExist if the shape functions of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depend on the shape of the cell in real space, i.e., if the shape functions are not defined by mapping from the reference cell. Some non-conforming elements are defined this way, as is the <a class="el" href="classFE__DGPNonparametric.html">FE_DGPNonparametric</a> class, to name just one example.</p>
<p>The default implementation of this virtual function does exactly this, i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a971968929f024cafb7aaf8b42138bf41">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ac4434ab7ada31c063dbeac96180be5ef">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aac8010df289d98ce60e5ae3aa68809dc">FE_PolyTensor&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aac8010df289d98ce60e5ae3aa68809dc">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aac8010df289d98ce60e5ae3aa68809dc">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aac8010df289d98ce60e5ae3aa68809dc">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aac8010df289d98ce60e5ae3aa68809dc">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aac8010df289d98ce60e5ae3aa68809dc">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aac8010df289d98ce60e5ae3aa68809dc">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aac8010df289d98ce60e5ae3aa68809dc">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a5aee9a3dee0d6074078080f706c87c9c">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a5aee9a3dee0d6074078080f706c87c9c">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a5aee9a3dee0d6074078080f706c87c9c">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a5aee9a3dee0d6074078080f706c87c9c">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a5aee9a3dee0d6074078080f706c87c9c">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a5aee9a3dee0d6074078080f706c87c9c">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a5aee9a3dee0d6074078080f706c87c9c">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a5aee9a3dee0d6074078080f706c87c9c">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a5aee9a3dee0d6074078080f706c87c9c">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00209">209</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a78d74d669ee2e15eedea95d75889b9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d74d669ee2e15eedea95d75889b9e3">&#9670;&nbsp;</a></span>shape_grad_grad_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_grad_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#af9735ea35b55b66b069cece0d5c55e9d">shape_grad_grad()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-th</code> vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a859b763ff0a58db2786cf844a23c66fd">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a9b2a5f9695d18bb045ff3c539ef938c5">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aa742d02cf5b28b4e0a6acbe5053c683e">FE_PolyTensor&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aa742d02cf5b28b4e0a6acbe5053c683e">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aa742d02cf5b28b4e0a6acbe5053c683e">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aa742d02cf5b28b4e0a6acbe5053c683e">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aa742d02cf5b28b4e0a6acbe5053c683e">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aa742d02cf5b28b4e0a6acbe5053c683e">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aa742d02cf5b28b4e0a6acbe5053c683e">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#aa742d02cf5b28b4e0a6acbe5053c683e">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ac567c67a5ed693adda3ae6c60cbefdd1">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ac567c67a5ed693adda3ae6c60cbefdd1">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ac567c67a5ed693adda3ae6c60cbefdd1">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#ac567c67a5ed693adda3ae6c60cbefdd1">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#ac567c67a5ed693adda3ae6c60cbefdd1">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ac567c67a5ed693adda3ae6c60cbefdd1">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#ac567c67a5ed693adda3ae6c60cbefdd1">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ac567c67a5ed693adda3ae6c60cbefdd1">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#ac567c67a5ed693adda3ae6c60cbefdd1">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00220">220</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="af9716de0908601e453e0b56935280eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9716de0908601e453e0b56935280eb3">&#9670;&nbsp;</a></span>shape_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of third derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. If the finite element is vector-valued, then return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#a4bc9c5e6fff74957e68a7dc40ce9001c">shape_3rd_derivative_component()</a> function.</p>
<p>Implementations of this function should throw an exception of type ExcUnitShapeValuesDoNotExist if the shape functions of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depend on the shape of the cell in real space, i.e., if the shape functions are not defined by mapping from the reference cell. Some non-conforming elements are defined this way, as is the <a class="el" href="classFE__DGPNonparametric.html">FE_DGPNonparametric</a> class, to name just one example.</p>
<p>The default implementation of this virtual function does exactly this, i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a0386c236d8f225069028bb668306abe9">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a6a3e8d2ddcbc2d05ee621a348e8435d3">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a6a3e8d2ddcbc2d05ee621a348e8435d3">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a6a3e8d2ddcbc2d05ee621a348e8435d3">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a6a3e8d2ddcbc2d05ee621a348e8435d3">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a6a3e8d2ddcbc2d05ee621a348e8435d3">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a6a3e8d2ddcbc2d05ee621a348e8435d3">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a6a3e8d2ddcbc2d05ee621a348e8435d3">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a6a3e8d2ddcbc2d05ee621a348e8435d3">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a6a3e8d2ddcbc2d05ee621a348e8435d3">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00232">232</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a4bc9c5e6fff74957e68a7dc40ce9001c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc9c5e6fff74957e68a7dc40ce9001c">&#9670;&nbsp;</a></span>shape_3rd_derivative_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_3rd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#af9716de0908601e453e0b56935280eb3">shape_3rd_derivative()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-</code> th vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a59bfd92b027463e93043c87c19090da8">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7a145b1c3c28a391a89730de0986def2">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7a145b1c3c28a391a89730de0986def2">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7a145b1c3c28a391a89730de0986def2">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a7a145b1c3c28a391a89730de0986def2">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a7a145b1c3c28a391a89730de0986def2">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7a145b1c3c28a391a89730de0986def2">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a7a145b1c3c28a391a89730de0986def2">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7a145b1c3c28a391a89730de0986def2">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a7a145b1c3c28a391a89730de0986def2">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00243">243</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="afca1cc51c17eefe7ae1b22d40739bb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca1cc51c17eefe7ae1b22d40739bb5b">&#9670;&nbsp;</a></span>shape_4th_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_4th_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of fourth derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. If the finite element is vector-valued, then return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#a25664d01bbe39b68056379410dd916ab">shape_4th_derivative_component()</a> function.</p>
<p>Implementations of this function should throw an exception of type ExcUnitShapeValuesDoNotExist if the shape functions of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depend on the shape of the cell in real space, i.e., if the shape functions are not defined by mapping from the reference cell. Some non-conforming elements are defined this way, as is the <a class="el" href="classFE__DGPNonparametric.html">FE_DGPNonparametric</a> class, to name just one example.</p>
<p>The default implementation of this virtual function does exactly this, i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a3fdba0e20f69b3869fc8f9b23ad8fbce">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a0d186688d1e299f945672b8e708fec01">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a0d186688d1e299f945672b8e708fec01">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a0d186688d1e299f945672b8e708fec01">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a0d186688d1e299f945672b8e708fec01">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a0d186688d1e299f945672b8e708fec01">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a0d186688d1e299f945672b8e708fec01">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a0d186688d1e299f945672b8e708fec01">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a0d186688d1e299f945672b8e708fec01">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a0d186688d1e299f945672b8e708fec01">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00255">255</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a25664d01bbe39b68056379410dd916ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25664d01bbe39b68056379410dd916ab">&#9670;&nbsp;</a></span>shape_4th_derivative_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_4th_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#afca1cc51c17eefe7ae1b22d40739bb5b">shape_4th_derivative()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-</code> th vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#aff70cdb99b8412331e890f27c040a5b8">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a53b33256c0124f1714e1ff697757941a">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a53b33256c0124f1714e1ff697757941a">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a53b33256c0124f1714e1ff697757941a">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a53b33256c0124f1714e1ff697757941a">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a53b33256c0124f1714e1ff697757941a">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a53b33256c0124f1714e1ff697757941a">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a53b33256c0124f1714e1ff697757941a">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a53b33256c0124f1714e1ff697757941a">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a53b33256c0124f1714e1ff697757941a">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00266">266</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ab275cbead21bb11b1208222b6d662357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab275cbead21bb11b1208222b6d662357">&#9670;&nbsp;</a></span>has_support_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_support_on_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shape_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns <code>true</code>, if the shape function <code>shape_index</code> has non-zero function values somewhere on the face <code>face_index</code>. The function is typically used to determine whether some matrix elements resulting from face integrals can be assumed to be zero and may therefore be omitted from integration.</p>
<p>A default implementation is provided in this base class which always returns <code>true</code>. This is the safe way to go. </p>

<p>Reimplemented in <a class="el" href="classFE__Q__Hierarchical.html#aa9a2c02a2be80ec4f97e7bb6bb4e52d8">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a6919653dcc9803b74731d78406d4ce9d">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFESystem.html#a7d6bc62d22a61c6c0b29829bba8e94d5">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#ab8c4aaca6a2d9ca3bdccc44b44cd3b17">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a43178d2676ba897bdb025f16825cdecb">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#ad14251963964ea5f112584529d41c017">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#a569796e4eaac9212ae7f5b676331c664">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#a529279fa2f55385d0bcb4303d73c1c12">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#a9940ef13527fac7a392e359917fef85f">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__FaceP.html#adff61afa952e0c69b339a2ddb14841ab">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#a1695d3e2ed516f81cc1a412b30517889">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#a70b6059417f00a2d1402a6096db533ec">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#adbe6d40b81553a856de8c6c758d118df">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a7488ad67c56eecee969c5eb1631eb90e">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#a75b10f8b89c430dfaf165a3ea19873e7">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a52c76a006b56c194fe4d5d649968fd3a">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#aa0d732ccb1209d581f01e172d329f225">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a8fa3d78947e31fda85afdd3be2f305f9">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#abd1e7c4913b6cea8148b22ff9d417703">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a8d45038b8e21f2e3362e752eed8f370e">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae9079b1a82fece54ceb7d67df0e86193">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae9079b1a82fece54ceb7d67df0e86193">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae9079b1a82fece54ceb7d67df0e86193">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae9079b1a82fece54ceb7d67df0e86193">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae9079b1a82fece54ceb7d67df0e86193">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae9079b1a82fece54ceb7d67df0e86193">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#adfbcd120f08c8d5153555125ebe8a26c">FE_DGVector&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#adfbcd120f08c8d5153555125ebe8a26c">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#adfbcd120f08c8d5153555125ebe8a26c">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#adfbcd120f08c8d5153555125ebe8a26c">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__TraceQ.html#a6799a46702650455803fe738b3ce2a2f">FE_TraceQ&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01079">1079</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a9fbcedd86a33fd947de495e7bf6923dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbcedd86a33fd947de495e7bf6923dd">&#9670;&nbsp;</a></span>get_restriction_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_restriction_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix that describes restricting a finite element field from the given <code>child</code> (as obtained by the given <code>refinement_case</code>) to the parent cell. The interpretation of the returned matrix depends on what <a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">restriction_is_additive()</a> returns for each shape function.</p>
<p>Row and column indices are related to coarse grid and fine grid spaces, respectively, consistent with the definition of the associated operator.</p>
<p>If projection matrices are not implemented in the derived finite element class, this function aborts with an exception of type <a class="el" href="group__Exceptions.html#gae5805a8b6dbd4b6f6dbfa0842e3aa7cf">FiniteElement::ExcProjectionVoid</a>. You can check whether this would happen by first calling the <a class="el" href="classFiniteElement.html#ab8539eac73f0305ba91e612ad5519250">restriction_is_implemented()</a> or the <a class="el" href="classFiniteElement.html#a645ff401ff38407d67a0785163939f87">isotropic_restriction_is_implemented()</a> function. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a6e3a777114340f515eb7200b20f75ed2">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a79d29d0b046a61f5b8476cf73969c9b8">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#ac0579000ef83fc779a436cde2a780352">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#afc9e13c262b9f31a847173fbcf34fe16">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#aed037280e78b1b67735d545e7d381bd0">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a54a5b1ffb8823aa4437fea0a0b8111dc">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a54a5b1ffb8823aa4437fea0a0b8111dc">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a54a5b1ffb8823aa4437fea0a0b8111dc">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a54a5b1ffb8823aa4437fea0a0b8111dc">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a54a5b1ffb8823aa4437fea0a0b8111dc">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a54a5b1ffb8823aa4437fea0a0b8111dc">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Bernstein.html#a33cdd85c7e1ef6cafcc485aff589f600">FE_Bernstein&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00305">305</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a3a4671144d9976b133c4f79c9aefdd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4671144d9976b133c4f79c9aefdd7c">&#9670;&nbsp;</a></span>get_prolongation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_prolongation_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prolongation/embedding matrix between grids.</p>
<p>The identity operator from a coarse grid space into a fine grid space (where both spaces are identified as functions defined on the parent and child cells) is associated with a matrix <code>P</code> that maps the corresponding representations of these functions in terms of their nodal values. The restriction of this matrix <code>P_i</code> to a single child cell is returned here.</p>
<p>The matrix <code>P</code> is the concatenation, not the sum of the cell matrices <code>P_i</code>. That is, if the same non-zero entry <code>j,k</code> exists in in two different child matrices <code>P_i</code>, the value should be the same in both matrices and it is copied into the matrix <code>P</code> only once.</p>
<p>Row and column indices are related to fine grid and coarse grid spaces, respectively, consistent with the definition of the associated operator.</p>
<p>These matrices are used by routines assembling the prolongation matrix for multi-level methods. Upon assembling the transfer matrix between cells using this matrix array, zero elements in the prolongation matrix are discarded and will not fill up the transfer matrix.</p>
<p>If prolongation matrices are not implemented in the derived finite element class, this function aborts with an exception of type <a class="el" href="group__Exceptions.html#ga416676a9802c3c02acff1847735547b9">FiniteElement::ExcEmbeddingVoid</a>. You can check whether this would happen by first calling the <a class="el" href="classFiniteElement.html#a1ead2dba2770c63493a139bec677ccdb">prolongation_is_implemented()</a> or the <a class="el" href="classFiniteElement.html#a0849d6c4188612816934d5468ecf9e6b">isotropic_prolongation_is_implemented()</a> function. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a4bfb41a362abdf2c8d1373809bd4eeab">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a1f1b8325ed87a1863834602ce690a428">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__Enriched.html#acd4e0a0f62e299a8c30cc41b7614cd63">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a3c371248b01ccb17d944ceefdbeeaaeb">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a71557f530b2a48fb9235a52f6daca168">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a09490d57b4a1dd4c117726127c7937c7">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a09490d57b4a1dd4c117726127c7937c7">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a09490d57b4a1dd4c117726127c7937c7">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a09490d57b4a1dd4c117726127c7937c7">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a09490d57b4a1dd4c117726127c7937c7">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a09490d57b4a1dd4c117726127c7937c7">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a5b6ec82bc41e54f919320acfc9c27647">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Bernstein.html#a791ba473c17ab8d96d86549cb22cc714">FE_Bernstein&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00325">325</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a1ead2dba2770c63493a139bec677ccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ead2dba2770c63493a139bec677ccdb">&#9670;&nbsp;</a></span>prolongation_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::prolongation_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its prolongation matrices. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix()</a> function will generate an error or not.</p>
<p>Note, that this function returns <code>true</code> only if the prolongation matrices of the isotropic and all anisotropic refinement cases are implemented. If you are interested in the prolongation matrices for isotropic refinement only, use the isotropic_prolongation_is_implemented function instead.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00672">672</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a0849d6c4188612816934d5468ecf9e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0849d6c4188612816934d5468ecf9e6b">&#9670;&nbsp;</a></span>isotropic_prolongation_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::isotropic_prolongation_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its prolongation matrices for isotropic children. The return value also indicates whether a call to the <code>get_prolongation_matrix</code> function will generate an error or not.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00724">724</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ab8539eac73f0305ba91e612ad5519250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8539eac73f0305ba91e612ad5519250">&#9670;&nbsp;</a></span>restriction_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its restriction matrices. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix()</a> function will generate an error or not.</p>
<p>Note, that this function returns <code>true</code> only if the restriction matrices of the isotropic and all anisotropic refinement cases are implemented. If you are interested in the restriction matrices for isotropic refinement only, use the <a class="el" href="classFiniteElement.html#a645ff401ff38407d67a0785163939f87">isotropic_restriction_is_implemented()</a> function instead.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00698">698</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a645ff401ff38407d67a0785163939f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645ff401ff38407d67a0785163939f87">&#9670;&nbsp;</a></span>isotropic_restriction_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::isotropic_restriction_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its restriction matrices for isotropic children. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix()</a> function will generate an error or not.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00750">750</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a6aa81cef78859c726852a1ee1ef37210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa81cef78859c726852a1ee1ef37210">&#9670;&nbsp;</a></span>restriction_is_additive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_additive </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the <a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a> field. See the discussion about restriction matrices in the general class documentation for more information.</p>
<p>The index must be between zero and the number of shape functions of this element. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02955">2955</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a9da3f9ca1fa6be8fa5afcb34d56028a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da3f9ca1fa6be8fa5afcb34d56028a3">&#9670;&nbsp;</a></span>constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::constraints </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em> = <code>::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt;::case_isotropic</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read only reference to the matrix that describes the constraints at the interface between a refined and an unrefined cell.</p>
<p>Some finite elements do not (yet) implement hanging node constraints. If this is the case, then this function will generate an exception, since no useful return value can be generated. If you should have a way to live with this, then you might want to use the <a class="el" href="classFiniteElement.html#a01f5b5d1700cf820f8989f35418efbfc">constraints_are_implemented()</a> function to check up front whether this function will succeed or generate the exception. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00797">797</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a01f5b5d1700cf820f8989f35418efbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f5b5d1700cf820f8989f35418efbfc">&#9670;&nbsp;</a></span>constraints_are_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::constraints_are_implemented </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em> = <code>::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt;::case_isotropic</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this element implements its hanging node constraints. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#a9da3f9ca1fa6be8fa5afcb34d56028a3">constraints()</a> function will generate an error or not.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case hanging node constraints are not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs hanging node constraints and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#a9da3f9ca1fa6be8fa5afcb34d56028a3">constraints()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00776">776</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ae5d64f4a56fb9fefc55a68fb7ac5e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d64f4a56fb9fefc55a68fb7ac5e71a">&#9670;&nbsp;</a></span>hp_constraints_are_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_constraints_are_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its hanging node constraints in the new way, which has to be used to make elements "hp compatible". That means, the element properly implements the get_face_interpolation_matrix and get_subface_interpolation_matrix methods. Therefore the return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#a893c7dd826fce7d3e6838fdb44e3132d">get_face_interpolation_matrix()</a> method and the <a class="el" href="classFiniteElement.html#a50fd529ffa0faaac061a56c957c63ded">get_subface_interpolation_matrix()</a> method will generate an error or not.</p>
<p>Currently the main purpose of this function is to allow the make_hanging_node_constraints method to decide whether the new procedures, which are supposed to work in the hp framework can be used, or if the old well verified but not hp capable functions should be used. Once the transition to the new scheme for computing the interface constraints is complete, this function will be superfluous and will probably go away.</p>
<p>Derived classes should implement this function accordingly. The default assumption is that a finite element does not provide hp capable face interpolation, and the default implementation therefore returns <code>false</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a163eddc7127890655dfe27fb76dd5cc3">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#ae7a96d4f7f84ebf65fbb9a7cc3c16fe1">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ab27ea3bce8766d77dff89bc122490a8d">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a3ce544700bb680221328e72a9da2288a">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#addc6cbca3cf4b7d7ead50728a418744c">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#ad6fe8c97117199497840e024a0fe3a72">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__Enriched.html#a337f23f5412b5143c2e2fb164629b25a">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#a9e57d5edd96f148231f112a103e932f7">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#ab8b0f03945bed2e37f0f2b3ac1699868">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a52baa498fd914daca031ad0fc06b7655">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a52baa498fd914daca031ad0fc06b7655">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a52baa498fd914daca031ad0fc06b7655">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a52baa498fd914daca031ad0fc06b7655">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a52baa498fd914daca031ad0fc06b7655">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a52baa498fd914daca031ad0fc06b7655">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a9ed60d32767324310bf94d9e67ccf4d2">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a9ed60d32767324310bf94d9e67ccf4d2">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#a8041947e05508393b61c13c7c254ae18">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a6ce3c41a310434d62c0f24c400152063">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a7f7cbb3bb5165da4192e22194e664f8a">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a0f2eb4d31e819dac848583f57da7b6ed">FE_FaceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__TraceQ.html#ae46ce98d7b530df1366d3f6d5a0bb970">FE_TraceQ&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00788">788</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a46d590413e360eb10dbe4f9e247cb2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d590413e360eb10dbe4f9e247cb2bb">&#9670;&nbsp;</a></span>get_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from the given finite element to the present one. The size of the matrix is then <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a> times <code>source.<a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a></code>.</p>
<p>Derived elements will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type ExcInterpolationNotImplemented. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ab29f6c366103b20b0c78bcb90bca0a7b">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a1f16a22b10ef2ddf04b948d96956ed4c">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#aae25de4e848fc1bc6a717fb9a0a8e275">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a4b5b4ff1c7241f69fdb3b045553d9ed9">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a008b8eeff164d2fbd9a5dedf7eb9e37f">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#aa4ee7375dbbd213e34d4c7e2309756fe">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aec15fa1c7fa666b3618f52a97ae9baa3">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aec15fa1c7fa666b3618f52a97ae9baa3">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aec15fa1c7fa666b3618f52a97ae9baa3">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aec15fa1c7fa666b3618f52a97ae9baa3">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aec15fa1c7fa666b3618f52a97ae9baa3">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#aec15fa1c7fa666b3618f52a97ae9baa3">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00850">850</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a893c7dd826fce7d3e6838fdb44e3132d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893c7dd826fce7d3e6838fdb44e3132d">&#9670;&nbsp;</a></span>get_face_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of of one element to the face of the neighboring element. The size of the matrix is then <code>source.<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code> times <code>this-&gt;<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>.</p>
<p>Derived elements will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type ExcInterpolationNotImplemented. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ab628f596fd9d1e24b38fff691b3dfa57">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a41fbf46db893527ec27fe1d59c0bf089">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a9f0dc0b3f09930098aa598c45020073c">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#abe651429576277bced14fa8a707d3c2c">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#aab68c43b24b1e4623fd698b13db25339">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a918c42022634788c0a5fb03f5cdcc4f2">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a1f75dc5d6eaf4708d1f6d3475df97b47">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a81c04fa486fbfb3e107f686caa62c858">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#a7c26567cb4ac124cf22e7cb7876199f0">FE_TraceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a4d765b37bcef52bcb67150db3d22aec5">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0e47ae2ff5ba477ceb9286692335e591">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0e47ae2ff5ba477ceb9286692335e591">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0e47ae2ff5ba477ceb9286692335e591">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0e47ae2ff5ba477ceb9286692335e591">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a0e47ae2ff5ba477ceb9286692335e591">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a0e47ae2ff5ba477ceb9286692335e591">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00867">867</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a50fd529ffa0faaac061a56c957c63ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fd529ffa0faaac061a56c957c63ded">&#9670;&nbsp;</a></span>get_subface_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_subface_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>subface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of of one element to the subface of the neighboring element. The size of the matrix is then <code>source.<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code> times <code>this-&gt;<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>.</p>
<p>Derived elements will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type ExcInterpolationNotImplemented. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#aab50c6c3c2ddac8a4d0652c35fa15a3f">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a79a664ef7dc4711ceeeededcb7fc4271">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ad688715fc25831e3450b99a69bf6e0cd">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a68c011ecb596abf5767c88d8aa114409">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#ac6645c4c5f3534ed26aca95c4145beed">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#af020fb4e7424d19d614320fd61aad574">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a13ca7b18757496901ba395c9b8cefdac">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a9fd09c087d8cf2c7d5146d2bdc69a1cd">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#ae112a8530563f915dd137a1c157d01fb">FE_TraceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a96107c4d3228a2758095d1445d10ce76">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a479134837143224c6f0adf6f668fabce">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a479134837143224c6f0adf6f668fabce">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a479134837143224c6f0adf6f668fabce">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a479134837143224c6f0adf6f668fabce">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a479134837143224c6f0adf6f668fabce">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a479134837143224c6f0adf6f668fabce">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00884">884</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a18c920830fe94b08cdf8754b6533e805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c920830fe94b08cdf8754b6533e805">&#9670;&nbsp;</a></span>hp_vertex_dof_identities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_vertex_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If, on a vertex, several finite elements are active, the hp code first assigns the degrees of freedom of each of these FEs different global indices. It then calls this function to find out which of them should get identical values, and consequently can receive the same global DoF index. This function therefore returns a list of identities between DoFs of the present finite element object with the DoFs of <code>fe_other</code>, which is a reference to a finite element object representing one of the other finite elements active on this particular vertex. The function computes which of the degrees of freedom of the two finite element objects are equivalent, both numbered between zero and the corresponding value of dofs_per_vertex of the two finite elements. The first index of each pair denotes one of the vertex dofs of the present element, whereas the second is the corresponding index of the other finite element. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a4e9366eadf8615ad3c4c2d02cbb0454d">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ae8e7ee25b07f1ad72757c7c7774dee51">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a6f823e7d0612479f9b72543b9997b887">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a3f09cc4f87c546bc4c0a5e404182b33c">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a2460a2c32036155656a44beb1ad598a7">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a719421aeafc9999296085064a0b4f419">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a719421aeafc9999296085064a0b4f419">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a719421aeafc9999296085064a0b4f419">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a719421aeafc9999296085064a0b4f419">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a719421aeafc9999296085064a0b4f419">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a719421aeafc9999296085064a0b4f419">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#aea2ec8d90144187a0890ea12286573b5">FE_Nothing&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Bernstein.html#a01dbd522fb1fe828e2814e5bb5b1c8b9">FE_Bernstein&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00901">901</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a0580b57287997a3aaa682d993bc952c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0580b57287997a3aaa682d993bc952c1">&#9670;&nbsp;</a></span>hp_line_dof_identities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_line_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on lines. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#af75aa405ceac0e5d546698c7ec41f333">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ac6e9d39d736f5aa59f622e97390f3596">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#af3f02d36c1da2d2c2a3fab0c2628c06d">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a25bc4f83dda8aa6bb7e5a69730e1c420">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a52885f8fb8c9bb8cc45ee41abec60a35">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a33d4b116767d15242f62ed159ff4918f">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a33d4b116767d15242f62ed159ff4918f">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a33d4b116767d15242f62ed159ff4918f">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a33d4b116767d15242f62ed159ff4918f">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a33d4b116767d15242f62ed159ff4918f">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a33d4b116767d15242f62ed159ff4918f">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a0c09c7e06f79426697886818a5cf7d9e">FE_Nothing&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Bernstein.html#aa800f14cf4fac65c78cb60738af14e4c">FE_Bernstein&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00912">912</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ac0a3ec8120fbefb4d1a3ba5c2f4a0038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a3ec8120fbefb4d1a3ba5c2f4a0038">&#9670;&nbsp;</a></span>hp_quad_dof_identities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_quad_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on quads. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#aad003fc27bc865b36a66a13ac285c033">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a015ebaca45ab3779255246990f234d25">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#aaf2c9a67cccc1ff104561df3a2bc7322">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a10fe1abaf7110eca0d02d4e9e3890c10">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a1e36259afb76db2162698fac5a1882de">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa26af8c3cf17c918513a2578dc14a347">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa26af8c3cf17c918513a2578dc14a347">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa26af8c3cf17c918513a2578dc14a347">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa26af8c3cf17c918513a2578dc14a347">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa26af8c3cf17c918513a2578dc14a347">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa26af8c3cf17c918513a2578dc14a347">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a3f93d24b03e72f30099bef9be9284b9d">FE_Nothing&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Bernstein.html#a1c6b82a8b7ebd7bbd2bc4cbdd36151b6">FE_Bernstein&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00923">923</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a1abb893b2f67182684932757c8eb985d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abb893b2f67182684932757c8eb985d">&#9670;&nbsp;</a></span>compare_for_face_domination()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::compare_for_face_domination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element dominates the one given as argument when they meet at a common face, whether it is the other way around, whether neither dominates, or if either could dominate.</p>
<p>For a definition of domination, see <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> and in particular the <a class="el" href="DEALGlossary.html#hp_paper">hp paper</a>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ae2d075f92e2db1fd7969431795933cf1">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a52feaf53400efbce19c607af7ea2f541">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a5c11bbecf019e7ac2387057bb10938dd">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a1ed409b4a6f3b61608166cc671aca355">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#aedbf68f4f3a02c58ab8d5542159e473a">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a6e2541a626de9677ed8fccc3064db471">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a90ae4a1c836194ab111fd4763368258f">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a90ae4a1c836194ab111fd4763368258f">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a90ae4a1c836194ab111fd4763368258f">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a90ae4a1c836194ab111fd4763368258f">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a90ae4a1c836194ab111fd4763368258f">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a90ae4a1c836194ab111fd4763368258f">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a8838586804602acc04c96bf4c26b2f9b">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a0e346ee7e86583492329a280516db243">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#a6d9e691c9c8bc3841e9ab9450733e0de">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#a819bae0ba2faa29858cad34acf569504">FE_TraceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__FaceQ.html#a720cf805f78682a23a8592245a17e9fe">FE_FaceQ&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00934">934</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ae90af45f3ad54d9df3ce230084a2c205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90af45f3ad54d9df3ce230084a2c205">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator. We also check for equality of the constraint matrix, which is quite an expensive operation. Do therefore use this function with care, if possible only for debugging purposes.</p>
<p>Since this function is not that important, we avoid an implementational question about comparing arrays and do not compare the matrix arrays <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a> and <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00944">944</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a86644fe67824373cd51e9ff7fca94f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86644fe67824373cd51e9ff7fca94f8c">&#9670;&nbsp;</a></span>system_to_component_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, unsigned int &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_component_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute vector component and index of this shape function within the shape functions corresponding to this component from the index of a shape function within this finite element.</p>
<p>If the element is scalar, then the component is always zero, and the index within this component is equal to the overall index.</p>
<p>If the shape function referenced has more than one non-zero component, then it cannot be associated with one vector component, and an exception of type ExcShapeFunctionNotPrimitive will be raised.</p>
<p>Note that if the element is composed of other (base) elements, and a base element has more than one component but all its shape functions are primitive (i.e. are non-zero in only one component), then this mapping contains valid information. However, the index of a shape function of this element within one component (i.e. the second number of the respective entry of this array) does not indicate the index of the respective shape function within the base element (since that has more than one vector-component). For this information, refer to the <a class="el" href="classFiniteElement.html#a4b487f5fe482180d2c856363ae39ab13">system_to_base_table</a> field and the <a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index()</a> function.</p>
<p>The use of this function is explained extensively in the <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_20.html">step-20</a> tutorial programs as well as in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02794">2794</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae2ea16b60a6fc644a9bc7097703a53e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ea16b60a6fc644a9bc7097703a53e8">&#9670;&nbsp;</a></span>component_to_system_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_system_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the shape function for the given vector component and index.</p>
<p>If the element is scalar, then the component must be zero, and the index within this component is equal to the overall index.</p>
<p>This is the opposite operation from the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02828">2828</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a29f9d46ef9521dc25cfa2be551391e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f9d46ef9521dc25cfa2be551391e1d">&#9670;&nbsp;</a></span>face_system_to_component_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, unsigned int &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_component_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a>, but do it for shape functions and their indices on a face. The range of allowed indices is therefore 0..<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>.</p>
<p>You will rarely need this function in application programs, since almost all application codes only need to deal with cell indices, not face indices. The function is mainly there for use inside the library. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02850">2850</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ac3e808ca035ce6c0e479025547d41910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e808ca035ce6c0e479025547d41910">&#9670;&nbsp;</a></span>adjust_quad_dof_index_for_face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_quad_dof_index_for_face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>face_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>face_flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>face_rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For faces with non-standard face_orientation in 3D, the dofs on faces (quads) have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a quad, return the local index, if the face has non-standard face_orientation, face_flip or face_rotation. In 2D and 1D there is no need for permutation and consequently an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00617">617</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a8d22a08e0e3136f181d6098db19f8b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d22a08e0e3136f181d6098db19f8b93">&#9670;&nbsp;</a></span>face_to_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_to_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an index in the natural ordering of indices on a face, return the index of the same degree of freedom on the cell.</p>
<p>To explain the concept, consider the case where we would like to know whether a degree of freedom on a face, for example as part of an <a class="el" href="classFESystem.html">FESystem</a> element, is primitive. Unfortunately, the <a class="el" href="classFiniteElement.html#a626abd282a25193db7f61b4ec53e7385">is_primitive()</a> function in the <a class="el" href="classFiniteElement.html">FiniteElement</a> class takes a cell index, so we would need to find the cell index of the shape function that corresponds to the present face index. This function does that.</p>
<p>Code implementing this would then look like this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>; ++i)</div><div class="line"> <span class="keywordflow">if</span> (fe.is_primitive(fe.face_to_cell_index(i, some_face_no)))</div><div class="line">  ... <span class="keywordflow">do</span> whatever</div></div><!-- fragment --><p> The function takes additional arguments that account for the fact that actual faces can be in their standard ordering with respect to the cell under consideration, or can be flipped, oriented, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_dof_index</td><td>The index of the degree of freedom on a face. This index must be between zero and dofs_per_face. </td></tr>
    <tr><td class="paramname">face</td><td>The number of the face this degree of freedom lives on. This number must be between zero and <a class="el" href="structGeometryInfo.html#a16f862f2b86e608697f7a36acffcaec4">GeometryInfo::faces_per_cell</a>. </td></tr>
    <tr><td class="paramname">face_orientation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a>. </td></tr>
    <tr><td class="paramname">face_flip</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a>. </td></tr>
    <tr><td class="paramname">face_rotation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of this degree of freedom within the set of degrees of freedom on the entire cell. The returned value will be between zero and dofs_per_cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function exists in this class because that is where it was first implemented. However, it can't really work in the most general case without knowing what element we have. The reason is that when a face is flipped or rotated, we also need to know whether we need to swap the degrees of freedom on this face, or whether they are immune from this. For this, consider the situation of a <img class="formulaInl" alt="$Q_3$" src="form_585.png"/> element in 2d. If face_flip is true, then we need to consider the two degrees of freedom on the edge in reverse order. On the other hand, if the element were a <img class="formulaInl" alt="$Q_1^2$" src="form_586.png"/>, then because the two degrees of freedom on this edge belong to different vector components, they should not be considered in reverse order. What all of this shows is that the function can't work if there are more than one degree of freedom per line or quad, and that in these cases the function will throw an exception pointing out that this functionality will need to be provided by a derived class that knows what degrees of freedom actually represent. </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#aeb59a8d2bba30f600729be7afb49beb5">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a7eb40544d7af22c4bc71791fdf483f72">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a7eb40544d7af22c4bc71791fdf483f72">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a7eb40544d7af22c4bc71791fdf483f72">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a7eb40544d7af22c4bc71791fdf483f72">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a7eb40544d7af22c4bc71791fdf483f72">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a7eb40544d7af22c4bc71791fdf483f72">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00528">528</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a5859e4b85feaa0406c4aa571fc4dfa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5859e4b85feaa0406c4aa571fc4dfa4f">&#9670;&nbsp;</a></span>adjust_line_dof_index_for_line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_line_dof_index_for_line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>line_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For lines with non-standard line_orientation in 3D, the dofs on lines have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a line, return the local index, if the line has non-standard line_orientation. In 2D and 1D there is no need for permutation, so the given index is simply returned. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00649">649</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a12aa649db6e1460a8d30b067af952fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12aa649db6e1460a8d30b067af952fc4">&#9670;&nbsp;</a></span>get_nonzero_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return in which of the vector components of this finite element the <code>ith</code> shape function is non-zero. The length of the returned array is equal to the number of vector components of this element.</p>
<p>For most finite element spaces, the result of this function will be a vector with exactly one element being <code>true</code>, since for most spaces the individual vector components are independent. In that case, the component with the single zero is also the first element of what <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a> returns.</p>
<p>Only for those spaces that couple the components, for example to make a shape function divergence free, will there be more than one <code>true</code> entry. Elements for which this is true are called non-primitive (see <a class="el" href="DEALGlossary.html#GlossPrimitive">GlossPrimitive</a>). </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02967">2967</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ac228df752c9c2462aabf284e862402d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac228df752c9c2462aabf284e862402d0">&#9670;&nbsp;</a></span>n_nonzero_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return in how many vector components the <code>ith</code> shape function is non- zero. This value equals the number of entries equal to <code>true</code> in the result of the <a class="el" href="classFiniteElement.html#a12aa649db6e1460a8d30b067af952fc4">get_nonzero_components()</a> function.</p>
<p>For most finite element spaces, the result will be equal to one. It is not equal to one only for those ansatz spaces for which vector-valued shape functions couple the individual components, for example in order to make them divergence-free. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02978">2978</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a626abd282a25193db7f61b4ec53e7385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626abd282a25193db7f61b4ec53e7385">&#9670;&nbsp;</a></span>is_primitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the entire finite element is primitive, in the sense that all its shape functions are primitive. If the finite element is scalar, then this is always the case.</p>
<p>Since this is an extremely common operation, the result is cached and returned by this function. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02989">2989</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a38241991825f67d635d53d25cb5a2fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38241991825f67d635d53d25cb5a2fda">&#9670;&nbsp;</a></span>is_primitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the <code>ith</code> shape function is primitive in the sense that the shape function is non-zero in only one vector component. Non- primitive shape functions would then, for example, be those of divergence free ansatz spaces, in which the individual vector components are coupled.</p>
<p>The result of the function is <code>true</code> if and only if the result of <code>n_nonzero_components(i)</code> is equal to one. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02999">2999</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ad12fbcc708737aa60fa272d4d3e22aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fbcc708737aa60fa272d4d3e22aea">&#9670;&nbsp;</a></span>n_base_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_base_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of base elements in a mixed discretization.</p>
<p>Note that even for vector valued finite elements, the number of components needs not coincide with the number of base elements, since they may be reused. For example, if you create a <a class="el" href="classFESystem.html">FESystem</a> with three identical finite element classes by using the constructor that takes one finite element and a multiplicity, then the number of base elements is still one, although the number of components of the finite element is equal to the multiplicity. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02808">2808</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a40c2ecc833033772889878116bd8a740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c2ecc833033772889878116bd8a740">&#9670;&nbsp;</a></span>base_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::base_element </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to base element objects. If the element is atomic, then <code>base_element(0)</code> is <code>this</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a519852593ff247de72353a1959bc8e79">FESystem&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Enriched.html#a52084800c6bb35be5b534167fa6cd006">FE_Enriched&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01182">1182</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="aa009769e662e34081f60ff16327db1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa009769e662e34081f60ff16327db1b1">&#9670;&nbsp;</a></span>element_multiplicity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::element_multiplicity </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This index denotes how often the base element <code>index</code> is used in a composed element. If the element is atomic, then the result is always equal to one. See the documentation for the <a class="el" href="classFiniteElement.html#ad12fbcc708737aa60fa272d4d3e22aea">n_base_elements()</a> function for more details. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02818">2818</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a95ac75dfc5b9f4e01c34d5865b4ca5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac75dfc5b9f4e01c34d5865b4ca5a2">&#9670;&nbsp;</a></span>system_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return for shape function <code>index</code> the base element it belongs to, the number of the copy of this base element (which is between zero and the multiplicity of this element), and the index of this shape function within this base element.</p>
<p>If the element is not composed of others, then base and instance are always zero, and the index is equal to the number of the shape function. If the element is composed of single instances of other elements (i.e. all with multiplicity one) all of which are scalar, then base values and dof indices within this element are equal to the <a class="el" href="classFiniteElement.html#a9af218ae93821b61054de7e88e1734aa">system_to_component_table</a>. It differs only in case the element is composed of other elements and at least one of them is vector-valued itself.</p>
<p>This function returns valid values also in the case of vector-valued (i.e. non-primitive) shape functions, in contrast to the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02879">2879</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae338ebce423fe2b85f4af2b425fbd70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae338ebce423fe2b85f4af2b425fbd70e">&#9670;&nbsp;</a></span>face_system_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::pair&lt; unsigned int, unsigned int &gt;, unsigned int &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index()</a>, but for degrees of freedom located on a face. The range of allowed indices is therefore 0..<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>.</p>
<p>You will rarely need this function in application programs, since almost all application codes only need to deal with cell indices, not face indices. The function is mainly there for use inside the library. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02892">2892</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="afc49f8114f396b20b9a7fe9a3c058568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc49f8114f396b20b9a7fe9a3c058568">&#9670;&nbsp;</a></span>first_block_of_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::first_block_of_base </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a base element number, return the first block of a <a class="el" href="classBlockVector.html">BlockVector</a> it would generate. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02904">2904</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a2e1ca2e63382a8fd20910ae0303f4f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1ca2e63382a8fd20910ae0303f4f6c">&#9670;&nbsp;</a></span>component_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, unsigned int &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each vector component, return which base element implements this component and which vector component in this base element this is. This information is only of interest for vector-valued finite elements which are composed of several sub-elements. In that case, one may want to obtain information about the element implementing a certain vector component, which can be done using this function and the <a class="el" href="classFESystem.html#a519852593ff247de72353a1959bc8e79">FESystem::base_element()</a> function.</p>
<p>If this is a scalar finite element, then the return value is always equal to a pair of zeros. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02914">2914</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a656f95e7c9144846758b804a41405cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656f95e7c9144846758b804a41405cd3">&#9670;&nbsp;</a></span>block_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, unsigned int &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the base element for this block and the number of the copy of the base element. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02927">2927</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a0763dd6212313f0ff69f04c735b2a147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0763dd6212313f0ff69f04c735b2a147">&#9670;&nbsp;</a></span>system_to_block_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_block_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The vector block and the index inside the block for this shape function. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02937">2937</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a7b3dd1574cabab93b67e3fe47a103b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3dd1574cabab93b67e3fe47a103b6a">&#9670;&nbsp;</a></span>component_to_block_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_block_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The vector block for this component. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00347">347</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a4409f54175f279ac24cc982cfcfcbd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4409f54175f279ac24cc982cfcfcbd2f">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the one component is true that corresponds to the given argument. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>An object that represents a single scalar vector component of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the one that corresponds to the argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00360">360</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a46d11c23f6db2eca49ba470defb873c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d11c23f6db2eca49ba470defb873c0">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>An object that represents dim vector components of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00378">378</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a2c0dcc1e76885ec0ddcaae340dcdcd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0dcc1e76885ec0ddcaae340dcdcd62">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim*(dim+1)/2</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>An object that represents dim*(dim+1)/2 components of this finite element that are jointly to be interpreted as forming a symmetric tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00397">397</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a24d2a54a95f43f0db77e74b1bfab21d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d2a54a95f43f0db77e74b1bfab21d2">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a block mask (see <a class="el" href="DEALGlossary.html#GlossBlockMask">this glossary entry</a>), produce a component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">this glossary entry</a>) that represents the components that correspond to the blocks selected in the input argument. This is essentially a conversion operator from <a class="el" href="classBlockMask.html">BlockMask</a> to <a class="el" href="classComponentMask.html">ComponentMask</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_mask</td><td>The mask that selects individual blocks of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask that selects those components corresponding to the selected blocks of the input argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00420">420</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a7cc5ed75cad6792b8b21a3ac635a8860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc5ed75cad6792b8b21a3ac635a8860">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a block mask with as many elements as this object has blocks and of which exactly the one component is true that corresponds to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only succeed if the scalar referenced by the argument encompasses a complete block. In other words, if, for example, you pass an extractor for the single <img class="formulaInl" alt="$x$" src="form_9.png"/> velocity and this object represents an <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object, then the single scalar object you selected is part of a larger block and consequently there is no block mask that would represent it. The function will then produce an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>An object that represents a single scalar vector component of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the one that corresponds to the argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00442">442</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a9294bf84eec96ac31f29808a5aa87551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9294bf84eec96ac31f29808a5aa87551">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The same caveat applies as to the version of the function above: The extractor object passed as argument must be so that it corresponds to full blocks and does not split blocks of this element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>An object that represents dim vector components of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00453">453</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ace95b8ef3a342bbb8f82cb17113be612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace95b8ef3a342bbb8f82cb17113be612">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim*(dim+1)/2</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The same caveat applies as to the version of the function above: The extractor object passed as argument must be so that it corresponds to full blocks and does not split blocks of this element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>An object that represents dim*(dim+1)/2 components of this finite element that are jointly to be interpreted as forming a symmetric tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00464">464</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a931d71caa9f14212b8dd89337e155fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931d71caa9f14212b8dd89337e155fc1">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">this glossary entry</a>), produce a block mask (see <a class="el" href="DEALGlossary.html#GlossBlockMask">this glossary entry</a>) that represents the blocks that correspond to the components selected in the input argument. This is essentially a conversion operator from <a class="el" href="classComponentMask.html">ComponentMask</a> to <a class="el" href="classBlockMask.html">BlockMask</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only succeed if the components referenced by the argument encompasses complete blocks. In other words, if, for example, you pass an component mask for the single <img class="formulaInl" alt="$x$" src="form_9.png"/> velocity and this object represents an <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object, then the single component you selected is part of a larger block and consequently there is no block mask that would represent it. The function will then produce an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component_mask</td><td>The mask that selects individual components of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask that selects those blocks corresponding to the selected blocks of the input argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00476">476</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a3584deb698371e24c78dcd27f962ede8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3584deb698371e24c78dcd27f962ede8">&#9670;&nbsp;</a></span>get_constant_modes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, bool &gt;, std::vector&lt; unsigned int &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_constant_modes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a list of constant modes of the element. The number of rows in the resulting table depends on the elements in use. For standard elements, the table has as many rows as there are components in the element and dofs_per_cell columns. To each component of the finite element, the row in the returned table contains a basis representation of the constant function 1 on the element. However, there are some scalar elements where there is more than one constant mode, e.g. the element <a class="el" href="classFE__Q__DG0.html">FE_Q_DG0</a>.</p>
<p>In order to match the constant modes to the actual components in the element, the returned data structure also returns a vector with as many components as there are constant modes on the element that contains the component number. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a20f56c70eaf74da9fa496b926daaf5cc">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#aa10cd5fcbbc137ed60e0e04c8fac4c0a">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__DGQHermite.html#aa6542d988133b7ee656eeded275ae013">FE_DGQHermite&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a38b7f2cc644c3cc235c38f8372b26e6d">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQLegendre.html#a64ead71340c4a1801d8696b4f93e7ddc">FE_DGQLegendre&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a0acbcb7c3740afe4530075f7c2c203f4">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a48e995a7de8d98c47d2cc2f5cf300a6f">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a4620df078f0c284b99e9d7f56c750c6a">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#ac8f4cd206a3c4b8664e0205b9eaca02e">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#a15559466da1521282cc058f643060a48">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a75ab17b9acc9bf9dc948a6c92c827701">FE_Q_Base&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a75ab17b9acc9bf9dc948a6c92c827701">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, dim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a75ab17b9acc9bf9dc948a6c92c827701">FE_Q_Base&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a75ab17b9acc9bf9dc948a6c92c827701">FE_Q_Base&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a75ab17b9acc9bf9dc948a6c92c827701">FE_Q_Base&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a75ab17b9acc9bf9dc948a6c92c827701">FE_Q_Base&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a73e26f7e6dd377c5066594d975e6a8ce">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a6d9326783ed3a90f206694e0475a42b8">FE_FaceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__TraceQ.html#a9df67f13f771febb48016fe49aaf0670">FE_TraceQ&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01090">1090</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a5b35a290aa7dd7562911a92a13b11fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b35a290aa7dd7562911a92a13b11fee">&#9670;&nbsp;</a></span>get_unit_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_unit_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the support points of the trial functions on the unit cell, if the derived finite element defines them. Finite elements that allow some kind of interpolation operation usually have support points. On the other hand, elements that define their degrees of freedom by, for example, moments on faces, or as derivatives, don't have support points. In that case, the returned field is empty.</p>
<p>If the finite element defines support points, then their number equals the number of degrees of freedom of the element. The order of points in the array matches that returned by the <code>cell-&gt;get_dof_indices</code> function.</p>
<p>See the class documentation for details on support points.</p>
<dl class="section note"><dt>Note</dt><dd>Finite elements' implementation of this function returns these points in the same order as shape functions. The order of shape functions is typically documented in the class documentation of the various finite element classes. In particular, shape functions (and consequently the mapped quadrature points discussed in the class documentation of this class) will then traverse first those shape functions located on vertices, then on lines, then on quads, etc.</dd>
<dd>
If this element implements support points, then it will return one such point per shape function. Since multiple shape functions may be defined at the same location, the support points returned here may be duplicated. An example would be an element of the kind <code><a class="el" href="classFESystem.html">FESystem(FE_Q(1),3)</a></code> for which each support point would appear three times in the returned array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00955">955</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a47f25ecdd4c356032bd44e3e6571d983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f25ecdd4c356032bd44e3e6571d983">&#9670;&nbsp;</a></span>has_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a finite element has defined support points. If the result is true, then a call to the <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points()</a> yields a non-empty array.</p>
<p>The result may be false if an element is not defined by interpolating shape functions, for example by P-elements on quadrilaterals. It will usually only be true if the element constructs its shape functions by the requirement that they be one at a certain point and zero at all the points associated with the other shape functions.</p>
<p>In composed elements (i.e. for the <a class="el" href="classFESystem.html">FESystem</a> class), the result will be true if all all the base elements have defined support points. <a class="el" href="classFE__Nothing.html">FE_Nothing</a> is a special case in FESystems, because it has 0 support points and <a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">has_support_points()</a> is false, but an <a class="el" href="classFESystem.html">FESystem</a> containing an <a class="el" href="classFE__Nothing.html">FE_Nothing</a> among other elements will return true. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00971">971</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a240719f4c467b178c7dea32040f8015e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240719f4c467b178c7dea32040f8015e">&#9670;&nbsp;</a></span>unit_support_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the position of the support point of the <code>indexth</code> shape function. If it does not exist, raise an exception.</p>
<p>The default implementation simply returns the respective element from the array you get from <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points()</a>, but derived elements may overload this function. In particular, note that the <a class="el" href="classFESystem.html">FESystem</a> class overloads it so that it can return the support points of individual base elements, if not all the base elements define support points. In this way, you can still ask for certain support points, even if <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points()</a> only returns an empty array. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#af9c3acc0422774b0681536db28e2f395">FESystem&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01004">1004</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a23a07be9f2b8fdd0715da23e6d97bb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a07be9f2b8fdd0715da23e6d97bb2c">&#9670;&nbsp;</a></span>get_unit_face_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_unit_face_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the support points of the trial functions on the unit face, if the derived finite element defines some. Finite elements that allow some kind of interpolation operation usually have support points. On the other hand, elements that define their degrees of freedom by, for example, moments on faces, or as derivatives, don't have support points. In that case, the returned field is empty</p>
<p>Note that elements that have support points need not necessarily have some on the faces, even if the interpolation points are located physically on a face. For example, the discontinuous elements have interpolation points on the vertices, and for higher degree elements also on the faces, but they are not defined to be on faces since in that case degrees of freedom from both sides of a face (or from all adjacent elements to a vertex) would be identified with each other, which is not what we would like to have). Logically, these degrees of freedom are therefore defined to belong to the cell, rather than the face or vertex. In that case, the returned element would therefore have length zero.</p>
<p>If the finite element defines support points, then their number equals the number of degrees of freedom on the face (<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>). The order of points in the array matches that returned by the <code>cell-&gt;get_dof_indices</code> function.</p>
<p>See the class documentation for details on support points. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01017">1017</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a1daff1756e17621edd8d10c535e4598d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1daff1756e17621edd8d10c535e4598d">&#9670;&nbsp;</a></span>has_face_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_face_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a finite element has defined support points on faces. If the result is true, then a call to the <a class="el" href="classFiniteElement.html#a23a07be9f2b8fdd0715da23e6d97bb2c">get_unit_face_support_points()</a> yields a non-empty array.</p>
<p>For more information, see the documentation for the <a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">has_support_points()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01033">1033</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a0367eebf4f24006facf5bfc2a60749c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0367eebf4f24006facf5bfc2a60749c8">&#9670;&nbsp;</a></span>unit_face_support_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_face_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function corresponding to the <a class="el" href="classFiniteElement.html#a240719f4c467b178c7dea32040f8015e">unit_support_point()</a> function, but for faces. See there for more information. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ae863a09e977a66b83aad0edb44452003">FESystem&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01066">1066</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="acd7d4db3494e48ce40d49da6f2c7d4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7d4db3494e48ce40d49da6f2c7d4b2">&#9670;&nbsp;</a></span>get_generalized_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_generalized_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector of generalized support points.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">glossary entry on generalized support points</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00980">980</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a4d7a3e41b44869ce600ae0b3a98b5b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7a3e41b44869ce600ae0b3a98b5b4e">&#9670;&nbsp;</a></span>has_generalized_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_generalized_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>true</code> if the class provides nonempty vectors either from <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points()</a> or <a class="el" href="classFiniteElement.html#acd7d4db3494e48ce40d49da6f2c7d4b2">get_generalized_support_points()</a>.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">glossary entry on generalized support points</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00995">995</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a393d5a5f81568ce0e9f831670e545af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393d5a5f81568ce0e9f831670e545af7">&#9670;&nbsp;</a></span>get_generalized_face_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt; &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_generalized_face_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the equivalent to <a class="el" href="classFiniteElement.html#acd7d4db3494e48ce40d49da6f2c7d4b2">get_generalized_support_points()</a>, except for faces. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01042">1042</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="aef7bf62843bddc89eee39b464f21f2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7bf62843bddc89eee39b464f21f2f8">&#9670;&nbsp;</a></span>has_generalized_face_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_generalized_face_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a finite element has defined generalized support points on faces. If the result is true, then a call to the <a class="el" href="classFiniteElement.html#a393d5a5f81568ce0e9f831670e545af7">get_generalized_face_support_points()</a> function yields a non-empty array.</p>
<p>For more information, see the documentation for the <a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">has_support_points()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01057">1057</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ae0ea3780c7d2e6140141a9afcbc421f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ea3780c7d2e6140141a9afcbc421f4">&#9670;&nbsp;</a></span>get_associated_geometry_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometryPrimitive.html">GeometryPrimitive</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_associated_geometry_primitive </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>cell_dof_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a given degree of freedom, return whether it is logically associated with a vertex, line, quad or hex.</p>
<p>For instance, for continuous finite elements this coincides with the lowest dimensional object the support point of the degree of freedom lies on. To give an example, for <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> elements in 3d, every degree of freedom is defined by a shape function that we get by interpolating using support points that lie on the vertices of the cell. The support of these points of course extends to all edges connected to this vertex, as well as the adjacent faces and the cell interior, but we say that logically the degree of freedom is associated with the vertex as this is the lowest- dimensional object it is associated with. Likewise, for <img class="formulaInl" alt="$Q_2$" src="form_575.png"/> elements in 3d, the degrees of freedom with support points at edge midpoints would yield a value of <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2a65afbb3592220b91df58e72e858050f4">GeometryPrimitive::line</a> from this function, whereas those on the centers of faces in 3d would return <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2aeeed229077b068966c4edd2ff537b995">GeometryPrimitive::quad</a>.</p>
<p>To make this more formal, the kind of object returned by this function represents the object so that the support of the shape function corresponding to the degree of freedom, (i.e., that part of the domain where the function "lives") is the union of all of the cells sharing this object. To return to the example above, for <img class="formulaInl" alt="$Q_2$" src="form_575.png"/> in 3d, the shape function with support point at an edge midpoint has support on all cells that share the edge and not only the cells that share the adjacent faces, and consequently the function will return <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2a65afbb3592220b91df58e72e858050f4">GeometryPrimitive::line</a>.</p>
<p>On the other hand, for discontinuous elements of type <img class="formulaInl" alt="$DGQ_2$" src="form_587.png"/>, a degree of freedom associated with an interpolation polynomial that has its support point physically located at a line bounding a cell, but is nonzero only on one cell. Consequently, it is logically associated with the interior of that cell (i.e., with a <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2aeeed229077b068966c4edd2ff537b995">GeometryPrimitive::quad</a> in 2d and a <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2acbbe64bcc53f9747fcf5ff863d59fe14">GeometryPrimitive::hex</a> in 3d).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_dof_index</td><td>The index of a shape function or degree of freedom. This index must be in the range <code>[0,dofs_per_cell)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The integer value of the object returned by this function equals the dimensionality of the object it describes, and can consequently be used in generic programming paradigms. For example, if a degree of freedom is associated with a vertex, then this function returns <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2af5e3dcc6059fdf418fc23763c0224d9f">GeometryPrimitive::vertex</a>, which has a numeric value of zero (the dimensionality of a vertex). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03024">3024</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a69948e87907f6b146c6c8bdf0cabdf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69948e87907f6b146c6c8bdf0cabdf22">&#9670;&nbsp;</a></span>convert_generalized_support_point_values_to_nodal_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::convert_generalized_support_point_values_to_nodal_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodal_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the values of a function <img class="formulaInl" alt="$f(\mathbf x)$" src="form_588.png"/> at the (generalized) support points, this function then computes what the nodal values of the element are, i.e., <img class="formulaInl" alt="$\Psi_i[f]$" src="form_589.png"/>, where <img class="formulaInl" alt="$\Psi_i$" src="form_590.png"/> are the node functionals of the element (see also <a class="el" href="DEALGlossary.html#GlossNodes">Node values or node functionals</a>). The values <img class="formulaInl" alt="$\Psi_i[f]$" src="form_589.png"/> are then the expansion coefficients for the shape functions of the finite element function that <em>interpolates</em> the given function <img class="formulaInl" alt="$f(x)$" src="form_418.png"/>, i.e., <img class="formulaInl" alt="$ f_h(\mathbf x) = \sum_i \Psi_i[f] \varphi_i(\mathbf x) $" src="form_591.png"/> is the finite element interpolant of <img class="formulaInl" alt="$f$" src="form_417.png"/> with the current element. The operation described here is used, for example, in the <a class="el" href="namespaceFETools.html#aec3d342cc4d853430f07ad49d8bf2eab">FETools::compute_node_matrix()</a> function.</p>
<p>In more detail, let us assume that the generalized support points (see <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">this glossary entry</a> ) of the current element are <img class="formulaInl" alt="$\hat{\mathbf x}_i$" src="form_592.png"/> and that the node functionals associated with the current element are <img class="formulaInl" alt="$\Psi_i[\cdot]$" src="form_85.png"/>. Then, the fact that the element is based on generalized support points, implies that if we apply <img class="formulaInl" alt="$\Psi_i$" src="form_590.png"/> to a (possibly vector-valued) finite element function <img class="formulaInl" alt="$\varphi$" src="form_94.png"/>, the result must have the form <img class="formulaInl" alt="$\Psi_i[\varphi] = f_i(\varphi(\hat{\mathbf x}_i))$" src="form_593.png"/> &ndash; in other words, the value of the node functional <img class="formulaInl" alt="$\Psi_i$" src="form_590.png"/> applied to <img class="formulaInl" alt="$\varphi$" src="form_94.png"/> <em>only</em> depends on the <em>values of <img class="formulaInl" alt="$\varphi$" src="form_94.png"/> at <img class="formulaInl" alt="$\hat{\mathbf x}_i$" src="form_592.png"/></em> and not on values anywhere else, or integrals of <img class="formulaInl" alt="$\varphi$" src="form_94.png"/>, or any other kind of information.</p>
<p>The exact form of <img class="formulaInl" alt="$f_i$" src="form_594.png"/> depends on the element. For example, for scalar <a class="el" href="DEALGlossary.html#GlossLagrange">Lagrange elements</a>, we have that in fact <img class="formulaInl" alt="$\Psi_i[\varphi] = \varphi(\hat{\mathbf x}_i)$" src="form_595.png"/>. If you combine multiple scalar Lagrange elements via an <a class="el" href="classFESystem.html">FESystem</a> object, then <img class="formulaInl" alt="$\Psi_i[\varphi] = \varphi(\hat{\mathbf x}_i)_{c(i)}$" src="form_596.png"/> where <img class="formulaInl" alt="$c(i)$" src="form_89.png"/> is the result of the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index()</a> function's return value's first component. In these two cases, <img class="formulaInl" alt="$f_i$" src="form_594.png"/> is therefore simply the identity (in the scalar case) or a function that selects a particular vector component of its argument. On the other hand, for Raviart-Thomas elements, one would have that <img class="formulaInl" alt="$f_i(\mathbf y) = \mathbf y \cdot \mathbf n_i$" src="form_597.png"/> where <img class="formulaInl" alt="$\mathbf n_i$" src="form_598.png"/> is the normal vector of the face at which the shape function is defined.</p>
<p>Given all of this, what this function does is the following: If you input a list of values of a function <img class="formulaInl" alt="$\varphi$" src="form_94.png"/> at all generalized support points (where each value is in fact a vector of values with as many components as the element has), then this function returns a vector of values obtained by applying the node functionals to these values. In other words, if you pass in <img class="formulaInl" alt="$\{\varphi(\hat{\mathbf x}_i)\}_{i=0}^{N-1}$" src="form_599.png"/> then you will get out a vector <img class="formulaInl" alt="$\{\Psi[\varphi]\}_{i=0}^{N-1}$" src="form_600.png"/> where <img class="formulaInl" alt="$N$" src="form_104.png"/> equals <code>dofs_per_cell</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">support_point_values</td><td>An array of size <code>dofs_per_cell</code> (which equals the number of points the <a class="el" href="classFiniteElement.html#acd7d4db3494e48ce40d49da6f2c7d4b2">get_generalized_support_points()</a> function will return) where each element is a vector with as many entries as the element has vector components. This array should contain the values of a function at the generalized support points of the current element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodal_values</td><td>An array of size <code>dofs_per_cell</code> that contains the node functionals of the element applied to the given function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Given what the function is supposed to do, the function clearly can only work for elements that actually implement (generalized) support points. Elements that do not have generalized support points &ndash; e.g., elements whose nodal functionals evaluate integrals or moments of functions (such as <a class="el" href="classFE__Q__Hierarchical.html">FE_Q_Hierarchical</a>) &ndash; can in general not make sense of the operation that is required for this function. They consequently may not implement it. </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#a23f1508f57f2a52a3fc2786d501ac39b">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#a19c07d0efbb6df3dbadad1ac9ceb51ec">FE_Q&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#a19c07d0efbb6df3dbadad1ac9ceb51ec">FE_Q&lt; dim &gt;</a>, <a class="el" href="classFE__DGQArbitraryNodes.html#a75855c8fa5540a42de0ff0a8f9faf419">FE_DGQArbitraryNodes&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#add4d01c96f57eb6d6b946f7536c13f46">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a4fc3ab96409980cc2937110963a3f7b0">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#ac6939c5de055a0d07eaa13a8476b324d">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__Nedelec.html#aa9eb4d4f96d4d5eb8d1ff75c1e35b490">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#a67432fa9c197326b5247226b88af089b">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#ae85a2cca51e9217b7a3ca34a05ad90ec">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#adab770af4308135bcc9beb75885807ad">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a14511d131a8e201f91ddcae8bf7197a7">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__BDM.html#a9ee2753e1d194dd4e04deae2d3a59c36">FE_BDM&lt; dim &gt;</a>, and <a class="el" href="classFE__RannacherTurek.html#a691722ce8303ab9edac9f45667ea47d3">FE_RannacherTurek&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01103">1103</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a5d91517978ab8b107c6951cc4c63c10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d91517978ab8b107c6951cc4c63c10f">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object.</p>
<p>This function is made virtual, since finite element objects are usually accessed through pointers to their base class, rather than the class itself. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ae5e3d52c5a4e117e90c0884410b8bc9a">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#aded1156c9bd58ccfe77ed84fa814ea3a">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#abf3740d59a257206f9b8fe8bb9fed4e3">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#ad1eccef7967ea4168f222a051a0c8b1d">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#a12c7d2c45e086f6ecc0be2df94dc5ec8">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a7552386c5991ac7262309e08c1d107ca">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a6bbc1e8495f13a9e6a34593d276ddf8a">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a1e7a0bf45e6dde02d804bb69fb3e24c2">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__ABF.html#a68375cc56f2d7b380cd418e757163e7c">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__DGVector.html#a92edd3a993f655f55a0d650950595555">FE_DGVector&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a92edd3a993f655f55a0d650950595555">FE_DGVector&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__DGVector.html#a92edd3a993f655f55a0d650950595555">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGVector.html#a92edd3a993f655f55a0d650950595555">FE_DGVector&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01119">1119</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a62838f7428ee56e34c4081ca6d03bc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62838f7428ee56e34c4081ca6d03bc26">&#9670;&nbsp;</a></span>reinit_restriction_and_prolongation_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::reinit_restriction_and_prolongation_matrices </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isotropic_restriction_only</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isotropic_prolongation_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reinit the vectors of restriction and prolongation matrices to the right sizes: For every refinement case, except for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>, and for every child of that refinement case the space of one restriction and prolongation matrix is allocated, see the documentation of the restriction and prolongation vectors for more detail on the actual vector sizes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isotropic_restriction_only</td><td>only the restriction matrices required for isotropic refinement are reinited to the right size. </td></tr>
    <tr><td class="paramname">isotropic_prolongation_only</td><td>only the prolongation matrices required for isotropic refinement are reinited to the right size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00277">277</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ab1d72dc54ae8d760b3c9c4e5ce0f96c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d72dc54ae8d760b3c9c4e5ce0f96c4">&#9670;&nbsp;</a></span>interface_constraints_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interface_constraints_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the size of interface constraint matrices. Since this is needed in every derived finite element class when initializing their size, it is placed into this function, to avoid having to recompute the dimension- dependent size of these matrices each time.</p>
<p>Note that some elements do not implement the interface constraints for certain polynomial degrees. In this case, this function still returns the size these matrices should have when implemented, but the actual matrices are empty. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00823">823</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ac7b5101c0c081760e5402767aed14c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b5101c0c081760e5402767aed14c0c">&#9670;&nbsp;</a></span>compute_n_nonzero_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::compute_n_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonzero_components</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the pattern of nonzero components for each shape function, compute for each entry how many components are non-zero for each shape function. This function is used in the constructor of this class. </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01139">1139</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a7ee9f47da3fcdfc8c1ca7c7a0feb1929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee9f47da3fcdfc8c1ca7c7a0feb1929">&#9670;&nbsp;</a></span>requires_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of update flags, compute which other quantities <em>also</em> need to be computed in order to satisfy the request by the given flags. Then return the combination of the original set of flags and those just computed.</p>
<p>As an example, if <code>update_flags</code> contains update_gradients a finite element class will typically require the computation of the inverse of the Jacobian matrix in order to rotate the gradient of shape functions on the reference cell to the real cell. It would then return not just update_gradients, but also update_covariant_transformation, the flag that makes the mapping class produce the inverse of the Jacobian matrix.</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> </dd></dl>

<p>Implemented in <a class="el" href="classFESystem.html#aa31fbc452f4afa89dc537ba57d53a1f5">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ad430d3fded24048077b51f7c4de8a352">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#aae41a4cc8be771613a960eb0b3e5eff5">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__P1NC.html#abc8570e5b2350390fea8d3fe6999bec0">FE_P1NC</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#a735b3e9851859cf3e1c14912fff71c4e">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a1d7f2cbee237269070a594858a490ab3">FE_PolyTensor&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a1d7f2cbee237269070a594858a490ab3">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a1d7f2cbee237269070a594858a490ab3">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a1d7f2cbee237269070a594858a490ab3">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a1d7f2cbee237269070a594858a490ab3">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a1d7f2cbee237269070a594858a490ab3">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a1d7f2cbee237269070a594858a490ab3">FE_PolyTensor&lt; PolynomialsABF&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a1d7f2cbee237269070a594858a490ab3">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a8de93bb455429b49a3c81136dff66c1b">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a8de93bb455429b49a3c81136dff66c1b">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__Poly.html#a7f7c49e93df78bd139933fa72ed81237">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7f7c49e93df78bd139933fa72ed81237">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7f7c49e93df78bd139933fa72ed81237">FE_Poly&lt; PolynomialsP&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a7f7c49e93df78bd139933fa72ed81237">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a7f7c49e93df78bd139933fa72ed81237">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7f7c49e93df78bd139933fa72ed81237">FE_Poly&lt; PolynomialsRannacherTurek&lt; dim &gt;, dim &gt;</a>, <a class="el" href="classFE__Poly.html#a7f7c49e93df78bd139933fa72ed81237">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7f7c49e93df78bd139933fa72ed81237">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a7f7c49e93df78bd139933fa72ed81237">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a3eb1e3abe2a0e80ae878777714c74b6e">FE_PolyFace&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a3eb1e3abe2a0e80ae878777714c74b6e">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#a3eb1e3abe2a0e80ae878777714c74b6e">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af02bc483fe9b867cc9643501bd586811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02bc483fe9b867cc9643501bd586811">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>* <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an internal data object and return a pointer to it of which the caller of this function then assumes ownership. This object will then be passed to the <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a> every time the finite element shape functions and their derivatives are evaluated on a concrete cell. The object created here is therefore used by derived classes as a place for scratch objects that are used in evaluating shape functions, as well as to store information that can be pre-computed once and re-used on every cell (e.g., for evaluating the values and gradients of shape functions on the reference cell, for later re-use when transforming these values to a concrete cell).</p>
<p>This function is the first one called in the process of initializing a <a class="el" href="classFEValues.html">FEValues</a> object for a given mapping and finite element object. The returned object will later be passed to <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a> for a concrete cell, which will itself place its output into an object of type <a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>. Since there may be data that can already be computed in its <em>final</em> form on the reference cell, this function also receives a reference to the <a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a> object as its last argument. This output argument is guaranteed to always be the same one when used with the <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> object returned by this function. In other words, the subdivision of scratch data and final data in the returned object and the <code>output_data</code> object is as follows: If data can be pre- computed on the reference cell in the exact form in which it will later be needed on a concrete cell, then this function should already emplace it in the <code>output_data</code> object. An example are the values of shape functions at quadrature points for the usual Lagrange elements which on a concrete cell are identical to the ones on the reference cell. On the other hand, if some data can be pre-computed to make computations on a concrete cell <em>cheaper</em>, then it should be put into the returned object for later re-use in a derive class's implementation of <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a>. An example are the gradients of shape functions on the reference cell for Lagrange elements: to compute the gradients of the shape functions on a concrete cell, one has to multiply the gradients on the reference cell by the inverse of the Jacobian of the mapping; consequently, we cannot already compute the gradients on a concrete cell at the time the current function is called, but we can at least pre-compute the gradients on the reference cell, and store it in the object returned.</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module. See also the documentation of the <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>A set of UpdateFlags values that describe what kind of information the <a class="el" href="classFEValues.html">FEValues</a> object requests the finite element to compute. This set of flags may also include information that the finite element can not compute, e.g., flags that pertain to data produced by the mapping. An implementation of this function needs to set up all data fields in the returned object that are necessary to produce the finite- element related data specified by these flags, and may already pre- compute part of this information as discussed above. Elements may want to store these update flags (or a subset of these flags) in <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">InternalDataBase::update_each</a> so they know at the time when FinitElement::fill_fe_values() is called what they are supposed to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping used for computing values and derivatives of shape functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the object that describes where the shape functions should be evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to the object that <a class="el" href="classFEValues.html">FEValues</a> will use in conjunction with the object returned here and where an implementation of <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a> will place the requested information. This allows the current function to already pre-compute pieces of information that can be computed on the reference cell, as discussed above. <a class="el" href="classFEValues.html">FEValues</a> guarantees that this output object and the object returned by the current function will always be used together. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an object of a type derived from <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> and that derived classes can use to store scratch data that can be pre- computed, or for scratch arrays that then only need to be allocated once. The calling site assumes ownership of this object and will delete it when it is no longer necessary. </dd></dl>

<p>Implemented in <a class="el" href="classFESystem.html#a55bb7841a9a30ef95f33217451b05edc">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a9de9d09b4216ad9164b571ddb1bfb0ec">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a91cb750e1753622b07e3767d117de174">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab9bacd81eb9103ce50b99afaba2e1f3a">FE_Poly&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab9bacd81eb9103ce50b99afaba2e1f3a">FE_Poly&lt; PolynomialSpace&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab9bacd81eb9103ce50b99afaba2e1f3a">FE_Poly&lt; TensorProductPolynomials&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab9bacd81eb9103ce50b99afaba2e1f3a">FE_Poly&lt; TensorProductPolynomialsBubbles&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab9bacd81eb9103ce50b99afaba2e1f3a">FE_Poly&lt; TensorProductPolynomialsConst&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#ab9bacd81eb9103ce50b99afaba2e1f3a">FE_Poly&lt; TensorProductPolynomials&lt; dim, Polynomials::PiecewisePolynomial&lt; double &gt; &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a864d12f870afdb10ea6c8db4eecaacc6">FE_PolyTensor&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a864d12f870afdb10ea6c8db4eecaacc6">FE_PolyTensor&lt; PolynomialsRaviartThomas&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a864d12f870afdb10ea6c8db4eecaacc6">FE_PolyTensor&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyTensor.html#a864d12f870afdb10ea6c8db4eecaacc6">FE_PolyTensor&lt; PolynomialsNedelec&lt; dim &gt;, dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a1133331e3a885767882546109ecd669c">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#aa29913d6c46261fbd70bd050e37b5deb">FE_PolyFace&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#aa29913d6c46261fbd70bd050e37b5deb">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#aa29913d6c46261fbd70bd050e37b5deb">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a64b51a66318b7c2d03e9311a8c3e2aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b51a66318b7c2d03e9311a8c3e2aaa">&#9670;&nbsp;</a></span>get_face_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> * <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data()</a>, but return an object that will later be used for evaluating shape function information at quadrature points on faces of cells. The object will then be used in calls to implementations of <a class="el" href="classFiniteElement.html#aace6650d4f9be28cf54df5df0a0aed46">FiniteElement::fill_fe_face_values()</a>. See the documentation of <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data()</a> for more information.</p>
<p>The default implementation of this function converts the face quadrature into a cell quadrature with appropriate quadrature point locations, and with that calls the <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data()</a> function above that has to be implemented in derived classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>A set of UpdateFlags values that describe what kind of information the <a class="el" href="classFEValues.html">FEValues</a> object requests the finite element to compute. This set of flags may also include information that the finite element can not compute, e.g., flags that pertain to data produced by the mapping. An implementation of this function needs to set up all data fields in the returned object that are necessary to produce the finite- element related data specified by these flags, and may already pre- compute part of this information as discussed above. Elements may want to store these update flags (or a subset of these flags) in <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">InternalDataBase::update_each</a> so they know at the time when FinitElement::fill_fe_face_values() is called what they are supposed to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping used for computing values and derivatives of shape functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the object that describes where the shape functions should be evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to the object that <a class="el" href="classFEValues.html">FEValues</a> will use in conjunction with the object returned here and where an implementation of <a class="el" href="classFiniteElement.html#aace6650d4f9be28cf54df5df0a0aed46">FiniteElement::fill_fe_face_values()</a> will place the requested information. This allows the current function to already pre-compute pieces of information that can be computed on the reference cell, as discussed above. <a class="el" href="classFEValues.html">FEValues</a> guarantees that this output object and the object returned by the current function will always be used together. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an object of a type derived from <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> and that derived classes can use to store scratch data that can be pre- computed, or for scratch arrays that then only need to be allocated once. The calling site assumes ownership of this object and will delete it when it is no longer necessary. </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#a3221aa38932a78df3a88ad6a65d83ac1">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a6099f88df2513883a30aa2fceaae57c2">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a8ba371420a7e78c608302f56f668a016">FE_PolyFace&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a8ba371420a7e78c608302f56f668a016">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#a8ba371420a7e78c608302f56f668a016">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01154">1154</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a43b7aabb6513cfc15a7db7242a5eaa55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b7aabb6513cfc15a7db7242a5eaa55">&#9670;&nbsp;</a></span>get_subface_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> * <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data()</a>, but return an object that will later be used for evaluating shape function information at quadrature points on children of faces of cells. The object will then be used in calls to implementations of <a class="el" href="classFiniteElement.html#ac26a9edae74018ed950df92574b2917a">FiniteElement::fill_fe_subface_values()</a>. See the documentation of <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data()</a> for more information.</p>
<p>The default implementation of this function converts the face quadrature into a cell quadrature with appropriate quadrature point locations, and with that calls the <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data()</a> function above that has to be implemented in derived classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>A set of UpdateFlags values that describe what kind of information the <a class="el" href="classFEValues.html">FEValues</a> object requests the finite element to compute. This set of flags may also include information that the finite element can not compute, e.g., flags that pertain to data produced by the mapping. An implementation of this function needs to set up all data fields in the returned object that are necessary to produce the finite- element related data specified by these flags, and may already pre- compute part of this information as discussed above. Elements may want to store these update flags (or a subset of these flags) in <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">InternalDataBase::update_each</a> so they know at the time when FinitElement::fill_fe_subface_values() is called what they are supposed to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping used for computing values and derivatives of shape functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the object that describes where the shape functions should be evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to the object that <a class="el" href="classFEValues.html">FEValues</a> will use in conjunction with the object returned here and where an implementation of <a class="el" href="classFiniteElement.html#ac26a9edae74018ed950df92574b2917a">FiniteElement::fill_fe_subface_values()</a> will place the requested information. This allows the current function to already pre-compute pieces of information that can be computed on the reference cell, as discussed above. <a class="el" href="classFEValues.html">FEValues</a> guarantees that this output object and the object returned by the current function will always be used together. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an object of a type derived from <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> and that derived classes can use to store scratch data that can be pre- computed, or for scratch arrays that then only need to be allocated once. The calling site assumes ownership of this object and will delete it when it is no longer necessary. </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#a400b0ac35a5a67cd240ce33a50117485">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a55e3b58cc2bdd45e09d48404c53c7dc9">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a4322b8f0c831d30a4833514aac9fbd98">FE_PolyFace&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a4322b8f0c831d30a4833514aac9fbd98">FE_PolyFace&lt; PolynomialSpace&lt; dim-1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#a4322b8f0c831d30a4833514aac9fbd98">FE_PolyFace&lt; TensorProductPolynomials&lt; dim-1 &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01168">1168</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="aa1bb7b495d2e578d58d6858430369fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bb7b495d2e578d58d6858430369fd2">&#9670;&nbsp;</a></span>fill_fe_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute information about the shape functions on the cell denoted by the first argument. Derived classes will have to implement this function based on the kind of element they represent. It is called by <a class="el" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">FEValues::reinit()</a>.</p>
<p>Conceptually, this function evaluates shape functions and their derivatives at the quadrature points represented by the mapped locations of those described by the quadrature argument to this function. In many cases, computing derivatives of shape functions (and in some cases also computing values of shape functions) requires making use of the mapping from the reference to the real cell; this information can either be taken from the <code>mapping_data</code> object that has been filled for the current cell before this function is called, or by calling the member functions of a <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> object with the <code>mapping_internal</code> object that also corresponds to the current cell.</p>
<p>The information computed by this function is used to fill the various member variables of the output argument of this function. Which of the member variables of that structure should be filled is determined by the update flags stored in the <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">FiniteElement::InternalDataBase::update_each</a> field of the object passed to this function. These flags are typically set by <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">FiniteElement::get_data()</a>, FiniteElement::get_face_date() and <a class="el" href="classFiniteElement.html#a43b7aabb6513cfc15a7db7242a5eaa55">FiniteElement::get_subface_data()</a> (or, more specifically, implementations of these functions in derived classes).</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_similarity</td><td>Whether or not the cell given as first argument is simply a translation, rotation, etc of the cell for which this function was called the most recent time. This information is computed simply by matching the vertices (as stored by the <a class="el" href="classTriangulation.html">Triangulation</a>) between the previous and the current cell. The value passed here may be modified by implementations of this function and should then be returned (see the discussion of the return value of this function). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The current object is then responsible for evaluating shape functions at the mapped locations of the quadrature points represented by this object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping object used to map from the reference cell to the current cell. This object was used to compute the information in the <code>mapping_data</code> object before the current function was called. It is also the mapping object that created the <code>mapping_internal</code> object via <a class="el" href="classMapping.html#a32ec2960edbcf550baf4eade254e941f">Mapping::get_data()</a>. You will need the reference to this mapping object most often to call <a class="el" href="classMapping.html#a3ce74638006ce574195c55a69aa48d79">Mapping::transform()</a> to transform gradients and higher derivatives from the reference to the current cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_internal</td><td>An object specific to the mapping object. What the mapping chooses to store in there is of no relevance to the current function, but you may have to pass a reference to this object to certain functions of the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class (e.g., <a class="el" href="classMapping.html#a3ce74638006ce574195c55a69aa48d79">Mapping::transform()</a>) if you need to call them from the current function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_data</td><td>The output object into which the <a class="el" href="classMapping.html#a66184bd60355f99a7c549552c9365d52">Mapping::fill_fe_values()</a> function wrote the mapping information corresponding to the current cell. This includes, for example, Jacobians of the mapping that may be of relevance to the current function, as well as other information that <a class="el" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">FEValues::reinit()</a> requested from the mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_internal</td><td>A reference to an object previously created by <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>fe_internal</code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classFEValues.html">FEValues</a> ensures that this function is always called with the same pair of <code>fe_internal</code> and <code>output_data</code> objects. In other words, if an implementation of this function knows that it has written a piece of data into the output argument in a previous call, then there is no need to copy it there again in a later call if the implementation knows that this is the same value. </dd></dl>

</div>
</div>
<a id="aace6650d4f9be28cf54df5df0a0aed46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace6650d4f9be28cf54df5df0a0aed46">&#9670;&nbsp;</a></span>fill_fe_face_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the equivalent to <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a>, but for faces of cells. See there for an extensive discussion of its purpose. It is called by <a class="el" href="classFEFaceValues.html#af6e079ca7429d54433343d50bd334c3c">FEFaceValues::reinit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>The number of the face we are currently considering, indexed among the faces of the cell specified by the previous argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The current object is then responsible for evaluating shape functions at the mapped locations of the quadrature points represented by this object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping object used to map from the reference cell to the current cell. This object was used to compute the information in the <code>mapping_data</code> object before the current function was called. It is also the mapping object that created the <code>mapping_internal</code> object via <a class="el" href="classMapping.html#a32ec2960edbcf550baf4eade254e941f">Mapping::get_data()</a>. You will need the reference to this mapping object most often to call <a class="el" href="classMapping.html#a3ce74638006ce574195c55a69aa48d79">Mapping::transform()</a> to transform gradients and higher derivatives from the reference to the current cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_internal</td><td>An object specific to the mapping object. What the mapping chooses to store in there is of no relevance to the current function, but you may have to pass a reference to this object to certain functions of the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class (e.g., <a class="el" href="classMapping.html#a3ce74638006ce574195c55a69aa48d79">Mapping::transform()</a>) if you need to call them from the current function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_data</td><td>The output object into which the <a class="el" href="classMapping.html#a66184bd60355f99a7c549552c9365d52">Mapping::fill_fe_values()</a> function wrote the mapping information corresponding to the current cell. This includes, for example, Jacobians of the mapping that may be of relevance to the current function, as well as other information that <a class="el" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">FEValues::reinit()</a> requested from the mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_internal</td><td>A reference to an object previously created by <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>fe_internal</code> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac26a9edae74018ed950df92574b2917a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26a9edae74018ed950df92574b2917a">&#9670;&nbsp;</a></span>fill_fe_subface_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the equivalent to <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a>, but for the children of faces of cells. See there for an extensive discussion of its purpose. It is called by <a class="el" href="classFESubfaceValues.html#a31715f7c441dd083cc02ea72859fb9a3">FESubfaceValues::reinit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>The number of the face we are currently considering, indexed among the faces of the cell specified by the previous argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_no</td><td>The number of the subface, i.e., the number of the child of a face, that we are currently considering, indexed among the children of the face specified by the previous argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The current object is then responsible for evaluating shape functions at the mapped locations of the quadrature points represented by this object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping object used to map from the reference cell to the current cell. This object was used to compute the information in the <code>mapping_data</code> object before the current function was called. It is also the mapping object that created the <code>mapping_internal</code> object via <a class="el" href="classMapping.html#a32ec2960edbcf550baf4eade254e941f">Mapping::get_data()</a>. You will need the reference to this mapping object most often to call <a class="el" href="classMapping.html#a3ce74638006ce574195c55a69aa48d79">Mapping::transform()</a> to transform gradients and higher derivatives from the reference to the current cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_internal</td><td>An object specific to the mapping object. What the mapping chooses to store in there is of no relevance to the current function, but you may have to pass a reference to this object to certain functions of the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class (e.g., <a class="el" href="classMapping.html#a3ce74638006ce574195c55a69aa48d79">Mapping::transform()</a>) if you need to call them from the current function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_data</td><td>The output object into which the <a class="el" href="classMapping.html#a66184bd60355f99a7c549552c9365d52">Mapping::fill_fe_values()</a> function wrote the mapping information corresponding to the current cell. This includes, for example, Jacobians of the mapping that may be of relevance to the current function, as well as other information that <a class="el" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">FEValues::reinit()</a> requested from the mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_internal</td><td>A reference to an object previously created by <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>fe_internal</code> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a577195e2fad97018b5dccb837952dad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577195e2fad97018b5dccb837952dad7">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dimension of the image space, corresponding to <a class="el" href="classTriangulation.html">Triangulation</a>. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l00576">576</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a4993707a4ec342560ff74e5d22401794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4993707a4ec342560ff74e5d22401794">&#9670;&nbsp;</a></span>restriction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;double&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> of projection matrices. See <a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix()</a> above. The constructor initializes these matrices to zero dimensions, which can be changed by derived classes implementing them.</p>
<p>Note, that <code>restriction[refinement_case-1][child]</code> includes the restriction matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) there are no restriction matrices available. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02142">2142</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="afbc42f850096c429fd39cfcbde1b6b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc42f850096c429fd39cfcbde1b6b56">&#9670;&nbsp;</a></span>prolongation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;double&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::prolongation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> of embedding matrices. See <code><a class="el" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix()</a></code> above. The constructor initializes these matrices to zero dimensions, which can be changed by derived classes implementing them.</p>
<p>Note, that <code>prolongation[refinement_case-1][child]</code> includes the prolongation matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) there are no prolongation matrices available. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02156">2156</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ac8d4cd5afce6a401892aeb5a40ccfa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d4cd5afce6a401892aeb5a40ccfa2f">&#9670;&nbsp;</a></span>interface_constraints</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;double&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interface_constraints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specify the constraints which the dofs on the two sides of a cell interface underlie if the line connects two cells of which one is refined once.</p>
<p>For further details see the general description of the derived class.</p>
<p>This field is obviously useless in one dimension and has there a zero size. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02168">2168</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ab4f6e0c83686b918fbb92716ead92313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f6e0c83686b918fbb92716ead92313">&#9670;&nbsp;</a></span>unit_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of support points on the unit cell, in case the finite element has any. The constructor leaves this field empty, derived classes may write in some contents.</p>
<p>Finite elements that allow some kind of interpolation operation usually have support points. On the other hand, elements that define their degrees of freedom by, for example, moments on faces, or as derivatives, don't have support points. In that case, this field remains empty. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02180">2180</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae029888ebd5d91b261bf45aa2bf40b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae029888ebd5d91b261bf45aa2bf40b5c">&#9670;&nbsp;</a></span>unit_face_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim-1&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_face_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same for the faces. See the description of the <a class="el" href="classFiniteElement.html#a23a07be9f2b8fdd0715da23e6d97bb2c">get_unit_face_support_points()</a> function for a discussion of what contributes a face support point. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02187">2187</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae2531d00b5c9e77e1e64981864c3b8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2531d00b5c9e77e1e64981864c3b8cc">&#9670;&nbsp;</a></span>generalized_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::generalized_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Support points used for interpolation functions of non-Lagrangian elements. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02193">2193</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a3b614baaf527c796af876c8807f5d7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b614baaf527c796af876c8807f5d7d7">&#9670;&nbsp;</a></span>generalized_face_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim-1&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::generalized_face_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Face support points used for interpolation functions of non-Lagrangian elements. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02199">2199</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a46646bf5621c347e3cb3a637857b14b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46646bf5621c347e3cb3a637857b14b5">&#9670;&nbsp;</a></span>adjust_quad_dof_index_for_face_orientation_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;2,int&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_quad_dof_index_for_face_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For faces with non-standard face_orientation in 3D, the dofs on faces (quads) have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a quad, return the shift in the local index, if the face has non-standard face_orientation, i.e. <code>old_index + shift = new_index</code>. In 2D and 1D there is no need for permutation so the vector is empty. In 3D it has the size of <code> <a class="el" href="classFiniteElementData.html#a00ab27b2dfa5520f2aa56f9bb8223878">dofs_per_quad</a> * 8 </code>, where 8 is the number of orientations, a face can be in (all combinations of the three bool flags face_orientation, face_flip and face_rotation).</p>
<p>The standard implementation fills this with zeros, i.e. no permutation at all. Derived finite element classes have to fill this <a class="el" href="classTable.html">Table</a> with the correct values. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02216">2216</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a6659bb0dccc62e2d680c964e5035daf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6659bb0dccc62e2d680c964e5035daf6">&#9670;&nbsp;</a></span>adjust_line_dof_index_for_line_orientation_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_line_dof_index_for_line_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For lines with non-standard line_orientation in 3D, the dofs on lines have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a line, return the shift in the local index, if the line has non-standard line_orientation, i.e. <code>old_index + shift = new_index</code>. In 2D and 1D there is no need for permutation so the vector is empty. In 3D it has the size of <a class="el" href="classFiniteElementData.html#a490e2ded19c0a8cad0846e07e57e3e76">dofs_per_line</a>.</p>
<p>The standard implementation fills this with zeros, i.e. no permutation at all. Derived finite element classes have to fill this vector with the correct values. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02231">2231</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a9af218ae93821b61054de7e88e1734aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af218ae93821b61054de7e88e1734aa">&#9670;&nbsp;</a></span>system_to_component_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned int, unsigned int&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_component_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store what <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a> will return. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02236">2236</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="abd2b27e44cffcc480d6d8f0e1d053e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2b27e44cffcc480d6d8f0e1d053e73">&#9670;&nbsp;</a></span>face_system_to_component_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned int, unsigned int&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_component_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between linear dofs and component dofs on face. This is filled with default values in the constructor, but derived classes will have to overwrite the information if necessary.</p>
<p>By component, we mean the vector component, not the base element. The information thus makes only sense if a shape function is non-zero in only one component. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02247">2247</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a4b487f5fe482180d2c856363ae39ab13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b487f5fe482180d2c856363ae39ab13">&#9670;&nbsp;</a></span>system_to_base_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned int,unsigned int&gt;,unsigned int&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each shape function, store to which base element and which instance of this base element (in case its multiplicity is greater than one) it belongs, and its index within this base element. If the element is not composed of others, then base and instance are always zero, and the index is equal to the number of the shape function. If the element is composed of single instances of other elements (i.e. all with multiplicity one) all of which are scalar, then base values and dof indices within this element are equal to the <a class="el" href="classFiniteElement.html#a9af218ae93821b61054de7e88e1734aa">system_to_component_table</a>. It differs only in case the element is composed of other elements and at least one of them is vector-valued itself.</p>
<p>This array has valid values also in the case of vector-valued (i.e. non- primitive) shape functions, in contrast to the <a class="el" href="classFiniteElement.html#a9af218ae93821b61054de7e88e1734aa">system_to_component_table</a>. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02266">2266</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a0a2b6095ae0093bb6c024853d65969e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2b6095ae0093bb6c024853d65969e4">&#9670;&nbsp;</a></span>face_system_to_base_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned int,unsigned int&gt;,unsigned int&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Likewise for the indices on faces. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02272">2272</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a61f62f39ded99d6525f1c33f4227ee8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f62f39ded99d6525f1c33f4227ee8d">&#9670;&nbsp;</a></span>base_to_block_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::base_to_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each base element, store the number of blocks generated by the base and the first block in a block vector it will generate. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02278">2278</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="aaf2c44f3a207e0e11880820a29ac37a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2c44f3a207e0e11880820a29ac37a8">&#9670;&nbsp;</a></span>component_to_base_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned int, unsigned int&gt;, unsigned int&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The base element establishing a component.</p>
<p>For each component number <code>c</code>, the entries have the following meaning: </p><dl>
<dt><code>table[c].first.first</code> </dt>
<dd>Number of the base element for <code>c</code>. </dd>
<dt><code>table[c].first.second</code> </dt>
<dd>Component in the base element for <code>c</code>. </dd>
<dt><code>table[c].second</code> </dt>
<dd>Multiple of the base element for <code>c</code>. </dd>
</dl>
<p>This variable is set to the correct size by the constructor of this class, but needs to be initialized by derived classes, unless its size is one and the only entry is a zero, which is the case for scalar elements. In that case, the initialization by the base class is sufficient. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02296">2296</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="aa8f4833a318127b42d2dc806bffe1c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f4833a318127b42d2dc806bffe1c2c">&#9670;&nbsp;</a></span>restriction_is_additive_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;bool&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_additive_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A flag determining whether restriction matrices are to be concatenated or summed up. See the discussion about restriction matrices in the general class documentation for more information. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02303">2303</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae6fe073d1e3ce59791b142067482bd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fe073d1e3ce59791b142067482bd5b">&#9670;&nbsp;</a></span>nonzero_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classComponentMask.html">ComponentMask</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::nonzero_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each shape function, give a vector of bools (with size equal to the number of vector components which this finite element has) indicating in which component each of these shape functions is non-zero.</p>
<p>For primitive elements, there is only one non-zero component. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02312">2312</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a0b7cb6ef5342900727931ef983636502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7cb6ef5342900727931ef983636502">&#9670;&nbsp;</a></span>n_nonzero_components_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned int&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_nonzero_components_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This array holds how many values in the respective entry of the <a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a> element are non-zero. The array is thus a short-cut to allow faster access to this information than if we had to count the non-zero entries upon each request for this information. The field is initialized in the constructor of this class. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02321">2321</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a4124079b6443590608046d8f150574f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4124079b6443590608046d8f150574f6">&#9670;&nbsp;</a></span>cached_primitivity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::cached_primitivity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store whether all shape functions are primitive. Since finding this out is a very common operation, we cache the result, i.e. compute the value in the constructor for simpler access. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02328">2328</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/dofs/<a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a></li>
<li>deal.II/fe/<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/fe/<a class="el" href="fe_8cc_source.html">fe.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
