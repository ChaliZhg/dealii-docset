<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SparsityTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SparsityTools Namespace Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Sparsity.html">Sparsity patterns</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4673bdd5ed26b4492008ac8366754f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a4673bdd5ed26b4492008ac8366754f9d">partition</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, const unsigned int n_partitions, std::vector&lt; unsigned int &gt; &amp;partition_indices)</td></tr>
<tr class="separator:a4673bdd5ed26b4492008ac8366754f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7da91ef608d0e4c17d75c21070db6e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#ad7da91ef608d0e4c17d75c21070db6e4">reorder_Cuthill_McKee</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;sparsity, std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a> &gt; &amp;new_indices, const std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a> &gt;())</td></tr>
<tr class="separator:ad7da91ef608d0e4c17d75c21070db6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f36665089b0b1d374f7047f98acde7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#ac5f36665089b0b1d374f7047f98acde7">reorder_Cuthill_McKee</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity, std::vector&lt; <a class="el" href="classSparsityPattern.html#ae7c7c33ee1c51e916f5832dd9764381b">SparsityPattern::size_type</a> &gt; &amp;new_indices, const std::vector&lt; <a class="el" href="classSparsityPattern.html#ae7c7c33ee1c51e916f5832dd9764381b">SparsityPattern::size_type</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="classSparsityPattern.html#ae7c7c33ee1c51e916f5832dd9764381b">SparsityPattern::size_type</a> &gt;()) 1</td></tr>
<tr class="separator:ac5f36665089b0b1d374f7047f98acde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576797328aeace287d271ee4e48e04a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a576797328aeace287d271ee4e48e04a6">reorder_hierarchical</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;sparsity, std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a> &gt; &amp;new_indices)</td></tr>
<tr class="separator:a576797328aeace287d271ee4e48e04a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c7bdbdb62642f60d60087e4cb6195f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">distribute_sparsity_pattern</a> (<a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;dsp, const std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a> &gt; &amp;rows_per_cpu, const MPI_Comm &amp;mpi_comm, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;myrange)</td></tr>
<tr class="separator:ae2c7bdbdb62642f60d60087e4cb6195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f68c3f11df0649b0ea1fbe643102e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a24f68c3f11df0649b0ea1fbe643102e9">distribute_sparsity_pattern</a> (<a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;dsp, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;owned_set_per_cpu, const MPI_Comm &amp;mpi_comm, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;myrange)</td></tr>
<tr class="separator:a24f68c3f11df0649b0ea1fbe643102e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f4f4e7bec2c40771a9822ebaafbe6e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa6f4f4e7bec2c40771a9822ebaafbe6e">ExcMETISNotInstalled</a> ()</td></tr>
<tr class="separator:gaa6f4f4e7bec2c40771a9822ebaafbe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18d70d5923f37d246460171199b8a6f0"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga18d70d5923f37d246460171199b8a6f0">ExcInvalidNumberOfPartitions</a> (int arg1)</td></tr>
<tr class="separator:ga18d70d5923f37d246460171199b8a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f0cf909462b561ba5978ab7290290e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad6f0cf909462b561ba5978ab7290290e">ExcMETISError</a> (int arg1)</td></tr>
<tr class="separator:gad6f0cf909462b561ba5978ab7290290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f54da66d1eb023284775fcdf39179b"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa6f54da66d1eb023284775fcdf39179b">ExcInvalidArraySize</a> (int arg1, int arg2)</td></tr>
<tr class="separator:gaa6f54da66d1eb023284775fcdf39179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace for functions that deal with things that one can do on sparsity patterns, such as renumbering rows and columns (or degrees of freedom if you want) according to the connectivity, or partitioning degrees of freedom. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4673bdd5ed26b4492008ac8366754f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4673bdd5ed26b4492008ac8366754f9d">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the METIS partitioner to generate a partitioning of the degrees of freedom represented by this sparsity pattern. In effect, we view this sparsity pattern as a graph of connections between various degrees of freedom, where each nonzero entry in the sparsity pattern corresponds to an edge between two nodes in the connection graph. The goal is then to decompose this graph into groups of nodes so that a minimal number of edges are cut by the boundaries between node groups. This partitioning is done by METIS. Note that METIS can only partition symmetric sparsity patterns, and that of course the sparsity pattern has to be square. We do not check for symmetry of the sparsity pattern, since this is an expensive operation, but rather leave this as the responsibility of caller of this function.</p>
<p>After calling this function, the output array will have values between zero and <code>n_partitions-1</code> for each node (i.e. row or column of the matrix).</p>
<p>This function will generate an error if METIS is not installed unless <code>n_partitions</code> is one. I.e., you can write a program so that it runs in the single-processor single-partition case without METIS installed, and only requires METIS when multiple partitions are required.</p>
<p>Note that the sparsity pattern itself is not changed by calling this function. However, you will likely use the information generated by calling this function to renumber degrees of freedom, after which you will of course have to regenerate the sparsity pattern.</p>
<p>This function will rarely be called separately, since in finite element methods you will want to partition the mesh, not the matrix. This can be done by calling <code><a class="el" href="namespaceGridTools.html#a5b4706b77042db5437cf81fd13e62b20">GridTools::partition_triangulation</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00048">48</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="ad7da91ef608d0e4c17d75c21070db6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7da91ef608d0e4c17d75c21070db6e4">&#9670;&nbsp;</a></span>reorder_Cuthill_McKee() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::reorder_Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;<a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given sparsity pattern, compute a re-enumeration of row/column indices based on the algorithm by Cuthill-McKee.</p>
<p>This algorithm is a graph renumbering algorithm in which we attempt to find a new numbering of all nodes of a graph based on their connectivity to other nodes (i.e. the edges that connect nodes). This connectivity is here represented by the sparsity pattern. In many cases within the library, the nodes represent degrees of freedom and edges are nonzero entries in a matrix, i.e. pairs of degrees of freedom that couple through the action of a bilinear form.</p>
<p>The algorithms starts at a node, searches the other nodes for those which are coupled with the one we started with and numbers these in a certain way. It then finds the second level of nodes, namely those that couple with those of the previous level (which were those that coupled with the initial node) and numbers these. And so on. For the details of the algorithm, especially the numbering within each level, we refer the reader to the book of Schwarz (H. R. Schwarz: Methode der finiten Elemente).</p>
<p>These algorithms have one major drawback: they require a good starting node, i.e. node that will have number zero in the output array. A starting node forming the initial level of nodes can thus be given by the user, e.g. by exploiting knowledge of the actual topology of the domain. It is also possible to give several starting indices, which may be used to simulate a simple upstream numbering (by giving the inflow nodes as starting values) or to make preconditioning faster (by letting the Dirichlet boundary indices be starting points).</p>
<p>If no starting index is given, one is chosen automatically, namely one with the smallest coordination number (the coordination number is the number of other nodes this node couples with). This node is usually located on the boundary of the domain. There is, however, large ambiguity in this when using the hierarchical meshes used in this library, since in most cases the computational domain is not approximated by tilting and deforming elements and by plugging together variable numbers of elements at vertices, but rather by hierarchical refinement. There is therefore a large number of nodes with equal coordination numbers. The renumbering algorithms will therefore not give optimal results.</p>
<p>If the graph has two or more unconnected components and if no starting indices are given, the algorithm will number each component consecutively. However, this requires the determination of a starting index for each component; as a consequence, the algorithm will produce an exception if starting indices are given, taking the latter as an indication that the caller of the function would like to override the part of the algorithm that chooses starting indices. </p>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00197">197</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="ac5f36665089b0b1d374f7047f98acde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f36665089b0b1d374f7047f98acde7">&#9670;&nbsp;</a></span>reorder_Cuthill_McKee() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::reorder_Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSparsityPattern.html#ae7c7c33ee1c51e916f5832dd9764381b">SparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparsityPattern.html#ae7c7c33ee1c51e916f5832dd9764381b">SparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;<a class="el" href="classSparsityPattern.html#ae7c7c33ee1c51e916f5832dd9764381b">SparsityPattern::size_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As above, but taking a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object instead.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00332">332</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="a576797328aeace287d271ee4e48e04a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576797328aeace287d271ee4e48e04a6">&#9670;&nbsp;</a></span>reorder_hierarchical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::reorder_hierarchical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given sparsity pattern, compute a re-enumeration of row/column indices in a hierarchical way, similar to what <a class="el" href="namespaceDoFRenumbering.html#af0306c2a1b1eeef2e3d54e0bf36d7bd7">DoFRenumbering::hierarchical</a> does for degrees of freedom on hierarchically refined meshes.</p>
<p>This algorithm first selects a node with the minimum number of neighbors and puts that node and its direct neighbors into one chunk. Next, it selects one of the neighbors of the already selected nodes, adds the node and its direct neighbors that are not part of one of the previous chunks, into the next. After this sweep, neighboring nodes are grouped together. To ensure a similar grouping on a more global level, this grouping is called recursively on the groups so formed. The recursion stops when no further grouping is possible. Eventually, the ordering obtained by this method passes through the indices represented in the sparsity pattern in a z-like way.</p>
<p>If the graph has two or more unconnected components, the algorithm will number each component consecutively, starting with the components with the lowest number of nodes. </p>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00508">508</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="ae2c7bdbdb62642f60d60087e4cb6195f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c7bdbdb62642f60d60087e4cb6195f">&#9670;&nbsp;</a></span>distribute_sparsity_pattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::distribute_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>dsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a95a97b47264afb282ed30a5d03832a26">DynamicSparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows_per_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>myrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Communicate rows in a dynamic sparsity pattern over MPI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dsp</td><td>A dynamic sparsity pattern that has been built locally and for which we need to exchange entries with other processors to make sure that each processor knows all the elements of the rows of a matrix it stores and that may eventually be written to. This sparsity pattern will be changed as a result of this function: All entries in rows that belong to a different processor are sent to them and added there.</td></tr>
    <tr><td class="paramname">rows_per_cpu</td><td>A vector containing the number of of rows per CPU for determining ownership. This is typically the value returned by <a class="el" href="classDoFHandler.html#aff791a67d5a9383fb2ef05ea540b71e8">DoFHandler::n_locally_owned_dofs_per_processor</a>.</td></tr>
    <tr><td class="paramname">mpi_comm</td><td>The MPI communicator shared between the processors that participate in this operation.</td></tr>
    <tr><td class="paramname">myrange</td><td>The range of elements stored locally. This should be the one used in the constructor of the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, and should also be the locally relevant set. Only rows contained in myrange are checked in dsp for transfer. This function needs to be used with <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> for it to work correctly in a parallel computation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00522">522</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="a24f68c3f11df0649b0ea1fbe643102e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f68c3f11df0649b0ea1fbe643102e9">&#9670;&nbsp;</a></span>distribute_sparsity_pattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::distribute_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>dsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>owned_set_per_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>myrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to the function above, but for <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dsp</td><td>The locally built sparsity pattern to be modified. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">owned_set_per_cpu</td><td>Typically the value given by <a class="el" href="classDoFHandler.html#a00905c2ab970f2da96ec6e762a36e227">DoFHandler::locally_owned_dofs_per_processor</a>.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mpi_comm</td><td>The MPI communicator to use.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">myrange</td><td>Typically the locally relevant DoFs. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00655">655</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
