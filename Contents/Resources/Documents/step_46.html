<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-46 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-46 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thegeneralidea">The general idea</a>
        <li><a href="#Implementation">Implementation</a>
        <li><a href="#Specificsoftheimplementation"> Specifics of the implementation </a>
      <ul>
        <li><a href="#Dealingwiththeinterfaceterms">Dealing with the interface terms</a>
        <li><a href="#Velocityboundaryconditionsontheinterface">Velocity boundary conditions on the interface</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
      <ul>
        <li><a href="#Identifyingwhichsubdomainacellisin">Identifying which subdomain a cell is in</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Meshrefinement">Mesh refinement</a>
    </ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeFluidStructureProblemcodeclasstemplate">The <code>FluidStructureProblem</code> class template</a>
        <li><a href="#Boundaryvaluesandrighthandside">Boundary values and right hand side</a>
        <li><a href="#ThecodeFluidStructureProblemcodeimplementation">The <code>FluidStructureProblem</code> implementation</a>
      <ul>
        <li><a href="#Constructorsandhelperfunctions">Constructors and helper functions</a>
        <li><a href="#Meshesandassigningsubdomains">Meshes and assigning subdomains</a>
        <li><a href="#codeFluidStructureProblemsetup_dofscode"><code>FluidStructureProblem::setup_dofs</code></a>
        <li><a href="#codeFluidStructureProblemassemble_systemcode"><code>FluidStructureProblem::assemble_system</code></a>
        <li><a href="#codeFluidStructureProblemsolvecode"><code>FluidStructureProblem::solve</code></a>
        <li><a href="#codeFluidStructureProblemoutput_resultscode"><code>FluidStructureProblem::output_results</code></a>
        <li><a href="#codeFluidStructureProblemrefine_meshcode"><code>FluidStructureProblem::refine_mesh</code></a>
        <li><a href="#codeFluidStructureProblemruncode"><code>FluidStructureProblem::run</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#2dresults">2d results</a>
        <li><a href="#3dresults">3d results</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
        <li><a href="#Refinementindicators">Refinement indicators</a>
        <li><a href="#Verification">Verification</a>
        <li><a href="#Bettermodels">Better models</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Wolfgang Bangerth. <br />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The University of California &ndash; Davis. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program deals with the problem of coupling different physics in different parts of the domain. Specifically, let us consider the following situation that couples a Stokes fluid with an elastic solid (these two problems were previously discussed separately in <a class="el" href="step_22.html">step-22</a> and <a class="el" href="step_8.html">step-8</a>, where you may want to read up on the individual equations):</p>
<ul>
<li>In a part <img class="formulaInl" alt="$\Omega_f$" src="form_3805.png"/> of <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>, we have a fluid flowing that satisfies the time independent Stokes equations (in the form that involves the strain tensor): <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -2\eta\nabla \cdot \varepsilon(\mathbf v) + \nabla p &amp;= 0, \qquad \qquad &amp;&amp; \text{in}\ \Omega_f\\ -\nabla \cdot \mathbf v &amp;= 0 &amp;&amp; \text{in}\ \Omega_f. \end{align*}" src="form_3806.png"/>
</p>
 Here, <img class="formulaInl" alt="$\mathbf v, p$" src="form_3807.png"/> are the fluid velocity and pressure, respectively. We prescribe the velocity on part of the external boundary, <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathbf v = \mathbf v_0 \qquad\qquad \text{on}\ \Gamma_{f,1} \subset \partial\Omega \cap \partial\Omega_f \end{align*}" src="form_3808.png"/>
</p>
 while we assume free-flow conditions on the remainder of the external boundary, <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (2\eta \varepsilon(\mathbf v) + p \mathbf 1) \cdot \mathbf n = 0 \qquad\qquad \text{on}\ \Gamma_{f,2} = \partial\Omega \cap \partial\Omega_f \backslash \Gamma_{f,1}. \end{align*}" src="form_3809.png"/>
</p>
</li>
<li>The remainder of the domain, <img class="formulaInl" alt="$\Omega_s = \Omega \backslash \Omega_f$" src="form_3810.png"/> is occupied by a solid whose deformation field <img class="formulaInl" alt="$\mathbf u$" src="form_220.png"/> satisfies the elasticity equation, <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -\nabla \cdot C \varepsilon(\mathbf u) = 0 \qquad\qquad &amp; \text{in}\ \Omega_s, \end{align*}" src="form_3811.png"/>
</p>
 where <img class="formulaInl" alt="$C$" src="form_43.png"/> is the rank-4 elasticity tensor (for which we will use a particularly simple form by assuming that the solid is isotropic). It deforms in reaction to the forces exerted by the fluid flowing along the boundary of the solid. We assume this deformation to be so small that it has no feedback effect on the fluid, i.e. the coupling is only in one direction. For simplicity, we will assume that the solid's external boundary is clamped, i.e. <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathbf u = \mathbf 0 \qquad\qquad \text{on}\ \Gamma_{s,1} = \partial\Omega \cap \partial\Omega_s \end{align*}" src="form_3812.png"/>
</p>
</li>
<li>As a consequence of the small displacement assumption, we will pose the following boundary conditions on the interface between the fluid and solid: first, we have no slip boundary conditions for the fluid, <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathbf v = \mathbf 0 \qquad\qquad \text{on}\ \Gamma_{i} = \partial\Omega_s \cap \partial\Omega_f. \end{align*}" src="form_3813.png"/>
</p>
 Secondly, the forces (traction) on the solid equal the normal stress from the fluid, <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (C \varepsilon(\mathbf u)) \mathbf n = (2 \eta \varepsilon(\mathbf v) + p \mathbf 1) \mathbf n \qquad\qquad \text{on}\ \Gamma_{i} = \partial\Omega_s \cap \partial\Omega_f. \end{align*}" src="form_3814.png"/>
</p>
</li>
</ul>
<p>We get a weak formulation of this problem by following our usual rule of multiplying from the left by a test function and integrating over the domain. It then looks like this: Find <img class="formulaInl" alt="$y = \{\mathbf v, p, \mathbf u\} \in Y \subset H^1(\Omega_f)^d \times L_2(\Omega_f) \times H^1(\Omega_s)^d$" src="form_3815.png"/> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{multline*} 2 \eta (\varepsilon(\mathbf a), \varepsilon(\mathbf v))_{\Omega_f} - (\nabla \cdot \mathbf a, p)_{\Omega_f} - (q, \nabla \cdot \mathbf v)_{\Omega_f} \\ + (\varepsilon(\mathbf b), C \varepsilon(\mathbf u))_{\Omega_s} \\ - (\mathbf b, (2 \eta \varepsilon(\mathbf v) + p \mathbf 1) \mathbf n)_{\Gamma_i} = 0, \end{multline*}" src="form_3816.png"/>
</p>
<p> for all test functions <img class="formulaInl" alt="$\mathbf a, q, \mathbf b$" src="form_3817.png"/>. Note that <img class="formulaInl" alt="$Y$" src="form_1157.png"/> is only a subspace of the spaces listed above to accommodate for the various Dirichlet boundary conditions.</p>
<p>This sort of coupling is of course possible by simply having two <a class="el" href="classTriangulation.html">Triangulation</a> and two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, one each for each of the two subdomains. On the other hand, deal.II is much simpler to use if there is a single <a class="el" href="classDoFHandler.html">DoFHandler</a> object that knows about the discretization of the entire problem.</p>
<p>This program is about how this can be achieved. Note that the goal is not to present a particularly useful physical model (a realistic fluid-structure interaction model would have to take into account the finite deformation of the solid and the effect this has on the fluid): this is, after all, just a tutorial program intended to demonstrate techniques, not to solve actual problems. Furthermore, we will make the assumption that the interface between the subdomains is aligned with coarse mesh cell faces.</p>
<p><a class="anchor" id="Thegeneralidea"></a></p><h3>The general idea</h3>
<p>Before going into more details let us state the obvious: this is a problem with multiple solution variables; for this, you will probably want to read the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> documentation module first, which presents the basic philosophical framework in which we address problems with more than one solution variable. But back to the problem at hand:</p>
<p>The fundamental idea to implement these sort of problems in deal.II goes as follows: in the problem formulation, the velocity and pressure variables <img class="formulaInl" alt="$\mathbf v, p$" src="form_3807.png"/> only live in the fluid subdomain <img class="formulaInl" alt="$\Omega_f$" src="form_3805.png"/>. But let's assume that we extend them by zero to the entire domain <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> (in the general case this means that they will be discontinuous along <img class="formulaInl" alt="$\Gamma_i$" src="form_3818.png"/>). So what is the appropriate function space for these variables? We know that on <img class="formulaInl" alt="$\Omega_f$" src="form_3805.png"/> we should require <img class="formulaInl" alt="$\mathbf v \in H^1(\Omega_f)^d, p \in L_2(\Omega_f)$" src="form_3819.png"/>, so for the extensions <img class="formulaInl" alt="$\tilde{\mathbf v}, \tilde p$" src="form_3820.png"/> to the whole domain the following appears a useful set of function spaces: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \tilde {\mathbf v} &amp;\in V = \{\tilde {\mathbf v}|_{\Omega_f} \in H^1(\Omega_f)^d, \quad \tilde {\mathbf v}|_{\Omega_s} = 0 \} \\ \tilde p &amp;\in P = \{\tilde p|_{\Omega_f} \in L_2(\Omega_f), \quad \tilde p|_{\Omega_s} = 0 \}. \end{align*}" src="form_3821.png"/>
</p>
<p> (Since this is not important for the current discussion, we have omitted the question of boundary values from the choice of function spaces; this question also affects whether we can choose <img class="formulaInl" alt="$L_2$" src="form_608.png"/> for the pressure or whether we have to choose the space <img class="formulaInl" alt="$L_{2,0}(\Omega_f)=\{q\in L_2(\Omega_f): \int_{\Omega_f} q = 0\}$" src="form_3822.png"/> for the pressure. None of these questions are relevant to the following discussion, however.)</p>
<p>Note that these are indeed a linear function spaces with obvious norm. Since no confusion is possible in practice, we will henceforth omit the tilde again to denote the extension of a function to the whole domain and simply refer by <img class="formulaInl" alt="$\mathbf v, p$" src="form_3807.png"/> to both the original and the extended function.</p>
<p>For discretization, we need finite dimensional subspaces <img class="formulaInl" alt="$V_h,P_h$" src="form_3823.png"/> of <img class="formulaInl" alt="$V, P$" src="form_3824.png"/>. For Stokes, we know from <a class="el" href="step_22.html">step-22</a> that an appropriate choice is <img class="formulaInl" alt="$Q_{p+1}^d\times Q_P$" src="form_3825.png"/> but this only holds for that part of the domain occupied by the fluid. For the extended field, let's use the following subspaces defined on the triangulation <img class="formulaInl" alt="$\mathbb T$" src="form_3826.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} V_h &amp;= \{{\mathbf v}_h \quad | \quad \forall K \in {\mathbb T}: {\mathbf v}_h|_K \in Q_{p+1}^d\ \text{if}\ K\subset {\Omega_f}, \quad {\mathbf v}_h|_{\Omega_f}\ \text{is continuous}, \quad {\mathbf v}_h|_K = 0\ \text{if}\ K\subset {\Omega_s}\} &amp;&amp; \subset V \\ P_h &amp;= \{ p_h \quad | \quad \forall K \in {\mathbb T}: p_h|_K \in Q_p\ \text{if}\ K\subset {\Omega_f}, \quad p_h|_{\Omega_f}\ \text{is continuous}, \quad p_h|_K = 0\ \text{if}\ K\subset {\Omega_s}\ \} &amp;&amp; \subset P. \end{align*}" src="form_3827.png"/>
</p>
<p> In other words, on <img class="formulaInl" alt="$\Omega_f$" src="form_3805.png"/> we choose the usual discrete spaces but we keep the (discontinuous) extension by zero. The point to make is that we now need a description of a finite element space for functions that are zero on a cell &mdash; and this is where the <a class="el" href="classFE__Nothing.html">FE_Nothing</a> class comes in: it describes a finite dimensional function space of functions that are constant zero. A particular property of this peculiar linear vector space is that it has no degrees of freedom: it isn't just finite dimensional, it is in fact zero dimensional, and consequently for objects of this type, <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">FiniteElement::dofs_per_cell</a> will return zero. For discussion below, let us give this space a proper symbol: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ Z = \{ \varphi: \varphi(x)=0 \}. \]" src="form_3828.png"/>
</p>
<p> The symbol <img class="formulaInl" alt="$Z$" src="form_3829.png"/> reminds of the fact that functions in this space are zero. Obviously, we choose <img class="formulaInl" alt="$Z_h=Z$" src="form_3830.png"/>.</p>
<p>This entire discussion above can be repeated for the variables we use to describe the elasticity equation. Here, for the extended variables, we have </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \tilde {\mathbf u} &amp;\in U = \{\tilde {\mathbf u}|_{\Omega_s} \in H^1(\Omega_f)^d, \quad \tilde {\mathbf u}|_{\Omega_f} \in Z(\Omega_s)^d \}, \end{align*}" src="form_3831.png"/>
</p>
<p> and we will typically use a finite element space of the kind </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} U_h &amp;= \{{\mathbf u}_h \quad | \quad \forall K \in {\mathbb T}: {\mathbf u}_h|_K \in Q_r^d\ \text{if}\ K\subset {\Omega_s}, \quad {\mathbf u}_h|_{\Omega_f}\ \text{is continuous}, \quad {\mathbf u}_h|_K \in Z^d\ \text{if}\ K\subset {\Omega_f}\} &amp;&amp; \subset U \end{align*}" src="form_3832.png"/>
</p>
<p> of polynomial degree <img class="formulaInl" alt="$r$" src="form_267.png"/>.</p>
<p>So to sum up, we are going to look for a discrete vector-valued solution <img class="formulaInl" alt="$y_h = \{\mathbf v_h, p_h, \mathbf u_h\}$" src="form_3833.png"/> in the following space: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} Y_h = \{ &amp; y_h = \{\mathbf v_h, p_h, \mathbf u_h\} : \\ &amp; y_h|_{\Omega_f} \in Q_{p+1}^d \times Q_p \times Z^d, \\ &amp; y_h|_{\Omega_s} \in Z^d \times Z \times Q_r^d \}. \end{align*}" src="form_3834.png"/>
</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>So how do we implement this sort of thing? First, we realize that the discrete space <img class="formulaInl" alt="$Y_h$" src="form_3835.png"/> essentially calls for two different finite elements: First, on the fluid subdomain, we need the element <img class="formulaInl" alt="$Q_{p+1}^d \times Q_p \times Z^d$" src="form_3836.png"/> which in deal.II is readily implemented by </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(p+1), dim,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(p), 1,</div><div class="line">               <a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), dim),</div></div><!-- fragment --><p> where <code><a class="el" href="classFE__Nothing.html">FE_Nothing</a></code> implements the space of functions that are always zero. Second, on the solid subdomain, we need the element <img class="formulaInl" alt="$\in Z^d \times Z \times Q_r^d$" src="form_3837.png"/>, which we get using </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), dim,</div><div class="line">               <a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), 1,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(r), dim),</div></div><!-- fragment --><p>The next step is that we associate each of these two elements with the cells that occupy each of the two subdomains. For this we realize that in a sense the two elements are just variations of each other in that they have the same number of vector components but have different polynomial degrees &mdash; this smells very much like what one would do in <img class="formulaInl" alt="$hp$" src="form_49.png"/> finite element methods, and it is exactly what we are going to do here: we are going to (ab)use the classes and facilities of the hp namespace to assign different elements to different cells. In other words, we will use collect the two finite elements in an <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>, will integrate with an appropriate <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> using an <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object, and our DoF handler will be of type <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. You may wish to take a look at <a class="el" href="step_27.html">step-27</a> for an overview of all of these concepts.</p>
<p>Before going on describing the testcase, let us clarify a bit <em>why</em> this approach of extending the functions by zero to the entire domain and then mapping the problem on to the hp framework makes sense:</p>
<ul>
<li>It makes things uniform: On all cells, the number of vector components is the same (here, <code>2*dim+1</code>). This makes all sorts of things possible since a uniform description allows for code re-use. For example, counting degrees of freedom per vector component (<a class="el" href="namespaceDoFTools.html#a1a86f6b2291b6bc814a982b85fa64a09">DoFTools::count_dofs_per_component</a>), sorting degrees of freedom by component (<a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>), subsequent partitioning of matrices and vectors into blocks and many other functions work as they always did without the need to add special logic to them that describes cases where some of the variables only live on parts of the domain. Consequently, you have all sorts of tools already available to you in programs like the current one that weren't originally written for the multiphysics case but work just fine in the current context.</li>
<li>It allows for easy graphical output: All graphical output formats we support require that each field in the output is defined on all nodes of the mesh. But given that now all solution components live everywhere, our existing <a class="el" href="classDataOut.html">DataOut</a> routines work as they always did, and produce graphical output suitable for visualization &ndash; the fields will simply be extended by zero, a value that can easily be filtered out by visualization programs if not desired.</li>
<li>There is essentially no cost: The trick with the <a class="el" href="classFE__Nothing.html">FE_Nothing</a> does not add any degrees of freedom to the overall problem, nor do we ever have to handle a shape function that belongs to these components &mdash; the <a class="el" href="classFE__Nothing.html">FE_Nothing</a> has no degrees of freedom, not does it have shape functions, all it does is take up vector components.</li>
</ul>
<p><a class="anchor" id="Specificsoftheimplementation"></a></p><h3>Specifics of the implementation </h3>
<p>More specifically, in the program we have to address the following points:</p><ul>
<li>Implementing the bilinear form, and in particular dealing with the interface term, both in the matrix and the sparsity pattern.</li>
<li>Implementing Dirichlet boundary conditions on the external and internal parts of the boundaries <img class="formulaInl" alt="$\partial\Omega_f,\partial\Omega_s$" src="form_3838.png"/>.</li>
</ul>
<p><a class="anchor" id="Dealingwiththeinterfaceterms"></a></p><h4>Dealing with the interface terms</h4>
<p>Let us first discuss implementing the bilinear form, which at the discrete level we recall to be </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{multline*} 2 \eta (\varepsilon(\mathbf a_h), \varepsilon(\mathbf v_h))_{\Omega_f} - (\nabla \cdot \mathbf a_h, p_h)_{\Omega_f} - (q_h, \nabla \cdot \mathbf v_h)_{\Omega_f} \\ + (\varepsilon(\mathbf b_h), C \varepsilon(\mathbf u_h))_{\Omega_s} \\ - (\mathbf b_h, (2 \eta \varepsilon(\mathbf v_h) + p \mathbf 1) \mathbf n)_{\Gamma_i} = 0, \end{multline*}" src="form_3839.png"/>
</p>
<p> Given that we have extended the fields by zero, we could in principle write the integrals over subdomains to the entire domain <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>, though it is little additional effort to first ask whether a cell is part of the elastic or fluid region before deciding which terms to integrate. Actually integrating these terms is not very difficult; for the Stokes equations, the relevant steps have been shown in <a class="el" href="step_22.html">step-22</a>, whereas for the elasticity equation we take essentially the form shown in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module (rather than the one from <a class="el" href="step_8.html">step-8</a>).</p>
<p>The term that is of more interest is the interface term, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (\mathbf b_h, (2 \eta \varepsilon(\mathbf v_h) + p \mathbf 1) \mathbf n)_{\Gamma_i}. \]" src="form_3840.png"/>
</p>
<p> Based on our assumption that the interface <img class="formulaInl" alt="$\Gamma_i$" src="form_3818.png"/> coincides with cell boundaries, this can in fact be written as a set of face integrals. If we denote the velocity, pressure and displacement components of shape function <img class="formulaInl" alt="$\psi_i\in Y_h$" src="form_3841.png"/> using the extractor notation <img class="formulaInl" alt="$\psi_i[\mathbf v],\psi_i[p], \psi_i[\mathbf u]$" src="form_3842.png"/>, then the term above yields the following contribution to the global matrix entry <img class="formulaInl" alt="$i,j$" src="form_2286.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_K (\psi_i[\mathbf u], (2 \eta \varepsilon(\psi_j[\mathbf v]) + \psi_j[p] \mathbf 1) \mathbf n)_{\partial K \cap \Gamma_i}. \]" src="form_3843.png"/>
</p>
<p> Although it isn't immediately obvious, this term presents a slight complication: while <img class="formulaInl" alt="$\psi_i[\mathbf u]$" src="form_3844.png"/> and <img class="formulaInl" alt="$\mathbf n$" src="form_1758.png"/> are evaluated on the solid side of the interface (they are test functions for the displacement and the normal vector to <img class="formulaInl" alt="$\Omega_s$" src="form_3845.png"/>, respectively, we need to evaluate <img class="formulaInl" alt="$\psi_j[\mathbf v],\psi_j[p]$" src="form_3846.png"/> on the fluid side of the interface since they correspond to the stress/force exerted by the fluid. In other words, in our implementation, we will need FEFaceValue objects for both sides of the interface. To make things slightly worse, we may also have to deal with the fact that one side or the other may be refined, leaving us with the need to integrate over parts of a face. Take a look at the implementation below on how to deal with this.</p>
<p>As an additional complication, the matrix entries that result from this term need to be added to the sparsity pattern of the matrix somehow. This is the realm of various functions in the <a class="el" href="namespaceDoFTools.html">DoFTools</a> namespace like <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> and <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a>. Essentially, what these functions do is simulate what happens during assembly of the system matrix: whenever assembly would write a nonzero entry into the global matrix, the functions in <a class="el" href="namespaceDoFTools.html">DoFTools</a> would add an entry to the sparsity pattern. We could therefore do the following: let <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> add all those entries to the sparsity pattern that arise from the regular cell-by-cell integration, and then do the same by hand that arise from the interface terms. If you look at the implementation of the interface integrals in the program below, it should be obvious how to do that and would require no more than maybe 100 lines of code at most.</p>
<p>But we're lazy people: the interface term couples degrees of freedom from two adjacent cells along a face, which is exactly the kind of thing one would do in discontinuous Galerkin schemes for which the function <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> was written. This is a superset of matrix entries compared to the usual <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>: it will also add all entries that result from computing terms coupling the degrees of freedom from both sides of all faces. Unfortunately, for the simplest version of this function, this is a pretty big superset. Consider for example the following mesh with two cells and a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> finite element: </p><div class="fragment"><div class="line">2---3---5</div><div class="line">|   |   |</div><div class="line">0---1---4</div></div><!-- fragment --><p> Here, the sparsity pattern produced by <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> will only have entries for degrees of freedom that couple on a cell. However, it will not have sparsity pattern entries <img class="formulaInl" alt="$(0,4),(0,5),(2,4),(2,5)$" src="form_3847.png"/>. The sparsity pattern generated by <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> will have these entries, however: it assumes that you want to build a sparsity pattern for a bilinear form that couples <em>all</em> degrees of freedom from adjacent cells. This is not what we want: our interface term acts only on a small subset of cells, and we certainly don't need all the extra couplings between two adjacent fluid cells, or two adjacent solid cells. Furthermore, the fact that we use higher order elements means that we would really generate many many more entries than we actually need: on the coarsest mesh, in 2d, 44,207 nonzero entries instead of 16,635 for <a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>, leading to plenty of zeros in the matrix we later build (of course, the 16,635 are not enough since they don't include the interface entries). This ratio would be even worse in 3d.</p>
<p>So being extremely lazy comes with a cost: too many entries in the matrix. But we can get away with being moderately lazy: there is a variant of <a class="el" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> that allows us to specify which vector components of the finite element couple with which other components, both in cell terms as well as in face terms. For cells that are in the solid subdomain, we couple all displacements with each other; for fluid cells, all velocities with all velocities and the pressure, but not the pressure with itself. Since no cell has both sets of variables, there is no need to distinguish between the two kinds of cells, so we can write the mask like this: </p><div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> cell_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                           fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++d)</div><div class="line">    <span class="keywordflow">if</span> (((c&lt;dim+1) &amp;&amp; (d&lt;dim+1)</div><div class="line">         &amp;&amp; !((c==dim) &amp;&amp; (d==dim)))</div><div class="line">        ||</div><div class="line">        ((c&gt;=dim+1) &amp;&amp; (d&gt;=dim+1)))</div><div class="line">      cell_coupling[c][d] = DoFTools::Coupling::always;</div></div><!-- fragment --><p> Here, we have used the fact that the first <code>dim</code> components of the finite element are the velocities, then the pressure, and then the <code>dim</code> displacements. (We could as well have stated that the velocities/pressure also couple with the displacements since no cell ever has both sets of variables.) On the other hand, the interface terms require a mask like this: </p><div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> face_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                           fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++d)</div><div class="line">    <span class="keywordflow">if</span> ((c&gt;=dim+1) &amp;&amp; (d&lt;dim+1))</div><div class="line">      face_coupling[c][d] = DoFTools::Coupling::always;</div></div><!-- fragment --><p> In other words, all displacement test functions (components <code>c&gt;=dim+1</code>) couple with all velocity and pressure shape functions on the other side of an interface. This is not entirely true, though close: in fact, the exact form of the interface term only those pressure displacement shape functions that are indeed nonzero on the common interface, which is not true for all shape functions; on the other hand, it really couples all velocities (since the integral involves gradients of the velocity shape functions, which are all nonzero on all faces of the cell). However, the mask we build above, is not capable of these subtleties. Nevertheless, through these masks we manage to get the number of sparsity pattern entries down to 21,028 &mdash; good enough for now.</p>
<p><a class="anchor" id="Velocityboundaryconditionsontheinterface"></a></p><h4>Velocity boundary conditions on the interface</h4>
<p>The second difficulty is that while we know how to enforce a zero velocity or stress on the external boundary (using <a class="el" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>, called with an appropriate component mask and setting different boundary indicators for solid and fluid external boundaries), we now also needed the velocity to be zero on the interior interface, i.e. <img class="formulaInl" alt="$\mathbf v|_{\Gamma_i}=0$" src="form_3848.png"/>. At the time of writing this, there is no function in deal.II that handles this part, but it isn't particularly difficult to implement by hand: essentially, we just have to loop over all cells, and if it is a fluid cell and its neighbor is a solid cell, then add constraints that ensure that the velocity degrees of freedom on this face are zero. Some care is necessary to deal with the case that the adjacent solid cell is refined, yielding the following code: </p><div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; local_face_dof_indices (stokes_fe.dofs_per_face);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">     cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell))</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">      <span class="keywordflow">if</span> (!cell-&gt;at_boundary(f))</div><div class="line">        {</div><div class="line">          <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>)</div><div class="line">              &amp;&amp;</div><div class="line">              (cell_is_in_solid_domain (cell-&gt;neighbor(f))))</div><div class="line">            face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">            {</div><div class="line">                                               <span class="comment">// The neighbor does</span></div><div class="line">                                               <span class="comment">// have</span></div><div class="line">                                               <span class="comment">// children. See if</span></div><div class="line">                                               <span class="comment">// any of the cells</span></div><div class="line">                                               <span class="comment">// on the other</span></div><div class="line">                                               <span class="comment">// side are elastic</span></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf=0; sf&lt;cell-&gt;face(f)-&gt;n_children(); ++sf)</div><div class="line">                <span class="keywordflow">if</span> (cell_is_in_solid_domain (cell-&gt;neighbor_child_on_subface(f, sf)))</div><div class="line">                  {</div><div class="line">                    face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                  }</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">            {</div><div class="line">              cell-&gt;face(f)-&gt;get_dof_indices (local_face_dof_indices, 0);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;local_face_dof_indices.size(); ++i)</div><div class="line">                <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt; dim)</div><div class="line">                  constraints.add_line (local_face_dof_indices[i]);</div><div class="line">            }</div><div class="line">        }</div></div><!-- fragment --><p>The call <code>constraints.add_line(t)</code> tells the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> to start a new constraint for degree of freedom <code>t</code> of the form <img class="formulaInl" alt="$x_t=\sum_{l=0}^{N-1} c_{tl} x_l + b_t$" src="form_3849.png"/>. Typically, one would then proceed to set individual coefficients <img class="formulaInl" alt="$c_{tl}$" src="form_3850.png"/> to nonzero values (using <a class="el" href="classConstraintMatrix.html#a4cd323a407cb379510a68c26e842304e">ConstraintMatrix::add_entry</a>) or set <img class="formulaInl" alt="$b_t$" src="form_3851.png"/> to something nonzero (using <a class="el" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">ConstraintMatrix::set_inhomogeneity</a>); doing nothing as above, funny as it looks, simply leaves the constraint to be <img class="formulaInl" alt="$x_t=0$" src="form_3852.png"/>, which is exactly what we need in the current context. The call to <a class="el" href="classFiniteElement.html#a29f9d46ef9521dc25cfa2be551391e1d">FiniteElement::face_system_to_component_index</a> makes sure that we only set boundary values to zero for velocity but not pressure components.</p>
<p>Note that there are cases where this may yield incorrect results: notably, once we find a solid neighbor child to a current fluid cell, we assume that all neighbor children on the common face are in the solid subdomain. But that need not be so; consider, for example, the following mesh: </p><div class="fragment"><div class="line">+---------+----+----+</div><div class="line">|         | f  |    |</div><div class="line">|    f    +----+----+</div><div class="line">|         | s  |    |</div><div class="line">+---------+----+----+</div></div><!-- fragment --><p>In this case, we would set all velocity degrees of freedom on the right face of the left cell to zero, which is incorrect for the top degree of freedom on that face. That said, that can only happen if the fluid and solid subdomains do not coincide with a set of complete coarse mesh cells &mdash; but this is a contradiction to the assumption stated at the end of the first section of this introduction.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>We will consider the following situation as a testcase:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.layout.png"/>
</div>
<p>As discussed at the top of this document, we need to assume in a few places that a cell is either entirely in the fluid or solid part of the domain and, furthermore, that all children of an inactive cell also belong to the same subdomain. This can definitely be ensured if the coarse mesh already subdivides the mesh into solid and fluid coarse mesh cells; given the geometry outlined above, we can do that by using an <img class="formulaInl" alt="$8\times 8$" src="form_1722.png"/> coarse mesh, conveniently provided by the <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> function.</p>
<p>The fixed boundary at the bottom implies <img class="formulaInl" alt="$\mathbf u=0$" src="form_3853.png"/>, and we also prescribe Dirichlet conditions for the flow at the top so that we get inflow at the left and outflow at the right. At the left and right boundaries, no boundary conditions are imposed explicitly for the flow, yielding the implicit no-stress condition <img class="formulaInl" alt="$(2\eta \varepsilon(\mathbf v) + p \mathbf 1) \cdot \mathbf n = 0$" src="form_3854.png"/>. The conditions on the interface between the two domains has already been discussed above.</p>
<p>For simplicity, we choose the material parameters to be <img class="formulaInl" alt="$\eta=\lambda=\mu=1$" src="form_3855.png"/>. In the results section below, we will also show a 3d simulation that can be obtained from the same program. The boundary conditions and geometry are defined nearly analogously to the 2d situation above.</p>
<p><a class="anchor" id="Identifyingwhichsubdomainacellisin"></a></p><h4>Identifying which subdomain a cell is in</h4>
<p>In the program, we need a way to identify which part of the domain a cell is in. There are many different ways of doing this. A typical way would be to use the <a class="el" href="DEALGlossary.html#GlossSubdomainId">subdomain_id</a> tag available with each cell, though this field has a special meaning in parallel computations. An alternative is the <a class="el" href="DEALGlossary.html#GlossMaterialId">material_id</a> field also available with every cell. It has the additional advantage that it is inherited from the mother to the child cell upon mesh refinement; in other words, we would set the material id once upon creating the mesh and it will be correct for all active cells even after several refinement cycles. We therefore go with this alternative: we define an <code>enum</code> with symbolic names for material_id numbers and will use them to identify which part of the domain a cell is on.</p>
<p>Secondly, we use an object of type <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>. This class needs to know which cells will use the Stokes and which the elasticity finite element. At the beginning of each refinement cycle we will therefore have to walk over all cells and set the (in hp parlance) active FE index to whatever is appropriate in the current situation. While we can use symbolic names for the material id, the active FE index is in fact a number that will frequently be used to index into collections of objects (e.g. of type <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> and <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>); that means that the active FE index actually has to have value zero for the fluid and one for the elastic part of the domain.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h4>Linear solvers</h4>
<p>This program is primarily intended to show how to deal with different physics in different parts of the domain, and how to implement such models in deal.II. As a consequence, we won't bother coming up with a good solver: we'll just use the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class which always works, even if not with optimal complexity. We will, however, comment on possible other solvers in the <a href="#Results">results</a> section.</p>
<p><a class="anchor" id="Meshrefinement"></a></p><h4>Mesh refinement</h4>
<p>One of the trickier aspects of this program is how to estimate the error. Because it works on almost any program, we'd like to use the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>, and we can relatively easily do that here as well using code like the following: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> stokes_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> elasticity_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">std::vector&lt;bool&gt; stokes_component_mask (dim+1+dim, <span class="keyword">false</span>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">  stokes_component_mask[d] = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                    face_q_collection,</div><div class="line">                                    <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                    solution,</div><div class="line">                                    stokes_estimated_error_per_cell,</div><div class="line">                                    stokes_component_mask);</div><div class="line"></div><div class="line">std::vector&lt;bool&gt; elasticity_component_mask (dim+1+dim, <span class="keyword">false</span>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">  elasticity_component_mask[dim+1+d] = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                    face_q_collection,</div><div class="line">                                    <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                    solution,</div><div class="line">                                    elasticity_estimated_error_per_cell,</div><div class="line">                                    elasticity_component_mask);</div></div><!-- fragment --><p> This gives us two sets of error indicators for each cell. We would then somehow combine them into one for mesh refinement, for example using something like the following (note that we normalize the squared error indicator in the two vectors because error quantities have physical units that do not match in the current situation, leading to error indicators that may differ by orders of magnitude between the two subdomains): </p><div class="fragment"><div class="line">stokes_estimated_error_per_cell /= stokes_estimated_error_per_cell.l2_norm();</div><div class="line">elasticity_estimated_error_per_cell /= elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">estimated_error_per_cell += elasticity_estimated_error_per_cell;</div></div><!-- fragment --><p> (In the code, we actually weigh the error indicators 4:1 in favor of the ones computed on the Stokes subdomain since refinement is otherwise heavily biased towards the elastic subdomain, but this is just a technicality. The factor 4 has been determined heuristically to work reasonably well.)</p>
<p>While this principle is sound, it doesn't quite work as expected. The reason is that the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class computes error indicators by integrating the jump in the solution's gradient around the faces of each cell. This jump is likely to be very large at the locations where the solution is discontinuous and extended by zero; it also doesn't become smaller as the mesh is refined. The <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class can't just ignore the interface because it essentially only sees an <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> where the element type changes from one cell to another &mdash; precisely the thing that the <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> was designed for, the interface in the current program looks no different than the interfaces in <a class="el" href="step_27.html">step-27</a>, for example, and certainly no less legitimate. Be that as it may, the end results is that there is a layer of cells on both sides of the interface between the two subdomains where error indicators are irrationally large. Consequently, most of the mesh refinement is focused on the interface.</p>
<p>This clearly wouldn't happen if we had a refinement indicator that actually understood something about the problem and simply ignore the interface between subdomains when integrating jump terms. On the other hand, this program is about showing how to represent problems where we have different physics in different subdomains, not about the peculiarities of the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>, and so we resort to the big hammer called "heuristics": we simply set the error indicators of cells at the interface to zero. This cuts off the spikes in the error indicators. At first sight one would also think that it prevents the mesh from being refined at the interface, but the requirement that neighboring cells may only differ by one level of refinement will still lead to a reasonably refined mesh.</p>
<p>While this is clearly a suboptimal solution, it works for now and leaves room for future improvement.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The include files for this program are the same as for many others before. The only new one is the one that declares <a class="el" href="classFE__Nothing.html">FE_Nothing</a> as discussed in the introduction. The ones in the hp directory have already been discussed in <a class="el" href="step_27.html">step-27</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_nothing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/fe_collection.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step46</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeFluidStructureProblemcodeclasstemplate"></a> </p><h3>The <code>FluidStructureProblem</code> class template</h3>
<p>This is the main class. It is, if you want, a combination of <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_22.html">step-22</a> in that it has member variables that either address the global problem (the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> objects, as well as the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> and various linear algebra objects) or that pertain to either the elasticity or Stokes sub-problems. The general structure of the class, however, is like that of most of the other programs implementing stationary problems.</p>
<p>There are a few helper functions (<code>cell_is_in_fluid_domain, cell_is_in_solid_domain</code>) of self-explanatory nature (operating on the symbolic names for the two subdomains that will be used as material_ids for cells belonging to the subdomains, as explained in the introduction) and a few functions (<code>make_grid, set_active_fe_indices, assemble_interface_terms</code>) that have been broken out of other functions that can be found in many of the other tutorial programs and that will be discussed as we get to their implementation.</p>
<p>The final set of variables (<code>viscosity, lambda, eta</code>) describes the material properties used for the two physics models.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>FluidStructureProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  FluidStructureProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree);</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">enum</span></div><div class="line">  {</div><div class="line">    fluid_domain_id,</div><div class="line">    solid_domain_id</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span></div><div class="line">  cell_is_in_fluid_domain (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">hp::DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span></div><div class="line">  cell_is_in_solid_domain (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">hp::DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> make_grid ();</div><div class="line">  <span class="keywordtype">void</span> set_active_fe_indices ();</div><div class="line">  <span class="keywordtype">void</span> setup_dofs ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_interface_term (<span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>          &amp;elasticity_fe_face_values,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>          &amp;stokes_fe_face_values,</div><div class="line">                                std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;          &amp;elasticity_phi,</div><div class="line">                                std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt; &amp;stokes_symgrad_phi_u,</div><div class="line">                                std::vector&lt;double&gt;                  &amp;stokes_phi_p,</div><div class="line">                                <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   &amp;local_interface_matrix) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> refine_mesh ();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    stokes_degree;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    elasticity_degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    triangulation;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         stokes_fe;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         elasticity_fe;</div><div class="line">  <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div><div class="line">  <a class="code" href="classhp_1_1DoFHandler.html">hp::DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>      constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>       sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>  system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>        solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>        system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>          viscosity;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>          lambda;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>          mu;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundaryvaluesandrighthandside"></a> </p><h3><a class="el" href="classBoundary.html">Boundary</a> values and right hand side</h3>
<p>The following classes do as their names suggest. The boundary values for the velocity are <img class="formulaInl" alt="$\mathbf u=(0, \sin(\pi x))^T$" src="form_3856.png"/> in 2d and <img class="formulaInl" alt="$\mathbf u=(0, 0, \sin(\pi x)\sin(\pi y))^T$" src="form_3857.png"/> in 3d, respectively. The remaining boundary conditions for this problem are all homogeneous and have been discussed in the introduction. The right hand side forcing term is zero for both the fluid and the solid.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StokesBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesBoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1+dim) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">StokesBoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component &lt; this-&gt;n_components,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (component == dim-1)</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">      <span class="keywordflow">case</span> 2:</div><div class="line">        <span class="keywordflow">return</span> std::sin(<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*p[0]);</div><div class="line">      <span class="keywordflow">case</span> 3:</div><div class="line">        <span class="keywordflow">return</span> std::sin(<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*p[0]) * std::sin(<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*p[1]);</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">StokesBoundaryValues&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                         <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;this-&gt;<a class="code" href="classFunction.html#aa568b98591fc2bda09b28539789aef7d">n_components</a>; ++c)</div><div class="line">    values(c) = StokesBoundaryValues&lt;dim&gt;::value (p, c);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;/ *p* /,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> / *component* /)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">RightHandSide&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;this-&gt;n_components; ++c)</div><div class="line">    values(c) = RightHandSide&lt;dim&gt;::value (p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeFluidStructureProblemcodeimplementation"></a> </p><h3>The <code>FluidStructureProblem</code> implementation</h3>
<p><a class="anchor" id="Constructorsandhelperfunctions"></a> </p><h4>Constructors and helper functions</h4>
<p>Let's now get to the implementation of the primary class of this program. The first few functions are the constructor and the helper functions that can be used to determine which part of the domain a cell is in. Given the discussion of these topics in the introduction, their implementation is rather obvious. In the constructor, note that we have to construct the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> object from the base elements for Stokes and elasticity; using the <a class="el" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">hp::FECollection::push_back</a> function assigns them spots zero and one in this collection, an order that we have to remember and use consistently in the rest of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">FluidStructureProblem&lt;dim&gt;::</div><div class="line">FluidStructureProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree)</div><div class="line">  :</div><div class="line">  stokes_degree (stokes_degree),</div><div class="line">  elasticity_degree (elasticity_degree),</div><div class="line">  triangulation (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing),</div><div class="line">  stokes_fe (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree+1), dim,</div><div class="line">             <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1,</div><div class="line">             <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(), dim),</div><div class="line">  elasticity_fe (<a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(), dim,</div><div class="line">                 <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(), 1,</div><div class="line">                 <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(elasticity_degree), dim),</div><div class="line">  dof_handler (triangulation),</div><div class="line">  viscosity (2),</div><div class="line">  lambda (1),</div><div class="line">  mu (1)</div><div class="line">{</div><div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a> (stokes_fe);</div><div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a> (elasticity_fe);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span></div><div class="line">FluidStructureProblem&lt;dim&gt;::</div><div class="line">cell_is_in_fluid_domain (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">hp::DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (cell-&gt;material_id() == fluid_domain_id);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span></div><div class="line">FluidStructureProblem&lt;dim&gt;::</div><div class="line">cell_is_in_solid_domain (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">hp::DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (cell-&gt;material_id() == solid_domain_id);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Meshesandassigningsubdomains"></a> </p><h4>Meshes and assigning subdomains</h4>
<p>The next pair of functions deals with generating a mesh and making sure all flags that denote subdomains are correct. <code>make_grid</code>, as discussed in the introduction, generates an <img class="formulaInl" alt="$8\times 8$" src="form_1722.png"/> mesh (or an <img class="formulaInl" alt="$8\times 8\times 8$" src="form_3858.png"/> mesh in 3d) to make sure that each coarse mesh cell is completely within one of the subdomains. After generating this mesh, we loop over its boundary and set the boundary indicator to one at the top boundary, the only place where we set nonzero Dirichlet boundary conditions. After this, we loop again over all cells to set the material indicator &mdash; used to denote which part of the domain we are in, to either the fluid or solid indicator.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">FluidStructureProblem&lt;dim&gt;::make_grid ()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">GridGenerator::subdivided_hyper_cube</a> (triangulation, 8, -1, 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">       cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary()</div><div class="line">          &amp;&amp;</div><div class="line">          (cell-&gt;face(f)-&gt;center()[dim-1] == 1))</div><div class="line">        cell-&gt;face(f)-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">       cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">    <span class="keywordflow">if</span> (((std::fabs(cell-&gt;center()[0]) &lt; 0.25)</div><div class="line">         &amp;&amp;</div><div class="line">         (cell-&gt;center()[dim-1] &gt; 0.5))</div><div class="line">        ||</div><div class="line">        ((std::fabs(cell-&gt;center()[0]) &gt;= 0.25)</div><div class="line">         &amp;&amp;</div><div class="line">         (cell-&gt;center()[dim-1] &gt; -0.5)))</div><div class="line">      cell-&gt;set_material_id (fluid_domain_id);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      cell-&gt;set_material_id (solid_domain_id);</div><div class="line">}</div></div><!-- fragment --><p>The second part of this pair of functions determines which finite element to use on each cell. Above we have set the material indicator for each coarse mesh cell, and as mentioned in the introduction, this information is inherited from mother to child cell upon mesh refinement.</p>
<p>In other words, whenever we have refined (or created) the mesh, we can rely on the material indicators to be a correct description of which part of the domain a cell is in. We then use this to set the active FE index of the cell to the corresponding element of the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> member variable of this class: zero for fluid cells, one for solid cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">FluidStructureProblem&lt;dim&gt;::set_active_fe_indices ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">       cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">        cell-&gt;set_active_fe_index (0);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">        cell-&gt;set_active_fe_index (1);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemsetup_dofscode"></a> </p><h4><code>FluidStructureProblem::setup_dofs</code></h4>
<p>The next step is to setup the data structures for the linear system. To this end, we first have to set the active FE indices with the function immediately above, then distribute degrees of freedom, and then determine constraints on the linear system. The latter includes hanging node constraints as usual, but also the inhomogeneous boundary values at the top fluid boundary, and zero boundary values along the perimeter of the solid subdomain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">FluidStructureProblem&lt;dim&gt;::setup_dofs ()</div><div class="line">{</div><div class="line">  set_active_fe_indices ();</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe_collection);</div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.clear ();</div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                             constraints);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              1,</div><div class="line">                                              StokesBoundaryValues&lt;dim&gt;(),</div><div class="line">                                              constraints,</div><div class="line">                                              fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim+1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              0,</div><div class="line">                                              <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+1+dim),</div><div class="line">                                              constraints,</div><div class="line">                                              fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line">  }</div></div><!-- fragment --><p>There are more constraints we have to handle, though: we have to make sure that the velocity is zero at the interface between fluid and solid. The following piece of code was already presented in the introduction:</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_face_dof_indices (stokes_fe.dofs_per_face);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">       cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell))</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">        <span class="keywordflow">if</span> (!cell-&gt;at_boundary(f))</div><div class="line">          {</div><div class="line">            <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">false</span>)</div><div class="line">                &amp;&amp;</div><div class="line">                (cell_is_in_solid_domain (cell-&gt;neighbor(f))))</div><div class="line">              face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">true</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf=0; sf&lt;cell-&gt;face(f)-&gt;n_children(); ++sf)</div><div class="line">                  <span class="keywordflow">if</span> (cell_is_in_solid_domain (cell-&gt;neighbor_child_on_subface</div><div class="line">                                               (f, sf)))</div><div class="line">                    {</div><div class="line">                      face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                      <span class="keywordflow">break</span>;</div><div class="line">                    }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">              {</div><div class="line">                cell-&gt;face(f)-&gt;get_dof_indices (local_face_dof_indices, 0);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;local_face_dof_indices.size(); ++i)</div><div class="line">                  <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt; dim)</div><div class="line">                    constraints.add_line (local_face_dof_indices[i]);</div><div class="line">              }</div><div class="line">          }</div><div class="line">}</div></div><!-- fragment --><p>At the end of all this, we can declare to the constraints object that we now have all constraints ready to go and that the object can rebuild its internal data structures for better efficiency:</p>
<div class="fragment"><div class="line">constraints.close ();</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">          &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>In the rest of this function we create a sparsity pattern as discussed extensively in the introduction, and use it to initialize the matrix; then also set vectors to their correct sizes:</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> cell_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line">    <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> face_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++d)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (((c&lt;dim+1) &amp;&amp; (d&lt;dim+1)</div><div class="line">               &amp;&amp; !((c==dim) &amp;&amp; (d==dim)))</div><div class="line">              ||</div><div class="line">              ((c&gt;=dim+1) &amp;&amp; (d&gt;=dim+1)))</div><div class="line">            cell_coupling[c][d] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((c&gt;=dim+1) &amp;&amp; (d&lt;dim+1))</div><div class="line">            face_coupling[c][d] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> (dof_handler, dsp,</div><div class="line">                                          cell_coupling, face_coupling);</div><div class="line">    constraints.condense (dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a> (dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemassemble_systemcode"></a> </p><h4><code>FluidStructureProblem::assemble_system</code></h4>
<p>Following is the central function of this program: the one that assembles the linear system. It has a long section of setting up auxiliary functions at the beginning: from creating the quadrature formulas and setting up the <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects necessary to integrate the cell terms as well as the interface terms for the case where cells along the interface come together at same size or with differing levels of refinement...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  system_matrix=0;</div><div class="line">  system_rhs=0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> stokes_quadrature(stokes_degree+2);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> elasticity_quadrature(elasticity_degree+2);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a>  q_collection;</div><div class="line">  q_collection.<a class="code" href="classhp_1_1QCollection.html#a166f1c95b492e6293215998210caf605">push_back</a> (stokes_quadrature);</div><div class="line">  q_collection.<a class="code" href="classhp_1_1QCollection.html#a166f1c95b492e6293215998210caf605">push_back</a> (elasticity_quadrature);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values (fe_collection, q_collection,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; common_face_quadrature(std::max (stokes_degree+2,</div><div class="line">                                                       elasticity_degree+2));</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    stokes_fe_face_values (stokes_fe,</div><div class="line">                                              common_face_quadrature,</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    elasticity_fe_face_values (elasticity_fe,</div><div class="line">                                                  common_face_quadrature,</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> stokes_fe_subface_values (stokes_fe,</div><div class="line">                                                 common_face_quadrature,</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> elasticity_fe_subface_values (elasticity_fe,</div><div class="line">                                                     common_face_quadrature,</div><div class="line">                                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div></div><!-- fragment --><p>...to objects that are needed to describe the local contributions to the global linear system...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_dofs_per_cell     = stokes_fe.dofs_per_cell;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        elasticity_dofs_per_cell = elasticity_fe.dofs_per_cell;</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        local_matrix;</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        local_interface_matrix (elasticity_dofs_per_cell,</div><div class="line">                                                  stokes_dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>            local_rhs;</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">std::vector&lt;types::global_dof_index&gt; neighbor_dof_indices (stokes_dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> RightHandSide&lt;dim&gt;  right_hand_side;</div></div><!-- fragment --><p>...to variables that allow us to extract certain components of the shape functions and cache their values rather than having to recompute them at every quadrature point:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities (0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure (dim);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     displacements (dim+1);</div><div class="line"></div><div class="line">std::vector&lt;SymmetricTensor&lt;2,dim&gt; &gt; stokes_symgrad_phi_u (stokes_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  stokes_div_phi_u     (stokes_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  stokes_phi_p         (stokes_dofs_per_cell);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;2,dim&gt; &gt;          elasticity_grad_phi (elasticity_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  elasticity_div_phi  (elasticity_dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1,dim&gt; &gt;          elasticity_phi      (elasticity_dofs_per_cell);</div></div><!-- fragment --><p>Then comes the main loop over all cells and, as in <a class="el" href="step_27.html">step-27</a>, the initialization of the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object for the current cell and the extraction of a <a class="el" href="classFEValues.html">FEValues</a> object that is appropriate for the current cell:</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    hp_fe_values.reinit (cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a4bc26790261f1f9f4cc7e8e69e3d7920">get_present_fe_values</a>();</div><div class="line"></div><div class="line">    local_matrix.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell,</div><div class="line">                         cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell);</div><div class="line">    local_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell);</div></div><!-- fragment --><p>With all of this done, we continue to assemble the cell terms for cells that are part of the Stokes and elastic regions. While we could in principle do this in one formula, in effect implementing the one bilinear form stated in the introduction, we realize that our finite element spaces are chosen in such a way that on each cell, one set of variables (either velocities and pressure, or displacements) are always zero, and consequently a more efficient way of computing local integrals is to do only what's necessary based on an <code>if</code> clause that tests which part of the domain we are in.</p>
<p>The actual computation of the local matrix is the same as in <a class="el" href="step_22.html">step-22</a> as well as that given in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> documentation module for the elasticity equations:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell))</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dofs_per_cell == stokes_dofs_per_cell,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            stokes_symgrad_phi_u[k] = fe_values[velocities].symmetric_gradient (k, q);</div><div class="line">            stokes_div_phi_u[k]     = fe_values[velocities].divergence (k, q);</div><div class="line">            stokes_phi_p[k]         = fe_values[pressure].value (k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            local_matrix(i,j) += (2 * viscosity * stokes_symgrad_phi_u[i] * stokes_symgrad_phi_u[j]</div><div class="line">                                  - stokes_div_phi_u[i] * stokes_phi_p[j]</div><div class="line">                                  - stokes_phi_p[i] * stokes_div_phi_u[j])</div><div class="line">                                 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dofs_per_cell == elasticity_dofs_per_cell,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            elasticity_grad_phi[k] = fe_values[displacements].gradient (k, q);</div><div class="line">            elasticity_div_phi[k]  = fe_values[displacements].divergence (k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              local_matrix(i,j)</div><div class="line">              +=  (lambda *</div><div class="line">                   elasticity_div_phi[i] * elasticity_div_phi[j]</div><div class="line">                   +</div><div class="line">                   mu *</div><div class="line">                   <a class="code" href="classSymmetricTensor.html#a46543b446a9cef02b1aeaf2f9b5739ba">scalar_product</a>(elasticity_grad_phi[i], elasticity_grad_phi[j])</div><div class="line">                   +</div><div class="line">                   mu *</div><div class="line">                   <a class="code" href="classSymmetricTensor.html#a46543b446a9cef02b1aeaf2f9b5739ba">scalar_product</a>(elasticity_grad_phi[i], <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(elasticity_grad_phi[j]))</div><div class="line">                  )</div><div class="line">                  *</div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Once we have the contributions from cell integrals, we copy them into the global matrix (taking care of constraints right away, through the <a class="el" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">ConstraintMatrix::distribute_local_to_global</a> function). Note that we have not written anything into the <code>local_rhs</code> variable, though we still need to pass it along since the elimination of nonzero boundary values requires the modification of local and consequently also global right hand side values:</p>
<div class="fragment"><div class="line">local_dof_indices.resize (cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell);</div><div class="line">cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">constraints.distribute_local_to_global (local_matrix, local_rhs,</div><div class="line">                                        local_dof_indices,</div><div class="line">                                        system_matrix, system_rhs);</div></div><!-- fragment --><p>The more interesting part of this function is where we see about face terms along the interface between the two subdomains. To this end, we first have to make sure that we only assemble them once even though a loop over all faces of all cells would encounter each part of the interface twice. We arbitrarily make the decision that we will only evaluate interface terms if the current cell is part of the solid subdomain and if, consequently, a face is not at the boundary and the potential neighbor behind it is part of the fluid domain. Let's start with these conditions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_is_in_solid_domain (cell))</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;at_boundary(f) == <span class="keyword">false</span>)</div><div class="line">      {</div></div><!-- fragment --><p>At this point we know that the current cell is a candidate for integration and that a neighbor behind face <code>f</code> exists. There are now three possibilities:</p>
<ul>
<li>The neighbor is at the same refinement level and has no children.</li>
<li>The neighbor has children.</li>
<li>The neighbor is coarser.</li>
</ul>
<p>In all three cases, we are only interested in it if it is part of the fluid subdomain. So let us start with the first and simplest case: if the neighbor is at the same level, has no children, and is a fluid cell, then the two cells share a boundary that is part of the interface along which we want to integrate interface terms. All we have to do is initialize two <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object with the current face and the face of the neighboring cell (note how we find out which face of the neighboring cell borders on the current cell) and pass things off to the function that evaluates the interface terms (the third through fifth arguments to this function provide it with scratch arrays). The result is then again copied into the global matrix, using a function that knows that the DoF indices of rows and columns of the local matrix result from different cells:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">    &amp;&amp;</div><div class="line">    (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">false</span>)</div><div class="line">    &amp;&amp;</div><div class="line">    cell_is_in_fluid_domain (cell-&gt;neighbor(f)))</div><div class="line">  {</div><div class="line">    elasticity_fe_face_values.reinit (cell, f);</div><div class="line">    stokes_fe_face_values.reinit (cell-&gt;neighbor(f),</div><div class="line">                                  cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">    assemble_interface_term (elasticity_fe_face_values, stokes_fe_face_values,</div><div class="line">                             elasticity_phi, stokes_symgrad_phi_u, stokes_phi_p,</div><div class="line">                             local_interface_matrix);</div><div class="line"></div><div class="line">    cell-&gt;neighbor(f)-&gt;get_dof_indices (neighbor_dof_indices);</div><div class="line">    constraints.distribute_local_to_global(local_interface_matrix,</div><div class="line">                                           local_dof_indices,</div><div class="line">                                           neighbor_dof_indices,</div><div class="line">                                           system_matrix);</div><div class="line">  }</div></div><!-- fragment --><p>The second case is if the neighbor has further children. In that case, we have to loop over all the children of the neighbor to see if they are part of the fluid subdomain. If they are, then we integrate over the common interface, which is a face for the neighbor and a subface of the current cell, requiring us to use an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> for the neighbor and an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> for the current cell:</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">         &amp;&amp;</div><div class="line">         (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">true</span>))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface=0;</div><div class="line">         subface&lt;cell-&gt;face(f)-&gt;n_children();</div><div class="line">         ++subface)</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell-&gt;neighbor_child_on_subface</div><div class="line">                                   (f, subface)))</div><div class="line">        {</div><div class="line">          elasticity_fe_subface_values.reinit (cell,</div><div class="line">                                               f,</div><div class="line">                                               subface);</div><div class="line">          stokes_fe_face_values.reinit (cell-&gt;neighbor_child_on_subface (f, subface),</div><div class="line">                                        cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">          assemble_interface_term (elasticity_fe_subface_values,</div><div class="line">                                   stokes_fe_face_values,</div><div class="line">                                   elasticity_phi,</div><div class="line">                                   stokes_symgrad_phi_u, stokes_phi_p,</div><div class="line">                                   local_interface_matrix);</div><div class="line"></div><div class="line">          cell-&gt;neighbor_child_on_subface (f, subface)</div><div class="line">          -&gt;get_dof_indices (neighbor_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(local_interface_matrix,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 neighbor_dof_indices,</div><div class="line">                                                 system_matrix);</div><div class="line">        }</div><div class="line">  }</div></div><!-- fragment --><p>The last option is that the neighbor is coarser. In that case we have to use an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object for the neighbor and a <a class="el" href="classFEFaceValues.html">FEFaceValues</a> for the current cell; the rest is the same as before:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor_is_coarser(f)</div><div class="line">                       &amp;&amp;</div><div class="line">                       cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                {</div><div class="line">                  elasticity_fe_face_values.reinit (cell, f);</div><div class="line">                  stokes_fe_subface_values.reinit (cell-&gt;neighbor(f),</div><div class="line">                                                   cell-&gt;neighbor_of_coarser_neighbor(f).first,</div><div class="line">                                                   cell-&gt;neighbor_of_coarser_neighbor(f).second);</div><div class="line"></div><div class="line">                  assemble_interface_term (elasticity_fe_face_values,</div><div class="line">                                           stokes_fe_subface_values,</div><div class="line">                                           elasticity_phi,</div><div class="line">                                           stokes_symgrad_phi_u, stokes_phi_p,</div><div class="line">                                           local_interface_matrix);</div><div class="line"></div><div class="line">                  cell-&gt;neighbor(f)-&gt;get_dof_indices (neighbor_dof_indices);</div><div class="line">                  constraints.distribute_local_to_global(local_interface_matrix,</div><div class="line">                                                         local_dof_indices,</div><div class="line">                                                         neighbor_dof_indices,</div><div class="line">                                                         system_matrix);</div><div class="line"></div><div class="line">                }</div><div class="line">            }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In the function that assembles the global system, we passed computing interface terms to a separate function we discuss here. The key is that even though we can't predict the combination of <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects, they are both derived from the <a class="el" href="classFEFaceValuesBase.html">FEFaceValuesBase</a> class and consequently we don't have to care: the function is simply called with two such objects denoting the values of the shape functions on the quadrature points of the two sides of the face. We then do what we always do: we fill the scratch arrays with the values of shape functions and their derivatives, and then loop over all entries of the matrix to compute the local integrals. The details of the bilinear form we evaluate here are given in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">FluidStructureProblem&lt;dim&gt;::</div><div class="line">assemble_interface_term (<span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>          &amp;elasticity_fe_face_values,</div><div class="line">                         <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>          &amp;stokes_fe_face_values,</div><div class="line">                         std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;          &amp;elasticity_phi,</div><div class="line">                         std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt; &amp;stokes_symgrad_phi_u,</div><div class="line">                         std::vector&lt;double&gt;                  &amp;stokes_phi_p,</div><div class="line">                         <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   &amp;local_interface_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a> ==</div><div class="line">          elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>,</div><div class="line">          ExcInternalError());</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_quadrature_points</div><div class="line">    = elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements (dim+1);</div><div class="line"></div><div class="line">  local_interface_matrix = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_quadrature_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> normal_vector = stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">        stokes_symgrad_phi_u[k] = stokes_fe_face_values[velocities].symmetric_gradient (k, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">        elasticity_phi[k] = elasticity_fe_face_values[displacements].value (k,q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">          local_interface_matrix(i,j) += -((2 * viscosity *</div><div class="line">                                            (stokes_symgrad_phi_u[j] *</div><div class="line">                                             normal_vector)</div><div class="line">                                            +</div><div class="line">                                            stokes_phi_p[j] *</div><div class="line">                                            normal_vector) *</div><div class="line">                                           elasticity_phi[i] *</div><div class="line">                                           stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemsolvecode"></a> </p><h4><code>FluidStructureProblem::solve</code></h4>
<p>As discussed in the introduction, we use a rather trivial solver here: we just pass the linear system off to the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct solver (see, for example, <a class="el" href="step_29.html">step-29</a>). The only thing we have to do after solving is ensure that hanging node and boundary value constraints are correct.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">FluidStructureProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a> (system_matrix);</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a> (solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute (solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemoutput_resultscode"></a> </p><h4><code>FluidStructureProblem::output_results</code></h4>
<p>Generating graphical output is rather trivial here: all we have to do is identify which components of the solution vector belong to scalars and/or vectors (see, for example, <a class="el" href="step_22.html">step-22</a> for a previous example), and then pass it all on to the <a class="el" href="classDataOut.html">DataOut</a> class (with the second template argument equal to <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> instead of the usual default <a class="el" href="classDoFHandler.html">DoFHandler</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">FluidStructureProblem&lt;dim&gt;::</div><div class="line">output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names (dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.push_back (<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  data_component_interpretation</div><div class="line">  (dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation</div><div class="line">  .push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">    data_component_interpretation</div><div class="line">    .push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim,hp::DoFHandler&lt;dim&gt;</a> &gt; data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, solution_names,</div><div class="line">                            <a class="code" href="classDataOut.html">DataOut</a>&lt;dim,<a class="code" href="classhp_1_1DoFHandler.html">hp::DoFHandler&lt;dim&gt;</a> &gt;::type_dof_data,</div><div class="line">                            data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  std::ostringstream filename;</div><div class="line">  filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div><div class="line">           &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (refinement_cycle, 2)</div><div class="line">           &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line"></div><div class="line">  std::ofstream output (filename.str().c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemrefine_meshcode"></a> </p><h4><code>FluidStructureProblem::refine_mesh</code></h4>
<p>The next step is to refine the mesh. As was discussed in the introduction, this is a bit tricky primarily because the fluid and the solid subdomains use variables that have different physical dimensions and for which the absolute magnitude of error estimates is consequently not directly comparable. We will therefore have to scale them. At the top of the function, we therefore first compute error estimates for the different variables separately (using the velocities but not the pressure for the fluid domain, and the displacements in the solid domain):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">FluidStructureProblem&lt;dim&gt;::refine_mesh ()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a></div><div class="line">  stokes_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a></div><div class="line">  elasticity_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; stokes_face_quadrature(stokes_degree+2);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; elasticity_face_quadrature(elasticity_degree+2);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim-1&gt; face_q_collection;</div><div class="line">  face_q_collection.<a class="code" href="classhp_1_1QCollection.html#a166f1c95b492e6293215998210caf605">push_back</a> (stokes_face_quadrature);</div><div class="line">  face_q_collection.push_back (elasticity_face_quadrature);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                      face_q_collection,</div><div class="line">                                      <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                      solution,</div><div class="line">                                      stokes_estimated_error_per_cell,</div><div class="line">                                      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim+1);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                      face_q_collection,</div><div class="line">                                      <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                      solution,</div><div class="line">                                      elasticity_estimated_error_per_cell,</div><div class="line">                                      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div></div><!-- fragment --><p>We then normalize error estimates by dividing by their norm and scale the fluid error indicators by a factor of 4 as discussed in the introduction. The results are then added together into a vector that contains error indicators for all cells:</p>
<div class="fragment"><div class="line">stokes_estimated_error_per_cell</div><div class="line">*= 4. / stokes_estimated_error_per_cell.l2_norm();</div><div class="line">elasticity_estimated_error_per_cell</div><div class="line">*= 1. / elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a></div><div class="line">estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">estimated_error_per_cell += elasticity_estimated_error_per_cell;</div></div><!-- fragment --><p>The second to last part of the function, before actually refining the mesh, involves a heuristic that we have already mentioned in the introduction: because the solution is discontinuous, the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class gets all confused about cells that sit at the boundary between subdomains: it believes that the error is large there because the jump in the gradient is large, even though this is entirely expected and a feature that is in fact present in the exact solution as well and therefore not indicative of any numerical error.</p>
<p>Consequently, we set the error indicators to zero for all cells at the interface; the conditions determining which cells this affects are slightly awkward because we have to account for the possibility of adaptively refined meshes, meaning that the neighboring cell can be coarser than the current one, or could in fact be refined some more. The structure of these nested conditions is much the same as we encountered when assembling interface terms in <code>assemble_system</code>.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">       cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">       cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_solid_domain (cell))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>)</div><div class="line">              &amp;&amp;</div><div class="line">              (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">false</span>)</div><div class="line">                &amp;&amp;</div><div class="line">                cell_is_in_fluid_domain (cell-&gt;neighbor(f)))</div><div class="line">               ||</div><div class="line">               ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">true</span>)</div><div class="line">                &amp;&amp;</div><div class="line">                (cell_is_in_fluid_domain (cell-&gt;neighbor_child_on_subface</div><div class="line">                                          (f, 0))))</div><div class="line">               ||</div><div class="line">               (cell-&gt;neighbor_is_coarser(f)</div><div class="line">                &amp;&amp;</div><div class="line">                cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">              ))</div><div class="line">            estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>)</div><div class="line">              &amp;&amp;</div><div class="line">              (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">false</span>)</div><div class="line">                &amp;&amp;</div><div class="line">                cell_is_in_solid_domain (cell-&gt;neighbor(f)))</div><div class="line">               ||</div><div class="line">               ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">true</span>)</div><div class="line">                &amp;&amp;</div><div class="line">                (cell_is_in_solid_domain (cell-&gt;neighbor_child_on_subface</div><div class="line">                                          (f, 0))))</div><div class="line">               ||</div><div class="line">               (cell-&gt;neighbor_is_coarser(f)</div><div class="line">                &amp;&amp;</div><div class="line">                cell_is_in_solid_domain(cell-&gt;neighbor(f)))</div><div class="line">              ))</div><div class="line">            estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                   estimated_error_per_cell,</div><div class="line">                                                   0.3, 0.0);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemruncode"></a> </p><h4><code>FluidStructureProblem::run</code></h4>
<p>This is, as usual, the function that controls the overall flow of operation. If you've read through tutorial programs <a class="el" href="step_1.html">step-1</a> through <a class="el" href="step_6.html">step-6</a>, for example, then you are already quite familiar with the following structure:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid ();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle&lt;10-2*dim;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh ();</div><div class="line"></div><div class="line">        setup_dofs ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_system ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing output...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        output_results (refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h4>The <code>main()</code> function</h4>
<p>This, final, function contains pretty much exactly what most of the other tutorial programs have:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step46;</div><div class="line"></div><div class="line">      FluidStructureProblem&lt;2&gt; flow_problem(1, 1);</div><div class="line">      flow_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="2dresults"></a></p><h3>2d results</h3>
<p>When running the program, you should get output like the following: </p><div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 64</div><div class="line">   Number of degrees of freedom: 531</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 136</div><div class="line">   Number of degrees of freedom: 1260</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 412</div><div class="line">   Number of degrees of freedom: 3667</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 1216</div><div class="line">   Number of degrees of freedom: 9999</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 2788</div><div class="line">   Number of degrees of freedom: 18537</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 6496</div><div class="line">   Number of degrees of freedom: 35985</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div></div><!-- fragment --><p>The results are easily visualized:</p>
<table width="60%" align="center">
<tr valign="top">
<td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.velocity-magnitude.png"/>
</div>
<p></p>
<p>Magnitude of the fluid velocity. </p>
<p></p>
<p class="endtd"></p>
</td><td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.pressure.png"/>
</div>
<p></p>
<p>Fluid pressure. The dynamic range has been truncated to cut off the pressure singularities at the top left and right corners of the domain as well as the top corners of the solid that forms re-entrant corners into the fluid domain. </p>
<p class="endtd"></p>
</td></tr>
<tr valign="top">
<td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.velocity.png"/>
</div>
<p></p>
<p>Fluid velocity. </p>
<p></p>
<p class="endtd"></p>
</td><td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.displacement.png"/>
</div>
<p></p>
<p>Solid displacement. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>In all figures, we have applied a mask to only show the original field, not the one extended by zero: for example, to plot the pressure, we have selected that part of the domain where the magnitude of the velocity is greater than <img class="formulaInl" alt="$10^{-7}$" src="form_3859.png"/>.</p>
<p>The plots are easily interpreted: as the flow drives down on the left side and up on the right side of the upright part of the solid, it produces a shear force that pulls the left side down and the right side up. An additional part force comes from the pressure, which bears down on the left side of the top and pulls up on the right side. Both forces yield a net torque on the solid that bends it to the left, as confirmed by the plot of the displacement vectors.</p>
<p><a class="anchor" id="3dresults"></a></p><h3>3d results</h3>
<p>By changing the dimension of the <code>FluidStructureProblem</code> class in <code>main()</code> to 3, we can also run the same problem 3d. You'd get output along the following lines: </p><div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 512</div><div class="line">   Number of degrees of freedom: 11631</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 1716</div><div class="line">   Number of degrees of freedom: 48984</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 8534</div><div class="line">   Number of degrees of freedom: 245647</div><div class="line">   Assembling...</div><div class="line">   Solving...</div></div><!-- fragment --><p> You'll notice that the big bottleneck is the solver: SparseDirectUmfpack needs approximately 8 hours and some 42 GB of memory to solve the last iteration of this problem on a 2010 workstation (the second to last iteration took only 6 minutes). Clearly a better solver is needed here, a topic discussed below.</p>
<p>The results can also be visualized and yield some good pictures:</p>
<table width="60%" align="center">
<tr valign="top">
<td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.3d.velocity.png"/>
</div>
<p></p>
<p>Vectors of the fluid velocity and magnitude of the displacement of the solid part. </p>
<p></p>
<p class="endtd"></p>
</td><td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.3d.streamlines.png"/>
</div>
<p></p>
<p>Streamlines of the velocity, with the mesh superimposed. </p>
<p class="endtd"></p>
</td></tr>
<tr valign="top">
<td valign="top" align="center" colspan="2"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.3d.displacement.png"/>
</div>
<p></p>
<p>Solid displacement. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>In addition to the lack of a good solver, the mesh is a bit unbalanced: mesh refinement heavily favors the fluid subdomain (in 2d, it was the other way around, prompting us to weigh the fluid error indicators higher). Clearly, some tweaking of the relative importance of error indicators in the two subdomains is important if one wanted to go on doing more 3d computations.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Linearsolversandpreconditioners"></a></p><h4>Linear solvers and preconditioners</h4>
<p>An obvious place to improve the program would be to use a more sophisticated solver &mdash; in particular one that scales well and will also work for realistic 3d problems. This shouldn't actually be too hard to achieve here, because of the one-way coupling from fluid into solid. To this end, assume we had re-ordered degrees of freedom in such a way that we first have all velocity and pressure degrees of freedom, and then all displacements (this is easily possible using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>). Then the system matrix could be split into the following block form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_\text{global} = \begin{pmatrix} A_{\text{fluid}} &amp; 0 \\ B &amp; A_{\text{solid}} \end{pmatrix} \]" src="form_3860.png"/>
</p>
<p> where <img class="formulaInl" alt="$A_{\text{fluid}}$" src="form_3861.png"/> is the Stokes matrix for velocity and pressure (it could be further subdivided into a <img class="formulaInl" alt="$2\times 2$" src="form_67.png"/> matrix as in <a class="el" href="step_22.html">step-22</a>, though this is immaterial for the current purpose), <img class="formulaInl" alt="$A_{\text{solid}}$" src="form_3862.png"/> results from the elasticity equations for the displacements, and <img class="formulaInl" alt="$B$" src="form_65.png"/> is the matrix that comes from the interface conditions. Now notice that the matrix </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A_\text{global}^{-1} = \begin{pmatrix} A_{\text{fluid}}^{-1} &amp; 0 \\ -A_\text{solid}^{-1} B A_\text{fluid}^{-1} &amp; A_{\text{solid}}^{-1} \end{pmatrix} \]" src="form_3863.png"/>
</p>
<p> is the inverse of <img class="formulaInl" alt="$A_\text{global}$" src="form_3864.png"/>. Applying this matrix requires only one solve with <img class="formulaInl" alt="$A_\text{fluid}$" src="form_3865.png"/> and <img class="formulaInl" alt="$A_\text{solid}$" src="form_3866.png"/> each since </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{pmatrix} p_x \\ p_y \end{pmatrix} = \begin{pmatrix} A_{\text{fluid}}^{-1} &amp; 0 \\ -A_\text{solid}^{-1} B A_\text{fluid}^{-1} &amp; A_{\text{solid}}^{-1} \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} \]" src="form_3867.png"/>
</p>
<p> can be computed as <img class="formulaInl" alt="$p_x = A_{\text{fluid}}^{-1} x$" src="form_3868.png"/> followed by <img class="formulaInl" alt="$p_y = A_{\text{solid}}^{-1} (y-Bp_x)$" src="form_3869.png"/>.</p>
<p>One can therefore expect that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \widetilde{A_\text{global}^{-1}} = \begin{pmatrix} \widetilde{A_{\text{fluid}}^{-1}} &amp; 0 \\ -\widetilde{A_\text{solid}^{-1}} B \widetilde{A_\text{fluid}^{-1}} &amp; \widetilde{A_{\text{solid}}^{-1}} \end{pmatrix} \]" src="form_3870.png"/>
</p>
<p> would be a good preconditioner if <img class="formulaInl" alt="$\widetilde{A_{\text{fluid}}^{-1}} \approx A_{\text{fluid}}^{-1}, \widetilde{A_{\text{solid}}^{-1}} \approx A_{\text{solid}}^{-1}$" src="form_3871.png"/>.</p>
<p>That means, we only need good preconditioners for Stokes and the elasticity equations separately. These are well known: for Stokes, we can use the preconditioner discussed in the results section of <a class="el" href="step_22.html">step-22</a>; for elasticity, a good preconditioner would be a single V-cycle of a geometric or algebraic multigrid. There are more open questions, however: For an "optimized" solver block-triangular preconditioner built from two sub-preconditioners, one point that often comes up is that, when choosing parameters for the sub-preconditioners, values that work well when solving the two problems separately may not be optimal when combined into a multiphysics preconditioner. In particular, when solving just a solid or fluid mechanics problem separately, the balancing act between the number of iterations to convergence and the cost of applying the preconditioner on a per iteration basis may lead one to choose an expensive preconditioner for the Stokes problem and a cheap preconditioner for the elasticity problem (or vice versa). When combined, however, there is the additional constraint that you want the two sub-preconditioners to converge at roughly the same rate, or else the cheap one may drive up the global number of iterations while the expensive one drives up the cost-per-iteration. For example, while a single AMG V-cycle is a good approach for elasticity by itself, when combined into a multiphysics problem there may be an incentive to using a full W-cycle or multiple cycles to help drive down the total solve time.</p>
<p><a class="anchor" id="Refinementindicators"></a></p><h4>Refinement indicators</h4>
<p>As mentioned in the introduction, the refinement indicator we use for this program is rather ad hoc. A better one would understand that the jump in the gradient of the solution across the interface is not indicative of the error but to be expected and ignore the interface when integrating the jump terms. Nevertheless, this is not what the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class does. Another, bigger question, is whether this kind of estimator is a good strategy in the first place: for example, if we want to have maximal accuracy in one particular aspect of the displacement (e.g. the displacement at the top right corner of the solid), then is it appropriate to scale the error indicators for fluid and solid to the same magnitude? Maybe it is necessary to solve the fluid problem with more accuracy than the solid because the fluid solution directly affects the solids solution? Maybe the other way around?</p>
<p>Consequently, an obvious possibility for improving the program would be to implement a better refinement criterion. There is some literature on this topic; one of a variety of possible starting points would be the paper by Thomas Wick on "Adaptive finite elements for monolithic fluid-structure
interaction on a prolongated domain: Applied to an heart valve simulation", Proceedings of the Computer Methods in Mechanics Conference 2011 (CMM-2011), 9-12 May 2011, Warszaw, Poland.</p>
<p><a class="anchor" id="Verification"></a></p><h4>Verification</h4>
<p>The results above are purely qualitative as there is no evidence that our scheme in fact converges. An obvious thing to do would therefore be to add some quantitative measures to check that the scheme at least converges to <em>something</em>. For example, we could output for each refinement cycle the deflection of the top right corner of the part of the solid that protrudes into the fluid subdomain. Or we could compute the net force vector or torque the fluid exerts on the solid.</p>
<p><a class="anchor" id="Bettermodels"></a></p><h4>Better models</h4>
<p>In reality, most fluid structure interaction problems are so that the movement of the solid does affect the flow of the fluid. For example, the forces of the air around an air foil cause it to flex and to change its shape. Likewise, a flag flaps in the wind, completely changing its shape.</p>
<p>Such problems where the coupling goes both ways are typically handled in an Arbitrary Lagrangian Eulerian (ALE) framework, in which the displacement of the solid is extended into the fluid domain in some smooth way, rather than by zero as we do here. The extended displacement field is then used to deform the mesh on which we compute the fluid flow. Furthermore, the boundary conditions for the fluid on the interface are no longer that the velocity is zero; rather, in a time dependent program, the fluid velocity must be equal to the time derivative of the displacement along the interface. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2011 - 2015 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_nothing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/fe_collection.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/hp/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step46</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>FluidStructureProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    FluidStructureProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree);</div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span></div><div class="line">    {</div><div class="line">      fluid_domain_id,</div><div class="line">      solid_domain_id</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span></div><div class="line">    cell_is_in_fluid_domain (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">hp::DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span></div><div class="line">    cell_is_in_solid_domain (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">hp::DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_grid ();</div><div class="line">    <span class="keywordtype">void</span> set_active_fe_indices ();</div><div class="line">    <span class="keywordtype">void</span> setup_dofs ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_interface_term (<span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>          &amp;elasticity_fe_face_values,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>          &amp;stokes_fe_face_values,</div><div class="line">                                  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;          &amp;elasticity_phi,</div><div class="line">                                  std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt; &amp;stokes_symgrad_phi_u,</div><div class="line">                                  std::vector&lt;double&gt;                  &amp;stokes_phi_p,</div><div class="line">                                  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   &amp;local_interface_matrix) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> refine_mesh ();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    stokes_degree;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    elasticity_degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    triangulation;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         stokes_fe;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         elasticity_fe;</div><div class="line">    <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div><div class="line">    <a class="code" href="classhp_1_1DoFHandler.html">hp::DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>      constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>       sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>  system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>        solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>        system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>          viscosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>          lambda;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>          mu;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesBoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1+dim) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  StokesBoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component &lt; this-&gt;n_components,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (component == dim-1)</div><div class="line">      <span class="keywordflow">switch</span> (dim)</div><div class="line">        {</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          <span class="keywordflow">return</span> std::sin(<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*p[0]);</div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          <span class="keywordflow">return</span> std::sin(<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*p[0]) * std::sin(<a class="code" href="namespacenumbers.html#a5ee2b45bb5bf8e0ab30d95a6afd0a4e8">numbers::PI</a>*p[1]);</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  StokesBoundaryValues&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                           <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;this-&gt;n_components; ++c)</div><div class="line">      values(c) = StokesBoundaryValues&lt;dim&gt;::value (p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim+1) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;value) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>  &amp;<span class="comment">/*p*/</span>,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  RightHandSide&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;this-&gt;n_components; ++c)</div><div class="line">      values(c) = RightHandSide&lt;dim&gt;::value (p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  FluidStructureProblem&lt;dim&gt;::</div><div class="line">  FluidStructureProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree)</div><div class="line">    :</div><div class="line">    stokes_degree (stokes_degree),</div><div class="line">    elasticity_degree (elasticity_degree),</div><div class="line">    triangulation (<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing),</div><div class="line">    stokes_fe (<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree+1), dim,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1,</div><div class="line">               <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(), dim),</div><div class="line">    elasticity_fe (<a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(), dim,</div><div class="line">                   <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(), 1,</div><div class="line">                   <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(elasticity_degree), dim),</div><div class="line">    dof_handler (triangulation),</div><div class="line">    viscosity (2),</div><div class="line">    lambda (1),</div><div class="line">    mu (1)</div><div class="line">  {</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a> (stokes_fe);</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a> (elasticity_fe);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span></div><div class="line">  FluidStructureProblem&lt;dim&gt;::</div><div class="line">  cell_is_in_fluid_domain (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">hp::DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> (cell-&gt;material_id() == fluid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span></div><div class="line">  FluidStructureProblem&lt;dim&gt;::</div><div class="line">  cell_is_in_solid_domain (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga60277a8a3957ba4b41c1e76a87decd30">hp::DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> (cell-&gt;material_id() == solid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  FluidStructureProblem&lt;dim&gt;::make_grid ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">GridGenerator::subdivided_hyper_cube</a> (triangulation, 8, -1, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">         cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary()</div><div class="line">            &amp;&amp;</div><div class="line">            (cell-&gt;face(f)-&gt;center()[dim-1] == 1))</div><div class="line">          cell-&gt;face(f)-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">         cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">if</span> (((std::fabs(cell-&gt;center()[0]) &lt; 0.25)</div><div class="line">           &amp;&amp;</div><div class="line">           (cell-&gt;center()[dim-1] &gt; 0.5))</div><div class="line">          ||</div><div class="line">          ((std::fabs(cell-&gt;center()[0]) &gt;= 0.25)</div><div class="line">           &amp;&amp;</div><div class="line">           (cell-&gt;center()[dim-1] &gt; -0.5)))</div><div class="line">        cell-&gt;set_material_id (fluid_domain_id);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        cell-&gt;set_material_id (solid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  FluidStructureProblem&lt;dim&gt;::set_active_fe_indices ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">         cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          cell-&gt;set_active_fe_index (0);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          cell-&gt;set_active_fe_index (1);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  FluidStructureProblem&lt;dim&gt;::setup_dofs ()</div><div class="line">  {</div><div class="line">    set_active_fe_indices ();</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe_collection);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.clear ();</div><div class="line">      <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (dof_handler,</div><div class="line">                                               constraints);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                                1,</div><div class="line">                                                StokesBoundaryValues&lt;dim&gt;(),</div><div class="line">                                                constraints,</div><div class="line">                                                fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim+1);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                                0,</div><div class="line">                                                <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(dim+1+dim),</div><div class="line">                                                constraints,</div><div class="line">                                                fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_face_dof_indices (stokes_fe.dofs_per_face);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">           cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">           cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell))</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">            <span class="keywordflow">if</span> (!cell-&gt;at_boundary(f))</div><div class="line">              {</div><div class="line">                <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">false</span>)</div><div class="line">                    &amp;&amp;</div><div class="line">                    (cell_is_in_solid_domain (cell-&gt;neighbor(f))))</div><div class="line">                  face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">true</span>)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf=0; sf&lt;cell-&gt;face(f)-&gt;n_children(); ++sf)</div><div class="line">                      <span class="keywordflow">if</span> (cell_is_in_solid_domain (cell-&gt;neighbor_child_on_subface</div><div class="line">                                                   (f, sf)))</div><div class="line">                        {</div><div class="line">                          face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                          <span class="keywordflow">break</span>;</div><div class="line">                        }</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">                  {</div><div class="line">                    cell-&gt;face(f)-&gt;get_dof_indices (local_face_dof_indices, 0);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;local_face_dof_indices.size(); ++i)</div><div class="line">                      <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt; dim)</div><div class="line">                        constraints.add_line (local_face_dof_indices[i]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">    }</div><div class="line"></div><div class="line">    constraints.close ();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> cell_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                                 fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line">      <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> face_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                                 fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++d)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (((c&lt;dim+1) &amp;&amp; (d&lt;dim+1)</div><div class="line">                 &amp;&amp; !((c==dim) &amp;&amp; (d==dim)))</div><div class="line">                ||</div><div class="line">                ((c&gt;=dim+1) &amp;&amp; (d&gt;=dim+1)))</div><div class="line">              cell_coupling[c][d] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ((c&gt;=dim+1) &amp;&amp; (d&lt;dim+1))</div><div class="line">              face_coupling[c][d] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          }</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaff02f744dd1e598c12dce9b9db76d115">DoFTools::make_flux_sparsity_pattern</a> (dof_handler, dsp,</div><div class="line">                                            cell_coupling, face_coupling);</div><div class="line">      constraints.condense (dsp);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a> (dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line"></div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    system_matrix=0;</div><div class="line">    system_rhs=0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> stokes_quadrature(stokes_degree+2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> elasticity_quadrature(elasticity_degree+2);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a>  q_collection;</div><div class="line">    q_collection.<a class="code" href="classhp_1_1QCollection.html#a166f1c95b492e6293215998210caf605">push_back</a> (stokes_quadrature);</div><div class="line">    q_collection.<a class="code" href="classhp_1_1QCollection.html#a166f1c95b492e6293215998210caf605">push_back</a> (elasticity_quadrature);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values (fe_collection, q_collection,</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; common_face_quadrature(std::max (stokes_degree+2,</div><div class="line">                                                         elasticity_degree+2));</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    stokes_fe_face_values (stokes_fe,</div><div class="line">                                                common_face_quadrature,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    elasticity_fe_face_values (elasticity_fe,</div><div class="line">                                                    common_face_quadrature,</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> stokes_fe_subface_values (stokes_fe,</div><div class="line">                                                   common_face_quadrature,</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> elasticity_fe_subface_values (elasticity_fe,</div><div class="line">                                                       common_face_quadrature,</div><div class="line">                                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_dofs_per_cell     = stokes_fe.dofs_per_cell;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        elasticity_dofs_per_cell = elasticity_fe.dofs_per_cell;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        local_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        local_interface_matrix (elasticity_dofs_per_cell,</div><div class="line">                                                      stokes_dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            local_rhs;</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; neighbor_dof_indices (stokes_dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities (0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure (dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     displacements (dim+1);</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2,dim&gt; &gt; stokes_symgrad_phi_u (stokes_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  stokes_div_phi_u     (stokes_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  stokes_phi_p         (stokes_dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2,dim&gt; &gt;          elasticity_grad_phi (elasticity_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  elasticity_div_phi  (elasticity_dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1,dim&gt; &gt;          elasticity_phi      (elasticity_dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        hp_fe_values.reinit (cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a4bc26790261f1f9f4cc7e8e69e3d7920">get_present_fe_values</a>();</div><div class="line"></div><div class="line">        local_matrix.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell,</div><div class="line">                             cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell);</div><div class="line">        local_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell;</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dofs_per_cell == stokes_dofs_per_cell,</div><div class="line">                    <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">                  {</div><div class="line">                    stokes_symgrad_phi_u[k] = fe_values[velocities].symmetric_gradient (k, q);</div><div class="line">                    stokes_div_phi_u[k]     = fe_values[velocities].divergence (k, q);</div><div class="line">                    stokes_phi_p[k]         = fe_values[pressure].value (k, q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                    local_matrix(i,j) += (2 * viscosity * stokes_symgrad_phi_u[i] * stokes_symgrad_phi_u[j]</div><div class="line">                                          - stokes_div_phi_u[i] * stokes_phi_p[j]</div><div class="line">                                          - stokes_phi_p[i] * stokes_div_phi_u[j])</div><div class="line">                                         * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell;</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dofs_per_cell == elasticity_dofs_per_cell,</div><div class="line">                    <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;dofs_per_cell; ++k)</div><div class="line">                  {</div><div class="line">                    elasticity_grad_phi[k] = fe_values[displacements].gradient (k, q);</div><div class="line">                    elasticity_div_phi[k]  = fe_values[displacements].divergence (k, q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                    {</div><div class="line">                      local_matrix(i,j)</div><div class="line">                      +=  (lambda *</div><div class="line">                           elasticity_div_phi[i] * elasticity_div_phi[j]</div><div class="line">                           +</div><div class="line">                           mu *</div><div class="line">                           scalar_product(elasticity_grad_phi[i], elasticity_grad_phi[j])</div><div class="line">                           +</div><div class="line">                           mu *</div><div class="line">                           scalar_product(elasticity_grad_phi[i], transpose(elasticity_grad_phi[j]))</div><div class="line">                          )</div><div class="line">                          *</div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                    }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        local_dof_indices.resize (cell-&gt;<a class="code" href="classhp_1_1DoFHandler.html#ae51d585fc36bf7f4b4ddbe24b7559ac7">get_fe</a>().dofs_per_cell);</div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global (local_matrix, local_rhs,</div><div class="line">                                                local_dof_indices,</div><div class="line">                                                system_matrix, system_rhs);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_solid_domain (cell))</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;at_boundary(f) == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                    &amp;&amp;</div><div class="line">                    (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">false</span>)</div><div class="line">                    &amp;&amp;</div><div class="line">                    cell_is_in_fluid_domain (cell-&gt;neighbor(f)))</div><div class="line">                  {</div><div class="line">                    elasticity_fe_face_values.reinit (cell, f);</div><div class="line">                    stokes_fe_face_values.reinit (cell-&gt;neighbor(f),</div><div class="line">                                                  cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">                    assemble_interface_term (elasticity_fe_face_values, stokes_fe_face_values,</div><div class="line">                                             elasticity_phi, stokes_symgrad_phi_u, stokes_phi_p,</div><div class="line">                                             local_interface_matrix);</div><div class="line"></div><div class="line">                    cell-&gt;neighbor(f)-&gt;get_dof_indices (neighbor_dof_indices);</div><div class="line">                    constraints.distribute_local_to_global(local_interface_matrix,</div><div class="line">                                                           local_dof_indices,</div><div class="line">                                                           neighbor_dof_indices,</div><div class="line">                                                           system_matrix);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                         &amp;&amp;</div><div class="line">                         (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">true</span>))</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface=0;</div><div class="line">                         subface&lt;cell-&gt;face(f)-&gt;n_children();</div><div class="line">                         ++subface)</div><div class="line">                      <span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell-&gt;neighbor_child_on_subface</div><div class="line">                                                   (f, subface)))</div><div class="line">                        {</div><div class="line">                          elasticity_fe_subface_values.reinit (cell,</div><div class="line">                                                               f,</div><div class="line">                                                               subface);</div><div class="line">                          stokes_fe_face_values.reinit (cell-&gt;neighbor_child_on_subface (f, subface),</div><div class="line">                                                        cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">                          assemble_interface_term (elasticity_fe_subface_values,</div><div class="line">                                                   stokes_fe_face_values,</div><div class="line">                                                   elasticity_phi,</div><div class="line">                                                   stokes_symgrad_phi_u, stokes_phi_p,</div><div class="line">                                                   local_interface_matrix);</div><div class="line"></div><div class="line">                          cell-&gt;neighbor_child_on_subface (f, subface)</div><div class="line">                          -&gt;get_dof_indices (neighbor_dof_indices);</div><div class="line">                          constraints.distribute_local_to_global(local_interface_matrix,</div><div class="line">                                                                 local_dof_indices,</div><div class="line">                                                                 neighbor_dof_indices,</div><div class="line">                                                                 system_matrix);</div><div class="line">                        }</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor_is_coarser(f)</div><div class="line">                         &amp;&amp;</div><div class="line">                         cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                  {</div><div class="line">                    elasticity_fe_face_values.reinit (cell, f);</div><div class="line">                    stokes_fe_subface_values.reinit (cell-&gt;neighbor(f),</div><div class="line">                                                     cell-&gt;neighbor_of_coarser_neighbor(f).first,</div><div class="line">                                                     cell-&gt;neighbor_of_coarser_neighbor(f).second);</div><div class="line"></div><div class="line">                    assemble_interface_term (elasticity_fe_face_values,</div><div class="line">                                             stokes_fe_subface_values,</div><div class="line">                                             elasticity_phi,</div><div class="line">                                             stokes_symgrad_phi_u, stokes_phi_p,</div><div class="line">                                             local_interface_matrix);</div><div class="line"></div><div class="line">                    cell-&gt;neighbor(f)-&gt;get_dof_indices (neighbor_dof_indices);</div><div class="line">                    constraints.distribute_local_to_global(local_interface_matrix,</div><div class="line">                                                           local_dof_indices,</div><div class="line">                                                           neighbor_dof_indices,</div><div class="line">                                                           system_matrix);</div><div class="line"></div><div class="line">                  }</div><div class="line">              }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  FluidStructureProblem&lt;dim&gt;::</div><div class="line">  assemble_interface_term (<span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>          &amp;elasticity_fe_face_values,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a>          &amp;stokes_fe_face_values,</div><div class="line">                           std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt;          &amp;elasticity_phi,</div><div class="line">                           std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> &gt; &amp;stokes_symgrad_phi_u,</div><div class="line">                           std::vector&lt;double&gt;                  &amp;stokes_phi_p,</div><div class="line">                           <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   &amp;local_interface_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a> ==</div><div class="line">            elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>,</div><div class="line">            ExcInternalError());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_quadrature_points</div><div class="line">      = elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements (dim+1);</div><div class="line"></div><div class="line">    local_interface_matrix = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_face_quadrature_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> normal_vector = stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">          stokes_symgrad_phi_u[k] = stokes_fe_face_values[velocities].symmetric_gradient (k, q);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">          elasticity_phi[k] = elasticity_fe_face_values[displacements].value (k,q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">            local_interface_matrix(i,j) += -((2 * viscosity *</div><div class="line">                                              (stokes_symgrad_phi_u[j] *</div><div class="line">                                               <a class="code" href="classManifold.html#a8f737627dc946fb68c097d6ec83419d4">normal_vector</a>)</div><div class="line">                                              +</div><div class="line">                                              stokes_phi_p[j] *</div><div class="line">                                              normal_vector) *</div><div class="line">                                             elasticity_phi[i] *</div><div class="line">                                             stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  FluidStructureProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a> (system_matrix);</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a> (solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute (solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  FluidStructureProblem&lt;dim&gt;::</div><div class="line">  output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword">  const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names (dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">      solution_names.push_back (<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation</div><div class="line">    (dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation</div><div class="line">    .push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++d)</div><div class="line">      data_component_interpretation</div><div class="line">      .push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim,hp::DoFHandler&lt;dim&gt;</a> &gt; data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, solution_names,</div><div class="line">                              <a class="code" href="classDataOut.html">DataOut</a>&lt;dim,<a class="code" href="classhp_1_1DoFHandler.html">hp::DoFHandler&lt;dim&gt;</a> &gt;::type_dof_data,</div><div class="line">                              data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">    std::ostringstream filename;</div><div class="line">    filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span></div><div class="line">             &lt;&lt; <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (refinement_cycle, 2)</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line"></div><div class="line">    std::ofstream output (filename.str().c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  FluidStructureProblem&lt;dim&gt;::refine_mesh ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a></div><div class="line">    stokes_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a></div><div class="line">    elasticity_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; stokes_face_quadrature(stokes_degree+2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt; elasticity_face_quadrature(elasticity_degree+2);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim-1&gt; face_q_collection;</div><div class="line">    face_q_collection.<a class="code" href="classhp_1_1QCollection.html#a166f1c95b492e6293215998210caf605">push_back</a> (stokes_face_quadrature);</div><div class="line">    face_q_collection.push_back (elasticity_face_quadrature);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                        face_q_collection,</div><div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                        solution,</div><div class="line">                                        stokes_estimated_error_per_cell,</div><div class="line">                                        fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim+1);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                        face_q_collection,</div><div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                        solution,</div><div class="line">                                        elasticity_estimated_error_per_cell,</div><div class="line">                                        fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line"></div><div class="line">    stokes_estimated_error_per_cell</div><div class="line">    *= 4. / stokes_estimated_error_per_cell.l2_norm();</div><div class="line">    elasticity_estimated_error_per_cell</div><div class="line">    *= 1. / elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a></div><div class="line">    estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">    estimated_error_per_cell += elasticity_estimated_error_per_cell;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="group__Iterators.html#gafe703004a41973a6808c81d42ad7e7b1">hp::DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">         cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">         cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(); ++cell)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f=0; f&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++f)</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_solid_domain (cell))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>)</div><div class="line">                &amp;&amp;</div><div class="line">                (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                  &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">false</span>)</div><div class="line">                  &amp;&amp;</div><div class="line">                  cell_is_in_fluid_domain (cell-&gt;neighbor(f)))</div><div class="line">                 ||</div><div class="line">                 ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                  &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">true</span>)</div><div class="line">                  &amp;&amp;</div><div class="line">                  (cell_is_in_fluid_domain (cell-&gt;neighbor_child_on_subface</div><div class="line">                                            (f, 0))))</div><div class="line">                 ||</div><div class="line">                 (cell-&gt;neighbor_is_coarser(f)</div><div class="line">                  &amp;&amp;</div><div class="line">                  cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                ))</div><div class="line">              estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>)</div><div class="line">                &amp;&amp;</div><div class="line">                (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                  &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">false</span>)</div><div class="line">                  &amp;&amp;</div><div class="line">                  cell_is_in_solid_domain (cell-&gt;neighbor(f)))</div><div class="line">                 ||</div><div class="line">                 ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level())</div><div class="line">                  &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;<a class="code" href="classhp_1_1DoFHandler.html#af25e58a7f0bb297671c6d77ec644cbe2">has_children</a>() == <span class="keyword">true</span>)</div><div class="line">                  &amp;&amp;</div><div class="line">                  (cell_is_in_solid_domain (cell-&gt;neighbor_child_on_subface</div><div class="line">                                            (f, 0))))</div><div class="line">                 ||</div><div class="line">                 (cell-&gt;neighbor_is_coarser(f)</div><div class="line">                  &amp;&amp;</div><div class="line">                  cell_is_in_solid_domain(cell-&gt;neighbor(f)))</div><div class="line">                ))</div><div class="line">              estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">          }</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a2500638aae40fe3bfbf094754645dc57">GridRefinement::refine_and_coarsen_fixed_number</a> (triangulation,</div><div class="line">                                                     estimated_error_per_cell,</div><div class="line">                                                     0.3, 0.0);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid ();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle&lt;10-2*dim;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh ();</div><div class="line"></div><div class="line">        setup_dofs ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_system ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve ();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing output...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        output_results (refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step46;</div><div class="line"></div><div class="line">      FluidStructureProblem&lt;2&gt; flow_problem(1, 1);</div><div class="line">      flow_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
