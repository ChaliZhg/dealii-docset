<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-2 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-2 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Meshgeneration">Mesh generation</a>
        <li><a href="#CreationofaDoFHandler">Creation of a DoFHandler</a>
        <li><a href="#RenumberingofDoFs">Renumbering of DoFs</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibleextensions"> Possible extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.9.html">video lecture 9</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>After we have created a grid in the previous example, we now show how to define degrees of freedom on this mesh. For this example, we will use the lowest order ( <img class="formulaInl" alt="$Q_1$" src="form_37.png"/>) finite elements, for which the degrees of freedom are associated with the vertices of the mesh. Later examples will demonstrate higher order elements where degrees of freedom are not necessarily associated with vertices any more, but can be associated with edges, faces, or cells.</p>
<p>The term "degree of freedom" is commonly used in the finite element community to indicate two slightly different, but related things. The first is that we'd like to represent the finite element solution as a linear combination of shape function, in the form <img class="formulaInl" alt="$u_h(\mathbf x) = \sum_{j=0}^{N-1} U_j \varphi_j(\mathbf x)$" src="form_1657.png"/>. Here, <img class="formulaInl" alt="$U_j$" src="form_75.png"/> is a vector of expansion coefficients. Because we don't know their values yet (we will compute them as the solution of a linear or nonlinear system), they are called "unknowns" or "degrees of freedom". The second meaning of the term can be explained as follows: A mathematical description of finite element problem is often to say that we are looking for a finite dimensional function <img class="formulaInl" alt="$u_h \in V_h$" src="form_76.png"/> that satisfies some set of equations (e.g. <img class="formulaInl" alt="$a(u_h,\varphi_h)=(f,\varphi_h)$" src="form_77.png"/> for all test functions <img class="formulaInl" alt="$\varphi_h\in V_h$" src="form_78.png"/>). In other words, all we say here that the solution needs to lie in some space <img class="formulaInl" alt="$V_h$" src="form_79.png"/>. However, to actually solve this problem on a computer we need to choose a basis of this space; this is the set of shape functions <img class="formulaInl" alt="$\varphi_j(\mathbf x)$" src="form_1658.png"/> we have used above in the expansion of <img class="formulaInl" alt="$u_h(\mathbf x)$" src="form_81.png"/> with coefficients <img class="formulaInl" alt="$U_j$" src="form_75.png"/>. There are of course many bases of the space <img class="formulaInl" alt="$V_h$" src="form_79.png"/>, but we will specifically choose the one that is described by the finite element functions that are traditionally defined locally on the cells of the mesh. Describing "degrees of freedom" in this context requires us to simply <em>enumerate</em> the basis functions of the space <img class="formulaInl" alt="$V_h$" src="form_79.png"/>. For <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> elements this means simply enumerating the vertices of the mesh in some way, but for higher elements one also has to enumerate the shape functions that are associated with edges, faces, or cell interiors of the mesh. The class that provides this enumeration of the basis functions of <img class="formulaInl" alt="$V_h$" src="form_79.png"/> is called <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<p>Defining degrees of freedom ("DoF"s in short) on a mesh is a rather simple task, since the library does all the work for you. Essentially, all you have to do is create a finite element object (from one of the many finite element classes deal.II already has, see for example the <a class="el" href="group__fe.html">Finite element space descriptions</a> documentation) and give it to a <a class="el" href="classDoFHandler.html">DoFHandler</a> object through the <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a> function ("distributing DoFs" is the term we use to describe the process of enumerating the basis functions as discussed above). The <a class="el" href="classDoFHandler.html">DoFHandler</a> is a class that manages which degrees of freedom live where, i.e., it can answer questions like "how many degrees of freedom are there globally" and "on this cell, give me the global indices of the shape functions that
live here". This is the sort of information you need when determining how big your system matrix should be, and when copying the contributions of a single cell into the global matrix.</p>
<p>The next step would then be to compute a matrix and right hand side corresponding to a particular differential equation using this finite element and mesh. We will keep this step for the <a class="el" href="step_3.html">step-3</a> program and rather talk about one practical aspect of a finite element program, namely that finite element matrices are almost always very sparse, i.e. almost all entries in these matrices are zero. (To be more precise, we say a discretization leads to a sparse matrix if the number of nonzero entries <em>per row</em> in the matrix is bounded by a number that is independent of the overall number of degrees of freedom. For example, the simple 5-point stencil of a finite difference approximation of the Laplace equation leads to a sparse matrix since the number of nonzero entries per row is five, and therefore independent of the total size of the matrix.) Sparsity is one of the distinguishing feature of the finite element method compared to, say, approximating the solution of a partial differential equation using a Taylor expansion and matching coefficients, or using a Fourier basis.</p>
<p>In practical terms, it is the sparsity of matrices that enables us to solve problems with millions or billions of unknowns. To understand this, note that a matrix with <img class="formulaInl" alt="$N$" src="form_104.png"/> rows, each with a fixed upper bound for the number of nonzero entries, requires <img class="formulaInl" alt="${\cal O}(N)$" src="form_106.png"/> memory locations for storage, and a matrix-vector multiplication also requires only <img class="formulaInl" alt="${\cal O}(N)$" src="form_106.png"/> operations. Consequently, if we had a linear solver that requires only a fixed number of matrix-vector multiplications to come up with the solution of a linear system with this matrix, then we would have a solver that can find the values of all <img class="formulaInl" alt="$N$" src="form_104.png"/> unknowns with optimal complexity, i.e., with a total of <img class="formulaInl" alt="${\cal O}(N)$" src="form_106.png"/> operations. It is clear that this wouldn't be possible if the matrix were not sparse, but it also requires very specialized solvers such as multigrid methods to satisfy the requirement that the solution requires only a fixed number of matrix-vector multiplications. We will frequently look at the question of what solver to use in the remaining programs of this tutorial.</p>
<p>The sparsity is generated by the fact that finite element shape functions are defined locally on individual cells, rather than globally, and that the local differential operators in the bilinear form only couple shape functions that have some overlap. By default, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class enumerates degrees of freedom on a mesh in a rather random way; consequently, the sparsity pattern is also not optimized for any particular purpose. However, for some algorithms, especially for some linear solvers and preconditioners, it is advantageous to have the degrees of freedom numbered in a certain order, and we will use the algorithm of Cuthill and McKee to do so. This can be thought of as choosing a different, permuted basis of the finite element space. The results are written to a file and visualized using a simple visualization program; you get to see the outcome in the <a href="#Results">results section below</a>. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The first few includes are just like in the previous program, so do not require additional comments:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div></div><!-- fragment --><p>However, the next file is new. We need this include file for the association of degrees of freedom ("DoF"s) to vertices, lines, and cells:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div></div><!-- fragment --><p>The following include contains the description of the bilinear finite element, including the facts that it has one degree of freedom on each vertex of the triangulation, but none on faces and none in the interior of the cells.</p>
<p>(In fact, the file contains the description of Lagrange elements in general, i.e. also the quadratic, cubic, etc versions, and not only for 2d but also 1d and 3d.)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div></div><!-- fragment --><p>In the following file, several tools for manipulating degrees of freedom can be found:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div></div><!-- fragment --><p>We will use a sparse matrix to visualize the pattern of nonzero entries resulting from the distribution of degrees of freedom on the grid. That class can be found here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div></div><!-- fragment --><p>We will also need to use an intermediate sparsity pattern structure, which is found in this file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div></div><!-- fragment --><p>We will want to use a special algorithm to renumber degrees of freedom. It is declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div></div><!-- fragment --><p>And this is again needed for C++ output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>Finally, as in <a class="el" href="step_1.html">step-1</a>, we import the deal.II namespace into the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Meshgeneration"></a> </p><h3>Mesh generation</h3>
<p>This is the function that produced the circular grid in the previous <a class="el" href="step_1.html">step-1</a> example program with fewer refinements steps. The sole difference is that it returns the grid it produces via its argument.</p>
<p>The details of what the function does are explained in <a class="el" href="step_1.html">step-1</a>. The only thing we would like to comment on is this:</p>
<p>Since we want to export the triangulation through this function's parameter, we need to make sure that the manifold object lives at least as long as the triangulation does. However, in <a class="el" href="step_1.html">step-1</a>, the manifold object is a local variable, and it would be deleted at the end of the function, which is too early. We avoid the problem by declaring it 'static' which makes sure that the object is initialized the first time control the program passes this point, but at the same time assures that it lives until the end of the program.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> make_grid (<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> center (1,0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">               outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                              center, inner_radius, outer_radius,</div><div class="line">                              5 );</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> manifold_description(center);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, manifold_description);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;3; ++step)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a> cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">      <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a> endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0;</div><div class="line">             v &lt; GeometryInfo&lt;2&gt;::vertices_per_cell;</div><div class="line">             ++v)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center</div><div class="line">              = center.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a> (cell-&gt;vertex(v));</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (std::fabs(distance_from_center - inner_radius) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag ();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="CreationofaDoFHandler"></a> </p><h3>Creation of a <a class="el" href="classDoFHandler.html">DoFHandler</a></h3>
<p>Up to now, we only have a grid, i.e. some geometrical (the position of the vertices) and some topological information (how vertices are connected to lines, and lines to cells, as well as which cells neighbor which other cells). To use numerical algorithms, one needs some logic information in addition to that: we would like to associate degree of freedom numbers to each vertex (or line, or cell, in case we were using higher order elements) to later generate matrices and vectors which describe a finite element field on the triangulation.</p>
<p>This function shows how to do this. The object to consider is the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> class template. Before we do so, however, we first need something that describes how many degrees of freedom are to be associated to each of these objects. Since this is one aspect of the definition of a finite element space, the finite element base class stores this information. In the present context, we therefore create an object of the derived class <code><a class="el" href="classFE__Q.html">FE_Q</a></code> that describes Lagrange elements. Its constructor takes one argument that states the polynomial degree of the element, which here is one (indicating a bi-linear element); this then corresponds to one degree of freedom for each vertex, while there are none on lines and inside the quadrilateral. A value of, say, three given to the constructor would instead give us a bi-cubic element with one degree of freedom per vertex, two per line, and four inside the cell. In general, <code><a class="el" href="classFE__Q.html">FE_Q</a></code> denotes the family of continuous elements with complete polynomials (i.e. tensor-product polynomials) up to the specified order.</p>
<p>We first need to create an object of this class and then pass it on to the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object to allocate storage for the degrees of freedom (in deal.II lingo: we <code>distribute degrees of freedom</code>). Note that the <a class="el" href="classDoFHandler.html">DoFHandler</a> object will store a reference to this finite element object, so we have to make sure its lifetime is at least as long as that of the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code>; one way to make sure this is so is to make it static as well, in order to prevent its preemptive destruction. (However, the library would warn us if we forgot about this and abort the program if that occurred. You can check this, if you want, by removing the 'static' declaration.)</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> distribute_dofs (<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div></div><!-- fragment --><p>As described above, let us first create a finite element object, and then use it to allocate degrees of freedom on the triangulation with which the dof_handler object is associated:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> finite_element(1);</div><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (finite_element);</div></div><!-- fragment --><p>Now that we have associated a degree of freedom with a global number to each vertex, we wonder how to visualize this? There is no simple way to directly visualize the DoF number associated with each vertex. However, such information would hardly ever be truly important, since the numbering itself is more or less arbitrary. There are more important factors, of which we will demonstrate one in the following.</p>
<p>Associated with each vertex of the triangulation is a shape function. Assume we want to solve something like Laplace's equation, then the different matrix entries will be the integrals over the gradient of each pair of such shape functions. Obviously, since the shape functions are nonzero only on the cells adjacent to the vertex they are associated with, matrix entries will be nonzero only if the supports of the shape functions associated to that column and row numbers intersect. This is only the case for adjacent shape functions, and therefore only for adjacent vertices. Now, since the vertices are numbered more or less randomly by the above function (<a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>), the pattern of nonzero entries in the matrix will be somewhat ragged, and we will take a look at it now.</p>
<p>First we have to create a structure which we use to store the places of nonzero elements. This can then later be used by one or more sparse matrix objects that store the values of the entries in the locations stored by this sparsity pattern. The class that stores the locations is the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class. As it turns out, however, this class has some drawbacks when we try to fill it right away: its data structures are set up in such a way that we need to have an estimate for the maximal number of entries we may wish to have in each row. In two space dimensions, reasonable values for this estimate are available through the <a class="el" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">DoFHandler::max_couplings_between_dofs()</a> function, but in three dimensions the function almost always severely overestimates the true number, leading to a lot of wasted memory, sometimes too much for the machine used, even if the unused memory can be released immediately after computing the sparsity pattern. In order to avoid this, we use an intermediate object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> that uses a different internal data structure and that we can later copy into the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object without much overhead. (Some more information on these data structures can be found in the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module.) In order to initialize this intermediate data structure, we have to give it the size of the matrix, which in our case will be square with as many rows and columns as there are degrees of freedom on the grid:</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div></div><!-- fragment --><p>We then fill this object with the places where nonzero elements will be located given the present numbering of degrees of freedom:</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dynamic_sparsity_pattern);</div></div><!-- fragment --><p>Now we are ready to create the actual sparsity pattern that we could later use for our matrix. It will just contain the data already assembled in the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dynamic_sparsity_pattern);</div></div><!-- fragment --><p>With this, we can now write the results to a file :</p>
<div class="fragment"><div class="line">std::ofstream out (<span class="stringliteral">&quot;sparsity_pattern1.svg&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a3614bd25c90b4f4c973e68f1dec304c8">print_svg</a> (out);</div></div><!-- fragment --><p>The result is stored in an <code>.svg</code> file, where each nonzero entry in the matrix corresponds with a red square in the image. The output will be shown below.</p>
<p>If you look at it, you will note that the sparsity pattern is symmetric. This should not come as a surprise, since we have not given the <code><a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a></code> any information that would indicate that our bilinear form may couple shape functions in a non-symmetric way. You will also note that it has several distinct region, which stem from the fact that the numbering starts from the coarsest cells and moves on to the finer ones; since they are all distributed symmetrically around the origin, this shows up again in the sparsity pattern.</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="RenumberingofDoFs"></a> </p><h3>Renumbering of DoFs</h3>
<p>In the sparsity pattern produced above, the nonzero entries extended quite far off from the diagonal. For some algorithms, for example for incomplete LU decompositions or Gauss-Seidel preconditioners, this is unfavorable, and we will show a simple way how to improve this situation.</p>
<p>Remember that for an entry <img class="formulaInl" alt="$(i,j)$" src="form_739.png"/> in the matrix to be nonzero, the supports of the shape functions i and j needed to intersect (otherwise in the integral, the integrand would be zero everywhere since either the one or the other shape function is zero at some point). However, the supports of shape functions intersected only if they were adjacent to each other, so in order to have the nonzero entries clustered around the diagonal (where <img class="formulaInl" alt="$i$" src="form_90.png"/> equals <img class="formulaInl" alt="$j$" src="form_513.png"/>), we would like to have adjacent shape functions to be numbered with indices (DoF numbers) that differ not too much.</p>
<p>This can be accomplished by a simple front marching algorithm, where one starts at a given vertex and gives it the index zero. Then, its neighbors are numbered successively, making their indices close to the original one. Then, their neighbors, if not yet numbered, are numbered, and so on.</p>
<p>One algorithm that adds a little bit of sophistication along these lines is the one by Cuthill and McKee. We will use it in the following function to renumber the degrees of freedom such that the resulting sparsity pattern is more localized around the diagonal. The only interesting part of the function is the first call to <code><a class="el" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a></code>, the rest is essentially as before:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> renumber_dofs (<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a> (dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out (<span class="stringliteral">&quot;sparsity_pattern2.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a3614bd25c90b4f4c973e68f1dec304c8">print_svg</a> (out);</div><div class="line">}</div></div><!-- fragment --><p>Again, the output is shown below. Note that the nonzero entries are clustered far better around the diagonal than before. This effect is even more distinguished for larger matrices (the present one has 1260 rows and columns, but large matrices often have several 100,000s).</p>
<p>It is worth noting that the <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> class offers a number of other algorithms as well to renumber degrees of freedom. For example, it would of course be ideal if all couplings were in the lower or upper triangular part of a matrix, since then solving the linear system would among to only forward or backward substitution. This is of course unachievable for symmetric sparsity patterns, but in some special situations involving transport equations, this is possible by enumerating degrees of freedom from the inflow boundary along streamlines to the outflow boundary. Not surprisingly, <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> also has algorithms for this.</p>
<p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, this is the main program. The only thing it does is to allocate and create the triangulation, then create a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object and associate it to the triangulation, and finally call above two functions on it:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  make_grid (triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler (triangulation);</div><div class="line"></div><div class="line">  distribute_dofs (dof_handler);</div><div class="line">  renumber_dofs (dof_handler);</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program has, after having been run, produced two sparsity patterns. We can visualize them by opening the <code>.svg</code> files in a web browser.</p>
<p>The results then look like this (every point denotes an entry which might be nonzero; of course the fact whether the entry actually is zero or not depends on the equation under consideration, but the indicated positions in the matrix tell us which shape functions can and which can't couple when discretizing a local, i.e. differential, equation): </p><table style="width:60%" align="center">
<tr>
<td><div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-2.sparsity-1.svg"></object>
</div>
 </td><td><div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-2.sparsity-2.svg"></object>
</div>
  </td></tr>
</table>
<p>The different regions in the left picture, indicated by kinks in the lines and single dots on the left and top, represent the degrees of freedom on the different refinement levels of the triangulation. As can be seen in the right picture, the sparsity pattern is much better clustered around the main diagonal of the matrix after renumbering. Although this might not be apparent, the number of nonzero entries is the same in both pictures, of course.</p>
<p><a class="anchor" id="Possibleextensions"></a></p><h3>Possible extensions </h3>
<p>Just as with <a class="el" href="step_1.html">step-1</a>, you may want to play with the program a bit to familiarize yourself with deal.II. For example, in the <code>distribute_dofs</code> function, we use linear finite elements (that's what the argument "1" to the <a class="el" href="classFE__Q.html">FE_Q</a> object is). Explore how the sparsity pattern changes if you use higher order elements, for example cubic or quintic ones (by using 3 and 5 as the respective arguments).</p>
<p>Or, you could see how the sparsity pattern changes with more refinements. You will see that not only the size of the matrix changes, but also its bandwidth (the distance from the diagonal of those nonzero elements of the matrix that are farthest away from the diagonal), though the ratio of bandwidth to size typically shrinks, i.e. the matrix clusters more around the diagonal.</p>
<p>Another idea of experiments would be to try other renumbering strategies than Cuthill-McKee from the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace and see how they affect the sparsity pattern.</p>
<p>You can also visualize the output using <a href="http://www.gnuplot.info/">GNUPLOT</a> (one of the simpler visualization programs; maybe not the easiest to use since it is command line driven, but also universally available on all Linux and other Unix-like systems) by changing from <code>print_svg()</code> to <code>print_gnuplot()</code> in <code>distribute_dofs()</code> and <code>renumber_dofs()</code>: </p><div class="fragment"><div class="line">examples/step-2&gt; <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a></div><div class="line"></div><div class="line">        G N U P L O T</div><div class="line">        Version 3.7 patchlevel 3</div><div class="line">        last modified Thu Dec 12 13:00:00 GMT 2002</div><div class="line">        System: Linux 2.6.11.4-21.10-<span class="keywordflow">default</span></div><div class="line"></div><div class="line">        Copyright(C) 1986 - 1993, 1998 - 2002</div><div class="line">        Thomas Williams, Colin Kelley and many others</div><div class="line"></div><div class="line">        Type `help` to access the on-line reference manual</div><div class="line">        The <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a> FAQ is available from</div><div class="line">        http:<span class="comment">//www.gnuplot.info/gnuplot-faq.html</span></div><div class="line"></div><div class="line">        Send comments and requests <span class="keywordflow">for</span> help to &lt;info-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line">        Send bugs, suggestions and mods to &lt;bug-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line"></div><div class="line"></div><div class="line">Terminal type <span class="keyword">set</span> to <span class="stringliteral">&#39;x11&#39;</span></div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; <span class="keyword">set</span> style data points</div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; plot <span class="stringliteral">&quot;sparsity_pattern.1&quot;</span></div></div><!-- fragment --><p> <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 1999</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> make_grid (<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> center (1,0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">               outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                              center, inner_radius, outer_radius,</div><div class="line">                              5 );</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> manifold_description(center);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, manifold_description);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;3; ++step)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a> cell = triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">      <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a> endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0;</div><div class="line">             v &lt; GeometryInfo&lt;2&gt;::vertices_per_cell;</div><div class="line">             ++v)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center</div><div class="line">              = center.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a> (cell-&gt;vertex(v));</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (std::fabs(distance_from_center - inner_radius) &lt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag ();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> distribute_dofs (<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> finite_element(1);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (finite_element);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out (<span class="stringliteral">&quot;sparsity_pattern1.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a3614bd25c90b4f4c973e68f1dec304c8">print_svg</a> (out);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> renumber_dofs (<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a> (dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out (<span class="stringliteral">&quot;sparsity_pattern2.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a3614bd25c90b4f4c973e68f1dec304c8">print_svg</a> (out);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  make_grid (triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler (triangulation);</div><div class="line"></div><div class="line">  distribute_dofs (dof_handler);</div><div class="line">  renumber_dofs (dof_handler);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
