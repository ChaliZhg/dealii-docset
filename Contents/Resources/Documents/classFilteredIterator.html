<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FilteredIterator&lt; BaseIterator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classFilteredIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FilteredIterator&lt; BaseIterator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a><a class="el" href="group__grid.html">Grid classes</a> &raquo;  &#124; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="filtered__iterator_8h_source.html">deal.II/grid/filtered_iterator.h</a>&gt;</code></p>

<p>Inherits BaseIterator.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator_1_1PredicateBase.html">PredicateBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator_1_1PredicateTemplate.html">PredicateTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0fe683ace1afee750662b293128fff6f"><td class="memItemLeft" align="right" valign="top">typedef BaseIterator::AccessorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a0fe683ace1afee750662b293128fff6f">AccessorType</a></td></tr>
<tr class="separator:a0fe683ace1afee750662b293128fff6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abdb7a4cce0c39d3fece3d3f272b06be8"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:abdb7a4cce0c39d3fece3d3f272b06be8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#abdb7a4cce0c39d3fece3d3f272b06be8">FilteredIterator</a> (Predicate p)</td></tr>
<tr class="separator:abdb7a4cce0c39d3fece3d3f272b06be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d5b3bb5eec9b464ea0ebce290aa610"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a60d5b3bb5eec9b464ea0ebce290aa610"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a60d5b3bb5eec9b464ea0ebce290aa610">FilteredIterator</a> (Predicate p, const BaseIterator &amp;bi)</td></tr>
<tr class="separator:a60d5b3bb5eec9b464ea0ebce290aa610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab7a13002adffd786ae8862c9551d1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a5ab7a13002adffd786ae8862c9551d1b">FilteredIterator</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi)</td></tr>
<tr class="separator:a5ab7a13002adffd786ae8862c9551d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189d588999b57b38a0fd7c7b5324356f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a189d588999b57b38a0fd7c7b5324356f">~FilteredIterator</a> ()</td></tr>
<tr class="separator:a189d588999b57b38a0fd7c7b5324356f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3884629b4542ec8d2e66d0ff0a84b77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af3884629b4542ec8d2e66d0ff0a84b77">operator=</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi)</td></tr>
<tr class="separator:af3884629b4542ec8d2e66d0ff0a84b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59726d809ae2f31cf87e234be9dd60bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a59726d809ae2f31cf87e234be9dd60bb">operator=</a> (const BaseIterator &amp;fi)</td></tr>
<tr class="separator:a59726d809ae2f31cf87e234be9dd60bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2793a746a3c8fd7d005461fa43828dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a> (const BaseIterator &amp;bi)</td></tr>
<tr class="separator:a2793a746a3c8fd7d005461fa43828dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3511a0ed07877e0e40c69492bb2c920e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a3511a0ed07877e0e40c69492bb2c920e">set_to_previous_positive</a> (const BaseIterator &amp;bi)</td></tr>
<tr class="separator:a3511a0ed07877e0e40c69492bb2c920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a2449c181a18d48ef16d8af3205f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a896a2449c181a18d48ef16d8af3205f1">operator==</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a896a2449c181a18d48ef16d8af3205f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7350af8676cc98cd1114a87afce47891"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a7350af8676cc98cd1114a87afce47891">operator==</a> (const BaseIterator &amp;fi) const</td></tr>
<tr class="separator:a7350af8676cc98cd1114a87afce47891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb1462542c6f5b1993c13c5af0a04b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a8cb1462542c6f5b1993c13c5af0a04b7">operator!=</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a8cb1462542c6f5b1993c13c5af0a04b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245437d652fb44642fb34c28545f1de2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a245437d652fb44642fb34c28545f1de2">operator!=</a> (const BaseIterator &amp;fi) const</td></tr>
<tr class="separator:a245437d652fb44642fb34c28545f1de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb790e543dd7713670478462bc77bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#abfb790e543dd7713670478462bc77bf3">operator&lt;</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi) const</td></tr>
<tr class="separator:abfb790e543dd7713670478462bc77bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ff0049dfc58d9df66b09dda7b4ebd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af4ff0049dfc58d9df66b09dda7b4ebd3">operator&lt;</a> (const BaseIterator &amp;fi) const</td></tr>
<tr class="separator:af4ff0049dfc58d9df66b09dda7b4ebd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af443c6eaae6bbf6d469d6f9c2bd8d45f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af443c6eaae6bbf6d469d6f9c2bd8d45f">operator++</a> ()</td></tr>
<tr class="separator:af443c6eaae6bbf6d469d6f9c2bd8d45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631025a97f88c3af83fd197e74955952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a631025a97f88c3af83fd197e74955952">operator++</a> (int)</td></tr>
<tr class="separator:a631025a97f88c3af83fd197e74955952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684a24d262a47514fcff64fc3e86c580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a684a24d262a47514fcff64fc3e86c580">operator--</a> ()</td></tr>
<tr class="separator:a684a24d262a47514fcff64fc3e86c580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1df9fa9cac3f0c00c27eb692200a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a8b1df9fa9cac3f0c00c27eb692200a03">operator--</a> (int)</td></tr>
<tr class="separator:a8b1df9fa9cac3f0c00c27eb692200a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga3ee478a7a971a5657229a4e6f55339e0"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3ee478a7a971a5657229a4e6f55339e0">ExcInvalidElement</a> (BaseIterator arg1)</td></tr>
<tr class="separator:ga3ee478a7a971a5657229a4e6f55339e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4ab92caab85c608c951651af86762ecd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFilteredIterator_1_1PredicateBase.html">PredicateBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a4ab92caab85c608c951651af86762ecd">predicate</a></td></tr>
<tr class="separator:a4ab92caab85c608c951651af86762ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab70266a7220e6ff4e3f915e0fb44a4dd"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ab70266a7220e6ff4e3f915e0fb44a4dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#ab70266a7220e6ff4e3f915e0fb44a4dd">make_filtered_iterator</a> (const BaseIterator &amp;i, const Predicate &amp;p)</td></tr>
<tr class="separator:ab70266a7220e6ff4e3f915e0fb44a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga3948dd66d9e66ac55d89dc8f75fa4855">filter_iterators</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; BaseIterator &gt; i, const Predicate &amp;p)</td></tr>
<tr class="separator:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0db06fce5af606f8fe78476ffd4587"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate , typename... Targs&gt; </td></tr>
<tr class="memitem:ga3c0db06fce5af606f8fe78476ffd4587"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename internal::FilteredIterator::NestFilteredIterators&lt; BaseIterator, std::tuple&lt; Predicate, Targs... &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga3c0db06fce5af606f8fe78476ffd4587">filter_iterators</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; BaseIterator &gt; i, const Predicate &amp;p, const Targs... args)</td></tr>
<tr class="separator:ga3c0db06fce5af606f8fe78476ffd4587"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename BaseIterator&gt;<br />
class FilteredIterator&lt; BaseIterator &gt;</h3>

<p>This class provides a certain view on a range of triangulation or <a class="el" href="classDoFHandler.html">DoFHandler</a> iterators by only iterating over elements that satisfy a given filter (called a <em>predicate</em>, following the notation of the C++ standard library). Once initialized with a predicate and a value for the iterator, a filtered iterator hops to the next or previous element that satisfies the predicate if operators ++ or &ndash; are invoked. Intermediate iterator values that lie in between but do not satisfy the predicate are skipped. It is thus very simple to write loops over a certain class of objects without the need to explicitly write down the condition they have to satisfy in each loop iteration. This in particular is helpful if functions are called with a pair of iterators denoting a range on which they shall act, by choosing a filtered iterator instead of usual ones.</p>
<p>This class is used in <a class="el" href="step_18.html">step-18</a> and <a class="el" href="step_32.html">step-32</a>.</p>
<h3>Predicates</h3>
<p>The object that represent the condition an iterator has to satisfy only have to provide an interface that allows to call the evaluation operator, i.e. <code>bool operator() (const BaseIterator&amp;)</code>. This includes function pointers as well as classes that implement an <code>bool operator ()(const BaseIterator&amp;)</code>. Then, the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> will skip all objects where the return value of this function is <code>false</code>.</p>
<p>An example of a simple valid predicate is the following: given the function </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIterator&gt;</div><div class="line"><span class="keywordtype">bool</span> level_equal_to_3 (<span class="keyword">const</span> BIterator&amp; c)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (static_cast&lt;unsigned int&gt;(c-&gt;level()) == 3);</div><div class="line">};</div></div><!-- fragment --><p> then </p><div class="fragment"><div class="line">&amp;level_equal_to_3&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator&gt;</div></div><!-- fragment --><p> is a valid predicate.</p>
<p>Likewise, given the following binary function </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIterator&gt;</div><div class="line"><span class="keywordtype">bool</span> level_equal_to (<span class="keyword">const</span> BIterator&amp;     c,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (static_cast&lt;unsigned int&gt;(c-&gt;level()) == level);</div><div class="line">};</div></div><!-- fragment --><p> then </p><div class="fragment"><div class="line">std::bind (&amp;level_equal_to&lt;active_cell_iterator&gt;, std::placeholders::_1, 3)</div></div><!-- fragment --><p> is another valid predicate (here: a function that returns true if either the iterator is past the end or the level is equal to the second argument; this second argument is bound to a fixed value using the <code>std::bind</code> function).</p>
<p>Finally, classes can be predicates. The following class is one: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Active</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> Iterator &amp;i)<span class="keyword"> const </span>{</div><div class="line">      <span class="keywordflow">return</span> (i-&gt;active());</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> and objects of this type can be used as predicates. Likewise, this more complicated one can also be used: </p><div class="fragment"><div class="line"><span class="keyword">class </span>SubdomainEqualTo</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SubdomainEqualTo (<span class="keyword">const</span> <a class="code" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> subdomain_id)</div><div class="line">                : subdomain_id (subdomain_id) {};</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> Iterator &amp;i)<span class="keyword"> const </span>{</div><div class="line">      <span class="keywordflow">return</span> (i-&gt;subdomain_id() == <a class="code" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">subdomain_id</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">types::subdomain_id</a> <a class="code" href="namespacetypes.html#a34b501118128294d2bc316a1b052454f">subdomain_id</a>;</div><div class="line">};</div></div><!-- fragment --><p> Objects like <code>SubdomainEqualTo(3)</code> can then be used as predicates.</p>
<p>Since whenever a predicate is evaluated it is checked that the iterator checked is actually valid (i.e. not past the end), no checks for this case have to be performed inside predicates.</p>
<p>A number of filter classes are already implemented in the <a class="el" href="namespaceIteratorFilters.html">IteratorFilters</a> namespace, but writing different ones is simple following the examples above.</p>
<h3>Initialization of filtered iterators</h3>
<p>Filtered iterators are given a predicate at construction time which cannot be changed any more. This behaviour would be expected if the predicate would have been given as a template parameter to the class, but since that would make the declaration of filtered iterators a nightmare, we rather give the predicate as an unchangeable entity to the constructor. Note that one can assign a filtered iterator with one predicate to another filtered iterator with another type; yet, this does <em>not</em> change the predicate of the assigned-to iterator, only the pointer indicating the iterator is changed.</p>
<p>If a filtered iterator is not assigned a value of the underlying (unfiltered) iterator type, the default value is taken. If, however, a value is given to the constructor, that value has either to be past the end, or has to satisfy the predicate. For example, if the predicate only evaluates to true if the level of an object is equal to three, then <code>tria.begin_active(3)</code> would be a valid choice while <code>tria.begin()</code> would not since the latter also returns iterators to non-active cells which always start at level 0.</p>
<p>Since one often only has some iterator and wants to set a filtered iterator to the first one that satisfies a predicate (for example, the first one for which the user flag is set, or the first one with a given subdomain id), there are assignement functions <a class="el" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a> and <a class="el" href="classFilteredIterator.html#a3511a0ed07877e0e40c69492bb2c920e">set_to_previous_positive</a> that assign the next or last previous iterator that satisfies the predicate, i.e. they follow the list of iterators in either direction until they find a matching one (or the past-the-end iterator). Like the <code>operator=</code> they return the resulting value of the filtered iterator.</p>
<h3>Examples</h3>
<p>The following call counts the number of active cells that have a set user flag: </p><div class="fragment"><div class="line"><a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">   begin (<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>()),</div><div class="line">   end (<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>());</div><div class="line">begin.set_to_next_positive(tria.begin_active());</div><div class="line">end = tria.end();</div><div class="line">n_flagged_cells = std::distance (begin, end);</div></div><!-- fragment --><p> Note that by the <code>set_to_next_positive</code> call the first cell with a set user flag was assigned to the <code>begin</code> iterator. For the end iterator, no such call was necessary, since the past-the-end iterator always satisfies all predicates.</p>
<p>The same can be achieved by the following snippet, though harder to read: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt; FI;</div><div class="line">n_flagged_cells =</div><div class="line">   std::distance (FI(<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>())</div><div class="line">                         .<a class="code" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a>(tria.begin_active()),</div><div class="line">                  FI(<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>(), tria.end()));</div></div><!-- fragment --><p> It relies on the fact that if we create an unnamed filtered iterator with a given predicate but no iterator value and assign it the next positive value with respect to this predicate, it returns itself which is then used as the first parameter to the <code>std::distance</code> function. This procedure is not necessary for the end element to this function here, since the past-the-end iterator always satisfies the predicate so that we can assign this value to the filtered iterator directly in the constructor.</p>
<p>Finally, the following loop only assembles the matrix on cells with subdomain id equal to three: </p><div class="fragment"><div class="line"><a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  cell (<a class="code" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a>(3)),</div><div class="line">  endc (<a class="code" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a>(3), tria.end());</div><div class="line">cell.<a class="code" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a> (tria.begin_active());</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  assemble_local_matrix (cell);</div></div><!-- fragment --><p>Since comparison between filtered and unfiltered iterators is defined, we could as well have let the <code>endc</code> variable in the last example be of type <a class="el" href="group__Iterators.html#ga7f54e1f60de3cc5adb6ad00d23ee150b">Triangulation::active_cell_iterator</a> since it is unchanged and its value does not depend on the filter.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2002 </dd></dl>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00511">511</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0fe683ace1afee750662b293128fff6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe683ace1afee750662b293128fff6f">&#9670;&nbsp;</a></span>AccessorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BaseIterator::AccessorType <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::<a class="el" href="classFilteredIterator.html#a0fe683ace1afee750662b293128fff6f">AccessorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef to the accessor type of the underlying iterator. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00517">517</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abdb7a4cce0c39d3fece3d3f272b06be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb7a4cce0c39d3fece3d3f272b06be8">&#9670;&nbsp;</a></span>FilteredIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Set the iterator to the default state and use the given predicate for filtering subsequent assignement and iteration. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00903">903</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a60d5b3bb5eec9b464ea0ebce290aa610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d5b3bb5eec9b464ea0ebce290aa610">&#9670;&nbsp;</a></span>FilteredIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BaseIterator &amp;&#160;</td>
          <td class="paramname"><em>bi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Use the given predicate for filtering and initialize the iterator with the given value.</p>
<p>If the initial value <code>bi</code> does not satisfy the predicate <code>p</code> then it is advanced until we either hit the the past-the-end iterator, or the predicate is satisfied. This allows, for example, to write code like </p><div class="fragment"><div class="line"><a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  cell (<a class="code" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a>(13),</div><div class="line">        triangulation.begin_active());</div></div><!-- fragment --><p>If the cell <code>triangulation.begin_active()</code> does not have a subdomain_id equal to 13, then the iterator will automatically be advanced to the first cell that has. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00914">914</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a5ab7a13002adffd786ae8862c9551d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab7a13002adffd786ae8862c9551d1b">&#9670;&nbsp;</a></span>FilteredIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Copy the predicate and iterator value of the given argument. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00930">930</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a189d588999b57b38a0fd7c7b5324356f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189d588999b57b38a0fd7c7b5324356f">&#9670;&nbsp;</a></span>~FilteredIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::~<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00945">945</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af3884629b4542ec8d2e66d0ff0a84b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3884629b4542ec8d2e66d0ff0a84b77">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. Copy the iterator value of the argument, but as discussed in the class documentation, the predicate of the argument is not copied. The iterator value underlying the argument has to satisfy the predicate of the object assigned to, as given at its construction time. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00957">957</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a59726d809ae2f31cf87e234be9dd60bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59726d809ae2f31cf87e234be9dd60bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const BaseIterator &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. Copy the iterator value of the argument, and keep the predicate of this object. The given iterator value has to satisfy the predicate of the object assigned to, as given at its construction time. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00974">974</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a2793a746a3c8fd7d005461fa43828dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2793a746a3c8fd7d005461fa43828dc7">&#9670;&nbsp;</a></span>set_to_next_positive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::set_to_next_positive </td>
          <td>(</td>
          <td class="paramtype">const BaseIterator &amp;&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the next iterator from <code>bi</code> onwards that satisfies the predicate of this object and assign it to this object.</p>
<p>Since filtered iterators are automatically converted to the underlying base iterator type, you can also give a filtered iterator as argument to this function. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00988">988</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a3511a0ed07877e0e40c69492bb2c920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3511a0ed07877e0e40c69492bb2c920e">&#9670;&nbsp;</a></span>set_to_previous_positive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::set_to_previous_positive </td>
          <td>(</td>
          <td class="paramtype">const BaseIterator &amp;&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As above, but search for the previous iterator from <code>bi</code> backwards that satisfies the predicate of this object and assign it to this object.</p>
<p>Since filtered iterators are automatically converted to the underlying base iterator type, you can also give a filtered iterator as argument to this function. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01004">1004</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a896a2449c181a18d48ef16d8af3205f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896a2449c181a18d48ef16d8af3205f1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for equality of the underlying iterator values of this and the given object.</p>
<p>We do not compare for equality of the predicates. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01020">1020</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a7350af8676cc98cd1114a87afce47891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7350af8676cc98cd1114a87afce47891">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const BaseIterator &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for equality of the underlying iterator value of this object with the given object.</p>
<p>The predicate of this object is irrelevant for this operation. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01060">1060</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a8cb1462542c6f5b1993c13c5af0a04b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb1462542c6f5b1993c13c5af0a04b7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for inequality of the underlying iterator values of this and the given object.</p>
<p>We do not compare for equality of the predicates. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01033">1033</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a245437d652fb44642fb34c28545f1de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245437d652fb44642fb34c28545f1de2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BaseIterator &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for inequality of the underlying iterator value of this object with the given object.</p>
<p>The predicate of this object is irrelevant for this operation. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01071">1071</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="abfb790e543dd7713670478462bc77bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb790e543dd7713670478462bc77bf3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for ordering of the underlying iterator values of this and the given object.</p>
<p>We do not compare the predicates. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01046">1046</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="af4ff0049dfc58d9df66b09dda7b4ebd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ff0049dfc58d9df66b09dda7b4ebd3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const BaseIterator &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for ordering of the underlying iterator value of this object with the given object.</p>
<p>The predicate of this object is irrelevant for this operation. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01082">1082</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="af443c6eaae6bbf6d469d6f9c2bd8d45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af443c6eaae6bbf6d469d6f9c2bd8d45f">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix advancement operator: move to the next iterator value satisfying the predicate and return the new iterator value. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01092">1092</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a631025a97f88c3af83fd197e74955952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631025a97f88c3af83fd197e74955952">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix advancement operator: move to the next iterator value satisfying the predicate and return the old iterator value. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01108">1108</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a684a24d262a47514fcff64fc3e86c580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684a24d262a47514fcff64fc3e86c580">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix decrement operator: move to the previous iterator value satisfying the predicate and return the new iterator value. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01127">1127</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a8b1df9fa9cac3f0c00c27eb692200a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1df9fa9cac3f0c00c27eb692200a03">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix advancement operator: move to the previous iterator value satisfying the predicate and return the old iterator value. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01143">1143</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab70266a7220e6ff4e3f915e0fb44a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70266a7220e6ff4e3f915e0fb44a4dd">&#9670;&nbsp;</a></span>make_filtered_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt; make_filtered_iterator </td>
          <td>(</td>
          <td class="paramtype">const BaseIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an object of type <a class="el" href="classFilteredIterator.html">FilteredIterator</a> given the base iterator and predicate. This function makes the creation of temporary objects (for example as function arguments) a lot simpler because one does not have to explicitly specify the type of the base iterator by hand &ndash; it is deduced automatically here.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth </dd></dl>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00766">766</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4ab92caab85c608c951651af86762ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab92caab85c608c951651af86762ecd">&#9670;&nbsp;</a></span>predicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFilteredIterator_1_1PredicateBase.html">PredicateBase</a>* <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; BaseIterator &gt;::predicate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to an object that encapsulated the actual data type of the predicate given to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00749">749</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deal.II/grid/<a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
