<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The &#39;Quasi-Static Finite-Strain Compressible Elasticity&#39; code gallery program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The 'Quasi-Static Finite-Strain Compressible Elasticity' code gallery program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<p align="center"> 
  This program was contributed by Jean-Paul Pelteret &lt;jppelteret@gmail.com&gt;.
  <br>
  It comes without any warranty or support by its authors or the authors of deal.II.
</p>

</p>
<p>This program is part of the <a class="el" href="CodeGallery.html">deal.II code gallery</a> and consists of the following files (click to inspect):</p><ul>
<li><a href="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/README.md">README.md</a> (<a href="#ann-README.md">annotated version</a>)</li>
<li><a href="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/CMakeLists.txt">CMakeLists.txt</a></li>
<li><a href="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/cook_membrane.cc">cook_membrane.cc</a> (<a href="#ann-cook_membrane.cc">annotated version</a>)</li>
<li><a href="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/disp_soln.png">doc/disp_soln.png</a></li>
<li><a href="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/entry-name">doc/entry-name</a></li>
<li><a href="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/problem_setup.png">doc/problem_setup.png</a></li>
<li><a href="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/ref_grid.png">doc/ref_grid.png</a></li>
<li><a href="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/parameters.prm">parameters.prm</a></li>
</ul>
<h1>Pictures from this code gallery program</h1>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/ref_grid.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/problem_setup.png" width="250"/>
</div>
  </td><td><div class="image">
<img src="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/disp_soln.png" width="250"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="ann-README.md"></a> </p><h1>Annotated version of README.md</h1>
<h2>Overview</h2>
<p>The Cook membrane (or cantilever) problem is a classic benchmark test for finite element formulations for solid mechanics. It is typically used to test for and demonstrate the shear-locking (or locking-free) behaviour of a finite element ansatz under quasi-incompressible conditions. As it is so widely referred to in the literature on finite-strain elasticity, we reproduce the example here. However, we consider on the compressible case to avoid many of the complexities that arise in <code>@ref step_44 "step-44"</code>, which provides an efficient approach to deal with the quasi-incompressible case.</p>
<h3>A classical approach to solving the cook membrane problem.</h3>
<p>In this work we take a classical approach to solving the equations governing quasi-static finite-strain compressible elasticity, with code based on <code>@ref step_44 "step-44"</code>. The formulation adopted here is that seen in many texts on solid mechanics and can be used as the starting point for extension into many topics such as material anisotropy, rate dependence or plasticity, or even as a component of multi-physics problems.</p>
<p>The basic problem configuration is summarised in the following image. A beam of specific dimensions is fixed at one end and a uniform traction load is applied at the other end such that the total force acting on this surface totals 1 Newton. Displacement in the third coordinate direction (out of plane) is prevented in order to impose plane strain conditions.</p>
<div class="image">
<img src="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/problem_setup.png" alt="Problem geometry"/>
</div>
<p>Note that we perform a three-dimensional computation as, for this particular formulation, the two-dimensional case corresponds to neither plane-strain nor plane-stress conditions.</p>
<h2>Requirements</h2>
<p>Version 8.2.1 or greater of <code>deal.II</code></p>
<h2>Compiling and running</h2>
<p>Similar to the example programs, run </p><div class="fragment"><div class="line">cmake -DDEAL_II_DIR=/path/to/deal.II .</div></div><!-- fragment --><p> in this directory to configure the problem. You can switch between debug and release mode by calling either </p><div class="fragment"><div class="line">make debug</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">make release</div></div><!-- fragment --><p> The problem may then be run with </p><div class="fragment"><div class="line">make run</div></div><!-- fragment --><h2>Reference for this work</h2>
<p>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: J-P. V. Pelteret and A. McBride, The deal.II code gallery: Quasi-Static Finite-Strain Compressible Elasticity, 2016. DOI: <a href="http://doi.org/10.5281/zenodo.437601">10.5281/zenodo.437601</a> </p><div class="image">
<object type="image/svg+xml" data="https://zenodo.org/badge/DOI/10.5281/zenodo.437601.svg" style="float: right;"></object>
</div>
<h3>Acknowledgements</h3>
<p>The support of this work by the European Research Council (ERC) through the Advanced Grant 289049 MOCOPOLY is gratefully acknowledged by the first author.</p>
<h2>Recommended Literature</h2>
<p>C. Miehe (1994), Aspects of the formulation and finite element implementation of large strain isotropic elasticity International Journal for Numerical Methods in Engineering 37 , 12, 1981-2004. DOI: <a href="http://doi.org/10.1002/nme.1620371202">10.1002/nme.1620371202</a>; G.A. Holzapfel (2001), Nonlinear Solid Mechanics. A Continuum Approach for Engineering, John Wiley &amp; Sons. ISBN: <a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-0471823198.html">978-0-471-82319-3</a>; P. Wriggers (2008), Nonlinear finite element methods, Springer. DOI: <a href="http://doi.org/10.1007/978-3-540-71001-1">10.1007/978-3-540-71001-1</a>; T.J.R. Hughes (2000), The Finite Element Method: Linear Static and Dynamic Finite Element Analysis, Dover. ISBN: <a href="http://store.doverpublications.com/0486411818.html">978-0486411811</a></p>
<p>The derivation of the finite-element problem, namely the definition and linearisation of the residual and their subsequent discretisation are quite lengthy and involved. Thankfully, the classical approach adopted in this work is well documented and therefore does not need to be reproduced here. We refer the reader to, among many other possible texts, Holzapfel (2001) and Wriggers (2008) for a detailed description of the approach applied in this work. It amounts to a reduction and slight reworking of <code>@ref step_44 "step-44"</code> (accounting for the removal of the two additional fields used therein). We also refer the reader to <code>@ref step_44 "step-44"</code> for a brief overview of the continuum mechanics and kinematics related to solid mechanics.</p>
<h2>Results</h2>
<p>These results were produced using the following material properties: Shear modulus is 422.5kPa Poisson ratio is 0.3</p>
<p>The 32x32x1 discretised reference geometry looks as follows:</p>
<div class="image">
<img src="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/ref_grid.png" alt="Problem geometry"/>
</div>
<p>And an example of the displaced solution is given in the next image.</p>
<div class="image">
<img src="../code-gallery/Quasi_static_Finite_strain_Compressible_Elasticity/doc/disp_soln.png" alt="Displaced solution"/>
</div>
<p>Below we briefly document the tip displacement as predicted for different discretisation levels and ansatz for the displacement field. A direct and, by visual inspection, favourable comparison of the following results can be made with those found in Miehe (1994). Since the material is compressible, shear-locking is not exhibited by the beam for low-order elements.</p>
<h4>Number of degrees of freedom</h4>
<table class="doxtable">
<tr>
<th align="center">Elements per edge </th><th align="center">Q1 </th><th align="center">Q2  </th></tr>
<tr>
<td align="center">1 </td><td align="center">24 </td><td align="center">81 </td></tr>
<tr>
<td align="center">2 </td><td align="center">54 </td><td align="center">225 </td></tr>
<tr>
<td align="center">4 </td><td align="center">150 </td><td align="center">729 </td></tr>
<tr>
<td align="center">8 </td><td align="center">486 </td><td align="center">2601 </td></tr>
<tr>
<td align="center">16 </td><td align="center">1734 </td><td align="center">9801 </td></tr>
<tr>
<td align="center">32 </td><td align="center">6534 </td><td align="center">38025 </td></tr>
<tr>
<td align="center">64 </td><td align="center">25350 </td><td align="center">149769 </td></tr>
</table>
<h4>Tip y-displacement (in mm)</h4>
<table class="doxtable">
<tr>
<th align="center">Elements per edge </th><th align="center">Q1 </th><th align="center">Q2  </th></tr>
<tr>
<td align="center">1 </td><td align="center">5.15 </td><td align="center">12.19 </td></tr>
<tr>
<td align="center">2 </td><td align="center">8.72 </td><td align="center">13.83 </td></tr>
<tr>
<td align="center">4 </td><td align="center">12.02 </td><td align="center">14.22 </td></tr>
<tr>
<td align="center">8 </td><td align="center">13.61 </td><td align="center">14.30 </td></tr>
<tr>
<td align="center">16 </td><td align="center">14.13 </td><td align="center">14.32 </td></tr>
<tr>
<td align="center">32 </td><td align="center">14.28 </td><td align="center">14.33 </td></tr>
<tr>
<td align="center">64 </td><td align="center">14.32 </td><td align="center">14.33 </td></tr>
</table>
<p><a class="anchor" id="ann-cook_membrane.cc"></a> </p><h1>Annotated version of cook_membrane.cc</h1>
<div class="fragment"><div class="line">/ * ---------------------------------------------------------------------</div><div class="line"> * Copyright (C) 2010 - 2015 by the deal.II authors and</div><div class="line"> *                              Jean-Paul Pelteret and Andrew McBride</div><div class="line"> *</div><div class="line"> * This file is part of the deal.II library.</div><div class="line"> *</div><div class="line"> * The deal.II library is free software; you can use it, redistribute</div><div class="line"> * it, and/or modify it under the terms of the GNU Lesser General</div><div class="line"> * Public License as published by the Free Software Foundation; either</div><div class="line"> * version 2.1 of the License, or (at your option) any later version.</div><div class="line"> * The full text of the license can be found in the file LICENSE at</div><div class="line"> * the top level of the deal.II distribution.</div><div class="line"> *</div><div class="line"> * ---------------------------------------------------------------------</div><div class="line"> * /</div><div class="line"></div><div class="line">/ *</div><div class="line"> * Authors: Jean-Paul Pelteret, University of Erlangen-Nuremberg,</div><div class="line"> *          Andrew McBride, University of Cape Town, 2015</div><div class="line"> * /</div></div><!-- fragment --><p>We start by including all the necessary deal.II header files and some C++ related ones. They have been discussed in detail in previous tutorial programs, so you need only refer to past tutorials for details.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/point.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/symmetric_tensor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/tensor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/work_stream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/std_cxx11/shared_ptr.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_renumbering.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_in.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_dgp_monomial.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q_eulerian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/block_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition_selector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>We then stick everything that relates to this tutorial program into a namespace of its own, and import all the deal.II function and class names into it:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Cook_Membrane</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Runtimeparameters"></a> </p><h3>Run-time parameters</h3>
<p>There are several parameters that can be set in the code so we set up a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object to read in the choices at run-time.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Parameters</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="FiniteElementsystem"></a> </p><h4>Finite Element system</h4>
<p>Here we specify the polynomial order used to approximate the solution. The quadrature order should be adjusted accordingly.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classFESystem.html">FESystem</a></div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> poly_degree;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> quad_order;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> FESystem::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Finite element system&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Polynomial degree&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Displacement system polynomial order&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Gauss quadrature order&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> FESystem::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Finite element system&quot;</span>);</div><div class="line">  {</div><div class="line">    poly_degree = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Polynomial degree&quot;</span>);</div><div class="line">    quad_order = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Quadrature order&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Geometry"></a> </p><h4>Geometry</h4>
<p>Make adjustments to the problem geometry and its discretisation.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Geometry</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elements_per_edge;</div><div class="line">  <span class="keywordtype">double</span>       <a class="code" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a>;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Geometry::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Geometry&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Elements per edge&quot;</span>, <span class="stringliteral">&quot;32&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Number of elements per long edge of the beam&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Grid scale&quot;</span>, <span class="stringliteral">&quot;1e-3&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Global grid scaling factor&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Geometry::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Geometry&quot;</span>);</div><div class="line">  {</div><div class="line">    elements_per_edge = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Elements per edge&quot;</span>);</div><div class="line">    <a class="code" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a> = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Grid scale&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Materials"></a> </p><h4>Materials</h4>
<p>We also need the shear modulus <img class="formulaInl" alt="$ \mu $" src="form_3688.png"/> and Poisson ration <img class="formulaInl" alt="$ \nu $" src="form_3689.png"/> for the neo-Hookean material.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Materials</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> nu;</div><div class="line">  <span class="keywordtype">double</span> mu;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Materials::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Material properties&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>, <span class="stringliteral">&quot;0.4999&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(-1.0,0.5),</div><div class="line">                      <span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Shear modulus&quot;</span>, <span class="stringliteral">&quot;80.194e6&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Shear modulus&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Materials::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Material properties&quot;</span>);</div><div class="line">  {</div><div class="line">    nu = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Poisson&#39;s ratio&quot;</span>);</div><div class="line">    mu = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Shear modulus&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Linearsolver"></a> </p><h4>Linear solver</h4>
<p>Next, we choose both solver and preconditioner settings. The use of an effective preconditioner is critical to ensure convergence when a large nonlinear motion occurs within a Newton increment.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>LinearSolver</div><div class="line">{</div><div class="line">  std::string type_lin;</div><div class="line">  <span class="keywordtype">double</span>      tol_lin;</div><div class="line">  <span class="keywordtype">double</span>      max_iterations_lin;</div><div class="line">  std::string preconditioner_type;</div><div class="line">  <span class="keywordtype">double</span>      preconditioner_relaxation;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearSolver::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Solver type&quot;</span>, <span class="stringliteral">&quot;CG&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|Direct&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Type of solver used to solve the linear system&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Residual&quot;</span>, <span class="stringliteral">&quot;1e-6&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Linear solver residual (scaled by residual norm)&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Max iteration multiplier&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Linear solver iterations (multiples of the system matrix size)&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Preconditioner type&quot;</span>, <span class="stringliteral">&quot;ssor&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;jacobi|ssor&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Type of preconditioner&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Preconditioner relaxation&quot;</span>, <span class="stringliteral">&quot;0.65&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Preconditioner relaxation value&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearSolver::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    type_lin = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Solver type&quot;</span>);</div><div class="line">    tol_lin = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Residual&quot;</span>);</div><div class="line">    max_iterations_lin = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Max iteration multiplier&quot;</span>);</div><div class="line">    preconditioner_type = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Preconditioner type&quot;</span>);</div><div class="line">    preconditioner_relaxation = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Preconditioner relaxation&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Nonlinearsolver"></a> </p><h4>Nonlinear solver</h4>
<p>A Newton-Raphson scheme is used to solve the nonlinear system of governing equations. We now define the tolerances and the maximum number of iterations for the Newton-Raphson nonlinear solver.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>NonlinearSolver</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iterations_NR;</div><div class="line">  <span class="keywordtype">double</span>       tol_f;</div><div class="line">  <span class="keywordtype">double</span>       tol_u;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> NonlinearSolver::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Max iterations Newton-Raphson&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Number of Newton-Raphson iterations allowed&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Tolerance force&quot;</span>, <span class="stringliteral">&quot;1.0e-9&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Force residual tolerance&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Tolerance displacement&quot;</span>, <span class="stringliteral">&quot;1.0e-6&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0),</div><div class="line">                      <span class="stringliteral">&quot;Displacement error tolerance&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> NonlinearSolver::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    max_iterations_NR = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Max iterations Newton-Raphson&quot;</span>);</div><div class="line">    tol_f = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Tolerance force&quot;</span>);</div><div class="line">    tol_u = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Tolerance displacement&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Time"></a> </p><h4>Time</h4>
<p>Set the timestep size <img class="formulaInl" alt="$ \varDelta t $" src="form_3690.png"/> and the simulation end-time.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Time</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> delta_t;</div><div class="line">  <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">  declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Time::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Time&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;End time&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                      <span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Time step size&quot;</span>, <span class="stringliteral">&quot;0.1&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Time step size&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Time::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Time&quot;</span>);</div><div class="line">  {</div><div class="line">    end_time = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line">    delta_t = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Time step size&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Allparameters"></a> </p><h4>All parameters</h4>
<p>Finally we consolidate all of the above structures into a single container that holds all of our run-time selections.</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>AllParameters : <span class="keyword">public</span> <a class="code" href="classFESystem.html">FESystem</a>,</div><div class="line">    <span class="keyword">public</span> Geometry,</div><div class="line">    <span class="keyword">public</span> Materials,</div><div class="line">    <span class="keyword">public</span> LinearSolver,</div><div class="line">    <span class="keyword">public</span> NonlinearSolver,</div><div class="line">    <span class="keyword">public</span> Time</div><div class="line"></div><div class="line">  {</div><div class="line">    AllParameters(<span class="keyword">const</span> std::string &amp;input_file);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">    declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">  };</div><div class="line"></div><div class="line">  AllParameters::AllParameters(<span class="keyword">const</span> std::string &amp;input_file)</div><div class="line">  {</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">    declare_parameters(prm);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#abc4fe419ccc4b128ec2bad5e0dec62ac">read_input</a>(input_file);</div><div class="line">    parse_parameters(prm);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> AllParameters::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    FESystem::declare_parameters(prm);</div><div class="line">    Geometry::declare_parameters(prm);</div><div class="line">    Materials::declare_parameters(prm);</div><div class="line">    LinearSolver::declare_parameters(prm);</div><div class="line">    NonlinearSolver::declare_parameters(prm);</div><div class="line">    Time::declare_parameters(prm);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> AllParameters::parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    FESystem::parse_parameters(prm);</div><div class="line">    Geometry::parse_parameters(prm);</div><div class="line">    Materials::parse_parameters(prm);</div><div class="line">    LinearSolver::parse_parameters(prm);</div><div class="line">    NonlinearSolver::parse_parameters(prm);</div><div class="line">    Time::parse_parameters(prm);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Somestandardtensors"></a> </p><h3>Some standard tensors</h3>
<p>Now we define some frequently used second and fourth-order tensors:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StandardTensors</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --><p><img class="formulaInl" alt="$\mathbf{I}$" src="form_151.png"/></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> I;</div></div><!-- fragment --><p><img class="formulaInl" alt="$\mathbf{I} \otimes \mathbf{I}$" src="form_1325.png"/></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> IxI;</div></div><!-- fragment --><p><img class="formulaInl" alt="$\mathcal{S}$" src="form_162.png"/>, note that as we only use this fourth-order unit tensor to operate on symmetric second-order tensors. To maintain notation consistent with Holzapfel (2001) we name the tensor <img class="formulaInl" alt="$\mathcal{I}$" src="form_155.png"/></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> II;</div></div><!-- fragment --><p>Fourth-order deviatoric tensor such that <img class="formulaInl" alt="$\textrm{dev} \{ \bullet \} = \{ \bullet \} - [1/\textrm{dim}][ \{ \bullet\} :\mathbf{I}]\mathbf{I}$" src="form_4338.png"/></p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dev_P;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">StandardTensors&lt;dim&gt;::I = unit_symmetric_tensor&lt;dim&gt;();</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">StandardTensors&lt;dim&gt;::IxI = <a class="code" href="classSymmetricTensor.html#ad8e50332a8602d09d12091217f775bec">outer_product</a>(I, I);</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">StandardTensors&lt;dim&gt;::II = identity_tensor&lt;dim&gt;();</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">StandardTensors&lt;dim&gt;::dev_P = deviator_tensor&lt;dim&gt;();</div></div><!-- fragment --><p><a class="anchor" id="Timeclass"></a> </p><h3>Time class</h3>
<p>A simple class to store time data. Its functioning is transparent so no discussion is necessary. For simplicity we assume a constant time step size.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Time</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Time (<span class="keyword">const</span> <span class="keywordtype">double</span> time_end,</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t)</div><div class="line">    :</div><div class="line">    timestep(0),</div><div class="line">    time_current(0.0),</div><div class="line">    time_end(time_end),</div><div class="line">    delta_t(delta_t)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~Time()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> current()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> time_current;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">double</span> end()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> time_end;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">double</span> get_delta_t()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> delta_t;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> get_timestep()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> timestep;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> increment()</div><div class="line">  {</div><div class="line">    time_current += delta_t;</div><div class="line">    ++timestep;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep;</div><div class="line">  <span class="keywordtype">double</span>       time_current;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_end;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="CompressibleneoHookeanmaterialwithinaonefieldformulation"></a> </p><h3>Compressible neo-Hookean material within a one-field formulation</h3>
<p>As discussed in the literature and <a class="el" href="step_44.html">step-44</a>, Neo-Hookean materials are a type of hyperelastic materials. The entire domain is assumed to be composed of a compressible neo-Hookean material. This class defines the behaviour of this material within a one-field formulation. Compressible neo-Hookean materials can be described by a strain-energy function (SEF) <img class="formulaInl" alt="$ \Psi = \Psi_{\text{iso}}(\overline{\mathbf{b}}) + \Psi_{\text{vol}}(J) $" src="form_4339.png"/>.</p>
<p>The isochoric response is given by <img class="formulaInl" alt="$ \Psi_{\text{iso}}(\overline{\mathbf{b}}) = c_{1} [\overline{I}_{1} - 3] $" src="form_3692.png"/> where <img class="formulaInl" alt="$ c_{1} = \frac{\mu}{2} $" src="form_3693.png"/> and <img class="formulaInl" alt="$\overline{I}_{1}$" src="form_3694.png"/> is the first invariant of the left- or right-isochoric Cauchy-Green deformation tensors. That is <img class="formulaInl" alt="$\overline{I}_1 :=\textrm{tr}(\overline{\mathbf{b}})$" src="form_3695.png"/>. In this example the SEF that governs the volumetric response is defined as <img class="formulaInl" alt="$ \Psi_{\text{vol}}(J) = \kappa \frac{1}{4} [ J^2 - 1 - 2\textrm{ln}\; J ]$" src="form_4340.png"/>, where <img class="formulaInl" alt="$\kappa:= \lambda + 2/3 \mu$" src="form_3697.png"/> is the <a href="http://en.wikipedia.org/wiki/Bulk_modulus">bulk modulus</a> and <img class="formulaInl" alt="$\lambda$" src="form_548.png"/> is <a href="http://en.wikipedia.org/wiki/Lam%C3%A9_parameters">Lame's first parameter</a>.</p>
<p>The following class will be used to characterize the material we work with, and provides a central point that one would need to modify if one were to implement a different material model. For it to work, we will store one object of this type per quadrature point, and in each of these objects store the current state (characterized by the values or measures of the displacement field) so that we can compute the elastic coefficients linearized around the current state.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Material_Compressible_Neo_Hook_One_Field</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Material_Compressible_Neo_Hook_One_Field(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">double</span> nu)</div><div class="line">    :</div><div class="line">    kappa((2.0 * mu * (1.0 + nu)) / (3.0 * (1.0 - 2.0 * nu))),</div><div class="line">    c_1(mu / 2.0),</div><div class="line">    det_F(1.0),</div><div class="line">    b_bar(StandardTensors&lt;dim&gt;::I)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(kappa &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  }</div><div class="line"></div><div class="line">  ~Material_Compressible_Neo_Hook_One_Field()</div><div class="line">  {}</div></div><!-- fragment --><p>We update the material model with various deformation dependent data based on the deformation gradient <img class="formulaInl" alt="$\mathbf{F}$" src="form_139.png"/> and the volumetric Jacobian <img class="formulaInl" alt="$J = \text{det} \mathbf{F}$" src="form_1337.png"/>, and at the end of the function include a physical check for internal consistency:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> update_material_data(<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &amp;F)</div><div class="line">{</div><div class="line">  det_F = <a class="code" href="classSymmetricTensor.html#a31d48ca1d251a7a32db8b673e6010193">determinant</a>(F);</div><div class="line">  b_bar = std::pow(det_F, -2.0 / 3.0) * <a class="code" href="classSymmetricTensor.html#a4acdda923e9b04d2d70308f3c095e12f">symmetrize</a>(F * <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(F));</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(det_F &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">}</div></div><!-- fragment --><p>The second function determines the Kirchhoff stress <img class="formulaInl" alt="$\boldsymbol{\tau} = \boldsymbol{\tau}_{\textrm{iso}} + \boldsymbol{\tau}_{\textrm{vol}}$" src="form_3698.png"/></p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau()</div><div class="line">{</div></div><!-- fragment --><p>See Holzapfel p231 eq6.98 onwards</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> get_tau_iso() + get_tau_vol();</div><div class="line">}</div></div><!-- fragment --><p>The fourth-order elasticity tensor in the spatial setting <img class="formulaInl" alt="$\mathfrak{c}$" src="form_3613.png"/> is calculated from the SEF <img class="formulaInl" alt="$\Psi$" src="form_99.png"/> as <img class="formulaInl" alt="$ J \mathfrak{c}_{ijkl} = F_{iA} F_{jB} \mathfrak{C}_{ABCD} F_{kC} F_{lD}$" src="form_3699.png"/> where <img class="formulaInl" alt="$ \mathfrak{C} = 4 \frac{\partial^2 \Psi(\mathbf{C})}{\partial \mathbf{C} \partial \mathbf{C}}$" src="form_3700.png"/></p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_Jc()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> get_Jc_vol() + get_Jc_iso();</div><div class="line">}</div></div><!-- fragment --><p>Derivative of the volumetric free energy with respect to <img class="formulaInl" alt="$J$" src="form_777.png"/> return <img class="formulaInl" alt="$\frac{\partial \Psi_{\text{vol}}(J)}{\partial J}$" src="form_4341.png"/></p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_dPsi_vol_dJ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keywordflow">return</span> (kappa / 2.0) * (det_F - 1.0 / det_F);</div><div class="line">}</div></div><!-- fragment --><p>Second derivative of the volumetric free energy wrt <img class="formulaInl" alt="$J$" src="form_777.png"/>. We need the following computation explicitly in the tangent so we make it public. We calculate <img class="formulaInl" alt="$\frac{\partial^2 \Psi_{\textrm{vol}}(J)}{\partial J \partial J}$" src="form_4342.png"/></p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_d2Psi_vol_dJ2()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keywordflow">return</span> ( (kappa / 2.0) * (1.0 + 1.0 / (det_F * det_F)));</div><div class="line">}</div></div><!-- fragment --><p>The next few functions return various data that we choose to store with the material:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> det_F;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>Define constitutive model parameters <img class="formulaInl" alt="$\kappa$" src="form_2495.png"/> (bulk modulus) and the neo-Hookean model parameter <img class="formulaInl" alt="$c_1$" src="form_2130.png"/>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> c_1;</div></div><!-- fragment --><p>Model specific data that is convenient to store with the material:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> det_F;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> b_bar;</div></div><!-- fragment --><p>The following functions are used internally in determining the result of some of the public functions above. The first one determines the volumetric Kirchhoff stress <img class="formulaInl" alt="$\boldsymbol{\tau}_{\textrm{vol}}$" src="form_3703.png"/>. Note the difference in its definition when compared to <a class="el" href="step_44.html">step-44</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau_vol()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keywordflow">return</span> get_dPsi_vol_dJ() * det_F * StandardTensors&lt;dim&gt;::I;</div><div class="line">}</div></div><!-- fragment --><p>Next, determine the isochoric Kirchhoff stress <img class="formulaInl" alt="$\boldsymbol{\tau}_{\textrm{iso}} = \mathcal{P}:\overline{\boldsymbol{\tau}}$" src="form_3704.png"/>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau_iso()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> StandardTensors&lt;dim&gt;::dev_P * get_tau_bar();</div><div class="line">}</div></div><!-- fragment --><p>Then, determine the fictitious Kirchhoff stress <img class="formulaInl" alt="$\overline{\boldsymbol{\tau}}$" src="form_3600.png"/>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_tau_bar()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 2.0 * c_1 * b_bar;</div><div class="line">}</div></div><!-- fragment --><p>Calculate the volumetric part of the tangent <img class="formulaInl" alt="$J \mathfrak{c}_\textrm{vol}$" src="form_3705.png"/>. Again, note the difference in its definition when compared to <a class="el" href="step_44.html">step-44</a>. The extra terms result from two quantities in <img class="formulaInl" alt="$\boldsymbol{\tau}_{\textrm{vol}}$" src="form_3703.png"/> being dependent on <img class="formulaInl" alt="$\boldsymbol{F}$" src="form_4343.png"/>.</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_Jc_vol()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>See Holzapfel p265</p>
<div class="fragment"><div class="line">    <span class="keywordflow">return</span> det_F</div><div class="line">    * ( (get_dPsi_vol_dJ() + det_F * get_d2Psi_vol_dJ2())*StandardTensors&lt;dim&gt;::IxI</div><div class="line">       - (2.0 * get_dPsi_vol_dJ())*StandardTensors&lt;dim&gt;::II );</div><div class="line">}</div></div><!-- fragment --><p>Calculate the isochoric part of the tangent <img class="formulaInl" alt="$J \mathfrak{c}_\textrm{iso}$" src="form_3706.png"/>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_Jc_iso()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau_bar = get_tau_bar();</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau_iso = get_tau_iso();</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> tau_iso_x_I</div><div class="line">    = <a class="code" href="classSymmetricTensor.html#ad8e50332a8602d09d12091217f775bec">outer_product</a>(tau_iso,</div><div class="line">                    StandardTensors&lt;dim&gt;::I);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> I_x_tau_iso</div><div class="line">    = <a class="code" href="classSymmetricTensor.html#ad8e50332a8602d09d12091217f775bec">outer_product</a>(StandardTensors&lt;dim&gt;::I,</div><div class="line">                    tau_iso);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> c_bar = get_c_bar();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (2.0 / 3.0) * <a class="code" href="classSymmetricTensor.html#a05096e7bc18fa734eae3bd1a5f08138e">trace</a>(tau_bar)</div><div class="line">         * StandardTensors&lt;dim&gt;::dev_P</div><div class="line">         - (2.0 / 3.0) * (tau_iso_x_I + I_x_tau_iso)</div><div class="line">         + StandardTensors&lt;dim&gt;::dev_P * c_bar</div><div class="line">         * StandardTensors&lt;dim&gt;::dev_P;</div><div class="line">}</div></div><!-- fragment --><p>Calculate the fictitious elasticity tensor <img class="formulaInl" alt="$\overline{\mathfrak{c}}$" src="form_3618.png"/>. For the material model chosen this is simply zero:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_c_bar()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a>();</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Quadraturepointhistory"></a> </p><h3><a class="el" href="classQuadrature.html">Quadrature</a> point history</h3>
<p>As seen in <a class="el" href="step_18.html">step-18</a>, the <code> PointHistory </code> class offers a method for storing data at the quadrature points. Here each quadrature point holds a pointer to a material description. Thus, different material models can be used in different regions of the domain. Among other data, we choose to store the Kirchhoff stress <img class="formulaInl" alt="$\boldsymbol{\tau}$" src="form_3707.png"/> and the tangent <img class="formulaInl" alt="$J\mathfrak{c}$" src="form_3708.png"/> for the quadrature points.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PointHistory</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PointHistory()</div><div class="line">    :</div><div class="line">    F_inv(StandardTensors&lt;dim&gt;::I),</div><div class="line">    tau(<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt;()),</div><div class="line">    Jc(<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;4, dim&gt;())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~PointHistory()</div><div class="line">  {}</div></div><!-- fragment --><p>The first function is used to create a material object and to initialize all tensors correctly: The second one updates the stored values and stresses based on the current deformation measure <img class="formulaInl" alt="$\textrm{Grad}\mathbf{u}_{\textrm{n}}$" src="form_3709.png"/>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_lqp (<span class="keyword">const</span> Parameters::AllParameters &amp;parameters)</div><div class="line">{</div><div class="line">  material.reset(<span class="keyword">new</span> Material_Compressible_Neo_Hook_One_Field&lt;dim&gt;(parameters.mu,</div><div class="line">      parameters.nu));</div><div class="line">  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>());</div><div class="line">}</div></div><!-- fragment --><p>To this end, we calculate the deformation gradient <img class="formulaInl" alt="$\mathbf{F}$" src="form_139.png"/> from the displacement gradient <img class="formulaInl" alt="$\textrm{Grad}\ \mathbf{u}$" src="form_3710.png"/>, i.e. <img class="formulaInl" alt="$\mathbf{F}(\mathbf{u}) = \mathbf{I} + \textrm{Grad}\ \mathbf{u}$" src="form_3711.png"/> and then let the material model associated with this quadrature point update itself. When computing the deformation gradient, we have to take care with which data types we compare the sum <img class="formulaInl" alt="$\mathbf{I} + \textrm{Grad}\ \mathbf{u}$" src="form_3712.png"/>: Since <img class="formulaInl" alt="$I$" src="form_3379.png"/> has data type <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>, just writing <code>I + Grad_u_n</code> would convert the second argument to a symmetric tensor, perform the sum, and then cast the result to a <a class="el" href="classTensor.html">Tensor</a> (i.e., the type of a possibly nonsymmetric tensor). However, since <code>Grad_u_n</code> is nonsymmetric in general, the conversion to <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> will fail. We can avoid this back and forth by converting <img class="formulaInl" alt="$I$" src="form_3379.png"/> to <a class="el" href="classTensor.html">Tensor</a> first, and then performing the addition as between nonsymmetric tensors:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> (<span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &amp;Grad_u_n)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F</div><div class="line">    = (<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(StandardTensors&lt;dim&gt;::I) +</div><div class="line">       Grad_u_n);</div><div class="line">  material-&gt;update_material_data(F);</div></div><!-- fragment --><p>The material has been updated so we now calculate the Kirchhoff stress <img class="formulaInl" alt="$\mathbf{\tau}$" src="form_3713.png"/>, the tangent <img class="formulaInl" alt="$J\mathfrak{c}$" src="form_3708.png"/> and the first and second derivatives of the volumetric free energy.</p>
<p>We also store the inverse of the deformation gradient since we frequently use it:</p>
<div class="fragment"><div class="line">  F_inv = <a class="code" href="classSymmetricTensor.html#a6270f4610919ac288e2bb142588c1b2f">invert</a>(F);</div><div class="line">  tau = material-&gt;get_tau();</div><div class="line">  Jc = material-&gt;get_Jc();</div><div class="line">}</div></div><!-- fragment --><p>We offer an interface to retrieve certain data. Here are the kinematic variables:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> material-&gt;get_det_F();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> &amp;get_F_inv()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> F_inv;</div><div class="line">}</div></div><!-- fragment --><p>...and the kinetic variables. These are used in the material and global tangent matrix and residual assembly operations:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_tau()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> tau;</div><div class="line">}</div></div><!-- fragment --><p>And finally the tangent:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_Jc()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> Jc;</div><div class="line">}</div></div><!-- fragment --><p>In terms of member functions, this class stores for the quadrature point it represents a copy of a material type in case different materials are used in different regions of the domain, as well as the inverse of the deformation gradient...</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  std_cxx11::shared_ptr&lt; Material_Compressible_Neo_Hook_One_Field&lt;dim&gt; &gt; material;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_inv;</div></div><!-- fragment --><p>... and stress-type variables along with the tangent <img class="formulaInl" alt="$J\mathfrak{c}$" src="form_3708.png"/>:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Jc;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Quasistaticcompressiblefinitestrainsolid"></a> </p><h3>Quasi-static compressible finite-strain solid</h3>
<p>The Solid class is the central class in that it represents the problem at hand. It follows the usual scheme in that all it really has is a constructor, destructor and a <code>run()</code> function that dispatches all the work to private functions of this class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solid</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Solid(<span class="keyword">const</span> std::string &amp;input_file);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  ~Solid();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  run();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>In the private section of this class, we first forward declare a number of objects that are used in parallelizing work using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> object (see the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> module for more information on this).</p>
<p>We declare such structures for the computation of tangent (stiffness) matrix, right hand side, and for updating quadrature points:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PerTaskData_K;</div><div class="line"><span class="keyword">struct </span>ScratchData_K;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>PerTaskData_RHS;</div><div class="line"><span class="keyword">struct </span>ScratchData_RHS;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>PerTaskData_UQPH;</div><div class="line"><span class="keyword">struct </span>ScratchData_UQPH;</div></div><!-- fragment --><p>We start the collection of member functions with one that builds the grid:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">make_grid();</div></div><!-- fragment --><p>Set up the finite element system to be solved:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">system_setup();</div></div><!-- fragment --><p>Several functions to assemble the system and right hand side matrices using multithreading. Each of them comes as a wrapper function, one that is executed to do the work in the <a class="el" href="namespaceWorkStream.html">WorkStream</a> model on one cell, and one that copies the work done on this one cell into the global object that represents it:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_system_tangent();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_system_tangent_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                 ScratchData_K &amp;scratch,</div><div class="line">                                 PerTaskData_K &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_K(<span class="keyword">const</span> PerTaskData_K &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_system_rhs();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">assemble_system_rhs_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                             ScratchData_RHS &amp;scratch,</div><div class="line">                             PerTaskData_RHS &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_rhs(<span class="keyword">const</span> PerTaskData_RHS &amp;data);</div></div><!-- fragment --><p>Apply Dirichlet boundary conditions on the displacement field</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">make_constraints(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;it_nr);</div></div><!-- fragment --><p>Create and update the quadrature points. Here, no data needs to be copied into a global object, so the copy_local_to_global function is empty:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">setup_qph();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">update_qph_incremental(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">update_qph_incremental_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                ScratchData_UQPH &amp;scratch,</div><div class="line">                                PerTaskData_UQPH &amp;data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">copy_local_to_global_UQPH(<span class="keyword">const</span> PerTaskData_UQPH &amp;/ *data* /)</div><div class="line">{}</div></div><!-- fragment --><p>Solve for the displacement using a Newton-Raphson method. We break this function into the nonlinear loop and the function that solves the linearized Newton-Raphson step:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">solve_nonlinear_timestep(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta);</div><div class="line"></div><div class="line">std::pair&lt;unsigned int, double&gt;</div><div class="line">solve_linear_system(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update);</div></div><!-- fragment --><p>Solution retrieval as well as post-processing and writing data to file :</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">get_total_solution(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">output_results() <span class="keyword">const</span>;</div></div><!-- fragment --><p>Finally, some member variables that describe the current state: A collection of the parameters used to describe the problem setup...</p>
<div class="fragment"><div class="line">Parameters::AllParameters        parameters;</div></div><!-- fragment --><p>...the volume of the reference and current configurations...</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>                           vol_reference;</div><div class="line"><span class="keywordtype">double</span>                           vol_current;</div></div><!-- fragment --><p>...and description of the geometry on which the problem is solved:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>               triangulation;</div></div><!-- fragment --><p>Also, keep track of the current time and the time spent evaluating certain functions</p>
<div class="fragment"><div class="line">Time                             time;</div><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a>                      timer;</div></div><!-- fragment --><p>A storage object for quadrature point information. See <a class="el" href="step_18.html">step-18</a> for more on this:</p>
<div class="fragment"><div class="line">std::vector&lt;PointHistory&lt;dim&gt; &gt;  quadrature_point_history;</div></div><!-- fragment --><p>A description of the finite-element system including the displacement polynomial degree, the degree-of-freedom handler, number of DoFs per cell and the extractor objects used to retrieve information from the solution vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               degree;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>              fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                  dof_handler_ref;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               dofs_per_cell;</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> u_fe;</div></div><!-- fragment --><p>Description of how the block-system is arranged. There is just 1 block, that contains a vector DOF <img class="formulaInl" alt="$\mathbf{u}$" src="form_1365.png"/>. There are two reasons that we retain the block system in this problem. The first is pure laziness to perform further modifications to the code from which this work originated. The second is that a block system would typically necessary when extending this code to multiphysics problems.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        n_blocks = 1;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        n_components = dim;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        first_u_component = 0;</div><div class="line"></div><div class="line"><span class="keyword">enum</span></div><div class="line">{</div><div class="line">  u_dof = 0</div><div class="line">};</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt;  dofs_per_block;</div></div><!-- fragment --><p>Rules for Gauss-quadrature on both the cell and faces. The number of quadrature points on both cells and faces is recorded.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>                qf_cell;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;            qf_face;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               n_q_points;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               n_q_points_f;</div></div><!-- fragment --><p>Objects that store the converged solution and right-hand side vectors, as well as the tangent matrix. There is a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object used to keep track of constraints. We make use of a sparsity pattern designed for a block system.</p>
<div class="fragment"><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>                 constraints;</div><div class="line"><a class="code" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>             sparsity_pattern;</div><div class="line"><a class="code" href="classBlockSparseMatrix.html">BlockSparseMatrix&lt;double&gt;</a>        tangent_matrix;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>              system_rhs;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>              solution_n;</div></div><!-- fragment --><p>Then define a number of variables to store norms and update norms and normalisation factors.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Errors</div><div class="line">{</div><div class="line">  Errors()</div><div class="line">    :</div><div class="line">    norm(1.0), u(1.0)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    norm = 1.0;</div><div class="line">    u = 1.0;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> normalise(<span class="keyword">const</span> Errors &amp;rhs)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rhs.norm != 0.0)</div><div class="line">      norm /= rhs.norm;</div><div class="line">    <span class="keywordflow">if</span> (rhs.u != 0.0)</div><div class="line">      u /= rhs.u;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> norm, u;</div><div class="line">};</div><div class="line"></div><div class="line">Errors error_residual, error_residual_0, error_residual_norm, error_update,</div><div class="line">       error_update_0, error_update_norm;</div></div><!-- fragment --><p>Methods to calculate error measures</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">get_error_residual(Errors &amp;error_residual);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">get_error_update(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update,</div><div class="line">                 Errors &amp;error_update);</div></div><!-- fragment --><p>Print information to screen in a pleasing way...</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  print_conv_header();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  print_conv_footer();</div><div class="line">  </div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  print_vertical_tip_displacement();</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeSolidcodeclass"></a> </p><h3>Implementation of the <code>Solid</code> class</h3>
<p><a class="anchor" id="Publicinterface"></a> </p><h4>Public interface</h4>
<p>We initialise the Solid class using data extracted from the parameter file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solid&lt;dim&gt;::Solid(<span class="keyword">const</span> std::string &amp;input_file)</div><div class="line">  :</div><div class="line">  parameters(input_file),</div><div class="line">  triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing),</div><div class="line">  time(parameters.end_time, parameters.delta_t),</div><div class="line">  timer(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times),</div><div class="line">  degree(parameters.poly_degree),</div></div><!-- fragment --><p>The Finite Element System is composed of dim continuous displacement DOFs.</p>
<div class="fragment"><div class="line">  fe(<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(parameters.poly_degree), dim), <span class="comment">// displacement</span></div><div class="line">  dof_handler_ref(triangulation),</div><div class="line">  dofs_per_cell (fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>),</div><div class="line">  u_fe(first_u_component),</div><div class="line">  dofs_per_block(n_blocks),</div><div class="line">  qf_cell(parameters.quad_order),</div><div class="line">  qf_face(parameters.quad_order),</div><div class="line">  n_q_points (qf_cell.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>()),</div><div class="line">  n_q_points_f (qf_face.size())</div><div class="line">{</div><div class="line">  </div><div class="line">}</div></div><!-- fragment --><p>The class destructor simply clears the data held by the DOFHandler</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solid&lt;dim&gt;::~Solid()</div><div class="line">{</div><div class="line">  dof_handler_ref.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">}</div></div><!-- fragment --><p>In solving the quasi-static problem, the time becomes a loading parameter, i.e. we increasing the loading linearly with time, making the two concepts interchangeable. We choose to increment time linearly using a constant time step size.</p>
<p>We start the function with preprocessing, and then output the initial grid before starting the simulation proper with the first time (and loading) increment.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::run()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line">  system_setup();</div><div class="line">  output_results();</div><div class="line">  time.increment();</div></div><!-- fragment --><p>We then declare the incremental solution update <img class="formulaInl" alt="$\varDelta \mathbf{\Xi}:= \{\varDelta \mathbf{u}\}$" src="form_4344.png"/> and start the loop over the time domain.</p>
<p>At the beginning, we reset the solution update for this time step...</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution_delta(dofs_per_block);</div><div class="line"><span class="keywordflow">while</span> (time.current() &lt;= time.end())</div><div class="line">  {</div><div class="line">    solution_delta = 0.0;</div></div><!-- fragment --><p>...solve the current time step and update total solution vector <img class="formulaInl" alt="$\mathbf{\Xi}_{\textrm{n}} = \mathbf{\Xi}_{\textrm{n-1}} + \varDelta \mathbf{\Xi}$" src="form_3717.png"/>...</p>
<div class="fragment"><div class="line">solve_nonlinear_timestep(solution_delta);</div><div class="line">solution_n += solution_delta;</div></div><!-- fragment --><p>...and plot the results before moving on happily to the next time step:</p>
<div class="fragment"><div class="line">  output_results();</div><div class="line">  time.increment();</div><div class="line">}</div></div><!-- fragment --><p>Lastly, we print the vertical tip displacement of the Cook cantilever after the full load is applied</p>
<div class="fragment"><div class="line">  print_vertical_tip_displacement();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Privateinterface"></a> </p><h3>Private interface</h3>
<p><a class="anchor" id="Threadingbuildingblocksstructures"></a> </p><h4>Threading-building-blocks structures</h4>
<p>The first group of private member functions is related to parallization. We use the Threading Building Blocks library (TBB) to perform as many computationally intensive distributed tasks as possible. In particular, we assemble the tangent matrix and right hand side vector, and update data stored at the quadrature points using TBB. Our main tool for this is the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class (see the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> module for more information).</p>
<p>Firstly we deal with the tangent matrix assembly structures. The PerTaskData object stores local contributions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_K</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        cell_matrix;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  PerTaskData_K(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    :</div><div class="line">    cell_matrix(dofs_per_cell, dofs_per_cell),</div><div class="line">    local_dof_indices(dofs_per_cell)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    cell_matrix = 0.0;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>On the other hand, the ScratchData object stores the larger objects such as the shape-function values array (<code>Nx</code>) and a shape function gradient and symmetric gradient vector which we will use during the assembly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_K</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_ref;</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;double&gt; &gt;                   Nx;</div><div class="line">  std::vector&lt;std::vector&lt;Tensor&lt;2, dim&gt; &gt; &gt;          grad_Nx;</div><div class="line">  std::vector&lt;std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; &gt; symm_grad_Nx;</div><div class="line"></div><div class="line">  ScratchData_K(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_cell,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;qf_cell,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell)</div><div class="line">    :</div><div class="line">    fe_values_ref(fe_cell, qf_cell, uf_cell),</div><div class="line">    Nx(qf_cell.size(),</div><div class="line">       <a class="code" href="namespacestd.html">std</a>::vector&lt;double&gt;(fe_cell.dofs_per_cell)),</div><div class="line">    grad_Nx(qf_cell.size(),</div><div class="line">            <a class="code" href="namespacestd.html">std</a>::vector&lt;<a class="code" href="classTensor.html">Tensor</a>&lt;2, dim&gt; &gt;(fe_cell.dofs_per_cell)),</div><div class="line">    symm_grad_Nx(qf_cell.size(),</div><div class="line">                 <a class="code" href="namespacestd.html">std</a>::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt; &gt;</div><div class="line">                 (fe_cell.dofs_per_cell))</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData_K(<span class="keyword">const</span> ScratchData_K &amp;rhs)</div><div class="line">    :</div><div class="line">    fe_values_ref(rhs.fe_values_ref.get_fe(),</div><div class="line">                  rhs.fe_values_ref.get_quadrature(),</div><div class="line">                  rhs.fe_values_ref.get_update_flags()),</div><div class="line">    Nx(rhs.Nx),</div><div class="line">    grad_Nx(rhs.grad_Nx),</div><div class="line">    symm_grad_Nx(rhs.symm_grad_Nx)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = Nx.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_per_cell = Nx[0].size();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( Nx[q_point].size() == n_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( grad_Nx[q_point].size() == n_dofs_per_cell,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( symm_grad_Nx[q_point].size() == n_dofs_per_cell,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; n_dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            Nx[q_point][k] = 0.0;</div><div class="line">            grad_Nx[q_point][k] = 0.0;</div><div class="line">            symm_grad_Nx[q_point][k] = 0.0;</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>Next, the same approach is used for the right-hand side assembly. The PerTaskData object again stores local contributions and the ScratchData object the shape function object and precomputed values vector:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_RHS</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  PerTaskData_RHS(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    :</div><div class="line">    cell_rhs(dofs_per_cell),</div><div class="line">    local_dof_indices(dofs_per_cell)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    cell_rhs = 0.0;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_RHS</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_ref;</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_ref;</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;double&gt; &gt;                   Nx;</div><div class="line">  std::vector&lt;std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt; &gt; symm_grad_Nx;</div><div class="line"></div><div class="line">  ScratchData_RHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_cell,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;qf_cell, <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a> &amp; qf_face, <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_face)</div><div class="line">    :</div><div class="line">    fe_values_ref(fe_cell, qf_cell, uf_cell),</div><div class="line">    fe_face_values_ref(fe_cell, qf_face, uf_face),</div><div class="line">    Nx(qf_cell.size(),</div><div class="line">       <a class="code" href="namespacestd.html">std</a>::vector&lt;double&gt;(fe_cell.dofs_per_cell)),</div><div class="line">    symm_grad_Nx(qf_cell.size(),</div><div class="line">                 <a class="code" href="namespacestd.html">std</a>::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt; &gt;</div><div class="line">                 (fe_cell.dofs_per_cell))</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData_RHS(<span class="keyword">const</span> ScratchData_RHS &amp;rhs)</div><div class="line">    :</div><div class="line">    fe_values_ref(rhs.fe_values_ref.get_fe(),</div><div class="line">                  rhs.fe_values_ref.get_quadrature(),</div><div class="line">                  rhs.fe_values_ref.get_update_flags()),</div><div class="line">    fe_face_values_ref(rhs.fe_face_values_ref.get_fe(),</div><div class="line">                       rhs.fe_face_values_ref.get_quadrature(),</div><div class="line">                       rhs.fe_face_values_ref.get_update_flags()),</div><div class="line">    Nx(rhs.Nx),</div><div class="line">    symm_grad_Nx(rhs.symm_grad_Nx)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = Nx.size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_per_cell = Nx[0].size();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( Nx[q_point].size() == n_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>( symm_grad_Nx[q_point].size() == n_dofs_per_cell,</div><div class="line">                <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; n_dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            Nx[q_point][k] = 0.0;</div><div class="line">            symm_grad_Nx[q_point][k] = 0.0;</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>And finally we define the structures to assist with updating the quadrature point information. We do not need the PerTaskData object (since there is nothing to store here) but must define one nonetheless. Note that this is because for the operation that we have here &ndash; updating the data on quadrature points &ndash; the operation is purely local: the things we do on every cell get consumed on every cell, without any global aggregation operation as is usually the case when using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class. The fact that we still have to define a per-task data structure points to the fact that the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class may be ill-suited to this operation (we could, in principle simply create a new task using <a class="el" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a> for each cell) but there is not much harm done to doing it this way anyway. Furthermore, should there be different material models associated with a quadrature point, requiring varying levels of computational expense, then the method used here could be advantageous.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::PerTaskData_UQPH</div><div class="line">{</div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {}</div><div class="line">};</div></div><!-- fragment --><p>The ScratchData object will be used to store an alias for the solution vector so that we don't have to copy this large data structure. We then define a number of vectors to extract the solution values and gradients at the quadrature points.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>Solid&lt;dim&gt;::ScratchData_UQPH</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a>   &amp;solution_total;</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt; &gt; solution_grads_u_total;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>                fe_values_ref;</div><div class="line"></div><div class="line">  ScratchData_UQPH(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe_cell,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> &amp;qf_cell,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_total)</div><div class="line">    :</div><div class="line">    solution_total(solution_total),</div><div class="line">    solution_grads_u_total(qf_cell.size()),</div><div class="line">    fe_values_ref(fe_cell, qf_cell, uf_cell)</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData_UQPH(<span class="keyword">const</span> ScratchData_UQPH &amp;rhs)</div><div class="line">    :</div><div class="line">    solution_total(rhs.solution_total),</div><div class="line">    solution_grads_u_total(rhs.solution_grads_u_total),</div><div class="line">    fe_values_ref(rhs.fe_values_ref.get_fe(),</div><div class="line">                  rhs.fe_values_ref.get_quadrature(),</div><div class="line">                  rhs.fe_values_ref.get_update_flags())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = solution_grads_u_total.size();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        solution_grads_u_total[q] = 0.0;</div><div class="line">      }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Solidmake_grid"></a> </p><h4>Solid::make_grid</h4>
<p>On to the first of the private member functions. Here we create the triangulation of the domain, for which we choose a scaled an anisotripically discretised rectangle which is subsequently transformed into the correct of the Cook cantilever. Each relevant boundary face is then given a boundary ID number.</p>
<p>We then determine the volume of the reference configuration and print it for comparison.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> grid_y_transform (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;pt_in)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;x = pt_in[0];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;y = pt_in[1];</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> y_upper = 44.0 + (16.0/48.0)*x; <span class="comment">// Line defining upper edge of beam</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> y_lower =  0.0 + (44.0/48.0)*x; <span class="comment">// Line defining lower edge of beam</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta = y/44.0; <span class="comment">// Fraction of height along left side of beam</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> y_transform = (1-theta)*y_lower + theta*y_upper; <span class="comment">// Final transformation</span></div><div class="line">  </div><div class="line">  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> pt_out = pt_in;</div><div class="line">  pt_out[1] = y_transform;</div><div class="line">  </div><div class="line">  <span class="keywordflow">return</span> pt_out;</div><div class="line">}</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Solid&lt;dim&gt;::make_grid()</div><div class="line">  {</div></div><!-- fragment --><p>Divide the beam, but only along the x- and y-coordinate directions</p>
<div class="fragment"><div class="line">std::vector&lt; unsigned int &gt; repetitions(dim, parameters.elements_per_edge);</div></div><!-- fragment --><p>Only allow one element through the thickness (modelling a plane strain condition)</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (dim == 3)</div><div class="line">  repetitions[dim-1] = 1;</div><div class="line">  </div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> bottom_left = (dim == 3 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.0, 0.0, -0.5) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(0.0, 0.0));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> top_right = (dim == 3 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(48.0, 44.0, 0.5) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(48.0, 44.0));</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation, </div><div class="line">                                          repetitions,</div><div class="line">                                          bottom_left,</div><div class="line">                                          top_right);</div></div><!-- fragment --><p>Since we wish to apply a Neumann BC to the right-hand surface, we must find the cell faces in this part of the domain and mark them with a distinct boundary ID number. The faces we are looking for are on the +x surface and will get boundary ID 11. Dirichlet boundaries exist on the left-hand face of the beam (this fixed boundary will get ID 1) and on the +Z and -Z faces (which correspond to ID 2 and we will use to impose the plane strain condition)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tol_boundary = 1e-6;</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(), endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face = 0;</div><div class="line">       face &lt; GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary() == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (std::abs(cell-&gt;face(face)-&gt;center()[0] - 0.0) &lt; tol_boundary)</div><div class="line">        cell-&gt;face(face)-&gt;set_boundary_id(1); <span class="comment">// -X faces</span></div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::abs(cell-&gt;face(face)-&gt;center()[0] - 48.0) &lt; tol_boundary)</div><div class="line">        cell-&gt;face(face)-&gt;set_boundary_id(11); <span class="comment">// +X faces</span></div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::abs(std::abs(cell-&gt;face(face)-&gt;center()[0]) - 0.5) &lt; tol_boundary)</div><div class="line">        cell-&gt;face(face)-&gt;set_boundary_id(2); <span class="comment">// +Z and -Z faces</span></div><div class="line">    }</div></div><!-- fragment --><p>Transform the hyper-rectangle into the beam shape</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;grid_y_transform&lt;dim&gt;, triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>(parameters.scale, triangulation);</div><div class="line">  </div><div class="line">  vol_reference = <a class="code" href="namespaceGridTools.html#a4ff265d387af7b430f5aec7005faace6">GridTools::volume</a>(triangulation);</div><div class="line">  vol_current = vol_reference;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid:\n\t Reference volume: &quot;</span> &lt;&lt; vol_reference &lt;&lt; std::endl;</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidsystem_setup"></a> </p><h4>Solid::system_setup</h4>
<p>Next we describe how the FE system is setup. We first determine the number of components per block. Since the displacement is a vector component, the first dim components belong to it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::system_setup()</div><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Setup system&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; block_component(n_components, u_dof); <span class="comment">// Displacement</span></div></div><!-- fragment --><p>The DOF handler is then initialised and we renumber the grid in an efficient manner. We also record the number of DOFs per block.</p>
<div class="fragment"><div class="line">dof_handler_ref.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"><a class="code" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a>(dof_handler_ref);</div><div class="line"><a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(dof_handler_ref, block_component);</div><div class="line"><a class="code" href="namespaceDoFTools.html#abfd9796e22113e13b5802e384e56af4f">DoFTools::count_dofs_per_block</a>(dof_handler_ref, dofs_per_block,</div><div class="line">                               block_component);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Triangulation:&quot;</span></div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;\n\t Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;\n\t Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler_ref.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>Setup the sparsity pattern and tangent matrix</p>
<div class="fragment"><div class="line">tangent_matrix.<a class="code" href="classBlockSparseMatrix.html#acf098688a1a7db16a6582be07dcbeb6a">clear</a>();</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> n_dofs_u = dofs_per_block[u_dof];</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> csp(n_blocks, n_blocks);</div><div class="line"></div><div class="line">  csp.block(u_dof, u_dof).reinit(n_dofs_u, n_dofs_u);</div><div class="line">  csp.collect_sizes();</div></div><!-- fragment --><p>Naturally, for a one-field vector-valued problem, all of the components of the system are coupled.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(n_components, n_components);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii = 0; ii &lt; <a class="code" href="classDoFHandler.html#ac69f2dc12d3d013e11f7bfd70e328dcb">n_components</a>; ++ii)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj = 0; jj &lt; <a class="code" href="classDoFHandler.html#ac69f2dc12d3d013e11f7bfd70e328dcb">n_components</a>; ++jj)</div><div class="line">        coupling[ii][jj] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a>(dof_handler_ref,</div><div class="line">                                  coupling,</div><div class="line">                                  csp,</div><div class="line">                                  constraints,</div><div class="line">                                  <span class="keyword">false</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(csp);</div><div class="line">}</div><div class="line"></div><div class="line">tangent_matrix.<a class="code" href="classBlockSparseMatrix.html#a1e0a45e360458e7350bd93487d6bf1e5">reinit</a>(sparsity_pattern);</div></div><!-- fragment --><p>We then set up storage vectors</p>
<div class="fragment"><div class="line">system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dofs_per_block);</div><div class="line">system_rhs.<a class="code" href="classBlockVectorBase.html#a6a27b2a48e5b5780cd0a6640b928d794">collect_sizes</a>();</div><div class="line"></div><div class="line">solution_n.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dofs_per_block);</div><div class="line">solution_n.<a class="code" href="classBlockVectorBase.html#a6a27b2a48e5b5780cd0a6640b928d794">collect_sizes</a>();</div></div><!-- fragment --><p>...and finally set up the quadrature point history:</p>
<div class="fragment"><div class="line">  setup_qph();</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidsetup_qph"></a> </p><h4>Solid::setup_qph</h4>
<p>The method used to store quadrature information is already described in <a class="el" href="step_18.html">step-18</a> and <a class="el" href="step_44.html">step-44</a>. Here we implement a similar setup for a SMP machine.</p>
<p>Firstly the actual QPH data objects are created. This must be done only once the grid is refined to its finest level.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::setup_qph()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;    Setting up quadrature point data...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a>();</div><div class="line">    {</div><div class="line">      std::vector&lt;PointHistory&lt;dim&gt; &gt; tmp;</div><div class="line">      tmp.swap(quadrature_point_history);</div><div class="line">    }</div><div class="line"></div><div class="line">    quadrature_point_history</div><div class="line">    .resize(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() * n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> history_index = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">           triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">         ++cell)</div><div class="line">      {</div><div class="line">        cell-&gt;set_user_pointer(&amp;quadrature_point_history[history_index]);</div><div class="line">        history_index += n_q_points;</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(history_index == quadrature_point_history.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  }</div></div><!-- fragment --><p>Next we setup the initial quadrature point data:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">         triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(); cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>(); ++cell)</div><div class="line">    {</div><div class="line">      PointHistory&lt;dim&gt; *lqph =</div><div class="line">        <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt;*<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph &gt;= &amp;quadrature_point_history.front(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph &lt;= &amp;quadrature_point_history.back(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        lqph[q_point].setup_lqp(parameters);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidupdate_qph_incremental"></a> </p><h4>Solid::update_qph_incremental</h4>
<p>As the update of QP information occurs frequently and involves a number of expensive operations, we define a multithreaded approach to distributing the task across a number of CPU cores.</p>
<p>To start this, we first we need to obtain the total solution as it stands at this Newton increment and then create the initial copy of the scratch and copy data objects:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::update_qph_incremental(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta)</div><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Update QPH data&quot;</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; UQPH &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution_total(get_total_solution(solution_delta));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_UQPH(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">  PerTaskData_UQPH per_task_data_UQPH;</div><div class="line">  ScratchData_UQPH scratch_data_UQPH(fe, qf_cell, uf_UQPH, solution_total);</div></div><!-- fragment --><p>We then pass them and the one-cell update function to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> to be processed:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  *<span class="keyword">this</span>,</div><div class="line">                  &amp;Solid::update_qph_incremental_one_cell,</div><div class="line">                  &amp;Solid::copy_local_to_global_UQPH,</div><div class="line">                  scratch_data_UQPH,</div><div class="line">                  per_task_data_UQPH);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p>Now we describe how we extract data from the solution vector and pass it along to each QP storage object for processing.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::update_qph_incremental_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                            ScratchData_UQPH &amp;scratch,</div><div class="line">                                            PerTaskData_UQPH &amp;/ *data* /)</div><div class="line">{</div><div class="line">  PointHistory&lt;dim&gt; *lqph =</div><div class="line">    <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt;*<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph &gt;= &amp;quadrature_point_history.front(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(lqph &lt;= &amp;quadrature_point_history.back(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(scratch.solution_grads_u_total.size() == n_q_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  scratch.reset();</div></div><!-- fragment --><p>We first need to find the solution gradients at quadrature points inside the current cell and then we update each local QP using the displacement gradient:</p>
<div class="fragment"><div class="line">  scratch.fe_values_ref.reinit(cell);</div><div class="line">  scratch.fe_values_ref[u_fe].get_function_gradients(scratch.solution_total,</div><div class="line">                                                     scratch.solution_grads_u_total);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    lqph[q_point].<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>(scratch.solution_grads_u_total[q_point]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidsolve_nonlinear_timestep"></a> </p><h4>Solid::solve_nonlinear_timestep</h4>
<p>The next function is the driver method for the Newton-Raphson scheme. At its top we create a new vector to store the current Newton update step, reset the error storage objects and print solver header.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::solve_nonlinear_timestep(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; time.get_timestep() &lt;&lt; <span class="stringliteral">&quot; @ &quot;</span></div><div class="line">            &lt;&lt; time.current() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> newton_update(dofs_per_block);</div><div class="line"></div><div class="line">  error_residual.reset();</div><div class="line">  error_residual_0.reset();</div><div class="line">  error_residual_norm.reset();</div><div class="line">  error_update.reset();</div><div class="line">  error_update_0.reset();</div><div class="line">  error_update_norm.reset();</div><div class="line"></div><div class="line">  print_conv_header();</div></div><!-- fragment --><p>We now perform a number of Newton iterations to iteratively solve the nonlinear problem. Since the problem is fully nonlinear and we are using a full Newton method, the data stored in the tangent matrix and right-hand side vector is not reusable and must be cleared at each Newton step. We then initially build the right-hand side vector to check for convergence (and store this value in the first iteration). The unconstrained DOFs of the rhs vector hold the out-of-balance forces. The building is done before assembling the system matrix as the latter is an expensive operation and we can potentially avoid an extra assembly process by not assembling the tangent matrix when convergence is attained.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_iteration = 0;</div><div class="line"><span class="keywordflow">for</span> (; newton_iteration &lt; parameters.max_iterations_NR;</div><div class="line">     ++newton_iteration)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::setw(2) &lt;&lt; newton_iteration &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    tangent_matrix = 0.0;</div><div class="line">    system_rhs = 0.0;</div><div class="line"></div><div class="line">    assemble_system_rhs();</div><div class="line">    get_error_residual(error_residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (newton_iteration == 0)</div><div class="line">      error_residual_0 = error_residual;</div></div><!-- fragment --><p>We can now determine the normalised residual error and check for solution convergence:</p>
<div class="fragment"><div class="line">error_residual_norm = error_residual;</div><div class="line">error_residual_norm.normalise(error_residual_0);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (newton_iteration &gt; 0 &amp;&amp; error_update_norm.u &lt;= parameters.tol_u</div><div class="line">    &amp;&amp; error_residual_norm.u &lt;= parameters.tol_f)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; CONVERGED! &quot;</span> &lt;&lt; std::endl;</div><div class="line">    print_conv_footer();</div><div class="line"></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div></div><!-- fragment --><p>If we have decided that we want to continue with the iteration, we assemble the tangent, make and impose the Dirichlet constraints, and do the solve of the linearized system:</p>
<div class="fragment"><div class="line">assemble_system_tangent();</div><div class="line">make_constraints(newton_iteration);</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a05a5f8d313eb2c777e8c9a66b9cd0a62">condense</a>(tangent_matrix, system_rhs);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::pair&lt;unsigned int, double&gt;</div><div class="line">lin_solver_output = solve_linear_system(newton_update);</div><div class="line"></div><div class="line">get_error_update(newton_update, error_update);</div><div class="line"><span class="keywordflow">if</span> (newton_iteration == 0)</div><div class="line">  error_update_0 = error_update;</div></div><!-- fragment --><p>We can now determine the normalised Newton update error, and perform the actual update of the solution increment for the current time step, update all quadrature point information pertaining to this new displacement and stress state and continue iterating:</p>
<div class="fragment"><div class="line">  error_update_norm = error_update;</div><div class="line">  error_update_norm.normalise(error_update_0);</div><div class="line"></div><div class="line">  solution_delta += newton_update;</div><div class="line">  update_qph_incremental(solution_delta);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; | &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; std::setw(7)</div><div class="line">            &lt;&lt; std::scientific &lt;&lt; lin_solver_output.first &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div><div class="line">            &lt;&lt; lin_solver_output.second &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_residual_norm.norm</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_residual_norm.u &lt;&lt; <span class="stringliteral">&quot;  &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.norm &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; error_update_norm.u</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>At the end, if it turns out that we have in fact done more iterations than the parameter file allowed, we raise an exception that can be caught in the main() function. The call <code>AssertThrow(condition, exc_object)</code> is in essence equivalent to <code>if (!cond) throw exc_object;</code> but the former form fills certain fields in the exception object that identify the location (filename and line number) where the exception was raised to make it simpler to identify where the problem happened.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a> (newton_iteration &lt;= parameters.max_iterations_NR,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No convergence in nonlinear solver!&quot;</span>));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidprint_conv_headerSolidprint_conv_footerandSolidprint_vertical_tip_displacement"></a> </p><h4>Solid::print_conv_header, Solid::print_conv_footer and Solid::print_vertical_tip_displacement</h4>
<p>This program prints out data in a nice table that is updated on a per-iteration basis. The next two functions set up the table header and footer:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::print_conv_header()</div><div class="line">{</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l_width = 102;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;           SOLVER STEP            &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; |  LIN_IT   LIN_RES    RES_NORM    &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; RES_U     NU_NORM     &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; NU_U &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::print_conv_footer()</div><div class="line">{</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l_width = 102;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Relative errors:&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Displacement:\t&quot;</span> &lt;&lt; error_update.u / error_update_0.u &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Force: \t\t&quot;</span> &lt;&lt; error_residual.u / error_residual_0.u &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;v / V_0:\t&quot;</span> &lt;&lt; vol_current &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; vol_reference</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>At the end we also output the result that can be compared to that found in the literature, namely the displacement at the upper right corner of the beam.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::print_vertical_tip_displacement()</div><div class="line">{</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l_width = 102;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; l_width; ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;_&quot;</span>;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> soln_pt (48.0*parameters.scale,60.0*parameters.scale,0.5*parameters.scale);</div><div class="line">  <span class="keywordtype">double</span> vertical_tip_displacement = 0.0;</div><div class="line">  <span class="keywordtype">double</span> vertical_tip_displacement_check = 0.0;</div><div class="line">  </div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">    dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(), endc = dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell)</div><div class="line">  {</div></div><!-- fragment --><p>if (cell-&gt;point_inside(soln_pt) == true)</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;vertex(v).distance(soln_pt) &lt; 1e-6)</div><div class="line">{</div></div><!-- fragment --><p>Extract y-component of solution at the given point This point is coindicent with a vertex, so we can extract it directly as we're using <a class="el" href="classFE__Q.html">FE_Q</a> finite elements that have support at the vertices</p>
<div class="fragment"><div class="line">vertical_tip_displacement = solution_n(cell-&gt;vertex_dof_index(v,u_dof+1));</div></div><!-- fragment --><p>Sanity check using alternate method to extract the solution at the given point. To do this, we must create an <a class="el" href="classFEValues.html">FEValues</a> instance to help us extract the solution value at the desired point</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping (parameters.poly_degree);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> qp_unit = mapping.transform_real_to_unit_cell(cell,soln_pt);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> soln_qrule (qp_unit);</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(soln_qrule.size() == 1, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_soln (fe, soln_qrule, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">fe_values_soln.reinit(cell);</div></div><!-- fragment --><p>Extract y-component of solution at given point</p>
<div class="fragment"><div class="line">      std::vector&lt; Tensor&lt;1,dim&gt; &gt; soln_values (soln_qrule.size());</div><div class="line">      fe_values_soln[u_fe].get_function_values(solution_n,</div><div class="line">                                               soln_values);</div><div class="line">      vertical_tip_displacement_check = soln_values[0][u_dof+1];</div><div class="line">      </div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(vertical_tip_displacement &gt; 0.0, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Found no cell with point inside!&quot;</span>))</div><div class="line"></div><div class="line">  <a class="code" href="namespacestd.html">std</a>::cout &lt;&lt; &quot;Vertical tip displacement: &quot; &lt;&lt; vertical_tip_displacement</div><div class="line">            &lt;&lt; &quot;\t Check: &quot; &lt;&lt; vertical_tip_displacement_check</div><div class="line">            &lt;&lt; <a class="code" href="namespacestd.html">std</a>::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidget_error_residual"></a> </p><h4>Solid::get_error_residual</h4>
<p>Determine the true residual error for the problem. That is, determine the error in the residual for the unconstrained degrees of freedom. Note that to do so, we need to ignore constrained DOFs by setting the residual in these vector components to zero.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::get_error_residual(Errors &amp;error_residual)</div><div class="line">{</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> error_res(dofs_per_block);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler_ref.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (!constraints.<a class="code" href="classConstraintMatrix.html#a997d5e0e75f237a2be3fb37d84e1d53c">is_constrained</a>(i))</div><div class="line">      error_res(i) = system_rhs(i);</div><div class="line"></div><div class="line">  error_residual.norm = error_res.l2_norm();</div><div class="line">  error_residual.u = error_res.block(u_dof).l2_norm();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidget_error_udpate"></a> </p><h4>Solid::get_error_udpate</h4>
<p>Determine the true Newton update error for the problem</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::get_error_update(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update,</div><div class="line">                                  Errors &amp;error_update)</div><div class="line">{</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> error_ud(dofs_per_block);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler_ref.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (!constraints.<a class="code" href="classConstraintMatrix.html#a997d5e0e75f237a2be3fb37d84e1d53c">is_constrained</a>(i))</div><div class="line">      error_ud(i) = newton_update(i);</div><div class="line"></div><div class="line">  error_update.norm = error_ud.l2_norm();</div><div class="line">  error_update.u = error_ud.block(u_dof).l2_norm();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidget_total_solution"></a> </p><h4>Solid::get_total_solution</h4>
<p>This function provides the total solution, which is valid at any Newton step. This is required as, to reduce computational error, the total solution is only updated at the end of the timestep.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a></div><div class="line">Solid&lt;dim&gt;::get_total_solution(<span class="keyword">const</span> <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;solution_delta)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> solution_total(solution_n);</div><div class="line">  solution_total += solution_delta;</div><div class="line">  <span class="keywordflow">return</span> solution_total;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidassemble_system_tangent"></a> </p><h4>Solid::assemble_system_tangent</h4>
<p>Since we use TBB for assembly, we simply setup a copy of the data structures required for the process and pass them, along with the memory addresses of the assembly functions to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> object for processing. Note that we must ensure that the matrix is reset before any assembly operations can occur.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::assemble_system_tangent()</div><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Assemble tangent matrix&quot;</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; ASM_K &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  tangent_matrix = 0.0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  PerTaskData_K per_task_data(dofs_per_cell);</div><div class="line">  ScratchData_K scratch_data(fe, qf_cell, uf_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  *<span class="keyword">this</span>,</div><div class="line">                  &amp;Solid::assemble_system_tangent_one_cell,</div><div class="line">                  &amp;Solid::copy_local_to_global_K,</div><div class="line">                  scratch_data,</div><div class="line">                  per_task_data);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p>This function adds the local contribution to the system matrix. Note that we choose not to use the constraint matrix to do the job for us because the tangent matrix and residual processes have been split up into two separate functions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::copy_local_to_global_K(<span class="keyword">const</span> PerTaskData_K &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">      tangent_matrix.<a class="code" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add</a>(data.local_dof_indices[i],</div><div class="line">                         data.local_dof_indices[j],</div><div class="line">                         data.cell_matrix(i, j));</div><div class="line">}</div></div><!-- fragment --><p>Of course, we still have to define how we assemble the tangent matrix contribution for a single cell. We first need to reset and initialise some of the scratch data structures and retrieve some basic information regarding the DOF numbering on this cell. We can precalculate the cell shape function gradients. Note that the shape function gradients are defined with regard to the current configuration. That is <img class="formulaInl" alt="$\textrm{grad}\ \boldsymbol{\varphi} = \textrm{Grad}\ \boldsymbol{\varphi} \ \mathbf{F}^{-1}$" src="form_3721.png"/>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::assemble_system_tangent_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                             ScratchData_K &amp;scratch,</div><div class="line">                                             PerTaskData_K &amp;data)</div><div class="line">{</div><div class="line">  data.reset();</div><div class="line">  scratch.reset();</div><div class="line">  scratch.fe_values_ref.reinit(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line">  PointHistory&lt;dim&gt; *lqph =</div><div class="line">    <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt;*<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_inv = lqph[q_point].get_F_inv();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(k).first.first;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (k_group == u_dof)</div><div class="line">            {</div><div class="line">              scratch.grad_Nx[q_point][k] = scratch.fe_values_ref[u_fe].gradient(k, q_point)</div><div class="line">                                            * F_inv;</div><div class="line">              scratch.symm_grad_Nx[q_point][k] = <a class="code" href="classSymmetricTensor.html#a4acdda923e9b04d2d70308f3c095e12f">symmetrize</a>(scratch.grad_Nx[q_point][k]);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(k_group &lt;= u_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Now we build the local cell stiffness matrix. Since the global and local system matrices are symmetric, we can exploit this property by building only the lower half of the local matrix and copying the values to the upper half.</p>
<p>In doing so, we first extract some configuration dependent variables from our QPH history objects for the current quadrature point.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> tau         = lqph[q_point].get_tau();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Jc = lqph[q_point].get_Jc();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> det_F               = lqph[q_point].get_det_F();</div></div><!-- fragment --><p>Next we define some aliases to make the assembly process easier to follow</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt;</div><div class="line">&amp;N = scratch.Nx[q_point];</div><div class="line"><span class="keyword">const</span> std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt;</div><div class="line">&amp;symm_grad_Nx = scratch.symm_grad_Nx[q_point];</div><div class="line"><span class="keyword">const</span> std::vector&lt;Tensor&lt;2, dim&gt; &gt;</div><div class="line">&amp;grad_Nx = scratch.grad_Nx[q_point];</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_ref.JxW(q_point);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i = fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_group     = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(i).first.first;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_j = fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_group     = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(j).first.first;</div></div><!-- fragment --><p>This is the <img class="formulaInl" alt="$\mathsf{\mathbf{k}}_{\mathbf{u} \mathbf{u}}$" src="form_4345.png"/> contribution. It comprises a material contribution, and a geometrical stress contribution which is only added along the local matrix diagonals:</p>
<div class="fragment"><div class="line">          <span class="keywordflow">if</span> ((i_group == j_group) &amp;&amp; (i_group == u_dof))</div><div class="line">            {</div><div class="line">              data.cell_matrix(i, j) += symm_grad_Nx[i] * Jc <span class="comment">// The material contribution:</span></div><div class="line">                                        * symm_grad_Nx[j] * JxW;</div><div class="line">              <span class="keywordflow">if</span> (component_i == component_j) <span class="comment">// geometrical stress contribution</span></div><div class="line">                data.cell_matrix(i, j) += grad_Nx[i][component_i] * tau</div><div class="line">                                          * grad_Nx[j][component_j] * JxW;</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((i_group &lt;= u_dof) &amp;&amp; (j_group &lt;= u_dof),</div><div class="line">                   <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, we need to copy the lower half of the local matrix into the upper half:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">      data.cell_matrix(i, j) = data.cell_matrix(j, i);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidassemble_system_rhs"></a> </p><h4>Solid::assemble_system_rhs</h4>
<p>The assembly of the right-hand side process is similar to the tangent matrix, so we will not describe it in too much detail. Note that since we are describing a problem with Neumann BCs, we will need the face normals and so must specify this in the update flags.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::assemble_system_rhs()</div><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Assemble system right-hand side&quot;</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; ASM_R &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  system_rhs = 0.0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_cell(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> uf_face(<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  PerTaskData_RHS per_task_data(dofs_per_cell);</div><div class="line">  ScratchData_RHS scratch_data(fe, qf_cell, uf_cell, qf_face, uf_face);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">WorkStream::run</a>(dof_handler_ref.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler_ref.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  *<span class="keyword">this</span>,</div><div class="line">                  &amp;Solid::assemble_system_rhs_one_cell,</div><div class="line">                  &amp;Solid::copy_local_to_global_rhs,</div><div class="line">                  scratch_data,</div><div class="line">                  per_task_data);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::copy_local_to_global_rhs(<span class="keyword">const</span> PerTaskData_RHS &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    system_rhs(data.local_dof_indices[i]) += data.cell_rhs(i);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Solid&lt;dim&gt;::assemble_system_rhs_one_cell(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">                                         ScratchData_RHS &amp;scratch,</div><div class="line">                                         PerTaskData_RHS &amp;data)</div><div class="line">{</div><div class="line">  data.reset();</div><div class="line">  scratch.reset();</div><div class="line">  scratch.fe_values_ref.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line">  PointHistory&lt;dim&gt; *lqph =</div><div class="line">    <span class="keyword">reinterpret_cast&lt;</span>PointHistory&lt;dim&gt;*<span class="keyword">&gt;</span>(cell-&gt;user_pointer());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F_inv = lqph[q_point].get_F_inv();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(k).first.first;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (k_group == u_dof)</div><div class="line">            scratch.symm_grad_Nx[q_point][k]</div><div class="line">              = <a class="code" href="classSymmetricTensor.html#a4acdda923e9b04d2d70308f3c095e12f">symmetrize</a>(scratch.fe_values_ref[u_fe].gradient(k, q_point)</div><div class="line">                           * F_inv);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(k_group &lt;= u_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> tau = lqph[q_point].get_tau();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt;</div><div class="line">      &amp;N = scratch.Nx[q_point];</div><div class="line">      <span class="keyword">const</span> std::vector&lt;SymmetricTensor&lt;2, dim&gt; &gt;</div><div class="line">      &amp;symm_grad_Nx = scratch.symm_grad_Nx[q_point];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_values_ref.JxW(q_point);</div></div><!-- fragment --><p>We first compute the contributions from the internal forces. Note, by definition of the rhs as the negative of the residual, these contributions are subtracted.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_group = fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(i).first.first;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (i_group == u_dof)</div><div class="line">        data.cell_rhs(i) -= (symm_grad_Nx[i] * tau) * JxW;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(i_group &lt;= u_dof, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next we assemble the Neumann contribution. We first check to see it the cell face exists on a boundary on which a traction is applied and add the contribution if this is the case.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face = 0; face &lt; GeometryInfo&lt;dim&gt;::faces_per_cell;</div><div class="line">     ++face)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary() == <span class="keyword">true</span></div><div class="line">      &amp;&amp; cell-&gt;face(face)-&gt;boundary_id() == 11)</div><div class="line">    {</div><div class="line">      scratch.fe_face_values_ref.reinit(cell, face);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> f_q_point = 0; f_q_point &lt; n_q_points_f;</div><div class="line">           ++f_q_point)</div><div class="line">        {</div></div><!-- fragment --><p>We specify the traction in reference configuration. For this problem, a defined total vertical force is applied in the reference configuration. The direction of the applied traction is assumed not to evolve with the deformation of the domain.</p>
<p>Note that the contributions to the right hand side vector we compute here only exist in the displacement components of the vector.</p>
<div class="fragment"><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> time_ramp = (time.current() / time.end());</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> magnitude  = (1.0/(16.0*parameters.scale*1.0*parameters.scale))*time_ramp; <span class="comment">// (Total force) / (RHS surface area)</span></div><div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dir ({0.0,1.0,0.0});</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> traction  = magnitude*dir;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_group =</div><div class="line">                  fe.<a class="code" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a>(i).first.first;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (i_group == u_dof)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> Ni =</div><div class="line">                      scratch.fe_face_values_ref.shape_value(i,</div><div class="line">                                                             f_q_point);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> JxW = scratch.fe_face_values_ref.JxW(</div><div class="line">                                         f_q_point);</div><div class="line"></div><div class="line">                    data.cell_rhs(i) += (Ni * traction[component_i])</div><div class="line">                                        * JxW;</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidmake_constraints"></a> </p><h4>Solid::make_constraints</h4>
<p>The constraints for this problem are simple to describe. However, since we are dealing with an iterative Newton method, it should be noted that any displacement constraints should only be specified at the zeroth iteration and subsequently no additional contributions are to be made since the constraints are already exactly satisfied.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::make_constraints(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;it_nr)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; CST &quot;</span> &lt;&lt; std::flush;</div></div><!-- fragment --><p>Since the constraints are different at different Newton iterations, we need to clear the constraints matrix and completely rebuild it. However, after the first iteration, the constraints remain the same and we can simply skip the rebuilding step if we do not clear it.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (it_nr &gt; 1)</div><div class="line">  <span class="keywordflow">return</span>;</div><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> apply_dirichlet_bc = (it_nr == 0);</div></div><!-- fragment --><p>The boundary conditions for the indentation problem are as follows: On the -x, -y and -z faces (ID's 0,2,4) we set up a symmetry condition to allow only planar movement while the +x and +y faces (ID's 1,3) are traction free. In this contrived problem, part of the +z face (ID 5) is set to have no motion in the x- and y-component. Finally, as described earlier, the other part of the +z face has an the applied pressure but is also constrained in the x- and y-directions.</p>
<p>In the following, we will have to tell the function interpolation boundary values which components of the solution vector should be constrained (i.e., whether it's the x-, y-, z-displacements or combinations thereof). This is done using <a class="el" href="classComponentMask.html">ComponentMask</a> objects (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>) which we can get from the finite element if we provide it with an extractor object for the component we wish to select. To this end we first set up such extractor objects and later use it when generating the relevant component masks:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> x_displacement(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> y_displacement(1);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> z_displacement(2);</div></div><!-- fragment --><p>Fixed left hand side of the beam</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 1;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                             boundary_id,</div><div class="line">                                             <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                             constraints,</div><div class="line">                                             fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement) | </div><div class="line">                                             fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(y_displacement) | </div><div class="line">                                             fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement));</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                             boundary_id,</div><div class="line">                                             <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                             constraints,</div><div class="line">                                             fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(x_displacement) | </div><div class="line">                                             fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(y_displacement) | </div><div class="line">                                             fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement));</div><div class="line">}</div></div><!-- fragment --><p>Zero Z-displacement through thickness direction This corresponds to a plane strain condition being imposed on the beam</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> boundary_id = 2;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (apply_dirichlet_bc == <span class="keyword">true</span>)</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                               boundary_id,</div><div class="line">                                               <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                               constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement));</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a>(dof_handler_ref,</div><div class="line">                                               boundary_id,</div><div class="line">                                               <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(n_components),</div><div class="line">                                               constraints,</div><div class="line">                                               fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(z_displacement));</div><div class="line">  }</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidsolve_linear_system"></a> </p><h4>Solid::solve_linear_system</h4>
<p>As the system is composed of a single block, defining a solution scheme for the linear problem is straight-forward.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;unsigned int, double&gt;</div><div class="line">Solid&lt;dim&gt;::solve_linear_system(<a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> &amp;newton_update)</div><div class="line">{</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> A(dofs_per_block);</div><div class="line">  <a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> B(dofs_per_block);</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lin_it = 0;</div><div class="line">  <span class="keywordtype">double</span> lin_res = 0.0;</div></div><!-- fragment --><p>We solve for the incremental displacement <img class="formulaInl" alt="$d\mathbf{u}$" src="form_3760.png"/>.</p>
<div class="fragment"><div class="line">{</div><div class="line">  timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; SLV &quot;</span> &lt;&lt; std::flush;</div><div class="line">  <span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;CG&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> solver_its = tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof).m()</div><div class="line">                             * parameters.max_iterations_lin;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> tol_sol = parameters.tol_lin</div><div class="line">                             * system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof).l2_norm();</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(solver_its, tol_sol);</div><div class="line"></div><div class="line">      <a class="code" href="classGrowingVectorMemory.html">GrowingVectorMemory&lt;Vector&lt;double&gt;</a> &gt; GVM;</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a> &gt; solver_CG(solver_control, GVM);</div></div><!-- fragment --><p>We've chosen by default a SSOR preconditioner as it appears to provide the fastest solver convergence characteristics for this problem on a single-thread machine. However, for multicore computing, the Jacobi preconditioner which is multithreaded may converge quicker for larger linear systems.</p>
<div class="fragment"><div class="line">    <a class="code" href="classPreconditionSelector.html">PreconditionSelector&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;</div><div class="line">    preconditioner (parameters.preconditioner_type,</div><div class="line">                    parameters.preconditioner_relaxation);</div><div class="line">    preconditioner.use_matrix(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line"></div><div class="line">    solver_CG.solve(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof),</div><div class="line">                    newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof),</div><div class="line">                    system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof),</div><div class="line">                    preconditioner);</div><div class="line"></div><div class="line">    lin_it = solver_control.last_step();</div><div class="line">    lin_res = solver_control.last_value();</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (parameters.type_lin == <span class="stringliteral">&quot;Direct&quot;</span>)</div><div class="line">  {</div></div><!-- fragment --><p>Otherwise if the problem is small enough, a direct solver can be utilised.</p>
<div class="fragment"><div class="line">      <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">      A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(tangent_matrix.<a class="code" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a>(u_dof, u_dof));</div><div class="line">      A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(newton_update.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof), system_rhs.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(u_dof));</div><div class="line"></div><div class="line">      lin_it = 1;</div><div class="line">      lin_res = 0.0;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Linear solver type not implemented&quot;</span>));</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimerOutput.html#a220e755259be51f43eaa547c24b08080">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p>Now that we have the displacement update, distribute the constraints back to the Newton update:</p>
<div class="fragment"><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a>(newton_update);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> std::make_pair(lin_it, lin_res);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solidoutput_results"></a> </p><h4>Solid::output_results</h4>
<p>Here we present how the results are written to file to be viewed using ParaView or Visit. The method is similar to that shown in the tutorials so will not be discussed in detail.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solid&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  data_component_interpretation(dim,</div><div class="line">                                <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; solution_name(dim, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a>(dof_handler_ref);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a>(solution_n,</div><div class="line">                           solution_name,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div></div><!-- fragment --><p>Since we are dealing with a large deformation problem, it would be nice to display the result on a displaced grid! The <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> class linked with the <a class="el" href="classDataOut.html">DataOut</a> class provides an interface through which this can be achieved without physically moving the grid points in the <a class="el" href="classTriangulation.html">Triangulation</a> object ourselves. We first need to copy the solution to a temporary vector and then create the Eulerian mapping. We also specify the polynomial degree to the <a class="el" href="classDataOut.html">DataOut</a> object in order to produce a more refined output data set when higher order polynomials are used.</p>
<div class="fragment"><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> soln(solution_n.<a class="code" href="classBlockVectorBase.html#a69b8dc1f71903659eb44f12e02359ac6">size</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; soln.size(); ++i)</div><div class="line">      soln(i) = solution_n(i);</div><div class="line">    <a class="code" href="classMappingQEulerian.html">MappingQEulerian&lt;dim&gt;</a> q_mapping(degree, dof_handler_ref, soln);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a>(q_mapping, degree);</div><div class="line"></div><div class="line">    std::ostringstream filename;</div><div class="line">    filename &lt;&lt; <span class="stringliteral">&quot;solution-&quot;</span> &lt;&lt; time.get_timestep() &lt;&lt; <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line"></div><div class="line">    std::ofstream output(filename.str().c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Mainfunction"></a> </p><h3>Main function</h3>
<p>Lastly we provide the main driver function which appears no different to the other tutorials.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <span class="keyword">using namespace </span>Cook_Membrane;</div><div class="line"></div><div class="line">  <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, ::<a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(0);</div><div class="line"></div><div class="line">      Solid&lt;3&gt; solid_3d(<span class="stringliteral">&quot;parameters.prm&quot;</span>);</div><div class="line">      solid_3d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl &lt;&lt; exc.what()</div><div class="line">                &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span></div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
