<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-41 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-41 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Introduction">Introduction</a>
        <li><a href="#Classicalformulation">Classical formulation</a>
        <li><a href="#Derivationofthevariationalinequality">Derivation of the variational inequality</a>
        <li><a href="#Formulationasasaddlepointproblem">Formulation as a saddle point problem</a>
        <li><a href="#ActiveSetmethodstosolvethesaddlepointproblem">Active Set methods to solve the saddle point problem</a>
        <li><a href="#Theprimaldualactivesetalgorithm">The primal-dual active set algorithm</a>
        <li><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeObstacleProblemcodeclasstemplate">The <code>ObstacleProblem</code> class template</a>
        <li><a href="#Righthandsideboundaryvaluesandtheobstacle">Right hand side, boundary values, and the obstacle</a>
        <li><a href="#ImplementationofthecodeObstacleProblemcodeclass">Implementation of the <code>ObstacleProblem</code> class</a>
      <ul>
        <li><a href="#ObstacleProblemObstacleProblem">ObstacleProblem::ObstacleProblem</a>
        <li><a href="#ObstacleProblemmake_grid">ObstacleProblem::make_grid</a>
        <li><a href="#ObstacleProblemsetup_system">ObstacleProblem::setup_system</a>
        <li><a href="#ObstacleProblemassemble_system">ObstacleProblem::assemble_system</a>
        <li><a href="#ObstacleProblemassemble_mass_matrix_diagonal">ObstacleProblem::assemble_mass_matrix_diagonal</a>
        <li><a href="#ObstacleProblemupdate_solution_and_constraints">ObstacleProblem::update_solution_and_constraints</a>
        <li><a href="#ObstacleProblemsolve">ObstacleProblem::solve</a>
        <li><a href="#ObstacleProblemoutput_results">ObstacleProblem::output_results</a>
        <li><a href="#ObstacleProblemrun">ObstacleProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by JÃ¶rg Frohne (University of Siegen, Germany) while on a long-term visit to Texas A&amp;M University. <br />
 This material is based upon work partly supported by ThyssenKrupp Steel Europe. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h3>Introduction</h3>
<p>This example is based on the Laplace equation in 2d and deals with the question what happens if a membrane is deflected by some external force but is also constrained by an obstacle. In other words, think of a elastic membrane clamped at the boundary to a rectangular frame (we choose <img class="formulaInl" alt="$\Omega = \left[-1,1\right]^2$" src="form_3253.png"/>) and that sags through due to gravity acting on it. What happens now if there is an obstacle under the membrane that prevents it from reaching its equilibrium position if gravity was the only existing force? In the current example program, we will consider that under the membrane is a stair step obstacle against which gravity pushes the membrane.</p>
<p>This problem is typically called the "obstacle problem" (see also <a href="http://en.wikipedia.org/wiki/Obstacle_problem">this Wikipedia article</a>), and it results in a variational inequality, rather than a variational equation when put into the weak form. We will below derive it from the classical formulation, but before we go on to discuss the mathematics let us show how the solution of the problem we will consider in this tutorial program looks to gain some intuition of what we should expect:</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.png"/>
</div>
   </td></tr>
</table>
<p>Here, at the left, we see the displacement of the membrane. The shape of the obstacle underneath is clearly visible. On the right, we overlay which parts of the membrane are in contact with the obstacle. We will later call this set of points the "active set" to indicate that an inequality constraint is active there.</p>
<p><a class="anchor" id="Classicalformulation"></a></p><h3>Classical formulation</h3>
<p>The classical formulation of the problem possesses the following form: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} -\textrm{div}\ \sigma &amp;\geq f &amp; &amp;\quad\text{in } \Omega,\\ \sigma &amp;= \nabla u &amp; &amp;\quad\text{in } \Omega,\\ u(\mathbf x) &amp;= 0 &amp; &amp;\quad\text{on }\partial\Omega,\\ (-\Delta u - f)(u - g) &amp;= 0 &amp; &amp;\quad\text{in } \Omega,\\ u(\mathbf x) &amp;\geq g(\mathbf x) &amp; &amp;\quad\text{in } \Omega \end{align*}" src="form_3254.png"/>
</p>
<p> with <img class="formulaInl" alt="$u\in H^2(\Omega)$" src="form_3255.png"/>. <img class="formulaInl" alt="$u$" src="form_256.png"/> is a scalar valued function that denotes the vertical displacement of the membrane. The first equation is called equilibrium condition with a force of areal density <img class="formulaInl" alt="$f$" src="form_417.png"/>. Here, we will consider this force to be gravity. The second one is known as Hooke's Law that says that the stresses <img class="formulaInl" alt="$\sigma$" src="form_456.png"/> are proportional to the gradient of the displacements <img class="formulaInl" alt="$u$" src="form_256.png"/> (the proportionality constant, often denoted by <img class="formulaInl" alt="$E$" src="form_1205.png"/>, has been set to one here, without loss of generality; if it is constant, it can be put into the right hand side function). At the boundary we have zero Dirichlet conditions. Obviously, the first two equations can be combined to yield <img class="formulaInl" alt="$-\Delta u \ge f$" src="form_3256.png"/>.</p>
<p>Intuitively, gravity acts downward and so <img class="formulaInl" alt="$f(\mathbf x)$" src="form_588.png"/> is a negative function (we choose <img class="formulaInl" alt="$f=-10$" src="form_3257.png"/> in this program). The first condition then means that the total force acting on the membrane is gravity plus something positive: namely the upward force that the obstacle exerts on the membrane at those places where the two of them are in contact. How big is this additional force? We don't know yet (and neither do we know "where" it actually acts) but it must be so that the membrane doesn't penetrate the obstacle.</p>
<p>The fourth equality above together with the last inequality forms the obstacle condition which has to hold at every point of the whole domain. The latter of these two means that the membrane must be above the obstacle <img class="formulaInl" alt="$g(\mathbf x)$" src="form_4.png"/> everywhere. The second to last equation, often called the "complementarity
condition" says that where the membrane is not in contact with the obstacle (i.e., those <img class="formulaInl" alt="$\mathbf x$" src="form_751.png"/> where <img class="formulaInl" alt="$u(\mathbf x) - g(\mathbf x) \neq 0$" src="form_3258.png"/>), then <img class="formulaInl" alt="$-\Delta u=f$" src="form_1490.png"/> at these locations; in other words, no additional forces act there, as expected. On the other hand, where <img class="formulaInl" alt="$u=g$" src="form_3259.png"/> we can have <img class="formulaInl" alt="$-\Delta u-f \neq 0$" src="form_3260.png"/>, i.e., there can be additional forces (though there don't have to be: it is possible for the membrane to just touch, not press against, the obstacle).</p>
<p><a class="anchor" id="Derivationofthevariationalinequality"></a></p><h3>Derivation of the variational inequality</h3>
<p>An obvious way to obtain the variational formulation of the obstacle problem is to consider the total potential energy: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} E(u):=\dfrac{1}{2}\int\limits_{\Omega} \nabla u \cdot \nabla u - \int\limits_{\Omega} fu. \end{equation*}" src="form_3261.png"/>
</p>
<p> We have to find a solution <img class="formulaInl" alt="$u\in G$" src="form_3262.png"/> of the following minimization problem: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} E(u)\leq E(v)\quad \forall v\in G, \end{equation*}" src="form_3263.png"/>
</p>
<p> with the convex set of admissible displacements: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} G:=\lbrace v\in V: v\geq g \text{ a.e. in } \Omega\rbrace,\quad V:=H^1_0(\Omega). \end{equation*}" src="form_3264.png"/>
</p>
<p> This set takes care of the third and fifth conditions above (the boundary values and the complementarity condition).</p>
<p>Consider now the minimizer <img class="formulaInl" alt="$u\in G$" src="form_3262.png"/> of <img class="formulaInl" alt="$E$" src="form_1205.png"/> and any other function <img class="formulaInl" alt="$v\in G$" src="form_3265.png"/>. Then the function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} F(\varepsilon) := E(u+\varepsilon(v-u)),\quad\varepsilon\in\left[0,1\right], \end{equation*}" src="form_3266.png"/>
</p>
<p> takes its minimum at <img class="formulaInl" alt="$\varepsilon = 0$" src="form_3267.png"/> (because <img class="formulaInl" alt="$u$" src="form_256.png"/> is a minimizer of the energy functional <img class="formulaInl" alt="$E(\cdot)$" src="form_3268.png"/>), so that <img class="formulaInl" alt="$F'(0)\geq 0$" src="form_3269.png"/> for any choice of <img class="formulaInl" alt="$v$" src="form_987.png"/>. Note that <img class="formulaInl" alt="$u+\varepsilon(v-u) = (1-\varepsilon)u+\varepsilon v\in G$" src="form_3270.png"/> because of the convexity of <img class="formulaInl" alt="$G$" src="form_2300.png"/>. If we compute <img class="formulaInl" alt="$F'(\varepsilon)\vert_{\varepsilon=0}$" src="form_3271.png"/> it yields the variational formulation we are searching for:</p>
<p><em>Find a function <img class="formulaInl" alt="$u\in G$" src="form_3262.png"/> with</em> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \left(\nabla u, \nabla(v-u)\right) \geq \left(f,v-u\right) \quad \forall v\in G. \end{equation*}" src="form_3272.png"/>
</p>
<p>This is the typical form of variational inequalities, where not just <img class="formulaInl" alt="$v$" src="form_987.png"/> appears in the bilinear form but in fact <img class="formulaInl" alt="$v-u$" src="form_3273.png"/>. The reason is this: if <img class="formulaInl" alt="$u$" src="form_256.png"/> is not constrained, then we can find test functions <img class="formulaInl" alt="$v$" src="form_987.png"/> in <img class="formulaInl" alt="$G$" src="form_2300.png"/> so that <img class="formulaInl" alt="$v-u$" src="form_3273.png"/> can have any sign. By choosing test functions <img class="formulaInl" alt="$v_1,v_2$" src="form_3274.png"/> so that <img class="formulaInl" alt="$v_1-u = -(v_2-u)$" src="form_3275.png"/> it follows that the inequality can only hold for both <img class="formulaInl" alt="$v_1$" src="form_839.png"/> and <img class="formulaInl" alt="$v_2$" src="form_840.png"/> if the two sides are in fact equal, i.e., we obtain a variational equality.</p>
<p>On the other hand, if <img class="formulaInl" alt="$u=g$" src="form_3259.png"/> then <img class="formulaInl" alt="$G$" src="form_2300.png"/> only allows test functions <img class="formulaInl" alt="$v$" src="form_987.png"/> so that in fact <img class="formulaInl" alt="$v-u\ge 0$" src="form_3276.png"/>. This means that we can't test the equation with both <img class="formulaInl" alt="$v-u$" src="form_3273.png"/> and <img class="formulaInl" alt="$-(v-u)$" src="form_3277.png"/> as above, and so we can no longer conclude that the two sides are in fact equal. Thus, this mimics the way we have discussed the complementarity condition above.</p>
<p><a class="anchor" id="Formulationasasaddlepointproblem"></a></p><h3>Formulation as a saddle point problem</h3>
<p>The variational inequality above is awkward to work with. We would therefore like to reformulate it as an equivalent saddle point problem. We introduce a Lagrange multiplier <img class="formulaInl" alt="$\lambda$" src="form_548.png"/> and the convex cone <img class="formulaInl" alt="$K\subset V'$" src="form_3278.png"/>, <img class="formulaInl" alt="$V'$" src="form_3279.png"/> dual space of <img class="formulaInl" alt="$V$" src="form_204.png"/>, <img class="formulaInl" alt="$K:=\{\mu\in V': \langle\mu,v\rangle\geq 0,\quad \forall v\in V, v \le 0 \}$" src="form_3280.png"/> of Lagrange multipliers, where <img class="formulaInl" alt="$\langle\cdot,\cdot\rangle$" src="form_3281.png"/> denotes the duality pairing between <img class="formulaInl" alt="$V'$" src="form_3279.png"/> and <img class="formulaInl" alt="$V$" src="form_204.png"/>. Intuitively, <img class="formulaInl" alt="$K$" src="form_57.png"/> is the cone of all "non-positive
functions", except that <img class="formulaInl" alt="$K\subset (H_0^1)'$" src="form_3282.png"/> and so contains other objects besides regular functions as well. This yields:</p>
<p><em>Find <img class="formulaInl" alt="$u\in V$" src="form_3283.png"/> and <img class="formulaInl" alt="$\lambda\in K$" src="form_3284.png"/> such that</em> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} a(u,v) + b(v,\lambda) &amp;= f(v),\quad &amp;&amp;v\in V\\ b(u,\mu - \lambda) &amp;\leq \langle g,\mu - \lambda\rangle,\quad&amp;&amp;\mu\in K, \end{align*}" src="form_3285.png"/>
</p>
<p> <em>with</em> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} a(u,v) &amp;:= \left(\nabla u, \nabla v\right),\quad &amp;&amp;u,v\in V\\ b(u,\mu) &amp;:= \langle u,\mu\rangle,\quad &amp;&amp;u\in V,\quad\mu\in V'. \end{align*}" src="form_3286.png"/>
</p>
<p> In other words, we can consider <img class="formulaInl" alt="$\lambda$" src="form_548.png"/> as the negative of the additional, positive force that the obstacle exerts on the membrane. The inequality in the second line of the statement above only appears to have the wrong sign because we have <img class="formulaInl" alt="$\mu-\lambda&lt;0$" src="form_3287.png"/> at points where <img class="formulaInl" alt="$\lambda=0$" src="form_3288.png"/>, given the definition of <img class="formulaInl" alt="$K$" src="form_57.png"/>.</p>
<p>The existence and uniqueness of <img class="formulaInl" alt="$(u,\lambda)\in V\times K$" src="form_3289.png"/> of this saddle point problem has been stated in Glowinski, Lions and Tr&eacute;moli&egrave;res: Numerical Analysis of Variational Inequalities, North-Holland, 1981.</p>
<p><a class="anchor" id="ActiveSetmethodstosolvethesaddlepointproblem"></a></p><h3>Active Set methods to solve the saddle point problem</h3>
<p>There are different methods to solve the variational inequality. As one possibility you can understand the saddle point problem as a convex quadratic program (QP) with inequality constraints.</p>
<p>To get there, let us assume that we discretize both <img class="formulaInl" alt="$u$" src="form_256.png"/> and <img class="formulaInl" alt="$\lambda$" src="form_548.png"/> with the same finite element space, for example the usual <img class="formulaInl" alt="$Q_k$" src="form_3128.png"/> spaces. We would then get the equations </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;[BU-G]_i \geq 0, \quad \Lambda_i \leq 0,\quad \Lambda_i[BU-G]_i = 0 \qquad \forall i.&amp; \end{eqnarray*}" src="form_3290.png"/>
</p>
<p> where <img class="formulaInl" alt="$B$" src="form_65.png"/> is the mass matrix on the chosen finite element space and the indices <img class="formulaInl" alt="$i$" src="form_90.png"/> above are for all degrees of freedom in the set <img class="formulaInl" alt="$\cal S$" src="form_3291.png"/> of degrees of freedom located in the interior of the domain (we have Dirichlet conditions on the perimeter). However, we can make our life simpler if we use a particular quadrature rule when assembling all terms that yield this mass matrix, namely a quadrature formula where quadrature points are only located at the interpolation points at which shape functions are defined; since all but one shape function are zero at these locations, we get a diagonal mass matrix with </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} B_{ii} = \int_\Omega \varphi_i(\mathbf x)^2\ \textrm{d}x, \qquad B_{ij}=0 \ \text{for } i\neq j. \end{align*}" src="form_3292.png"/>
</p>
<p> To define <img class="formulaInl" alt="$G$" src="form_2300.png"/> we use the same technique as for <img class="formulaInl" alt="$B$" src="form_65.png"/>. In other words, we define </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} G_{i} = \int_\Omega g_h(x) \varphi_i(\mathbf x)\ \textrm{d}x, \end{align*}" src="form_3293.png"/>
</p>
<p> where <img class="formulaInl" alt="$g_h$" src="form_3294.png"/> is a suitable approximation of <img class="formulaInl" alt="$g$" src="form_36.png"/>. The integral in the definition of <img class="formulaInl" alt="$B_{ii}$" src="form_3295.png"/> and <img class="formulaInl" alt="$G_i$" src="form_3296.png"/> are then approximated by the trapezoidal rule. With this, the equations above can be restated as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;U_i-B_{ii}^{-1}G_i \ge 0, \quad \Lambda_i \leq 0,\quad \Lambda_i[U_i-B_{ii}^{-1}G_i] = 0 \qquad \forall i\in{\cal S}.&amp; \end{eqnarray*}" src="form_3297.png"/>
</p>
<p>Now we define for each degree of freedom <img class="formulaInl" alt="$i$" src="form_90.png"/> the function </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} C([BU]_i,\Lambda_i):=-\Lambda_i + \min\lbrace 0, \Lambda_i + c([BU]_i - G_i) \rbrace, \end{equation*}" src="form_3298.png"/>
</p>
<p> with some <img class="formulaInl" alt="$c&gt;0$" src="form_3299.png"/>. (In this program we choose <img class="formulaInl" alt="$c = 100$" src="form_3300.png"/>. It is a kind of a penalty parameter which depends on the problem itself and needs to be chosen large enough; for example there is no convergence for <img class="formulaInl" alt="$c = 1$" src="form_3301.png"/> using the current program if we use 7 global refinements.)</p>
<p>After some head-scratching one can then convince oneself that the inequalities above can equivalently be rewritten as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} C([BU]_i,\Lambda_i) = 0, \qquad \forall i\in{\cal S}. \end{equation*}" src="form_3302.png"/>
</p>
<p> The primal-dual active set strategy we will use here is an iterative scheme which is based on this condition to predict the next active and inactive sets <img class="formulaInl" alt="$\mathcal{A}_k$" src="form_3303.png"/> and <img class="formulaInl" alt="$\mathcal{F}_k$" src="form_3304.png"/> (that is, those complementary sets of indices <img class="formulaInl" alt="$i$" src="form_90.png"/> for which <img class="formulaInl" alt="$U_i$" src="form_2459.png"/> is either equal to or not equal to the value of the obstacle <img class="formulaInl" alt="$B^{-1}G$" src="form_3305.png"/>). For a more in depth treatment of this approach, see Hintermueller, Ito, Kunisch: The primal-dual active set strategy as a semismooth newton method, SIAM J. OPTIM., 2003, Vol. 13, No. 3, pp. 865-888.</p>
<p><a class="anchor" id="Theprimaldualactivesetalgorithm"></a></p><h3>The primal-dual active set algorithm</h3>
<p>The algorithm for the primal-dual active set method works as follows (NOTE: <img class="formulaInl" alt="$B = B^T$" src="form_3306.png"/>):</p>
<ol type="1">
<li>Initialize <img class="formulaInl" alt="$\mathcal{A}_k$" src="form_3303.png"/> and <img class="formulaInl" alt="$\mathcal{F}_k$" src="form_3304.png"/>, such that <img class="formulaInl" alt="$\mathcal{S}=\mathcal{A}_k\cup\mathcal{F}_k$" src="form_3307.png"/> and <img class="formulaInl" alt="$\mathcal{A}_k\cap\mathcal{F}_k=\emptyset$" src="form_3308.png"/> and set <img class="formulaInl" alt="$k=1$" src="form_3309.png"/>.</li>
<li>Find the primal-dual pair <img class="formulaInl" alt="$(U^k,\Lambda^k)$" src="form_3310.png"/> that satisfies <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} AU^k + B\Lambda^k &amp;= F,\\ [BU^k]_i &amp;= G_i\quad&amp;&amp;\forall i\in\mathcal{A}_k,\\ \Lambda_i^k &amp;= 0\quad&amp;&amp;\forall i\in\mathcal{F}_k. \end{align*}" src="form_3311.png"/>
</p>
 Note that the second and third conditions imply that exactly <img class="formulaInl" alt="$|S|$" src="form_3312.png"/> unknowns are fixed, with the first condition yielding the remaining <img class="formulaInl" alt="$|S|$" src="form_3312.png"/> equations necessary to determine both <img class="formulaInl" alt="$U$" src="form_203.png"/> and <img class="formulaInl" alt="$\Lambda$" src="form_3313.png"/>.</li>
<li>Define the new active and inactive sets by <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \begin{split} \mathcal{A}_{k+1}:=\lbrace i\in\mathcal{S}:\Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\rbrace,\\ \mathcal{F}_{k+1}:=\lbrace i\in\mathcal{S}:\Lambda^k_i + c([BU^k]_i - G_i)\geq 0\rbrace. \end{split} \end{equation*}" src="form_3314.png"/>
</p>
</li>
<li>If <img class="formulaInl" alt="$\mathcal{A}_{k+1}=\mathcal{A}_k$" src="form_3315.png"/> (and then, obviously, also <img class="formulaInl" alt="$\mathcal{F}_{k+1}=\mathcal{F}_k$" src="form_3316.png"/>) then stop, else set <img class="formulaInl" alt="$k=k+1$" src="form_3317.png"/> and go to step (2).</li>
</ol>
<p>The method is called "primal-dual" because it uses both primal (the displacement <img class="formulaInl" alt="$U$" src="form_203.png"/>) as well as dual variables (the Lagrange multiplier <img class="formulaInl" alt="$\Lambda$" src="form_3313.png"/>) to determine the next active set.</p>
<p>At the end of this section, let us add two observations. First, for any primal-dual pair <img class="formulaInl" alt="$(U^k,\Lambda^k)$" src="form_3310.png"/> that satisfies these condition, we can distinguish the following cases:</p>
<ol type="1">
<li><img class="formulaInl" alt="$\Lambda^k_i + c([BU^k]_i - G_i) &lt; 0$" src="form_3318.png"/> (i active): <br />
 Then either <img class="formulaInl" alt="$[BU^k]_i&lt;G_i$" src="form_3319.png"/> and <img class="formulaInl" alt="$\Lambda^k_i=0$" src="form_3320.png"/> (penetration) or <img class="formulaInl" alt="$\Lambda^k_i&lt;0$" src="form_3321.png"/> and <img class="formulaInl" alt="$[BU^k]_i=G_i$" src="form_3322.png"/> (pressing load).</li>
<li><img class="formulaInl" alt="$\Lambda^k_i + c([BU^k]_i - G_i)\geq 0$" src="form_3323.png"/> (i inactive): <br />
 Then either <img class="formulaInl" alt="$[BU^k]_i\geq G_i$" src="form_3324.png"/> and <img class="formulaInl" alt="$\Lambda^k_i=0$" src="form_3320.png"/> (no contact) or <img class="formulaInl" alt="$\Lambda^k_i\geq0$" src="form_3325.png"/> and <img class="formulaInl" alt="$[BU^k]_i=G_i$" src="form_3322.png"/> (unpressing load).</li>
</ol>
<p>Second, the method above appears intuitively correct and useful but a bit ad hoc. However, it can be derived in a concisely in the following way. To this end, note that we'd like to solve the nonlinear system </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} &amp;A U + B\Lambda = F,&amp;\\ &amp;C([BU-G]_i, \Lambda_i) = 0, \qquad \forall i.&amp; \end{eqnarray*}" src="form_3326.png"/>
</p>
<p> We can iteratively solve this by always linearizing around the previous iterate (i.e., applying a Newton method), but for this we need to linearize the function <img class="formulaInl" alt="$C(\cdot,\cdot)$" src="form_3327.png"/> that is not differentiable. That said, it is slantly differentiable, and in fact we have </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \dfrac{\partial}{\partial U^k_i}C([BU^k]_i,\Lambda^k_i) = \begin{cases} cB_{ii},&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\\ 0,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)\geq 0. \end{cases} \end{equation*}" src="form_3328.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \dfrac{\partial}{\partial\Lambda^k_i}C([BU^k]_i,\Lambda^k_i) = \begin{cases} 0,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)&lt; 0\\ -1,&amp; \text{if}\ \Lambda^k_i + c([BU^k]_i - G_i)\geq 0. \end{cases} \end{equation*}" src="form_3329.png"/>
</p>
<p> This suggest a semismooth Newton step of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; B_{\mathcal{F}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; 0 &amp; B_{\mathcal{A}_k}\\ 0 &amp; 0 &amp; -Id_{\mathcal{F}_k} &amp; 0\\ 0 &amp; cB_{\mathcal{A}_k} &amp; 0 &amp; 0 \end{pmatrix} \begin{pmatrix} \delta U^k_{\mathcal{F}_k}\\ \delta U^k_{\mathcal{A}_k}\\ \delta \Lambda^k_{\mathcal{F}_k}\\ \delta \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = -\begin{pmatrix} (AU^k + \Lambda^k - F)_{\mathcal{F}_k}\\ (AU^k + \Lambda^k - F)_{\mathcal{A}_k}\\ -\Lambda^k_{\mathcal{F}_k}\\ c(B_{\mathcal{A}_k} U^k - G)_{\mathcal{A}_k} \end{pmatrix}, \end{equation*}" src="form_3330.png"/>
</p>
<p> where we have split matrices <img class="formulaInl" alt="$A,B$" src="form_3331.png"/> as well as vectors in the natural way into rows and columns whose indices belong to either the active set <img class="formulaInl" alt="${\mathcal{A}_k}$" src="form_3332.png"/> or the inactive set <img class="formulaInl" alt="${\mathcal{F}_k}$" src="form_3333.png"/>.</p>
<p>Rather than solving for updates <img class="formulaInl" alt="$\delta U, \delta \Lambda$" src="form_3334.png"/>, we can also solve for the variables we are interested in right away by setting <img class="formulaInl" alt="$\delta U^k := U^{k+1} - U^k$" src="form_3335.png"/> and <img class="formulaInl" alt="$\delta \Lambda^k := \Lambda^{k+1} - \Lambda^k$" src="form_3336.png"/> and bringing all known terms to the right hand side. This yields </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; B_{\mathcal{F}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; 0 &amp; B_{\mathcal{A}_k}\\ 0 &amp; 0 &amp; Id_{\mathcal{F}_k} &amp; 0\\ 0 &amp; B_{\mathcal{A}_k} &amp; 0 &amp; 0 \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k}\\ \Lambda^k_{\mathcal{F}_k}\\ \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k}\\ 0\\ G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}" src="form_3337.png"/>
</p>
<p> These are the equations outlined above in the description of the basic algorithm.</p>
<p>We could even drive this a bit further. It's easy to see that we can eliminate the third row and the third column because it implies <img class="formulaInl" alt="$\Lambda_{\mathcal{F}_k} = 0$" src="form_3338.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} &amp; 0\\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} &amp; B_{\mathcal{A}_k}\\ 0 &amp; B_{\mathcal{A}_k} &amp; 0 \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k}\\ \Lambda^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k}\\ G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}" src="form_3339.png"/>
</p>
<p> This shows that one in fact only needs to solve for the Lagrange multipliers located on the active set. By considering the second row one would then recover the full Lagrange multiplier vector through </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \Lambda^k_S = B^{-1}\left(f_{\mathcal{S}} - A_{\mathcal{S}}U^k_{\mathcal{S}}\right). \end{equation*}" src="form_3340.png"/>
</p>
<p> Because of the third row and the fact that <img class="formulaInl" alt="$B_{\mathcal{A}_k}$" src="form_3341.png"/> is a diagonal matrix we are able to calculate <img class="formulaInl" alt="$U^k_{\mathcal{A}_k}=B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k}$" src="form_3342.png"/> directly. We can therefore also write the linear system as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; 0\\ 0 &amp; Id_{\mathcal{A}_k} \\ \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k} - A_{\mathcal{F}_k\mathcal{A}_k}B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k} \\ B_{\mathcal{A}_k}^{-1}G_{\mathcal{A}_k} \end{pmatrix}. \end{equation*}" src="form_3343.png"/>
</p>
<p> Fortunately, this form is easy to arrive at: we simply build the usual Laplace linear system </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \begin{pmatrix} A_{\mathcal{F}_k\mathcal{F}_k} &amp; A_{\mathcal{F}_k\mathcal{A}_k} \\ A_{\mathcal{A}_k\mathcal{F}_k} &amp; A_{\mathcal{A}_k\mathcal{A}_k} \end{pmatrix} \begin{pmatrix} U^k_{\mathcal{F}_k}\\ U^k_{\mathcal{A}_k} \end{pmatrix} = \begin{pmatrix} F_{\mathcal{F}_k}\\ F_{\mathcal{A}_k} \end{pmatrix}, \end{equation*}" src="form_3344.png"/>
</p>
<p> and then let the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class eliminate all constrained degrees of freedom, namely <img class="formulaInl" alt="$U^k_{\mathcal{A}_k}=B^{-1}_{\mathcal{A}_k}G_{\mathcal{A}_k}$" src="form_3342.png"/>, in the same way as if the dofs in <img class="formulaInl" alt="$\mathcal{A}_k$" src="form_3303.png"/> were Dirichlet data. The result linear system (the second to last one above) is symmetric and positive definite and we solve it with a CG-method and the AMG preconditioner from Trilinos.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>This tutorial is quite similar to <a class="el" href="step_4.html">step-4</a>. The general structure of the program follows <a class="el" href="step_4.html">step-4</a> with minor differences:</p><ul>
<li>We need two new methods, <code>assemble_mass_matrix_diagonal</code> and <code>update_solution_and_constraints</code>.</li>
<li>We need new member variables that denote the constraints we have here.</li>
<li>We change the preconditioner for the solver.</li>
</ul>
<p>You may want to read up on <a class="el" href="step_4.html">step-4</a> if you want to understand the current program. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As usual, at the beginning we include all the header files we need in here. With the exception of the various files that provide interfaces to the Trilinos library, there are no surprises:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_precondition.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step41</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeObstacleProblemcodeclasstemplate"></a> </p><h3>The <code>ObstacleProblem</code> class template</h3>
<p>This class supplies all function and variables needed to describe the obstacle problem. It is close to what we had to do in <a class="el" href="step_4.html">step-4</a>, and so relatively simple. The only real new components are the update_solution_and_constraints function that computes the active set and a number of variables that are necessary to describe the original (unconstrained) form of the linear system (<code>complete_system_matrix</code> and <code>complete_system_rhs</code>) as well as the active set itself and the diagonal of the mass matrix <img class="formulaInl" alt="$B$" src="form_65.png"/> used in scaling Lagrange multipliers in the active set formulation. The rest is as in <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ObstacleProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ObstacleProblem ();</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid ();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_mass_matrix_diagonal (TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">  <span class="keywordtype">void</span> update_solution_and_constraints ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a>             active_set;</div><div class="line"></div><div class="line">  TrilinosWrappers::SparseMatrix system_matrix;</div><div class="line">  TrilinosWrappers::SparseMatrix complete_system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  system_rhs;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  complete_system_rhs;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  diagonal_of_mass_matrix;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  contact_force;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideboundaryvaluesandtheobstacle"></a> </p><h3>Right hand side, boundary values, and the obstacle</h3>
<p>In the following, we define classes that describe the right hand side function, the Dirichlet boundary values, and the height of the obstacle as a function of <img class="formulaInl" alt="$\mathbf x$" src="form_751.png"/>. In all three cases, we derive these classes from <a class="el" href="classFunction.html">Function</a>&lt;dim&gt;, although in the case of <code>RightHandSide</code> and <code>Obstacle</code> this is more out of convention than necessity since we never pass such objects to the library. In any case, the definition of the right hand side and boundary values classes is obvious given our choice of <img class="formulaInl" alt="$f=-10$" src="form_3257.png"/>, <img class="formulaInl" alt="$u|_{\partial\Omega}=0$" src="form_3118.png"/>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void) component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> -10;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void) component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>We describe the obstacle function by a cascaded barrier (think: stair steps):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Obstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Obstacle () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Obstacle&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void) component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (p (0) &lt; -0.5)</div><div class="line">    <span class="keywordflow">return</span> -0.2;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p (0) &gt;= -0.5 &amp;&amp; p (0) &lt; 0.0)</div><div class="line">    <span class="keywordflow">return</span> -0.4;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p (0) &gt;= 0.0 &amp;&amp; p (0) &lt; 0.5)</div><div class="line">    <span class="keywordflow">return</span> -0.6;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> -0.8;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeObstacleProblemcodeclass"></a> </p><h3>Implementation of the <code>ObstacleProblem</code> class</h3>
<p><a class="anchor" id="ObstacleProblemObstacleProblem"></a> </p><h4>ObstacleProblem::ObstacleProblem</h4>
<p>To everyone who has taken a look at the first few tutorial programs, the constructor is completely obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ObstacleProblem&lt;dim&gt;::ObstacleProblem ()</div><div class="line">  :</div><div class="line">  fe (1),</div><div class="line">  dof_handler (triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemmake_grid"></a> </p><h4>ObstacleProblem::make_grid</h4>
<p>We solve our obstacle problem on the square <img class="formulaInl" alt="$[-1,1]\times [-1,1]$" src="form_3247.png"/> in 2D. This function therefore just sets up one of the simplest possible meshes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::make_grid ()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemsetup_system"></a> </p><h4>ObstacleProblem::setup_system</h4>
<p>In this first function of note, we set up the degrees of freedom handler, resize vectors and matrices, and deal with the constraints. Initially, the constraints are, of course, only given by boundary values, so we interpolate them towards the top of the function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">  active_set.set_size (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            BoundaryValues&lt;dim&gt;(),</div><div class="line">                                            constraints);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler,</div><div class="line">                                   dsp,</div><div class="line">                                   constraints,</div><div class="line">                                   <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  system_matrix.reinit (dsp);</div><div class="line">  complete_system_matrix.reinit (dsp);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> solution_index_set = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (solution_index_set, MPI_COMM_WORLD);</div><div class="line">  system_rhs.reinit (solution_index_set, MPI_COMM_WORLD);</div><div class="line">  complete_system_rhs.reinit (solution_index_set, MPI_COMM_WORLD);</div><div class="line">  contact_force.reinit (solution_index_set, MPI_COMM_WORLD);</div></div><!-- fragment --><p>The only other thing to do here is to compute the factors in the <img class="formulaInl" alt="$B$" src="form_65.png"/> matrix which is used to scale the residual. As discussed in the introduction, we'll use a little trick to make this mass matrix diagonal, and in the following then first compute all of this as a matrix and then extract the diagonal elements for later use:</p>
<div class="fragment"><div class="line">  TrilinosWrappers::SparseMatrix mass_matrix;</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a> (dsp);</div><div class="line">  assemble_mass_matrix_diagonal (mass_matrix);</div><div class="line">  diagonal_of_mass_matrix.reinit (solution_index_set);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;solution.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a> (); j++)</div><div class="line">    diagonal_of_mass_matrix (j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a> (j);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemassemble_system"></a> </p><h4>ObstacleProblem::assemble_system</h4>
<p>This function at once assembles the system matrix and right-hand-side and applied the constraints (both due to the active set as well as from boundary values) to our system. Otherwise, it is functionally equivalent to the corresponding function in, for example, <a class="el" href="step_4.html">step-4</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>         quadrature_formula(fe.degree+1);</div><div class="line">  <span class="keyword">const</span> RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>             fe_values (fe, quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              cell_matrix(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a> (i, q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a> (j, q_point) *</div><div class="line">                                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point));</div><div class="line"></div><div class="line">            cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i, q_point) *</div><div class="line">                            right_hand_side.value (fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a> (q_point)) *</div><div class="line">                            fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point));</div><div class="line">          }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a> (cell_matrix,</div><div class="line">                                              cell_rhs,</div><div class="line">                                              local_dof_indices,</div><div class="line">                                              system_matrix,</div><div class="line">                                              system_rhs,</div><div class="line">                                              <span class="keyword">true</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemassemble_mass_matrix_diagonal"></a> </p><h4>ObstacleProblem::assemble_mass_matrix_diagonal</h4>
<p>The next function is used in the computation of the diagonal mass matrix <img class="formulaInl" alt="$B$" src="form_65.png"/> used to scale variables in the active set method. As discussed in the introduction, we get the mass matrix to be diagonal by choosing the trapezoidal rule for quadrature. Doing so we don't really need the triple loop over quadrature points, indices <img class="formulaInl" alt="$i$" src="form_90.png"/> and indices <img class="formulaInl" alt="$j$" src="form_513.png"/> any more and can, instead, just use a double loop. The rest of the function is obvious given what we have discussed in many of the previous tutorial programs.</p>
<p>Note that at the time this function is called, the constraints object only contains boundary value constraints; we therefore do not have to pay attention in the last copy-local-to-global step to preserve the values of matrix entries that may later on be constrained by the active set.</p>
<p>Note also that the trick with the trapezoidal rule only works if we have in fact <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> elements. For higher order elements, one would need to use a quadrature formula that has quadrature points at all the support points of the finite element. Constructing such a quadrature formula isn't really difficult, but not the point here, and so we simply assert at the top of the function that our implicit assumption about the finite element is in fact satisfied.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ObstacleProblem&lt;dim&gt;::</div><div class="line">assemble_mass_matrix_diagonal (TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (fe.degree == 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQTrapez.html">QTrapez&lt;dim&gt;</a>        quadrature_formula;</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>             fe_values (fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">      cell_matrix = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          cell_matrix(i,i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i, q_point) *</div><div class="line">                               fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i, q_point) *</div><div class="line">                               fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point));</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a> (cell_matrix,</div><div class="line">                                              local_dof_indices,</div><div class="line">                                              mass_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemupdate_solution_and_constraints"></a> </p><h4>ObstacleProblem::update_solution_and_constraints</h4>
<p>In a sense, this is the central function of this program. It updates the active set of constrained degrees of freedom as discussed in the introduction and computes a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object from it that can then be used to eliminate constrained degrees of freedom from the solution of the next iteration. At the same time we set the constrained degrees of freedom of the solution to the correct value, namely the height of the obstacle.</p>
<p>Fundamentally, the function is rather simple: We have to loop over all degrees of freedom and check the sign of the function <img class="formulaInl" alt="$\Lambda^k_i + c([BU^k]_i - G_i) = \Lambda^k_i + cB_i(U^k_i - [g_h]_i)$" src="form_3345.png"/> because in our case <img class="formulaInl" alt="$G_i = B_i[g_h]_i$" src="form_3346.png"/>. To this end, we use the formula given in the introduction by which we can compute the Lagrange multiplier as the residual of the original linear system (given via the variables <code>complete_system_matrix</code> and <code>complete_system_rhs</code>. At the top of this function, we compute this residual using a function that is part of the matrix classes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ObstacleProblem&lt;dim&gt;::update_solution_and_constraints ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty_parameter = 100.0;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda (<a class="code" href="classIndexSet.html#a9ce660b8e47e336e4842066394d44a65">complete_index_set</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()));</div><div class="line">  complete_system_matrix.residual (lambda,</div><div class="line">                                   solution, complete_system_rhs);</div></div><!-- fragment --><p>compute contact_force[i] = - lambda[i] * diagonal_of_mass_matrix[i]</p>
<div class="fragment"><div class="line">contact_force = lambda;</div><div class="line">contact_force.scale (diagonal_of_mass_matrix);</div><div class="line">contact_force *= -1;</div></div><!-- fragment --><p>The next step is to reset the active set and constraints objects and to start the loop over all degrees of freedom. This is made slightly more complicated by the fact that we can't just loop over all elements of the solution vector since there is no way for us then to find out what location a DoF is associated with; however, we need this location to test whether the displacement of a DoF is larger or smaller than the height of the obstacle at this location.</p>
<p>We work around this by looping over all cells and DoFs defined on each of these cells. We use here that the displacement is described using a <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> function for which degrees of freedom are always located on the vertices of the cell; thus, we can get the index of each degree of freedom and its location by asking the vertex for this information. On the other hand, this clearly wouldn't work for higher order elements, and so we add an assertion that makes sure that we only deal with elements for which all degrees of freedom are located in vertices to avoid tripping ourselves with non-functional code in case someone wants to play with increasing the polynomial degree of the solution.</p>
<p>The price to pay for having to loop over cells rather than DoFs is that we may encounter some degrees of freedom more than once, namely each time we visit one of the cells adjacent to a given vertex. We will therefore have to keep track which vertices we have already touched and which we haven't so far. We do so by using an array of flags <code>dof_touched</code>:</p>
<div class="fragment"><div class="line">constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a>();</div><div class="line">active_set.clear ();</div><div class="line"></div><div class="line"><span class="keyword">const</span> Obstacle&lt;dim&gt; obstacle;</div><div class="line">std::vector&lt;bool&gt;   dof_touched (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a> ==</div><div class="line">              <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::vertices_per_cell</a>,</div><div class="line">              <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_index = cell-&gt;vertex_dof_index (v,0);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (dof_touched[dof_index] == <span class="keyword">false</span>)</div><div class="line">        dof_touched[dof_index] = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">continue</span>;</div></div><!-- fragment --><p>Now that we know that we haven't touched this DoF yet, let's get the value of the displacement function there as well as the value of the obstacle function and use this to decide whether the current DoF belongs to the active set. For that we use the function given above and in the introduction.</p>
<p>If we decide that the DoF should be part of the active set, we add its index to the active set, introduce an inhomogeneous equality constraint in the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object, and reset the solution value to the height of the obstacle. Finally, the residual of the non-contact part of the system serves as an additional control (the residual equals the remaining, unaccounted forces, and should be zero outside the contact zone), so we zero out the components of the residual vector (i.e., the Lagrange multiplier lambda) that correspond to the area where the body is in contact; at the end of the loop over all cells, the residual will therefore only consist of the residual in the non-contact zone. We output the norm of this residual along with the size of the active set after the loop.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value = obstacle.value (cell-&gt;vertex(v));</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> solution_value = solution (dof_index);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (lambda (dof_index) +</div><div class="line">          penalty_parameter *</div><div class="line">          diagonal_of_mass_matrix(dof_index) *</div><div class="line">          (solution_value - obstacle_value)</div><div class="line">          &lt;</div><div class="line">          0)</div><div class="line">        {</div><div class="line">          active_set.add_index (dof_index);</div><div class="line">          constraints.<a class="code" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line</a> (dof_index);</div><div class="line">          constraints.<a class="code" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity</a> (dof_index, obstacle_value);</div><div class="line"></div><div class="line">          solution (dof_index) = obstacle_value;</div><div class="line"></div><div class="line">          lambda (dof_index) = 0;</div><div class="line">        }</div><div class="line">    }</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;      Size of active set: &quot;</span> &lt;&lt; active_set.n_elements()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Residual of the non-contact part of the system: &quot;</span></div><div class="line">          &lt;&lt; lambda.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>()</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>In a final step, we add to the set of constraints on DoFs we have so far from the active set those that result from Dirichlet boundary values, and close the constraints object:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            0,</div><div class="line">                                            BoundaryValues&lt;dim&gt;(),</div><div class="line">                                            constraints);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemsolve"></a> </p><h4>ObstacleProblem::solve</h4>
<p>There is nothing to say really about the solve function. In the context of a Newton method, we are not typically interested in very high accuracy (why ask for a highly accurate solution of a linear problem that we know only gives us an approximation of the solution of the nonlinear problem), and so we use the <a class="el" href="classReductionControl.html">ReductionControl</a> class that stops iterations when either an absolute tolerance is reached (for which we choose <img class="formulaInl" alt="$10^{-12}$" src="form_2479.png"/>) or when the residual is reduced by a certain factor (here, <img class="formulaInl" alt="$10^{-3}$" src="form_1580.png"/>).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classReductionControl.html">ReductionControl</a>                    reduction_control (100, 1e-12, 1e-3);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a>  solver (reduction_control);</div><div class="line">  TrilinosWrappers::PreconditionAMG   precondition;</div><div class="line">  precondition.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a> (system_matrix);</div><div class="line"></div><div class="line">  solver.solve (system_matrix, solution, system_rhs, precondition);</div><div class="line">  constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;      Error: &quot;</span> &lt;&lt; reduction_control.initial_value()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; reduction_control.last_value()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">            &lt;&lt;  reduction_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemoutput_results"></a> </p><h4>ObstacleProblem::output_results</h4>
<p>We use the vtk-format for the output. The file contains the displacement and a numerical representation of the active set. The function looks standard but note that we can add an <a class="el" href="classIndexSet.html">IndexSet</a> object to the <a class="el" href="classDataOut.html">DataOut</a> object in exactly the same way as a regular solution vector: it is simply interpreted as a function that is either zero (when a degree of freedom is not part of the <a class="el" href="classIndexSet.html">IndexSet</a>) or one (if it is).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing graphical output...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (active_set, <span class="stringliteral">&quot;active_set&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (contact_force, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">  std::ofstream output_vtk ((std::string(<span class="stringliteral">&quot;output_&quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (iteration, 3) +</div><div class="line">                             <span class="stringliteral">&quot;.vtk&quot;</span>).c_str ());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output_vtk);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ObstacleProblemrun"></a> </p><h4>ObstacleProblem::run</h4>
<p>This is the function which has the top-level control over everything. It is not very long, and in fact rather straightforward: in every iteration of the active set method, we assemble the linear system, solve it, update the active set and project the solution back to the feasible set, and then output the results. The iteration is terminated whenever the active set has not changed in the previous iteration.</p>
<p>The only trickier part is that we have to save the linear system (i.e., the matrix and right hand side) after assembling it in the first iteration. The reason is that this is the only step where we can access the linear system as built without any of the contact constraints active. We need this to compute the residual of the solution at other iterations, but in other iterations that linear system we form has the rows and columns that correspond to constrained degrees of freedom eliminated, and so we can no longer access the full residual of the original equation.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system ();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> active_set_old (active_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration=0; iteration&lt;=solution.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a> (); ++iteration)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Newton iteration &quot;</span> &lt;&lt; iteration &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (iteration == 0)</div><div class="line">          {</div><div class="line">            complete_system_matrix.copy_from (system_matrix);</div><div class="line">            complete_system_rhs = system_rhs;</div><div class="line">          }</div><div class="line"></div><div class="line">        solve ();</div><div class="line">        update_solution_and_constraints ();</div><div class="line">        output_results (iteration);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (active_set == active_set_old)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        active_set_old = active_set;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>And this is the main function. It follows the pattern of all other main functions. The call to initialize MPI exists because the Trilinos library upon which we build our linear solvers in this program requires it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step41;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization (argc, argv,</div><div class="line">                                                           <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD)==1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;This program can only be run in serial, use ./step-41&quot;</span>));</div><div class="line"></div><div class="line">      ObstacleProblem&lt;2&gt; obstacle_problem;</div><div class="line">      obstacle_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the program produces output like this: </p><div class="fragment"><div class="line">Number of active cells: 16384</div><div class="line">Total number of cells: 21845</div><div class="line">Number of degrees of freedom: 16641</div><div class="line"></div><div class="line">Newton iteration 0</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.310059 -&gt; 5.16619e-05 in 5 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 13164</div><div class="line">   Residual of the non-contact part of the system: 1.61863e-05</div><div class="line">   Writing graphical output...</div><div class="line"></div><div class="line">Newton iteration 1</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 1.11987 -&gt; 0.00109377 in 6 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 12363</div><div class="line">   Residual of the non-contact part of the system: 3.9373</div><div class="line">   Writing graphical output...</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Newton iteration 17</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.00713308 -&gt; 2.29249e-06 in 4 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 5399</div><div class="line">   Residual of the non-contact part of the system: 0.000957525</div><div class="line">   Writing graphical output...</div><div class="line"></div><div class="line">Newton iteration 18</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 0.000957525 -&gt; 2.8033e-07 in 4 CG iterations.</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 5399</div><div class="line">   Residual of the non-contact part of the system: 2.8033e-07</div><div class="line">   Writing graphical output...</div></div><!-- fragment --><p>The iterations end once the active set doesn't change any more (it has 5,399 constrained degrees of freedom at that point). The algebraic precondition is apparently working nicely since we only need 4-6 CG iterations to solve the linear system (although this also has a lot to do with the fact that we are not asking for very high accuracy of the linear solver).</p>
<p>More revealing is to look at a sequence of graphical output files (every third step is shown, with the number of the iteration in the leftmost column):</p>
<table align="center">
<tr>
<td valign="top">0 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.00.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.00.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.00.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td valign="top">3 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.03.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.03.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.03.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td valign="top">6 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.06.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.06.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.06.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td valign="top">9 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.09.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td valign="top">12 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.12.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.12.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.12.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td valign="top">15 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.15.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.15.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.15.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td valign="top">18 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.18.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.active-set.18.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.displacement.3d.18.png"/>
</div>
   </td></tr>
</table>
<p>The pictures show that in the first step, the solution (which has been computed without any of the constraints active) bends through so much that pretty much every interior point has to be bounced back to the stairstep function, producing a discontinuous solution. Over the course of the active set iterations, this unphysical membrane shape is smoothed out, the contact with the lower-most stair step disappears, and the solution stabilizes.</p>
<p>In addition to this, the program also outputs the values of the Lagrange multipliers. Remember that these are the contact forces and so should only be positive on the contact set, and zero outside. If, on the other hand, a Lagrange multiplier is negative in the active set, then this degree of freedom must be removed from the active set. The following pictures show the multipliers in iterations 1, 9 and 18, where we use red and browns to indicate positive values, and blue for negative values.</p>
<table align="center">
<tr>
<td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.01.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.09.png"/>
</div>
  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-41.forces.18.png"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td align="center">Iteration 1  </td><td align="center">Iteration 9  </td><td align="center">Iteration 18   </td></tr>
</table>
<p>It is easy to see that the positive values converge nicely to moderate values in the interior of the contact set and large upward forces at the edges of the steps, as one would expect (to support the large curvature of the membrane there); at the fringes of the active set, multipliers are initially negative, causing the set to shrink until, in iteration 18, there are no more negative multipliers and the algorithm has converged.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>As with any of the programs of this tutorial, there are a number of obvious possibilities for extensions and experiments. The first one is clear: introduce adaptivity. Contact problems are prime candidates for adaptive meshes because the solution has lines along which it is less regular (the places where contact is established between membrane and obstacle) and other areas where the solution is very smooth (or, in the present context, constant wherever it is in contact with the obstacle). Adding this to the current program should not pose too many difficulties, but it is not trivial to find a good error estimator for that purpose.</p>
<p>A more challenging task would be an extension to 3d. The problem here is not so much to simply make everything run in 3d. Rather, it is that when a 3d body is deformed and gets into contact with an obstacle, then the obstacle does not act as a constraining body force within the domain as is the case here. Rather, the contact force only acts on the boundary of the object. The inequality then is not in the differential equation but in fact in the (Neumann-type) boundary conditions, though this leads to a similar kind of variational inequality. Mathematically, this means that the Lagrange multiplier only lives on the surface, though it can of course be extended by zero into the domain if that is convenient. As in the current program, one does not need to form and store this Lagrange multiplier explicitly.</p>
<p>A further interesting problem for the 3d case is to consider contact problems with friction. In almost every mechanical process friction has a big influence. For the modelling we have to take into account tangential stresses at the contact surface. Also we have to observe that friction adds another nonlinearity to our problem.</p>
<p>Another nontrivial modification is to implement a more complex constitutive law like nonlinear elasticity or elasto-plastic material behavior. The difficulty here is to handle the additional nonlinearity arising through the nonlinear constitutive law. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2011 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Joerg Frohne, Texas A&amp;M University and</span></div><div class="line"><span class="comment"> *                        University of Siegen, 2011, 2012</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2012</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/trilinos_precondition.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step41</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ObstacleProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ObstacleProblem ();</div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid ();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_mass_matrix_diagonal (TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">    <span class="keywordtype">void</span> update_solution_and_constraints ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>             active_set;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix system_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix complete_system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  system_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  complete_system_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  diagonal_of_mass_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>  contact_force;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RightHandSide () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void) component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> -10;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void) component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Obstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Obstacle () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Obstacle&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void) component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (p (0) &lt; -0.5)</div><div class="line">      <span class="keywordflow">return</span> -0.2;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p (0) &gt;= -0.5 &amp;&amp; p (0) &lt; 0.0)</div><div class="line">      <span class="keywordflow">return</span> -0.4;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p (0) &gt;= 0.0 &amp;&amp; p (0) &lt; 0.5)</div><div class="line">      <span class="keywordflow">return</span> -0.6;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> -0.8;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ObstacleProblem&lt;dim&gt;::ObstacleProblem ()</div><div class="line">    :</div><div class="line">    fe (1),</div><div class="line">    dof_handler (triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::make_grid ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (7);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Total number of cells: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line">    active_set.set_size (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              0,</div><div class="line">                                              BoundaryValues&lt;dim&gt;(),</div><div class="line">                                              constraints);</div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler,</div><div class="line">                                     dsp,</div><div class="line">                                     constraints,</div><div class="line">                                     <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    system_matrix.reinit (dsp);</div><div class="line">    complete_system_matrix.reinit (dsp);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> solution_index_set = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (solution_index_set, MPI_COMM_WORLD);</div><div class="line">    system_rhs.reinit (solution_index_set, MPI_COMM_WORLD);</div><div class="line">    complete_system_rhs.reinit (solution_index_set, MPI_COMM_WORLD);</div><div class="line">    contact_force.reinit (solution_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix mass_matrix;</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a> (dsp);</div><div class="line">    assemble_mass_matrix_diagonal (mass_matrix);</div><div class="line">    diagonal_of_mass_matrix.reinit (solution_index_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;solution.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a> (); j++)</div><div class="line">      diagonal_of_mass_matrix (j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a> (j);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>         quadrature_formula(fe.degree+1);</div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>             fe_values (fe, quadrature_formula,</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                cell_matrix(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a> (i, q_point) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a> (j, q_point) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point));</div><div class="line"></div><div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i, q_point) *</div><div class="line">                              right_hand_side.value (fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a> (q_point)) *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point));</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a> (cell_matrix,</div><div class="line">                                                cell_rhs,</div><div class="line">                                                local_dof_indices,</div><div class="line">                                                system_matrix,</div><div class="line">                                                system_rhs,</div><div class="line">                                                <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  ObstacleProblem&lt;dim&gt;::</div><div class="line">  assemble_mass_matrix_diagonal (TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (fe.degree == 1, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQTrapez.html">QTrapez&lt;dim&gt;</a>        quadrature_formula;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>             fe_values (fe,</div><div class="line">                                         quadrature_formula,</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        dofs_per_cell = fe.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>        cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            cell_matrix(i,i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i, q_point) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (i, q_point) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (q_point));</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classConstraintMatrix.html#a1c61203741d499990c6288c3fcf3d48c">distribute_local_to_global</a> (cell_matrix,</div><div class="line">                                                local_dof_indices,</div><div class="line">                                                mass_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  ObstacleProblem&lt;dim&gt;::update_solution_and_constraints ()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty_parameter = 100.0;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda (complete_index_set(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()));</div><div class="line">    complete_system_matrix.residual (lambda,</div><div class="line">                                     solution, complete_system_rhs);</div><div class="line"></div><div class="line">    contact_force = lambda;</div><div class="line">    contact_force.scale (diagonal_of_mass_matrix);</div><div class="line">    contact_force *= -1;</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a24120d0331183f9a63cbe41493a19f6b">clear</a>();</div><div class="line">    active_set.clear ();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Obstacle&lt;dim&gt; obstacle;</div><div class="line">    std::vector&lt;bool&gt;   dof_touched (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell; ++v)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (dof_handler.<a class="code" href="classDoFHandler.html#ababc43bc9d09faea98dca14a2b6352a1">get_fe</a>().<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a> ==</div><div class="line">                  <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::vertices_per_cell</a>,</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof_index = cell-&gt;vertex_dof_index (v,0);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (dof_touched[dof_index] == <span class="keyword">false</span>)</div><div class="line">            dof_touched[dof_index] = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value = obstacle.value (cell-&gt;vertex(v));</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> solution_value = solution (dof_index);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (lambda (dof_index) +</div><div class="line">              penalty_parameter *</div><div class="line">              diagonal_of_mass_matrix(dof_index) *</div><div class="line">              (solution_value - obstacle_value)</div><div class="line">              &lt;</div><div class="line">              0)</div><div class="line">            {</div><div class="line">              active_set.add_index (dof_index);</div><div class="line">              constraints.<a class="code" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">add_line</a> (dof_index);</div><div class="line">              constraints.<a class="code" href="classConstraintMatrix.html#a2121ba9d256cbab8e6b8390fb89dda74">set_inhomogeneity</a> (dof_index, obstacle_value);</div><div class="line"></div><div class="line">              solution (dof_index) = obstacle_value;</div><div class="line"></div><div class="line">              lambda (dof_index) = 0;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      Size of active set: &quot;</span> &lt;&lt; active_set.n_elements()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Residual of the non-contact part of the system: &quot;</span></div><div class="line">              &lt;&lt; lambda.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              0,</div><div class="line">                                              BoundaryValues&lt;dim&gt;(),</div><div class="line">                                              constraints);</div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a8056d07faa2a7ed3f158c1b42d56abc8">close</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving system...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>                    reduction_control (100, 1e-12, 1e-3);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a>  solver (reduction_control);</div><div class="line">    TrilinosWrappers::PreconditionAMG   precondition;</div><div class="line">    precondition.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a> (system_matrix);</div><div class="line"></div><div class="line">    solver.solve (system_matrix, solution, system_rhs, precondition);</div><div class="line">    constraints.<a class="code" href="classConstraintMatrix.html#a5bd4b10531ae0809a415d91742d1870c">distribute</a> (solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      Error: &quot;</span> &lt;&lt; reduction_control.initial_value()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; reduction_control.last_value()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">              &lt;&lt;  reduction_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing graphical output...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, <span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (active_set, <span class="stringliteral">&quot;active_set&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (contact_force, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line"></div><div class="line">    std::ofstream output_vtk ((std::string(<span class="stringliteral">&quot;output_&quot;</span>) +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (iteration, 3) +</div><div class="line">                               <span class="stringliteral">&quot;.vtk&quot;</span>).c_str ());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (output_vtk);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ObstacleProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">    setup_system ();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> active_set_old (active_set);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration=0; iteration&lt;=solution.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a> (); ++iteration)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Newton iteration &quot;</span> &lt;&lt; iteration &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (iteration == 0)</div><div class="line">          {</div><div class="line">            complete_system_matrix.copy_from (system_matrix);</div><div class="line">            complete_system_rhs = system_rhs;</div><div class="line">          }</div><div class="line"></div><div class="line">        solve ();</div><div class="line">        update_solution_and_constraints ();</div><div class="line">        output_results (iteration);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (active_set == active_set_old)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        active_set_old = active_set;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step41;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization (argc, argv,</div><div class="line">                                                           <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD)==1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;This program can only be run in serial, use ./step-41&quot;</span>));</div><div class="line"></div><div class="line">      ObstacleProblem&lt;2&gt; obstacle_problem;</div><div class="line">      obstacle_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
