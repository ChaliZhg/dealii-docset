<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DoFRenumbering Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DoFRenumbering Namespace Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDoFRenumbering_1_1boost"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering_1_1boost.html">boost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDoFRenumbering_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDoFRenumbering_1_1CompareDownstream.html">CompareDownstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDoFRenumbering_1_1ComparePointwiseDownstream.html">ComparePointwiseDownstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab938a690bf4e2adff191fe969b0f21d3"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ab938a690bf4e2adff191fe969b0f21d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">Cuthill_McKee</a> (DoFHandlerType &amp;dof_handler, const bool reversed_numbering=false, const bool use_constraints=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;())</td></tr>
<tr class="separator:ab938a690bf4e2adff191fe969b0f21d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae741607c100829702ae117f17d3392d8"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ae741607c100829702ae117f17d3392d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ae741607c100829702ae117f17d3392d8">compute_Cuthill_McKee</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DoFHandlerType &amp;, const bool reversed_numbering=false, const bool use_constraints=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;())</td></tr>
<tr class="separator:ae741607c100829702ae117f17d3392d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3679f1c36e1b0ce5ba6f9360ef2f79ed"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a3679f1c36e1b0ce5ba6f9360ef2f79ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a3679f1c36e1b0ce5ba6f9360ef2f79ed">Cuthill_McKee</a> (DoFHandlerType &amp;dof_handler, const unsigned int level, const bool reversed_numbering=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt;())</td></tr>
<tr class="separator:a3679f1c36e1b0ce5ba6f9360ef2f79ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbfcc9818cd38406d5167b987a7ba4c"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafbbfcc9818cd38406d5167b987a7ba4c">ExcRenumberingIncomplete</a> ()</td></tr>
<tr class="separator:gafbbfcc9818cd38406d5167b987a7ba4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69fa092d95ea597fc8277b6abf9235ae"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga69fa092d95ea597fc8277b6abf9235ae">ExcInvalidComponentOrder</a> ()</td></tr>
<tr class="separator:ga69fa092d95ea597fc8277b6abf9235ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2c89376f02c275627e3356f5ade07b"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb2c89376f02c275627e3356f5ade07b">ExcNotDGFEM</a> ()</td></tr>
<tr class="separator:gaeb2c89376f02c275627e3356f5ade07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Component-wise numberings</div></td></tr>
<tr class="memitem:a52c1941406d1ce2937e29a46edf111f4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a52c1941406d1ce2937e29a46edf111f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; unsigned int &gt; &amp;target_component=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:a52c1941406d1ce2937e29a46edf111f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430d58fb5b4bc3ce863e001cb5868a61"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a430d58fb5b4bc3ce863e001cb5868a61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a430d58fb5b4bc3ce863e001cb5868a61">component_wise</a> (<a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const std::vector&lt; unsigned int &gt; &amp;target_component=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:a430d58fb5b4bc3ce863e001cb5868a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213581cd94d84c5d904b10ee28d01e54"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a213581cd94d84c5d904b10ee28d01e54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a213581cd94d84c5d904b10ee28d01e54">component_wise</a> (DoFHandlerType &amp;dof_handler, const unsigned int level, const std::vector&lt; unsigned int &gt; &amp;target_component=std::vector&lt; unsigned int &gt;())</td></tr>
<tr class="separator:a213581cd94d84c5d904b10ee28d01e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4613fd6a1a984e492be6d6b7f12c63"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </td></tr>
<tr class="memitem:aab4613fd6a1a984e492be6d6b7f12c63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#aab4613fd6a1a984e492be6d6b7f12c63">compute_component_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const ITERATOR &amp;start, const ENDITERATOR &amp;end, const std::vector&lt; unsigned int &gt; &amp;target_component, bool is_level_operation)</td></tr>
<tr class="separator:aab4613fd6a1a984e492be6d6b7f12c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Block-wise numberings</div></td></tr>
<tr class="memitem:a658593cab0e93a92a7d8ce0ffe086518"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a658593cab0e93a92a7d8ce0ffe086518"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a658593cab0e93a92a7d8ce0ffe086518">block_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a658593cab0e93a92a7d8ce0ffe086518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5a402d98753ac352ad8b9abaad32ad"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8b5a402d98753ac352ad8b9abaad32ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a8b5a402d98753ac352ad8b9abaad32ad">block_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned int level)</td></tr>
<tr class="separator:a8b5a402d98753ac352ad8b9abaad32ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645678ac23c256c226a40540cdbac428"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a645678ac23c256c226a40540cdbac428"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a645678ac23c256c226a40540cdbac428">block_wise</a> (<a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a645678ac23c256c226a40540cdbac428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d683f395aa69974e33cc9de333b337"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </td></tr>
<tr class="memitem:af6d683f395aa69974e33cc9de333b337"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#af6d683f395aa69974e33cc9de333b337">compute_block_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const ITERATOR &amp;start, const ENDITERATOR &amp;end, bool is_level_operation)</td></tr>
<tr class="separator:af6d683f395aa69974e33cc9de333b337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Various cell-wise numberings</div></td></tr>
<tr class="memitem:af0306c2a1b1eeef2e3d54e0bf36d7bd7"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:af0306c2a1b1eeef2e3d54e0bf36d7bd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#af0306c2a1b1eeef2e3d54e0bf36d7bd7">hierarchical</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:af0306c2a1b1eeef2e3d54e0bf36d7bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52b1a0409ab7906be7c963daec263a9"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ab52b1a0409ab7906be7c963daec263a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ab52b1a0409ab7906be7c963daec263a9">cell_wise</a> (DoFHandlerType &amp;dof_handler, const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:ab52b1a0409ab7906be7c963daec263a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6bd2328877f25e956174a7d0635e3c"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a3a6bd2328877f25e956174a7d0635e3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a3a6bd2328877f25e956174a7d0635e3c">compute_cell_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;inverse_renumbering, const DoFHandlerType &amp;dof_handler, const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:a3a6bd2328877f25e956174a7d0635e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f7fae3e101e239923d4fc650de29fe"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ac2f7fae3e101e239923d4fc650de29fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ac2f7fae3e101e239923d4fc650de29fe">cell_wise</a> (DoFHandlerType &amp;dof_handler, const unsigned int level, const std::vector&lt; typename DoFHandlerType::level_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:ac2f7fae3e101e239923d4fc650de29fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f94c4927cdecdeb840420e6a80ba02"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a42f94c4927cdecdeb840420e6a80ba02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a42f94c4927cdecdeb840420e6a80ba02">compute_cell_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;inverse_renumbering, const DoFHandlerType &amp;dof_handler, const unsigned int level, const std::vector&lt; typename DoFHandlerType::level_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:a42f94c4927cdecdeb840420e6a80ba02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Directional numberings</div></td></tr>
<tr class="memitem:aa8507cca091079d78aa6d587a5de13aa"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:aa8507cca091079d78aa6d587a5de13aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#aa8507cca091079d78aa6d587a5de13aa">downstream</a> (DoFHandlerType &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;direction, const bool dof_wise_renumbering=false)</td></tr>
<tr class="separator:aa8507cca091079d78aa6d587a5de13aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab629b9a4ad13d34d318282e9138df25c"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ab629b9a4ad13d34d318282e9138df25c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ab629b9a4ad13d34d318282e9138df25c">downstream</a> (DoFHandlerType &amp;dof_handler, const unsigned int level, const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;direction, const bool dof_wise_renumbering=false)</td></tr>
<tr class="separator:ab629b9a4ad13d34d318282e9138df25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20862edbbac0e1349d3a2760b36fb8d"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ae20862edbbac0e1349d3a2760b36fb8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ae20862edbbac0e1349d3a2760b36fb8d">compute_downstream</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;reverse, const DoFHandlerType &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;direction, const bool dof_wise_renumbering)</td></tr>
<tr class="separator:ae20862edbbac0e1349d3a2760b36fb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379a1f5c1e9dc24f4b25a04bbec14d3e"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a379a1f5c1e9dc24f4b25a04bbec14d3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a379a1f5c1e9dc24f4b25a04bbec14d3e">compute_downstream</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;reverse, const DoFHandlerType &amp;dof_handler, const unsigned int level, const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;direction, const bool dof_wise_renumbering)</td></tr>
<tr class="separator:a379a1f5c1e9dc24f4b25a04bbec14d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5602fa5250f40633650fa634d2a8b9d"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:af5602fa5250f40633650fa634d2a8b9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#af5602fa5250f40633650fa634d2a8b9d">clockwise_dg</a> (DoFHandlerType &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;center, const bool counter=false)</td></tr>
<tr class="separator:af5602fa5250f40633650fa634d2a8b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b61c090f315a7008d9488666ed3ee7"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a70b61c090f315a7008d9488666ed3ee7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a70b61c090f315a7008d9488666ed3ee7">clockwise_dg</a> (DoFHandlerType &amp;dof_handler, const unsigned int level, const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;center, const bool counter=false)</td></tr>
<tr class="separator:a70b61c090f315a7008d9488666ed3ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18ec9ac243e2fb738b8fbfec60be5c8"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ac18ec9ac243e2fb738b8fbfec60be5c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ac18ec9ac243e2fb738b8fbfec60be5c8">compute_clockwise_dg</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DoFHandlerType &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;center, const bool counter)</td></tr>
<tr class="separator:ac18ec9ac243e2fb738b8fbfec60be5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Selective and random numberings</div></td></tr>
<tr class="memitem:a37bc01a74fb5340ae110dbcfb4c6777b"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a37bc01a74fb5340ae110dbcfb4c6777b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a37bc01a74fb5340ae110dbcfb4c6777b">sort_selected_dofs_back</a> (DoFHandlerType &amp;dof_handler, const std::vector&lt; bool &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a37bc01a74fb5340ae110dbcfb4c6777b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438256a7d5bf2d5690e3f23193404e5"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ad438256a7d5bf2d5690e3f23193404e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ad438256a7d5bf2d5690e3f23193404e5">sort_selected_dofs_back</a> (DoFHandlerType &amp;dof_handler, const std::vector&lt; bool &gt; &amp;selected_dofs, const unsigned int level)</td></tr>
<tr class="separator:ad438256a7d5bf2d5690e3f23193404e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0529a95ff4c8e61e17987a1c005d23"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:aaf0529a95ff4c8e61e17987a1c005d23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#aaf0529a95ff4c8e61e17987a1c005d23">compute_sort_selected_dofs_back</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DoFHandlerType &amp;dof_handler, const std::vector&lt; bool &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:aaf0529a95ff4c8e61e17987a1c005d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7f0b22d50b175e280cc9e9091d0258"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:aad7f0b22d50b175e280cc9e9091d0258"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#aad7f0b22d50b175e280cc9e9091d0258">compute_sort_selected_dofs_back</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DoFHandlerType &amp;dof_handler, const std::vector&lt; bool &gt; &amp;selected_dofs, const unsigned int level)</td></tr>
<tr class="separator:aad7f0b22d50b175e280cc9e9091d0258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11db38e857f876c15b5dc2a8be7df48b"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a11db38e857f876c15b5dc2a8be7df48b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a11db38e857f876c15b5dc2a8be7df48b">random</a> (DoFHandlerType &amp;dof_handler)</td></tr>
<tr class="separator:a11db38e857f876c15b5dc2a8be7df48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05604dcda07d94c31bc31abf7fe2fb94"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a05604dcda07d94c31bc31abf7fe2fb94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a05604dcda07d94c31bc31abf7fe2fb94">compute_random</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DoFHandlerType &amp;dof_handler)</td></tr>
<tr class="separator:a05604dcda07d94c31bc31abf7fe2fb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Numberings based on cell attributes</div></td></tr>
<tr class="memitem:a442e0991d482f8d208069945d4cee508"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a442e0991d482f8d208069945d4cee508"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a442e0991d482f8d208069945d4cee508">subdomain_wise</a> (DoFHandlerType &amp;dof_handler)</td></tr>
<tr class="separator:a442e0991d482f8d208069945d4cee508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d43edd942d5d8f53112953fbac191e"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ae4d43edd942d5d8f53112953fbac191e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ae4d43edd942d5d8f53112953fbac191e">compute_subdomain_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;new_dof_indices, const DoFHandlerType &amp;dof_handler)</td></tr>
<tr class="separator:ae4d43edd942d5d8f53112953fbac191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of a number of renumbering algorithms for the degrees of freedom on a triangulation.</p>
<h3>Cuthill-McKee like algorithms</h3>
<p>Within this class, the Cuthill-McKee algorithm is implemented. It starts at a degree of freedom, searches the other DoFs for those which are coupled with the one we started with and numbers these in a certain way. It then finds the second level of DoFs, namely those that couple with those of the previous level (which were those that coupled with the initial DoF) and numbers these. And so on. For the details of the algorithm, especially the numbering within each level, please see H. R. Schwarz: "Methode der finiten
Elemente". The reverse Cuthill-McKee algorithm does the same job, but numbers all elements in the reverse order.</p>
<p>These algorithms have one major drawback: they require a good starting point, i.e. the degree of freedom index that will get a new index of zero. The renumbering functions therefore allow the caller to specify such an initial DoF, e.g. by exploiting knowledge of the actual topology of the domain. It is also possible to give several starting indices, which may be used to simulate a simple upstream numbering (by giving the inflow dofs as starting values) or to make preconditioning faster (by letting the Dirichlet boundary indices be starting points).</p>
<p>If no starting index is given, one is chosen automatically, namely one with the smallest coordination number (the coordination number is the number of other dofs this dof couples with). This dof is usually located on the boundary of the domain. There is, however, large ambiguity in this when using the hierarchical meshes used in this library, since in most cases the computational domain is not approximated by tilting and deforming elements and by plugging together variable numbers of elements at vertices, but rather by hierarchical refinement. There is therefore a large number of dofs with equal coordination numbers. The renumbering algorithms will therefore not give optimal results.</p>
<p>In the book of Schwarz (H.R.Schwarz: Methode der finiten Elemente), it is advised to test many starting points, if possible all with the smallest coordination number and also those with slightly higher numbers. However, this seems only possible for meshes with at most several dozen or a few hundred elements found in small engineering problems of the early 1980s (the second edition was published in 1984), but certainly not with those used in this library, featuring several 10,000 to a few 100,000 elements.</p>
<h4>Implementation of renumbering schemes</h4>
<p>The renumbering algorithms need quite a lot of memory, since they have to store for each dof with which other dofs it couples. This is done using a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object used to store the sparsity pattern of matrices. It is not useful for the user to do anything between distributing the dofs and renumbering, i.e. the calls to <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a> and <a class="el" href="classDoFHandler.html#a44e80b846cf60a8671969ce90ae3625b">DoFHandler::renumber_dofs</a> should follow each other immediately. If you try to create a sparsity pattern or anything else in between, these will be invalid afterwards.</p>
<p>The renumbering may take care of dof-to-dof couplings only induced by eliminating constraints. In addition to the memory consumption mentioned above, this also takes quite some computational time, but it may be switched off upon calling the <code>renumber_dofs</code> function. This will then give inferior results, since knots in the graph (representing dofs) are not found to be neighbors even if they would be after condensation.</p>
<p>The renumbering algorithms work on a purely algebraic basis, due to the isomorphism between the graph theoretical groundwork underlying the algorithms and binary matrices (matrices of which the entries are binary values) represented by the sparsity patterns. In special, the algorithms do not try to exploit topological knowledge (e.g. corner detection) to find appropriate starting points. This way, however, they work in arbitrary space dimension.</p>
<p>If you want to give starting points, you may give a list of dof indices which will form the first step of the renumbering. The dofs of the list will be consecutively numbered starting with zero, i.e. this list is not renumbered according to the coordination number of the nodes. Indices not in the allowed range are deleted. If no index is allowed, the algorithm will search for its own starting point.</p>
<h4>Results of renumbering</h4>
<p>The renumbering schemes mentioned above do not lead to optimal results. However, after all there is no algorithm that accomplishes this within reasonable time. There are situations where the lack of optimality even leads to worse results than with the original, crude, levelwise numbering scheme; one of these examples is a mesh of four cells of which always those cells are refined which are neighbors to the center (you may call this mesh a `zoom in' mesh). In one such example the bandwidth was increased by about 50 per cent.</p>
<p>In most other cases, the bandwidth is reduced significantly. The reduction is the better the less structured the grid is. With one grid where the cells were refined according to a random driven algorithm, the bandwidth was reduced by a factor of six.</p>
<p>Using the constraint information usually leads to reductions in bandwidth of 10 or 20 per cent, but may for some very unstructured grids also lead to an increase. You have to weigh the decrease in your case with the time spent to use the constraint information, which usually is several times longer than the `pure' renumbering algorithm.</p>
<p>In almost all cases, the renumbering scheme finds a corner to start with. Since there is more than one corner in most grids and since even an interior degree of freedom may be a better starting point, giving the starting point by the user may be a viable way if you have a simple scheme to derive a suitable point (e.g. by successively taking the third child of the cell top left of the coarsest level, taking its third vertex and the dof index thereof, if you want the top left corner vertex). If you do not know beforehand what your grid will look like (e.g. when using adaptive algorithms), searching a best starting point may be difficult, however, and in many cases will not justify the effort.</p>
<h3>Component-wise and block-wise numberings</h3>
<p>For finite elements composed of several base elements using the <a class="el" href="classFESystem.html">FESystem</a> class, or for elements which provide several components themselves, it may be of interest to sort the DoF indices by component. This will then bring out the block matrix structure, since otherwise the degrees of freedom are numbered cell-wise without taking into account that they may belong to different components. For example, one may want to sort degree of freedom for a Stokes discretization so that we first get all velocities and then all the pressures so that the resulting matrix naturally decomposes into a <img class="formulaInl" alt="$2\times 2$" src="form_67.png"/> system.</p>
<p>This kind of numbering may be obtained by calling the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise()</a> function of this class. Since it does not touch the order of indices within each component, it may be worthwhile to first renumber using the Cuthill- McKee or a similar algorithm and afterwards renumbering component-wise. This will bring out the matrix structure and additionally have a good numbering within each block.</p>
<p>The <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise()</a> function allows not only to honor enumeration based on vector components, but also allows to group together vector components into "blocks" using a defaulted argument to the various <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise()</a> functions (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a> vs <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a> for a description of the difference). The blocks designated through this argument may, but do not have to be, equal to the blocks that the finite element reports. For example, a typical Stokes element would be </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,   <span class="comment">// dim velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);    <span class="comment">// one pressure</span></div></div><!-- fragment --><p> This element has <code>dim+1</code> vector components and equally many blocks. However, one may want to consider the velocities as one logical block so that all velocity degrees of freedom are enumerated the same way, independent of whether they are <img class="formulaInl" alt="$x$" src="form_9.png"/>- or <img class="formulaInl" alt="$y$" src="form_10.png"/>-velocities. This is done, for example, in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_22.html">step-22</a> as well as several other tutorial programs.</p>
<p>On the other hand, if you really want to use block structure reported by the finite element itself (a case that is often the case if you have finite elements that have multiple vector components, e.g. the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> or <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> elements) then you can use the <a class="el" href="namespaceDoFRenumbering.html#a658593cab0e93a92a7d8ce0ffe086518">DoFRenumbering::block_wise</a> instead of the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> functions.</p>
<h3>Cell-wise numbering</h3>
<p>Given an ordered vector of cells, the function <a class="el" href="namespaceDoFRenumbering.html#ab52b1a0409ab7906be7c963daec263a9">cell_wise()</a> sorts the degrees of freedom such that degrees on earlier cells of this vector will occur before degrees on later cells.</p>
<p>This rule produces a well-defined ordering for discontinuous Galerkin methods (<a class="el" href="classFE__DGP.html">FE_DGP</a>, <a class="el" href="classFE__DGQ.html">FE_DGQ</a>). For continuous methods, we use the additional rule that each degree of freedom is ordered according to the first cell in the ordered vector it belongs to.</p>
<p>Applications of this scheme are <a class="el" href="namespaceDoFRenumbering.html#aa8507cca091079d78aa6d587a5de13aa">downstream()</a> and clock_wise_dg(). The first orders the cells according to a downstream direction and then applies <a class="el" href="namespaceDoFRenumbering.html#ab52b1a0409ab7906be7c963daec263a9">cell_wise()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For DG elements, the internal numbering in each cell remains unaffected. This cannot be guaranteed for continuous elements anymore, since degrees of freedom shared with an earlier cell will be accounted for by the other cell.</dd></dl>
<h3>Random renumbering</h3>
<p>The <a class="el" href="namespaceDoFRenumbering.html#a11db38e857f876c15b5dc2a8be7df48b">random()</a> function renumbers degrees of freedom randomly. This function is probably seldom of use, except to check the dependence of solvers (iterative or direct ones) on the numbering of the degrees of freedom.</p>
<h3>A comparison of reordering strategies</h3>
<p>As a benchmark of comparison, let us consider what the different sparsity patterns produced by the various algorithms when using the <img class="formulaInl" alt="$Q_2^d\times Q_1$" src="form_515.png"/> element combination typically employed in the discretization of Stokes equations, when used on the mesh obtained in <a class="el" href="step_22.html">step-22</a> after one adaptive mesh refinement in 3d. The space dimension together with the coupled finite element leads to a rather dense system matrix with, on average around 180 nonzero entries per row. After applying each of the reordering strategies shown below, the degrees of freedom are also sorted using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> into velocity and pressure groups; this produces the <img class="formulaInl" alt="$2\times 2$" src="form_67.png"/> block structure seen below with the large velocity-velocity block at top left, small pressure-pressure block at bottom right, and coupling blocks at top right and bottom left.</p>
<p>The goal of reordering strategies is to improve the preconditioner. In <a class="el" href="step_22.html">step-22</a> we use a <a class="el" href="classSparseILU.html">SparseILU</a> to preconditioner for the velocity-velocity block at the top left. The quality of the preconditioner can then be measured by the number of CG iterations required to solve a linear system with this block. For some of the reordering strategies below we record this number for adaptive refinement cycle 3, with 93176 degrees of freedom; because we solve several linear systems with the same matrix in the Schur complement, the average number of iterations is reported. The lower the number the better the preconditioner and consequently the better the renumbering of degrees of freedom is suited for this task. We also state the run-time of the program, in part determined by the number of iterations needed, for the first 4 cycles on one of our machines. Note that the reported times correspond to the run time of the entire program, not just the affected solver; if a program runs twice as fast with one particular ordering than with another one, then this means that the actual solver is actually several times faster.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="reorder_sparsity_step_31_original.png" alt="reorder_sparsity_step_31_original.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_random.png" alt="reorder_sparsity_step_31_random.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_deal_cmk.png" alt="reorder_sparsity_step_31_deal_cmk.png"/>
</div>
   </td></tr>
<tr>
<td><p class="starttd">Enumeration as produced by deal.II's <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a> function and no further reordering apart from the component-wise one.</p>
<p class="endtd">With this renumbering, we needed an average of 92.2 iterations for the testcase outlined above, and a runtime of 7min53s.  </p>
</td><td><p class="starttd">Random enumeration as produced by applying <a class="el" href="namespaceDoFRenumbering.html#a11db38e857f876c15b5dc2a8be7df48b">DoFRenumbering::random</a> after calling <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>. This enumeration produces nonzero entries in matrices pretty much everywhere, appearing here as an entirely unstructured matrix.</p>
<p class="endtd">With this renumbering, we needed an average of 71 iterations for the testcase outlined above, and a runtime of 10min55s. The longer runtime despite less iterations compared to the default ordering may be due to the fact that computing and applying the ILU requires us to jump back and forth all through memory due to the lack of localization of matrix entries around the diagonal; this then leads to many cache misses and consequently bad timings.  </p>
</td><td><p class="starttd">Cuthill-McKee enumeration as produced by calling the deal.II implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">DoFRenumbering::Cuthill_McKee</a> after <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>.</p>
<p>With this renumbering, we needed an average of 57.3 iterations for the testcase outlined above, and a runtime of 6min10s.   </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="reorder_sparsity_step_31_boost_cmk.png" alt="reorder_sparsity_step_31_boost_cmk.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_boost_king.png" alt="reorder_sparsity_step_31_boost_king.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_boost_md.png" alt="reorder_sparsity_step_31_boost_md.png"/>
</div>
   </td></tr>
<tr>
<td><p class="starttd">Cuthill- McKee enumeration as produced by calling the BOOST implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a43cb05858725237e060219f5d94f3a3b">DoFRenumbering::boost::Cuthill_McKee</a> after <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>.</p>
<p class="endtd">With this renumbering, we needed an average of 51.7 iterations for the testcase outlined above, and a runtime of 5min52s.  </p>
</td><td><p class="starttd">King enumeration as produced by calling the BOOST implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a7dae40bee2464606f71a81ddf85e1811">DoFRenumbering::boost::king_ordering</a> after <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>. The sparsity pattern appears denser than with BOOST's Cuthill-McKee algorithm; however, this is only an illusion: the number of nonzero entries is the same, they are simply not as well clustered.</p>
<p class="endtd">With this renumbering, we needed an average of 51.0 iterations for the testcase outlined above, and a runtime of 5min03s. Although the number of iterations is only slightly less than with BOOST's Cuthill-McKee implementation, runtime is significantly less. This, again, may be due to cache effects. As a consequence, this is the algorithm best suited to the testcase, and is in fact used in <a class="el" href="step_22.html">step-22</a>.  </p>
</td><td><p class="starttd">Minimum degree enumeration as produced by calling the BOOST implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering_1_1boost.html#adef8c984e1e18d50e694771eaa24235d">DoFRenumbering::boost::minimum_degree</a> after <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>. The minimum degree algorithm does not attempt to minimize the bandwidth of a matrix but to minimize the amount of fill-in a LU decomposition would produce, i.e. the number of places in the matrix that would be occupied by elements of an LU decomposition that are not already occupied by elements of the original matrix. The resulting sparsity pattern obviously has an entirely different structure than the ones produced by algorithms trying to minimize the bandwidth.</p>
<p>With this renumbering, we needed an average of 58.9 iterations for the testcase outlined above, and a runtime of 6min11s.  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="reorder_sparsity_step_31_downstream.png" alt="reorder_sparsity_step_31_downstream.png"/>
</div>
  </td><td></td><td></td></tr>
<tr>
<td><p class="starttd">Downstream enumeration using <a class="el" href="namespaceDoFRenumbering.html#aa8507cca091079d78aa6d587a5de13aa">DoFRenumbering::downstream</a> using a direction that points diagonally through the domain.</p>
<p class="endtd">With this renumbering, we needed an average of 90.5 iterations for the testcase outlined above, and a runtime of 7min05s.  </p>
</td><td></td><td></td></tr>
</table>
<h3><a class="el" href="classMultigrid.html">Multigrid</a> DoF numbering</h3>
<p>Most of the algorithms listed above also work on multigrid degree of freedom numberings. Refer to the actual function declarations to get more information on this.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, Guido Kanschat, 1998, 1999, 2000, 2004, 2007, 2008 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab938a690bf4e2adff191fe969b0f21d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab938a690bf4e2adff191fe969b0f21d3">&#9670;&nbsp;</a></span>Cuthill_McKee() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reversed_numbering</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_constraints</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom according to the Cuthill-McKee method, possibly using the reverse numbering scheme.</p>
<p>See the general documentation of this class for details on the different methods.</p>
<p>As an example of the results of this algorithm, take a look at the comparison of various algorithms in the documentation of the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace.</p>
<p>If the given <a class="el" href="classDoFHandler.html">DoFHandler</a> uses a distributed triangulation (i.e., if dof_handler.locally_owned() is not the complete index set), the renumbering is performed on each processor's degrees of freedom individually, without any communication between processors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> or <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> object to work on. </td></tr>
    <tr><td class="paramname">reversed_numbering</td><td>Whether to use the original Cuthill-McKee algorithm, or to reverse the ordering. </td></tr>
    <tr><td class="paramname">use_constraints</td><td>Whether or not to use hanging node constraints in determining the reordering of degrees of freedom. </td></tr>
    <tr><td class="paramname">starting_indices</td><td>A set of degrees of freedom that form the first level of renumbered degrees of freedom. If the set is empty, then a single starting entry is chosen automatically among those that have the smallest number of others that couple with it. If the <a class="el" href="classDoFHandler.html">DoFHandler</a> is built on a parallel triangulation, then on every processor, these starting indices need to be a (possibly empty) subset of the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned degrees of freedom</a>. These will then be used as starting indices for the local renumbering on the current processor. (In other words, this argument will in fact be different on every processor unless you pass an empty list as is the default.) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00350">350</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="ae741607c100829702ae117f17d3392d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae741607c100829702ae117f17d3392d8">&#9670;&nbsp;</a></span>compute_Cuthill_McKee()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reversed_numbering</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_constraints</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#ab938a690bf4e2adff191fe969b0f21d3">Cuthill_McKee()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00370">370</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a3679f1c36e1b0ce5ba6f9360ef2f79ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3679f1c36e1b0ce5ba6f9360ef2f79ed">&#9670;&nbsp;</a></span>Cuthill_McKee() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>reversed_numbering</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;<a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a>&gt;&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom according to the Cuthill-McKee method, eventually using the reverse numbering scheme, in this case for a multigrid numbering of degrees of freedom.</p>
<p>You can give a triangulation level to which this function is to be applied. Since with a level-wise numbering there are no hanging nodes, no constraints can be used, so the respective parameter of the previous function is omitted.</p>
<p>See the general documentation of this class for details on the different methods. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00471">471</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a52c1941406d1ce2937e29a46edf111f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c1941406d1ce2937e29a46edf111f4">&#9670;&nbsp;</a></span>component_wise() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::component_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;unsigned&#160;int&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by vector component. The numbering within each component is not touched, so a degree of freedom with index <img class="formulaInl" alt="$i$" src="form_90.png"/>, belonging to some component, and another degree of freedom with index <img class="formulaInl" alt="$j$" src="form_513.png"/> belonging to the same component will be assigned new indices <img class="formulaInl" alt="$n(i)$" src="form_516.png"/> and <img class="formulaInl" alt="$n(j)$" src="form_517.png"/> with <img class="formulaInl" alt="$n(i)&lt;n(j)$" src="form_518.png"/> if <img class="formulaInl" alt="$i&lt;j$" src="form_519.png"/> and <img class="formulaInl" alt="$n(i)&gt;n(j)$" src="form_520.png"/> if <img class="formulaInl" alt="$i&gt;j$" src="form_521.png"/>.</p>
<p>You can specify that the components are ordered in a different way than suggested by the <a class="el" href="classFESystem.html">FESystem</a> object you use. To this end, set up the vector <code>target_component</code> such that the entry at index <code>i</code> denotes the number of the target component for dofs with component <code>i</code> in the <a class="el" href="classFESystem.html">FESystem</a>. Naming the same target component more than once is possible and results in a blocking of several components into one. This is discussed in <a class="el" href="step_22.html">step-22</a>. If you omit this argument, the same order as given by the finite element is used.</p>
<p>If one of the base finite elements from which the global finite element under consideration here, is a non-primitive one, i.e. its shape functions have more than one non-zero component, then it is not possible to associate these degrees of freedom with a single vector component. In this case, they are associated with the first vector component to which they belong.</p>
<p>For finite elements with only one component, or a single non-primitive base element, this function is the identity operation. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00501">501</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a430d58fb5b4bc3ce863e001cb5868a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430d58fb5b4bc3ce863e001cb5868a61">&#9670;&nbsp;</a></span>component_wise() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::component_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;unsigned&#160;int&gt;&#160;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by component. It does the same thing as the above function. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00545">545</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a213581cd94d84c5d904b10ee28d01e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213581cd94d84c5d904b10ee28d01e54">&#9670;&nbsp;</a></span>component_wise() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::component_wise </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;unsigned&#160;int&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by component. It does the same thing as the above function, only that it does this for one single level of a multilevel discretization. The non-multigrid part of the the <a class="el" href="classDoFHandler.html">DoFHandler</a> is not touched. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00575">575</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="aab4613fd6a1a984e492be6d6b7f12c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4613fd6a1a984e492be6d6b7f12c63">&#9670;&nbsp;</a></span>compute_component_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> DoFRenumbering::compute_component_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ENDITERATOR &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_level_operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise()</a> functions. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00606">606</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a658593cab0e93a92a7d8ce0ffe086518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658593cab0e93a92a7d8ce0ffe086518">&#9670;&nbsp;</a></span>block_wise() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::block_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by vector block. The numbering within each block is not touched, so a degree of freedom with index <img class="formulaInl" alt="$i$" src="form_90.png"/>, belonging to some block, and another degree of freedom with index <img class="formulaInl" alt="$j$" src="form_513.png"/> belonging to the same block will be assigned new indices <img class="formulaInl" alt="$n(i)$" src="form_516.png"/> and <img class="formulaInl" alt="$n(j)$" src="form_517.png"/> with <img class="formulaInl" alt="$n(i)&lt;n(j)$" src="form_518.png"/> if <img class="formulaInl" alt="$i&lt;j$" src="form_519.png"/> and <img class="formulaInl" alt="$n(i)&gt;n(j)$" src="form_520.png"/> if <img class="formulaInl" alt="$i&gt;j$" src="form_521.png"/>. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00845">845</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a8b5a402d98753ac352ad8b9abaad32ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5a402d98753ac352ad8b9abaad32ad">&#9670;&nbsp;</a></span>block_wise() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::block_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by vector block. It does the same thing as the above function, only that it does this for one single level of a multilevel discretization. The non-multigrid part of the the <a class="el" href="classDoFHandler.html">DoFHandler</a> is not touched. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00911">911</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a645678ac23c256c226a40540cdbac428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645678ac23c256c226a40540cdbac428">&#9670;&nbsp;</a></span>block_wise() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::block_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by block. It does the same thing as the above function.</p>
<p>This function only succeeds if each of the elements in the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> attached to the <a class="el" href="classhp_1_1DoFHandler.html">hp::DoFHandler</a> argument has exactly the same number of blocks (see <a class="el" href="DEALGlossary.html#GlossBlock">the glossary</a> for more information). Note that this is not always given: while the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> class ensures that all of its elements have the same number of vector components, they need not have the same number of blocks. At the same time, this function here needs to match individual blocks across elements and therefore requires that elements have the same number of blocks and that subsequent blocks in one element have the same meaning as in another element. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00883">883</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="af6d683f395aa69974e33cc9de333b337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d683f395aa69974e33cc9de333b337">&#9670;&nbsp;</a></span>compute_block_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> DoFRenumbering::compute_block_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ENDITERATOR &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_level_operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a658593cab0e93a92a7d8ce0ffe086518">block_wise()</a> functions. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l00942">942</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="af0306c2a1b1eeef2e3d54e0bf36d7bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0306c2a1b1eeef2e3d54e0bf36d7bd7">&#9670;&nbsp;</a></span>hierarchical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::hierarchical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees cell by cell in hierarchical order (also known as z-order). The main usage is that this guarantees the same ordering independent of the number of processors involved in a parallel distributed computation. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01185">1185</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="ab52b1a0409ab7906be7c963daec263a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52b1a0409ab7906be7c963daec263a9">&#9670;&nbsp;</a></span>cell_wise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::cell_wise </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber degrees of freedom by cell. The function takes a vector of cell iterators (which needs to list <em>all</em> active cells of the DoF handler objects) and will give degrees of freedom new indices based on where in the given list of cells the cell is on which the degree of freedom is located. Degrees of freedom that exist at the interface between two or more cells will be numbered when they are encountered first.</p>
<p>Degrees of freedom that are encountered first on the same cell retain their original ordering before the renumbering step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose degrees of freedom are to be renumbered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_order</td><td>A vector that contains the order of the cells that defines the order in which degrees of freedom should be renumbered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>cell_order</code> must have size <code>dof_handler.get_triangulation().n_active_cells()</code>. Every active cell iterator of that triangulation needs to be present in <code>cell_order</code> exactly once. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01371">1371</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a3a6bd2328877f25e956174a7d0635e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6bd2328877f25e956174a7d0635e3c">&#9670;&nbsp;</a></span>compute_cell_wise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_cell_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a renumbering of degrees of freedom by cell. The function takes a vector of cell iterators (which needs to list <em>all</em> active cells of the DoF handler objects) and will give degrees of freedom new indices based on where in the given list of cells the cell is on which the degree of freedom is located. Degrees of freedom that exist at the interface between two or more cells will be numbered when they are encountered first.</p>
<p>Degrees of freedom that are encountered first on the same cell retain their original ordering before the renumbering step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">renumbering</td><td>A vector of length <code>dof_handler.n_dofs()</code> that contains for each degree of freedom (in their current numbering) their future DoF index. This vector therefore presents a (very particular) <em>permutation</em> of the current DoF indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inverse_renumbering</td><td>The reverse of the permutation returned in the previous argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose degrees of freedom are to be renumbered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_order</td><td>A vector that contains the order of the cells that defines the order in which degrees of freedom should be renumbered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>cell_order</code> must have size <code>dof_handler.get_triangulation().n_active_cells()</code>. Every active cell iterator of that triangulation needs to be present in <code>cell_order</code> exactly once. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>For each <code>i</code> between zero and <code>dof_handler.n_dofs()</code>, the condition <code>renumbering[inverse_renumbering[i]] == i</code> will hold. </dd></dl>

</div>
</div>
<a id="ac2f7fae3e101e239923d4fc650de29fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f7fae3e101e239923d4fc650de29fe">&#9670;&nbsp;</a></span>cell_wise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::cell_wise </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename DoFHandlerType::level_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the other <a class="el" href="namespaceDoFRenumbering.html#ab52b1a0409ab7906be7c963daec263a9">cell_wise()</a> function, but for one level of a multilevel enumeration of degrees of freedom. </p>

</div>
</div>
<a id="a42f94c4927cdecdeb840420e6a80ba02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f94c4927cdecdeb840420e6a80ba02">&#9670;&nbsp;</a></span>compute_cell_wise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_cell_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename DoFHandlerType::level_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the other <a class="el" href="namespaceDoFRenumbering.html#a3a6bd2328877f25e956174a7d0635e3c">compute_cell_wise()</a> function, but for one level of a multilevel enumeration of degrees of freedom. </p>

</div>
</div>
<a id="aa8507cca091079d78aa6d587a5de13aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8507cca091079d78aa6d587a5de13aa">&#9670;&nbsp;</a></span>downstream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::downstream </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Downstream numbering with respect to a constant flow direction. If the additional argument <code>dof_wise_renumbering</code> is set to <code>false</code>, the numbering is performed cell-wise, otherwise it is performed based on the location of the support points.</p>
<p>The cells are sorted such that the centers of higher numbers are further downstream with respect to the constant vector <code>direction</code> than the centers of lower numbers. Even if this yields a downstream numbering with respect to the flux on the edges for fairly general grids, this might not be guaranteed for all meshes.</p>
<p>If the <code>dof_wise_renumbering</code> argument is set to <code>false</code>, this function produces a downstream ordering of the mesh cells and calls <a class="el" href="namespaceDoFRenumbering.html#ab52b1a0409ab7906be7c963daec263a9">cell_wise()</a>. Therefore, the output only makes sense for Discontinuous Galerkin Finite Elements (all degrees of freedom have to be associated with the interior of the cell in that case) in that case.</p>
<p>If <code>dof_wise_renumbering</code> is set to <code>true</code>, the degrees of freedom are renumbered based on the support point location of the individual degrees of freedom (obviously, the finite element needs to define support points for this to work). The numbering of points with the same position in downstream location (e.g. those parallel to the flow direction, or several dofs within a <a class="el" href="classFESystem.html">FESystem</a>) will be unaffected. </p>

</div>
</div>
<a id="ab629b9a4ad13d34d318282e9138df25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab629b9a4ad13d34d318282e9138df25c">&#9670;&nbsp;</a></span>downstream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::downstream </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise downstream numbering with respect to a constant flow direction on one level. See the other function with the same name. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01616">1616</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="ae20862edbbac0e1349d3a2760b36fb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20862edbbac0e1349d3a2760b36fb8d">&#9670;&nbsp;</a></span>compute_downstream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_downstream </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#aa8507cca091079d78aa6d587a5de13aa">downstream()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01527">1527</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a379a1f5c1e9dc24f4b25a04bbec14d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379a1f5c1e9dc24f4b25a04bbec14d3e">&#9670;&nbsp;</a></span>compute_downstream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_downstream </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#aa8507cca091079d78aa6d587a5de13aa">downstream()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01634">1634</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="af5602fa5250f40633650fa634d2a8b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5602fa5250f40633650fa634d2a8b9d">&#9670;&nbsp;</a></span>clockwise_dg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::clockwise_dg </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>counter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise clockwise numbering.</p>
<p>This function produces a (counter)clockwise ordering of the mesh cells with respect to the hub <code>center</code> and calls <a class="el" href="namespaceDoFRenumbering.html#ab52b1a0409ab7906be7c963daec263a9">cell_wise()</a>. Therefore, it only works with Discontinuous Galerkin Finite Elements, i.e. all degrees of freedom have to be associated with the interior of the cell. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01781">1781</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a70b61c090f315a7008d9488666ed3ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b61c090f315a7008d9488666ed3ee7">&#9670;&nbsp;</a></span>clockwise_dg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::clockwise_dg </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>counter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise clockwise numbering on one level. See the other function with the same name. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01823">1823</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="ac18ec9ac243e2fb738b8fbfec60be5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18ec9ac243e2fb738b8fbfec60be5c8">&#9670;&nbsp;</a></span>compute_clockwise_dg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_clockwise_dg </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; DoFHandlerType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#af5602fa5250f40633650fa634d2a8b9d">clockwise_dg()</a> functions. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01797">1797</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a37bc01a74fb5340ae110dbcfb4c6777b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bc01a74fb5340ae110dbcfb4c6777b">&#9670;&nbsp;</a></span>sort_selected_dofs_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort those degrees of freedom which are tagged with <code>true</code> in the <code>selected_dofs</code> array to the back of the DoF numbers. The sorting is stable, i.e. the relative order within the tagged degrees of freedom is preserved, as is the relative order within the untagged ones.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01259">1259</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="ad438256a7d5bf2d5690e3f23193404e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad438256a7d5bf2d5690e3f23193404e5">&#9670;&nbsp;</a></span>sort_selected_dofs_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort those degrees of freedom which are tagged with <code>true</code> in the <code>selected_dofs</code> array on the level <code>level</code> to the back of the DoF numbers. The sorting is stable, i.e. the relative order within the tagged degrees of freedom is preserved, as is the relative order within the untagged ones.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom on the given level. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01273">1273</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="aaf0529a95ff4c8e61e17987a1c005d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0529a95ff4c8e61e17987a1c005d23">&#9670;&nbsp;</a></span>compute_sort_selected_dofs_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a37bc01a74fb5340ae110dbcfb4c6777b">sort_selected_dofs_back()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01291">1291</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="aad7f0b22d50b175e280cc9e9091d0258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7f0b22d50b175e280cc9e9091d0258">&#9670;&nbsp;</a></span>compute_sort_selected_dofs_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes the renumbering vector on each level needed by the <a class="el" href="namespaceDoFRenumbering.html#a37bc01a74fb5340ae110dbcfb4c6777b">sort_selected_dofs_back()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but only computes the renumbering and returns the renumbering vector.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom on the given level. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01329">1329</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a11db38e857f876c15b5dc2a8be7df48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11db38e857f876c15b5dc2a8be7df48b">&#9670;&nbsp;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::random </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom in a random way. The result of this function is repeatable in that two runs of the same program will yield the same result. This is achieved by creating a new random number generator with a fixed seed every time this function is entered. In particular, the function therefore does not rely on an external random number generator for which it would matter how often it has been called before this function (or, for that matter, whether other threads running concurrently to this function also draw random numbers). </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01849">1849</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a05604dcda07d94c31bc31abf7fe2fb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05604dcda07d94c31bc31abf7fe2fb94">&#9670;&nbsp;</a></span>compute_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_random </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a11db38e857f876c15b5dc2a8be7df48b">random()</a> function. See there for more information on the computed random renumbering.</p>
<p>This function does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01862">1862</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="a442e0991d482f8d208069945d4cee508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442e0991d482f8d208069945d4cee508">&#9670;&nbsp;</a></span>subdomain_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::subdomain_wise </td>
          <td>(</td>
          <td class="paramtype">DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom such that they are associated with the subdomain id of the cells they are living on, i.e. first all degrees of freedom that belong to cells with subdomain zero, then all with subdomain one, etc. This is useful when doing parallel computations after assigning subdomain ids using a partitioner (see the <a class="el" href="namespaceGridTools.html#a5b4706b77042db5437cf81fd13e62b20">GridTools::partition_triangulation</a> function for this).</p>
<p>Note that degrees of freedom associated with faces, edges, and vertices may be associated with multiple subdomains if they are sitting on partition boundaries. It would therefore be undefined with which subdomain they have to be associated. For this, we use what we get from the <a class="el" href="namespaceDoFTools.html#aafdaa16476cd2bec333a7197ab06bff9">DoFTools::get_subdomain_association</a> function.</p>
<p>The algorithm is stable, i.e. if two dofs i,j have <code>i&lt;j</code> and belong to the same subdomain, then they will be in this order also after reordering. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01892">1892</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
<a id="ae4d43edd942d5d8f53112953fbac191e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d43edd942d5d8f53112953fbac191e">&#9670;&nbsp;</a></span>compute_subdomain_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_subdomain_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DoFHandlerType &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a442e0991d482f8d208069945d4cee508">subdomain_wise()</a> function. Does not perform the renumbering on the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> dofs but returns the renumbering vector. </p>

<p class="definition">Definition at line <a class="el" href="dof__renumbering_8cc_source.html#l01905">1905</a> of file <a class="el" href="dof__renumbering_8cc_source.html">dof_renumbering.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
