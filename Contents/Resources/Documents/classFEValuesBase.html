<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FEValuesBase&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFEValuesBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEValuesBase&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__feaccess.html">Finite element access/FEValues classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe_2fe__values_8h_source.html">deal.II/fe/fe_values.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FEValuesBase&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFEValuesBase__inherit__graph.svg" width="574" height="312"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase_1_1CellIterator.html">CellIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase_1_1TriaCellIterator.html">TriaCellIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3adde03753e99c526bb323533faa25d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3adde03753e99c526bb323533faa25d2">FEValuesBase</a> (const unsigned int n_q_points, const unsigned int <a class="el" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a8fb1d5f367902df6b2b598d9da1b0398">mapping</a>, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#aeb05cc9511ff887438f3e6cf036a3134">fe</a>)</td></tr>
<tr class="separator:a3adde03753e99c526bb323533faa25d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d56296cbd8389414d14d7d42219b7e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5d56296cbd8389414d14d7d42219b7e7">~FEValuesBase</a> ()</td></tr>
<tr class="separator:a5d56296cbd8389414d14d7d42219b7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">ShapeAccess Access to shape function values. These fields are filled by the finite element.</div></td></tr>
<tr class="memitem:a1dd48cb744013c448d57f8f77640c08d"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (const unsigned int function_no, const unsigned int point_no) const</td></tr>
<tr class="separator:a1dd48cb744013c448d57f8f77640c08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57a7e777b0798ec009b4ce888ad9574"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a> (const unsigned int function_no, const unsigned int point_no, const unsigned int component) const</td></tr>
<tr class="separator:aa57a7e777b0798ec009b4ce888ad9574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e7840de879ca71f64e6a371e3c66bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a> (const unsigned int function_no, const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a07e7840de879ca71f64e6a371e3c66bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab503ff51db247a8b31b62a50478f3a2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab503ff51db247a8b31b62a50478f3a2e">shape_grad_component</a> (const unsigned int function_no, const unsigned int point_no, const unsigned int component) const</td></tr>
<tr class="separator:ab503ff51db247a8b31b62a50478f3a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec09a1f6b6f364c135df6d58af908ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a8ec09a1f6b6f364c135df6d58af908ad">shape_hessian</a> (const unsigned int function_no, const unsigned int point_no) const</td></tr>
<tr class="separator:a8ec09a1f6b6f364c135df6d58af908ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c87d2be6d45a5eb0200fa56633ef13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad2c87d2be6d45a5eb0200fa56633ef13">shape_hessian_component</a> (const unsigned int function_no, const unsigned int point_no, const unsigned int component) const</td></tr>
<tr class="separator:ad2c87d2be6d45a5eb0200fa56633ef13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dc5ecb928f794f17d4b9a2f2d7df25"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a67dc5ecb928f794f17d4b9a2f2d7df25">shape_3rd_derivative</a> (const unsigned int function_no, const unsigned int point_no) const</td></tr>
<tr class="separator:a67dc5ecb928f794f17d4b9a2f2d7df25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4470bc39c6f7d9ded5f749910deb7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aac4470bc39c6f7d9ded5f749910deb7a">shape_3rd_derivative_component</a> (const unsigned int function_no, const unsigned int point_no, const unsigned int component) const</td></tr>
<tr class="separator:aac4470bc39c6f7d9ded5f749910deb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to values of global finite element fields</div></td></tr>
<tr class="memitem:a357b422e374f2f2207af3512093f3907"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a357b422e374f2f2207af3512093f3907"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (const InputVector &amp;fe_function, std::vector&lt; typename InputVector::value_type &gt; &amp;values) const</td></tr>
<tr class="separator:a357b422e374f2f2207af3512093f3907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b85db94c36810850a8f9c92209a5854"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a9b85db94c36810850a8f9c92209a5854"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9b85db94c36810850a8f9c92209a5854">get_function_values</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:a9b85db94c36810850a8f9c92209a5854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9057b177b0447f8249afc65bd521427"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ae9057b177b0447f8249afc65bd521427"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae9057b177b0447f8249afc65bd521427">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; typename InputVector::value_type &gt; &amp;values) const</td></tr>
<tr class="separator:ae9057b177b0447f8249afc65bd521427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9395e7737f49a44696a6680603ac712"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:af9395e7737f49a44696a6680603ac712"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af9395e7737f49a44696a6680603ac712">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt; &gt; &amp;values) const</td></tr>
<tr class="separator:af9395e7737f49a44696a6680603ac712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7af0e7b22f81342dac42ed03893c238"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ae7af0e7b22f81342dac42ed03893c238"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae7af0e7b22f81342dac42ed03893c238">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; typename InputVector::value_type &gt; &gt; &gt; values, const bool quadrature_points_fastest) const</td></tr>
<tr class="separator:ae7af0e7b22f81342dac42ed03893c238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to derivatives of global finite element fields</div></td></tr>
<tr class="memitem:aab06de0a7599e39bd417cdc8d5732362"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aab06de0a7599e39bd417cdc8d5732362"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">get_function_gradients</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:aab06de0a7599e39bd417cdc8d5732362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe07e36e68c545e87e8754bc9812598"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a2fe07e36e68c545e87e8754bc9812598"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a2fe07e36e68c545e87e8754bc9812598">get_function_gradients</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt; &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:a2fe07e36e68c545e87e8754bc9812598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9664aee9984eb360f9a595f8e88a8a93"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a9664aee9984eb360f9a595f8e88a8a93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9664aee9984eb360f9a595f8e88a8a93">get_function_gradients</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt; &gt; &amp;gradients) const</td></tr>
<tr class="separator:a9664aee9984eb360f9a595f8e88a8a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27834ef7b041a32cef6763861e163610"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a27834ef7b041a32cef6763861e163610"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a27834ef7b041a32cef6763861e163610">get_function_gradients</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt; &gt; &gt; &gt; gradients, bool quadrature_points_fastest=false) const</td></tr>
<tr class="separator:a27834ef7b041a32cef6763861e163610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to second derivatives (Hessian matrices and Laplacians) of global finite element fields</div></td></tr>
<tr class="memitem:ae2f5e7078c3fffb1b46b113614c9caa7"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ae2f5e7078c3fffb1b46b113614c9caa7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae2f5e7078c3fffb1b46b113614c9caa7">get_function_hessians</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt; &gt; &amp;hessians) const</td></tr>
<tr class="separator:ae2f5e7078c3fffb1b46b113614c9caa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59fdbc14818ecbb115795e591749a9e"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:af59fdbc14818ecbb115795e591749a9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af59fdbc14818ecbb115795e591749a9e">get_function_hessians</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt; &gt; &gt; &amp;hessians, bool quadrature_points_fastest=false) const</td></tr>
<tr class="separator:af59fdbc14818ecbb115795e591749a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bcd9e99062d7812f54dc57543a91bf"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ac1bcd9e99062d7812f54dc57543a91bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac1bcd9e99062d7812f54dc57543a91bf">get_function_hessians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt; &gt; &amp;hessians) const</td></tr>
<tr class="separator:ac1bcd9e99062d7812f54dc57543a91bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e034245396bbd89d2e9d87628444a41"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a1e034245396bbd89d2e9d87628444a41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a1e034245396bbd89d2e9d87628444a41">get_function_hessians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt; &gt; &gt; &gt; hessians, bool quadrature_points_fastest=false) const</td></tr>
<tr class="separator:a1e034245396bbd89d2e9d87628444a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e058f0caf1c888010bfc2c616ab4ebd"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a9e058f0caf1c888010bfc2c616ab4ebd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9e058f0caf1c888010bfc2c616ab4ebd">get_function_laplacians</a> (const InputVector &amp;fe_function, std::vector&lt; typename InputVector::value_type &gt; &amp;laplacians) const</td></tr>
<tr class="separator:a9e058f0caf1c888010bfc2c616ab4ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785dde9cf28906fc152c9f435d066a55"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a785dde9cf28906fc152c9f435d066a55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a785dde9cf28906fc152c9f435d066a55">get_function_laplacians</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt; &gt; &amp;laplacians) const</td></tr>
<tr class="separator:a785dde9cf28906fc152c9f435d066a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23160b827fa78006474d2ae5248d923"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ac23160b827fa78006474d2ae5248d923"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac23160b827fa78006474d2ae5248d923">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; typename InputVector::value_type &gt; &amp;laplacians) const</td></tr>
<tr class="separator:ac23160b827fa78006474d2ae5248d923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cbcce5865553afe06128797adfb5e8"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:af3cbcce5865553afe06128797adfb5e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af3cbcce5865553afe06128797adfb5e8">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt; &gt; &amp;laplacians) const</td></tr>
<tr class="separator:af3cbcce5865553afe06128797adfb5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de869e6e0f0b21faf2f4e4ce475a548"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a3de869e6e0f0b21faf2f4e4ce475a548"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3de869e6e0f0b21faf2f4e4ce475a548">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; std::vector&lt; typename InputVector::value_type &gt; &gt; &amp;laplacians, bool quadrature_points_fastest=false) const</td></tr>
<tr class="separator:a3de869e6e0f0b21faf2f4e4ce475a548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to third derivatives of global finite element fields</div></td></tr>
<tr class="memitem:afc15197360be20953699adf3b67bf2b2"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:afc15197360be20953699adf3b67bf2b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#afc15197360be20953699adf3b67bf2b2">get_function_third_derivatives</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt; &gt; &amp;third_derivatives) const</td></tr>
<tr class="separator:afc15197360be20953699adf3b67bf2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71597acafa134435df9f1bf1ad76574"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ab71597acafa134435df9f1bf1ad76574"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab71597acafa134435df9f1bf1ad76574">get_function_third_derivatives</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt; &gt; &gt; &amp;third_derivatives, bool quadrature_points_fastest=false) const</td></tr>
<tr class="separator:ab71597acafa134435df9f1bf1ad76574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cb6da166163613d501253a3e8d9765"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aa5cb6da166163613d501253a3e8d9765"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa5cb6da166163613d501253a3e8d9765">get_function_third_derivatives</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt; &gt; &amp;third_derivatives) const</td></tr>
<tr class="separator:aa5cb6da166163613d501253a3e8d9765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d0a5dada84490539639b33c1745a7d"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:af2d0a5dada84490539639b33c1745a7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af2d0a5dada84490539639b33c1745a7d">get_function_third_derivatives</a> (const InputVector &amp;fe_function, const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;indices, <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt; &gt; &gt; &gt; third_derivatives, bool quadrature_points_fastest=false) const</td></tr>
<tr class="separator:af2d0a5dada84490539639b33c1745a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometry of the cell</div></td></tr>
<tr class="memitem:ab123e5da03736be4977c76fbcb6a2e37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a> (const unsigned int q) const</td></tr>
<tr class="separator:ab123e5da03736be4977c76fbcb6a2e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41b67cfd48e02f6035e39c84f0fb47a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a> () const</td></tr>
<tr class="separator:ae41b67cfd48e02f6035e39c84f0fb47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abade89efb068b71b7ced7082012a2441"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:abade89efb068b71b7ced7082012a2441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7371618d5977d28dfe82c81fbac29c0f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> () const</td></tr>
<tr class="separator:a7371618d5977d28dfe82c81fbac29c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a66566d1b429d37ebe9347e7e1f1877"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7a66566d1b429d37ebe9347e7e1f1877">jacobian</a> (const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a7a66566d1b429d37ebe9347e7e1f1877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581eaad30b2ad577a7a5e0c500581364"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a581eaad30b2ad577a7a5e0c500581364">get_jacobians</a> () const</td></tr>
<tr class="separator:a581eaad30b2ad577a7a5e0c500581364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b1e5bd1176c3a8720dfdb1c09a4576"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a91b1e5bd1176c3a8720dfdb1c09a4576">jacobian_grad</a> (const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a91b1e5bd1176c3a8720dfdb1c09a4576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1991ee62632076743edb81fb763b0abd"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a1991ee62632076743edb81fb763b0abd">get_jacobian_grads</a> () const</td></tr>
<tr class="separator:a1991ee62632076743edb81fb763b0abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906c5afbaec52697c97e98c3f8443c74"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a906c5afbaec52697c97e98c3f8443c74">jacobian_pushed_forward_grad</a> (const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a906c5afbaec52697c97e98c3f8443c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae119e9bd1cd65969c0b8a776e77d29ed"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae119e9bd1cd65969c0b8a776e77d29ed">get_jacobian_pushed_forward_grads</a> () const</td></tr>
<tr class="separator:ae119e9bd1cd65969c0b8a776e77d29ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53133fb9a5597549bf6da6ecb234616d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 3, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a53133fb9a5597549bf6da6ecb234616d">jacobian_2nd_derivative</a> (const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a53133fb9a5597549bf6da6ecb234616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7cc2a9cb7fba17e86aef3de3195fe7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 3, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a0e7cc2a9cb7fba17e86aef3de3195fe7">get_jacobian_2nd_derivatives</a> () const</td></tr>
<tr class="separator:a0e7cc2a9cb7fba17e86aef3de3195fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd32cadb5596e057774e50407b0207a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 4, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a0bd32cadb5596e057774e50407b0207a">jacobian_pushed_forward_2nd_derivative</a> (const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a0bd32cadb5596e057774e50407b0207a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5325e97f29cee53bff240dbcd077cd"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6d5325e97f29cee53bff240dbcd077cd">get_jacobian_pushed_forward_2nd_derivatives</a> () const</td></tr>
<tr class="separator:a6d5325e97f29cee53bff240dbcd077cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7c9dba799bbfa62304d77f68e3652a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 4, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9b7c9dba799bbfa62304d77f68e3652a">jacobian_3rd_derivative</a> (const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a9b7c9dba799bbfa62304d77f68e3652a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a1a2eaa1ceebcead8153193e621e43"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 4, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab0a1a2eaa1ceebcead8153193e621e43">get_jacobian_3rd_derivatives</a> () const</td></tr>
<tr class="separator:ab0a1a2eaa1ceebcead8153193e621e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf1d14e92d838b8b4eebd3e609ec905"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 5, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a1cf1d14e92d838b8b4eebd3e609ec905">jacobian_pushed_forward_3rd_derivative</a> (const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a1cf1d14e92d838b8b4eebd3e609ec905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7314862c9fe73c3904d541a15152a46"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 5, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab7314862c9fe73c3904d541a15152a46">get_jacobian_pushed_forward_3rd_derivatives</a> () const</td></tr>
<tr class="separator:ab7314862c9fe73c3904d541a15152a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5962dd60e1d9fd85564350ca8e530d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, spacedim, dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a1a5962dd60e1d9fd85564350ca8e530d">inverse_jacobian</a> (const unsigned int <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a1a5962dd60e1d9fd85564350ca8e530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c418078ee9299121efdb069d9e43a0f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, spacedim, dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6c418078ee9299121efdb069d9e43a0f">get_inverse_jacobians</a> () const</td></tr>
<tr class="separator:a6c418078ee9299121efdb069d9e43a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd4fac1ac908ea671c96ef9ccccc81f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a8fd4fac1ac908ea671c96ef9ccccc81f">normal_vector</a> (const unsigned int i) const</td></tr>
<tr class="separator:a8fd4fac1ac908ea671c96ef9ccccc81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af690a5a25a9517f7b3ae211b11f9b7cb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors</a> () const</td></tr>
<tr class="separator:af690a5a25a9517f7b3ae211b11f9b7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16490a59a0207bb018a64c393bd6b961"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a16490a59a0207bb018a64c393bd6b961">get_normal_vectors</a> () const 1</td></tr>
<tr class="separator:a16490a59a0207bb018a64c393bd6b961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ac6f931ae9bf4321d0c12271ffeba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa8ac6f931ae9bf4321d0c12271ffeba1">transform</a> (std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;transformed, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;original, <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a> <a class="el" href="classFEValuesBase.html#a8fb1d5f367902df6b2b598d9da1b0398">mapping</a>) const 1</td></tr>
<tr class="separator:aa8ac6f931ae9bf4321d0c12271ffeba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extractors Methods to extract individual components</div></td></tr>
<tr class="memitem:acb2e7a5b351659b96ec7098566171d15"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#acb2e7a5b351659b96ec7098566171d15">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:acb2e7a5b351659b96ec7098566171d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df920e7dfa235492a3d4c3b9f974703"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a1df920e7dfa235492a3d4c3b9f974703">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a1df920e7dfa235492a3d4c3b9f974703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6861b7033c01434829ff37114b7c8c7c"><td class="memItemLeft" align="right" valign="top">const FEValuesViews::SymmetricTensor&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6861b7033c01434829ff37114b7c8c7c">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;tensor) const</td></tr>
<tr class="separator:a6861b7033c01434829ff37114b7c8c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa8be17963dbb8be9ba7fedcf1c6646"><td class="memItemLeft" align="right" valign="top">const FEValuesViews::Tensor&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a0aa8be17963dbb8be9ba7fedcf1c6646">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor</a>&lt; 2 &gt; &amp;tensor) const</td></tr>
<tr class="separator:a0aa8be17963dbb8be9ba7fedcf1c6646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to the raw data</div></td></tr>
<tr class="memitem:a4af6380946790416bf9476050709662a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a4af6380946790416bf9476050709662a">get_mapping</a> () const</td></tr>
<tr class="separator:a4af6380946790416bf9476050709662a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac036b6304c3dbf98eabb14fd390fe1be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac036b6304c3dbf98eabb14fd390fe1be">get_fe</a> () const</td></tr>
<tr class="separator:ac036b6304c3dbf98eabb14fd390fe1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b258a1619829f7ec03a184ffb8e556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a55b258a1619829f7ec03a184ffb8e556">get_update_flags</a> () const</td></tr>
<tr class="separator:a55b258a1619829f7ec03a184ffb8e556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3a1c53c139e2553b672de682d6233e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9d3a1c53c139e2553b672de682d6233e">get_cell</a> () const</td></tr>
<tr class="separator:a9d3a1c53c139e2553b672de682d6233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808af56bde1d82893b88875dc651e749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a808af56bde1d82893b88875dc651e749">get_cell_similarity</a> () const</td></tr>
<tr class="separator:a808af56bde1d82893b88875dc651e749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821f21ed0d993cae6df69f41d99f68a2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a821f21ed0d993cae6df69f41d99f68a2">memory_consumption</a> () const</td></tr>
<tr class="separator:a821f21ed0d993cae6df69f41d99f68a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga10ed08551ffd294db194fa94d873cf83"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga10ed08551ffd294db194fa94d873cf83">ExcAccessToUninitializedField</a> (char *arg1)</td></tr>
<tr class="separator:ga10ed08551ffd294db194fa94d873cf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe32e761993573fccaedd755f0c4a9a0"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafe32e761993573fccaedd755f0c4a9a0">ExcCannotInitializeField</a> ()</td></tr>
<tr class="separator:gafe32e761993573fccaedd755f0c4a9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3a34ef4f756028ed11554e3098311d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e3a34ef4f756028ed11554e3098311d">ExcInvalidUpdateFlag</a> ()</td></tr>
<tr class="separator:ga7e3a34ef4f756028ed11554e3098311d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5abfa92aff1a602aff21a7bfe2b0063"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa5abfa92aff1a602aff21a7bfe2b0063">ExcFEDontMatch</a> ()</td></tr>
<tr class="separator:gaa5abfa92aff1a602aff21a7bfe2b0063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4890548457fefcdd304ea3798c50288a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga4890548457fefcdd304ea3798c50288a">ExcShapeFunctionNotPrimitive</a> (int arg1)</td></tr>
<tr class="separator:ga4890548457fefcdd304ea3798c50288a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96fa769f20a415c302bff67da417cf95"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga96fa769f20a415c302bff67da417cf95">ExcFENotPrimitive</a> ()</td></tr>
<tr class="separator:ga96fa769f20a415c302bff67da417cf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a807c3049bfe81743fc0f237dfc2fbdea"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a></td></tr>
<tr class="separator:a807c3049bfe81743fc0f237dfc2fbdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b264d5b2fb6615f5dea7a21135ed1a5"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a></td></tr>
<tr class="separator:a5b264d5b2fb6615f5dea7a21135ed1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afd889a38bbce8ea33d46d152f14abdd3"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#afd889a38bbce8ea33d46d152f14abdd3">dimension</a> = dim</td></tr>
<tr class="separator:afd889a38bbce8ea33d46d152f14abdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6541820cb52f78a4d43de18be0352002"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6541820cb52f78a4d43de18be0352002">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a6541820cb52f78a4d43de18be0352002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aaf01126d2e3b926fecbaf122357add53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aaf01126d2e3b926fecbaf122357add53">invalidate_present_cell</a> ()</td></tr>
<tr class="separator:aaf01126d2e3b926fecbaf122357add53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed652da6ec16e368e27da4085b4281bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aed652da6ec16e368e27da4085b4281bb">maybe_invalidate_previous_present_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:aed652da6ec16e368e27da4085b4281bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1352ba7f04525e175d2c6fa552a1c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa1352ba7f04525e175d2c6fa552a1c6a">compute_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>) const</td></tr>
<tr class="separator:aa1352ba7f04525e175d2c6fa552a1c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c38a7d7c3a6b384ad5b46f38248524d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5c38a7d7c3a6b384ad5b46f38248524d">check_cell_similarity</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a5c38a7d7c3a6b384ad5b46f38248524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acf87f79b7e82e60650bc9227deb6aeb9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const CellIteratorBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#acf87f79b7e82e60650bc9227deb6aeb9">present_cell</a></td></tr>
<tr class="separator:acf87f79b7e82e60650bc9227deb6aeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7274f2ea9bbe0ea61bd983c5746ffef"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa7274f2ea9bbe0ea61bd983c5746ffef">tria_listener_refinement</a></td></tr>
<tr class="separator:aa7274f2ea9bbe0ea61bd983c5746ffef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f853782c9ba1f6c4093f64ede145253"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a2f853782c9ba1f6c4093f64ede145253">tria_listener_mesh_transform</a></td></tr>
<tr class="separator:a2f853782c9ba1f6c4093f64ede145253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb1d5f367902df6b2b598d9da1b0398"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a8fb1d5f367902df6b2b598d9da1b0398">mapping</a></td></tr>
<tr class="separator:a8fb1d5f367902df6b2b598d9da1b0398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe490ab7d47719d8624cf8074316ff"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7cfe490ab7d47719d8624cf8074316ff">mapping_data</a></td></tr>
<tr class="separator:a7cfe490ab7d47719d8624cf8074316ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f83245158720fa8d386ad44608d77b"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa9f83245158720fa8d386ad44608d77b">mapping_output</a></td></tr>
<tr class="separator:aa9f83245158720fa8d386ad44608d77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb05cc9511ff887438f3e6cf036a3134"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aeb05cc9511ff887438f3e6cf036a3134">fe</a></td></tr>
<tr class="separator:aeb05cc9511ff887438f3e6cf036a3134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea8d393398e95d8a421c1513c7c8454"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9ea8d393398e95d8a421c1513c7c8454">fe_data</a></td></tr>
<tr class="separator:a9ea8d393398e95d8a421c1513c7c8454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3931ad13b4e3b9f87a49e81e74a40443"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3931ad13b4e3b9f87a49e81e74a40443">finite_element_output</a></td></tr>
<tr class="separator:a3931ad13b4e3b9f87a49e81e74a40443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ed91bcc8004390e372704d63177162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a></td></tr>
<tr class="separator:a63ed91bcc8004390e372704d63177162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096d4ea9edea6618e23f5f13ab40784c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a096d4ea9edea6618e23f5f13ab40784c">cell_similarity</a></td></tr>
<tr class="separator:a096d4ea9edea6618e23f5f13ab40784c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac52b829e28b9d9d38c69f6662783f92c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac52b829e28b9d9d38c69f6662783f92c">FEValuesBase</a> (const <a class="el" href="classFEValuesBase.html">FEValuesBase</a> &amp;)</td></tr>
<tr class="separator:ac52b829e28b9d9d38c69f6662783f92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48091346190d2c2c562bca0b5d6e73b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEValuesBase.html">FEValuesBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a48091346190d2c2c562bca0b5d6e73b7">operator=</a> (const <a class="el" href="classFEValuesBase.html">FEValuesBase</a> &amp;)</td></tr>
<tr class="separator:a48091346190d2c2c562bca0b5d6e73b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7cf406ac2334ec378cdbaed4b836cc45"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="structinternal_1_1FEValuesViews_1_1Cache.html">internal::FEValuesViews::Cache</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7cf406ac2334ec378cdbaed4b836cc45">fe_values_views_cache</a></td></tr>
<tr class="separator:a7cf406ac2334ec378cdbaed4b836cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abd66d1380ef2e58a1e433bc1626c324e"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:abd66d1380ef2e58a1e433bc1626c324e"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abd66d1380ef2e58a1e433bc1626c324e">FEValuesViews::Scalar</a></td></tr>
<tr class="separator:abd66d1380ef2e58a1e433bc1626c324e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a6d19c4bc8339d65379e8f358cf5c5"><td class="memTemplParams" colspan="2"><a id="ab7a6d19c4bc8339d65379e8f358cf5c5"></a>
template&lt;int , int &gt; </td></tr>
<tr class="memitem:ab7a6d19c4bc8339d65379e8f358cf5c5"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FEValuesViews::Vector</b></td></tr>
<tr class="separator:ab7a6d19c4bc8339d65379e8f358cf5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim&gt;<br />
class FEValuesBase&lt; dim, spacedim &gt;</h3>

<p><a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects are interfaces to finite element and mapping classes on the one hand side, to cells and quadrature rules on the other side. They allow to evaluate values or derivatives of shape functions at the quadrature points of a quadrature formula when projected by a mapping from the unit cell onto a cell in real space. The reason for this abstraction is possible optimization: Depending on the type of finite element and mapping, some values can be computed once on the unit cell. Others must be computed on each cell, but maybe computation of several values at the same time offers ways for optimization. Since this interplay may be complex and depends on the actual finite element, it cannot be left to the applications programmer.</p>
<p><a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> provide only data handling: computations are left to objects of type <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a>. These provide functions <code>get_*_data</code> and <code>fill_*_values</code> which are called by the constructor and <code>reinit</code> functions of <code>FEValues*</code>, respectively.</p>
<h3>General usage</h3>
<p>Usually, an object of <code>FEValues*</code> is used in integration loops over all cells of a triangulation (or faces of cells). To take full advantage of the optimization features, it should be constructed before the loop so that information that does not depend on the location and shape of cells can be computed once and for all (this includes, for example, the values of shape functions at quadrature points for the most common elements: we can evaluate them on the unit cell and they will be the same when mapped to the real cell). Then, in the loop over all cells, it must be re-initialized for each grid cell to compute that part of the information that changes depending on the actual cell (for example, the gradient of shape functions equals the gradient on the unit cell &ndash; which can be computed once and for all &ndash; times the Jacobian matrix of the mapping between unit and real cell, which needs to be recomputed for each cell).</p>
<p>A typical piece of code, adding up local contributions to the Laplace matrix looks like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues</a> values (<a class="code" href="classFEValuesBase.html#a8fb1d5f367902df6b2b598d9da1b0398">mapping</a>, finite_element, quadrature, flags);</div><div class="line"><span class="keywordflow">for</span> (cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">     cell != dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">     ++cell)</div><div class="line">  {</div><div class="line">    values.reinit(cell);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;quadrature.size(); ++q)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;finite_element.dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;finite_element.dofs_per_cell; ++j)</div><div class="line">        A(i,j) += fe_values.shape_value(i,q) *</div><div class="line">                  fe_values.shape_value(j,q) *</div><div class="line">                  fe_values.JxW(q);</div><div class="line">    ...</div><div class="line">  }</div></div><!-- fragment --><p>The individual functions used here are described below. Note that by design, the order of quadrature points used inside the <a class="el" href="classFEValues.html">FEValues</a> object is the same as defined by the quadrature formula passed to the constructor of the <a class="el" href="classFEValues.html">FEValues</a> object above.</p>
<h3>Member functions</h3>
<p>The functions of this class fall into different categories: </p><ul>
<li>
<p class="startli"><a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a>, <a class="el" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad()</a>, etc: return one of the values of this object at a time. These functions are inlined, so this is the suggested access to all finite element values. There should be no loss in performance with an optimizing compiler. If the finite element is vector valued, then these functions return the only non-zero component of the requested shape function. However, some finite elements have shape functions that have more than one non-zero component (we call them non-"primitive"), and in this case this set of functions will throw an exception since they cannot generate a useful result. Rather, use the next set of functions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a>, <a class="el" href="classFEValuesBase.html#ab503ff51db247a8b31b62a50478f3a2e">shape_grad_component()</a>, etc: This is the same set of functions as above, except that for vector valued finite elements they return only one vector component. This is useful for elements of which shape functions have more than one non-zero component, since then the above functions cannot be used, and you have to walk over all (or only the non- zero) components of the shape function using this set of functions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a>, <a class="el" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">get_function_gradients()</a>, etc.: Compute a finite element function or its derivative in quadrature points.</p>
<p class="endli"></p>
</li>
<li>
reinit: initialize the <a class="el" href="classFEValues.html">FEValues</a> object for a certain cell. This function is not in the present class but only in the derived classes and has a variable call syntax. See the docs for the derived classes for more information. </li>
</ul>
<h3>Internals about the implementation</h3>
<p>The mechanisms by which this class work are discussed on the page on <a class="el" href="group__UpdateFlags.html">Update flags</a> and about the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 1998, 2003, Guido Kanschat, 2001 </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l00029">29</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3adde03753e99c526bb323533faa25d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adde03753e99c526bb323533faa25d2">&#9670;&nbsp;</a></span>FEValuesBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValuesBase.html">FEValuesBase</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_q_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dofs_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Set up the array sizes with <code>n_q_points</code> quadrature points, <code>dofs_per_cell</code> trial functions per cell and with the given pattern to update the fields when the <code>reinit</code> function of the derived classes is called. The fields themselves are not set up, this must happen in the constructor of the derived class. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02255">2255</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a5d56296cbd8389414d14d7d42219b7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d56296cbd8389414d14d7d42219b7e7">&#9670;&nbsp;</a></span>~FEValuesBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::~<a class="el" href="classFEValuesBase.html">FEValuesBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02277">2277</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ac52b829e28b9d9d38c69f6662783f92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52b829e28b9d9d38c69f6662783f92c">&#9670;&nbsp;</a></span>FEValuesBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValuesBase.html">FEValuesBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Since objects of this class are not copyable, we make it private, and also do not implement it. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1dd48cb744013c448d57f8f77640c08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd48cb744013c448d57f8f77640c08d">&#9670;&nbsp;</a></span>shape_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value of a shape function at a quadrature point on the cell, face or subface selected the last time the <code>reinit</code> function of the derived class was called.</p>
<p>If the shape function is vector-valued, then this returns the only non- zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>Number of the shape function to be evaluated. Note that this number runs from zero to dofs_per_cell, even in the case of an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object.</td></tr>
    <tr><td class="paramname">point_no</td><td>Number of the quadrature point at which function is to be evaluated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="aa57a7e777b0798ec009b4ce888ad9574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57a7e777b0798ec009b4ce888ad9574">&#9670;&nbsp;</a></span>shape_value_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute one vector component of the value of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>Number of the shape function to be evaluated.</td></tr>
    <tr><td class="paramname">point_no</td><td>Number of the quadrature point at which function is to be evaluated.</td></tr>
    <tr><td class="paramname">component</td><td>vector component to be evaluated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a07e7840de879ca71f64e6a371e3c66bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e7840de879ca71f64e6a371e3c66bb">&#9670;&nbsp;</a></span>shape_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the gradient of the <code>function_no</code>th shape function at the <code>quadrature_point</code>th quadrature point with respect to real cell coordinates. If you want to get the derivative in one of the coordinate directions, use the appropriate function of the <a class="el" href="classTensor.html">Tensor</a> class to extract one component of the <a class="el" href="classTensor.html">Tensor</a> returned by this function. Since only a reference to the gradient's value is returned, there should be no major performance drawback.</p>
<p>If the shape function is vector-valued, then this returns the only non- zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then it will throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFEValuesBase.html#ab503ff51db247a8b31b62a50478f3a2e">shape_grad_component()</a> function.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>Number of the shape function to be evaluated.</td></tr>
    <tr><td class="paramname">quadrature_point</td><td>Number of the quadrature point at which function is to be evaluated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ab503ff51db247a8b31b62a50478f3a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab503ff51db247a8b31b62a50478f3a2e">&#9670;&nbsp;</a></span>shape_grad_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1,spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return one vector component of the gradient of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the <a class="el" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad()</a> function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by <a class="el" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad()</a> equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a8ec09a1f6b6f364c135df6d58af908ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec09a1f6b6f364c135df6d58af908ad">&#9670;&nbsp;</a></span>shape_hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;2,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_hessian </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Second derivatives of the <code>function_no</code>th shape function at the <code>point_no</code>th quadrature point with respect to real cell coordinates. If you want to get the derivatives in one of the coordinate directions, use the appropriate function of the <a class="el" href="classTensor.html">Tensor</a> class to extract one component. Since only a reference to the hessian values is returned, there should be no major performance drawback.</p>
<p>If the shape function is vector-valued, then this returns the only non- zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFEValuesBase.html#ad2c87d2be6d45a5eb0200fa56633ef13">shape_hessian_component()</a> function.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ad2c87d2be6d45a5eb0200fa56633ef13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c87d2be6d45a5eb0200fa56633ef13">&#9670;&nbsp;</a></span>shape_hessian_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;2,spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_hessian_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return one vector component of the hessian of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the <a class="el" href="classFEValuesBase.html#a8ec09a1f6b6f364c135df6d58af908ad">shape_hessian()</a> function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by <a class="el" href="classFEValuesBase.html#a8ec09a1f6b6f364c135df6d58af908ad">shape_hessian()</a> equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a67dc5ecb928f794f17d4b9a2f2d7df25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dc5ecb928f794f17d4b9a2f2d7df25">&#9670;&nbsp;</a></span>shape_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;3,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Third derivatives of the <code>function_no</code>th shape function at the <code>point_no</code>th quadrature point with respect to real cell coordinates. If you want to get the 3rd derivatives in one of the coordinate directions, use the appropriate function of the <a class="el" href="classTensor.html">Tensor</a> class to extract one component. Since only a reference to the 3rd derivative values is returned, there should be no major performance drawback.</p>
<p>If the shape function is vector-valued, then this returns the only non- zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the shape_3rdderivative_component() function.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="aac4470bc39c6f7d9ded5f749910deb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac4470bc39c6f7d9ded5f749910deb7a">&#9670;&nbsp;</a></span>shape_3rd_derivative_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;3,spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_3rd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return one vector component of the third derivative of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the shape_3rdderivative() function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by shape_3rdderivative() equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a357b422e374f2f2207af3512093f3907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357b422e374f2f2207af3512093f3907">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the values of a finite element function restricted to the current cell, face or subface selected the last time the <code>reinit</code> function of the derived class was called, at the quadrature points.</p>
<p>If the present cell is not active then values are interpolated to the current cell and point values are computed from that.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. To get values of multi- component elements, there is another <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> below, returning a vector of vectors of results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The values of the function specified by fe_function at the quadrature points of the current cell. The object is assume to already have the correct size. The data type stored by this output vector must be what you get when you multiply the values of shape function times the type used to store the values of the unknowns <img class="formulaInl" alt="$U_j$" src="form_75.png"/> of your finite element vector <img class="formulaInl" alt="$U$" src="form_203.png"/> (represented by the <code>fe_function</code> argument). This happens to be equal to the type of the elements of the solution vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>values[q]</code> will contain the value of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the sequential PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the DofHandler object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized. Alternatively, if the vector argument is of type <a class="el" href="classIndexSet.html">IndexSet</a>, then the function is represented as one that is either zero or one, depending on whether a DoF index is in the set or not.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02690">2690</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a9b85db94c36810850a8f9c92209a5854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b85db94c36810850a8f9c92209a5854">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>values[q]</code> is a vector of values of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. The size of the vector accessed by <code>values[q]</code> equals the number of components of the finite element, i.e. <code>values[q](c)</code> returns the value of the <img class="formulaInl" alt="$c$" src="form_257.png"/>th vector component at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02747">2747</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ae9057b177b0447f8249afc65bd521427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9057b177b0447f8249afc65bd521427">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate function values from an arbitrary vector.</p>
<p>This function offers the possibility to extract function values in quadrature points from vectors not corresponding to a whole discretization.</p>
<p>The vector <code>indices</code> corresponds to the degrees of freedom on a single cell. Its length may even be a multiple of the number of dofs per cell. Then, the vectors in <code>value</code> should allow for the same multiple of the components of the finite element.</p>
<p>You may want to use this function, if you want to access just a single block from a <a class="el" href="classBlockVector.html">BlockVector</a>, if you have a multi-level vector or if you already have a local representation of your finite element data.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02714">2714</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="af9395e7737f49a44696a6680603ac712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9395e7737f49a44696a6680603ac712">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate vector function values from an arbitrary vector.</p>
<p>This function offers the possibility to extract function values in quadrature points from vectors not corresponding to a whole discretization.</p>
<p>The vector <code>indices</code> corresponds to the degrees of freedom on a single cell. Its length may even be a multiple of the number of dofs per cell. Then, the vectors in <code>value</code> should allow for the same multiple of the components of the finite element.</p>
<p>You may want to use this function, if you want to access just a single block from a <a class="el" href="classBlockVector.html">BlockVector</a>, if you have a multi-level vector or if you already have a local representation of your finite element data.</p>
<p>Since this function allows for fairly general combinations of argument sizes, be aware that the checks on the arguments may not detect errors.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02771">2771</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ae7af0e7b22f81342dac42ed03893c238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7af0e7b22f81342dac42ed03893c238">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; typename InputVector::value_type &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate vector function values from an arbitrary vector.</p>
<p>This function offers the possibility to extract function values in quadrature points from vectors not corresponding to a whole discretization.</p>
<p>The vector <code>indices</code> corresponds to the degrees of freedom on a single cell. Its length may even be a multiple of the number of dofs per cell. Then, the vectors in <code>value</code> should allow for the same multiple of the components of the finite element.</p>
<p>Depending on the value of the last argument, the outer vector of <code>values</code> has either the length of the quadrature rule (<code>quadrature_points_fastest == false</code>) or the length of components to be filled <code>quadrature_points_fastest == true</code>. If <code>p</code> is the current quadrature point number and <code>i</code> is the vector component of the solution desired, the access to <code>values</code> is <code>values[p][i]</code> if <code>quadrature_points_fastest == false</code>, and <code>values[i][p]</code> otherwise.</p>
<p>You may want to use this function, if you want to access just a single block from a <a class="el" href="classBlockVector.html">BlockVector</a>, if you have a multi-level vector or if you already have a local representation of your finite element data.</p>
<p>Since this function allows for fairly general combinations of argument sizes, be aware that the checks on the arguments may not detect errors.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02809">2809</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aab06de0a7599e39bd417cdc8d5732362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab06de0a7599e39bd417cdc8d5732362">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the gradients of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> function (see there for more information) but evaluates the finite element field's gradient instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gradients</td><td>The gradients of the function specified by fe_function at the quadrature points of the current cell. The gradients are computed in real space (as opposed to on the unit cell). The object is assume to already have the correct size. The data type stored by this output vector must be what you get when you multiply the gradients of shape function times the type used to store the values of the unknowns <img class="formulaInl" alt="$U_j$" src="form_75.png"/> of your finite element vector <img class="formulaInl" alt="$U$" src="form_203.png"/> (represented by the <code>fe_function</code> argument).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>gradients[q]</code> will contain the gradient of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. <code>gradients[q][d]</code> represents the derivative in coordinate direction <img class="formulaInl" alt="$d$" src="form_301.png"/> at quadrature point <img class="formulaInl" alt="$q$" src="form_171.png"/>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the sequential PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the <a class="el" href="classDoFHandler.html">DoFHandler</a> object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized. Alternatively, if the vector argument is of type <a class="el" href="classIndexSet.html">IndexSet</a>, then the function is represented as one that is either zero or one, depending on whether a DoF index is in the set or not.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02851">2851</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a2fe07e36e68c545e87e8754bc9812598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe07e36e68c545e87e8754bc9812598">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#aab06de0a7599e39bd417cdc8d5732362">get_function_gradients()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>gradients[q]</code> is a vector of gradients of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. The size of the vector accessed by <code>gradients[q]</code> equals the number of components of the finite element, i.e. <code>gradients[q][c]</code> returns the gradient of the <img class="formulaInl" alt="$c$" src="form_257.png"/>th vector component at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. Consequently, <code>gradients[q][c][d]</code> is the derivative in coordinate direction <img class="formulaInl" alt="$d$" src="form_301.png"/> of the <img class="formulaInl" alt="$c$" src="form_257.png"/>th vector component of the vector field at quadrature point <img class="formulaInl" alt="$q$" src="form_171.png"/> of the current cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02908">2908</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a9664aee9984eb360f9a595f8e88a8a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9664aee9984eb360f9a595f8e88a8a93">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classFunction.html">Function</a> gradient access with more flexibility. See <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with corresponding arguments.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02874">2874</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a27834ef7b041a32cef6763861e163610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27834ef7b041a32cef6763861e163610">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt; &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classFunction.html">Function</a> gradient access with more flexibility. See <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with corresponding arguments.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02932">2932</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ae2f5e7078c3fffb1b46b113614c9caa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f5e7078c3fffb1b46b113614c9caa7">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the tensor of second derivatives of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> function (see there for more information) but evaluates the finite element field's second derivatives instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hessians</td><td>The Hessians of the function specified by fe_function at the quadrature points of the current cell. The Hessians are computed in real space (as opposed to on the unit cell). The object is assume to already have the correct size. The data type stored by this output vector must be what you get when you multiply the Hessians of shape function times the type used to store the values of the unknowns <img class="formulaInl" alt="$U_j$" src="form_75.png"/> of your finite element vector <img class="formulaInl" alt="$U$" src="form_203.png"/> (represented by the <code>fe_function</code> argument).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>hessians[q]</code> will contain the Hessian of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. <code>hessians[q][i][j]</code> represents the <img class="formulaInl" alt="$(i,j)$" src="form_739.png"/>th component of the matrix of second derivatives at quadrature point <img class="formulaInl" alt="$q$" src="form_171.png"/>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the sequential PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the DofHandler object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized. Alternatively, if the vector argument is of type <a class="el" href="classIndexSet.html">IndexSet</a>, then the function is represented as one that is either zero or one, depending on whether a DoF index is in the set or not.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02974">2974</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="af59fdbc14818ecbb115795e591749a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59fdbc14818ecbb115795e591749a9e">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#ae2f5e7078c3fffb1b46b113614c9caa7">get_function_hessians()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>hessians[q]</code> is a vector of Hessians of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. The size of the vector accessed by <code>hessians[q]</code> equals the number of components of the finite element, i.e. <code>hessians[q][c]</code> returns the Hessian of the <img class="formulaInl" alt="$c$" src="form_257.png"/>th vector component at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. Consequently, <code>hessians[q][c][i][j]</code> is the <img class="formulaInl" alt="$(i,j)$" src="form_739.png"/>th component of the matrix of second derivatives of the <img class="formulaInl" alt="$c$" src="form_257.png"/>th vector component of the vector field at quadrature point <img class="formulaInl" alt="$q$" src="form_171.png"/> of the current cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03031">3031</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ac1bcd9e99062d7812f54dc57543a91bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bcd9e99062d7812f54dc57543a91bf">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. See <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with corresponding arguments. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l02996">2996</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a1e034245396bbd89d2e9d87628444a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e034245396bbd89d2e9d87628444a41">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt; &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. See <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with corresponding arguments.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03055">3055</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a9e058f0caf1c888010bfc2c616ab4ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e058f0caf1c888010bfc2c616ab4ebd">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the (scalar) Laplacian (i.e. the trace of the tensor of second derivatives) of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> function (see there for more information) but evaluates the finite element field's second derivatives instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">laplacians</td><td>The Laplacians of the function specified by fe_function at the quadrature points of the current cell. The Laplacians are computed in real space (as opposed to on the unit cell). The object is assume to already have the correct size. The data type stored by this output vector must be what you get when you multiply the Laplacians of shape function times the type used to store the values of the unknowns <img class="formulaInl" alt="$U_j$" src="form_75.png"/> of your finite element vector <img class="formulaInl" alt="$U$" src="form_203.png"/> (represented by the <code>fe_function</code> argument). This happens to be equal to the type of the elements of the input vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>laplacians[q]</code> will contain the Laplacian of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point.</dd>
<dd>
For each component of the output vector, there holds <code>laplacians[q]=trace(hessians[q])</code>, where <code>hessians</code> would be the output of the <a class="el" href="classFEValuesBase.html#ae2f5e7078c3fffb1b46b113614c9caa7">get_function_hessians()</a> function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the sequential PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the DofHandler object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized. Alternatively, if the vector argument is of type <a class="el" href="classIndexSet.html">IndexSet</a>, then the function is represented as one that is either zero or one, depending on whether a DoF index is in the set or not.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03092">3092</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a785dde9cf28906fc152c9f435d066a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785dde9cf28906fc152c9f435d066a55">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#a9e058f0caf1c888010bfc2c616ab4ebd">get_function_laplacians()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>laplacians[q]</code> is a vector of Laplacians of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. The size of the vector accessed by <code>laplacians[q]</code> equals the number of components of the finite element, i.e. <code>laplacians[q][c]</code> returns the Laplacian of the <img class="formulaInl" alt="$c$" src="form_257.png"/>th vector component at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point.</dd>
<dd>
For each component of the output vector, there holds <code>laplacians[q][c]=trace(hessians[q][c])</code>, where <code>hessians</code> would be the output of the <a class="el" href="classFEValuesBase.html#ae2f5e7078c3fffb1b46b113614c9caa7">get_function_hessians()</a> function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03147">3147</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ac23160b827fa78006474d2ae5248d923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23160b827fa78006474d2ae5248d923">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. See <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with corresponding arguments.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03115">3115</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="af3cbcce5865553afe06128797adfb5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cbcce5865553afe06128797adfb5e8">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. See <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with corresponding arguments.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03170">3170</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a3de869e6e0f0b21faf2f4e4ce475a548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de869e6e0f0b21faf2f4e4ce475a548">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the second derivatives of a function with more flexibility. See <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with corresponding arguments.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03208">3208</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="afc15197360be20953699adf3b67bf2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc15197360be20953699adf3b67bf2b2">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the tensor of third derivatives of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> function (see there for more information) but evaluates the finite element field's third derivatives instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">third_derivatives</td><td>The third derivatives of the function specified by fe_function at the quadrature points of the current cell. The third derivatives are computed in real space (as opposed to on the unit cell). The object is assumed to already have the correct size. The data type stored by this output vector must be what you get when you multiply the third derivatives of shape function times the type used to store the values of the unknowns <img class="formulaInl" alt="$U_j$" src="form_75.png"/> of your finite element vector <img class="formulaInl" alt="$U$" src="form_203.png"/> (represented by the <code>fe_function</code> argument).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>third_derivatives[q]</code> will contain the third derivatives of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. <code>third_derivatives[q][i][j][k]</code> represents the <img class="formulaInl" alt="$(i,j,k)$" src="form_740.png"/>th component of the 3rd order tensor of third derivatives at quadrature point <img class="formulaInl" alt="$q$" src="form_171.png"/>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the sequential PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the DofHandler object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized. Alternatively, if the vector argument is of type <a class="el" href="classIndexSet.html">IndexSet</a>, then the function is represented as one that is either zero or one, depending on whether a DoF index is in the set or not.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03247">3247</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ab71597acafa134435df9f1bf1ad76574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71597acafa134435df9f1bf1ad76574">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#afc15197360be20953699adf3b67bf2b2">get_function_third_derivatives()</a>, but applied to multi-component (vector- valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>third_derivatives[q]</code> is a vector of third derivatives of the field described by fe_function at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. The size of the vector accessed by <code>third_derivatives[q]</code> equals the number of components of the finite element, i.e. <code>third_derivatives[q][c]</code> returns the third derivative of the <img class="formulaInl" alt="$c$" src="form_257.png"/>th vector component at the <img class="formulaInl" alt="$q$" src="form_171.png"/>th quadrature point. Consequently, <code>third_derivatives[q][c][i][j][k]</code> is the <img class="formulaInl" alt="$(i,j,k)$" src="form_740.png"/>th component of the tensor of third derivatives of the <img class="formulaInl" alt="$c$" src="form_257.png"/>th vector component of the vector field at quadrature point <img class="formulaInl" alt="$q$" src="form_171.png"/> of the current cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03304">3304</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aa5cb6da166163613d501253a3e8d9765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cb6da166163613d501253a3e8d9765">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the third derivatives of a function with more flexibility. See <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with corresponding arguments. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03269">3269</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="af2d0a5dada84490539639b33c1745a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d0a5dada84490539639b33c1745a7d">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; const std::vector&lt; <a class="el" href="namespacetypes.html#a3bf9e493f1aab00b04933b81856144c4">types::global_dof_index</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorSlice.html">VectorSlice</a>&lt; std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt; &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the third derivatives of a function with more flexibility. See <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with corresponding arguments.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03328">3328</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ab123e5da03736be4977c76fbcb6a2e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab123e5da03736be4977c76fbcb6a2e37">&#9670;&nbsp;</a></span>quadrature_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::quadrature_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Position of the <code>q</code>th quadrature point in real space.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_quadrature_points</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ae41b67cfd48e02f6035e39c84f0fb47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41b67cfd48e02f6035e39c84f0fb47a">&#9670;&nbsp;</a></span>get_quadrature_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_quadrature_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the vector of quadrature points in real space.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_quadrature_points</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="abade89efb068b71b7ced7082012a2441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abade89efb068b71b7ced7082012a2441">&#9670;&nbsp;</a></span>JxW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::JxW </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mapped quadrature weight. If this object refers to a volume evaluation (i.e. the derived class is of type <a class="el" href="classFEValues.html">FEValues</a>), then this is the Jacobi determinant times the weight of the *<code>i</code>th unit quadrature point.</p>
<p>For surface evaluations (i.e. classes <a class="el" href="classFEFaceValues.html">FEFaceValues</a> or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a>), it is the mapped surface element times the weight of the quadrature point.</p>
<p>You can think of the quantity returned by this function as the volume or surface element <img class="formulaInl" alt="$dx, ds$" src="form_741.png"/> in the integral that we implement here by quadrature.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_JxW_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a7371618d5977d28dfe82c81fbac29c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7371618d5977d28dfe82c81fbac29c0f">&#9670;&nbsp;</a></span>get_JxW_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_JxW_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW()</a>. </p>

</div>
</div>
<a id="a7a66566d1b429d37ebe9347e7e1f1877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a66566d1b429d37ebe9347e7e1f1877">&#9670;&nbsp;</a></span>jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the Jacobian of the transformation at the specified quadrature point, i.e. <img class="formulaInl" alt="$J_{ij}=dx_i/d\hat x_j$" src="form_742.png"/></p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a581eaad30b2ad577a7a5e0c500581364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581eaad30b2ad577a7a5e0c500581364">&#9670;&nbsp;</a></span>get_jacobians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1,dim,spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by <a class="el" href="classFEValuesBase.html#a7a66566d1b429d37ebe9347e7e1f1877">jacobian()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a91b1e5bd1176c3a8720dfdb1c09a4576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b1e5bd1176c3a8720dfdb1c09a4576">&#9670;&nbsp;</a></span>jacobian_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;2,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the second derivative of the transformation from unit to real cell, i.e. the first derivative of the Jacobian, at the specified quadrature point, i.e. <img class="formulaInl" alt="$G_{ijk}=dJ_{jk}/d\hat x_i$" src="form_743.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a1991ee62632076743edb81fb763b0abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1991ee62632076743edb81fb763b0abd">&#9670;&nbsp;</a></span>get_jacobian_grads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;2,dim,spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_grads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_grads().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a906c5afbaec52697c97e98c3f8443c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906c5afbaec52697c97e98c3f8443c74">&#9670;&nbsp;</a></span>jacobian_pushed_forward_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;3,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_pushed_forward_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the second derivative of the transformation from unit to real cell, i.e. the first derivative of the Jacobian, at the specified quadrature point, pushed forward to the real cell coordinates, i.e. <img class="formulaInl" alt="$G_{ijk}=dJ_{iJ}/d\hat x_K (J_{jJ})^{-1} (J_{kK})^{-1}$" src="form_744.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ae119e9bd1cd65969c0b8a776e77d29ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae119e9bd1cd65969c0b8a776e77d29ed">&#9670;&nbsp;</a></span>get_jacobian_pushed_forward_grads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;3,spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_pushed_forward_grads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_pushed_forward_grads().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a53133fb9a5597549bf6da6ecb234616d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53133fb9a5597549bf6da6ecb234616d">&#9670;&nbsp;</a></span>jacobian_2nd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;3,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the third derivative of the transformation from unit to real cell, i.e. the second derivative of the Jacobian, at the specified quadrature point, i.e. <img class="formulaInl" alt="$G_{ijkl}=\frac{d^2J_{ij}}{d\hat x_k d\hat x_l}$" src="form_745.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a0e7cc2a9cb7fba17e86aef3de3195fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7cc2a9cb7fba17e86aef3de3195fe7">&#9670;&nbsp;</a></span>get_jacobian_2nd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;3,dim,spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_2nd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_2nd_derivatives().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a0bd32cadb5596e057774e50407b0207a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd32cadb5596e057774e50407b0207a">&#9670;&nbsp;</a></span>jacobian_pushed_forward_2nd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;4,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_pushed_forward_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the third derivative of the transformation from unit to real cell, i.e. the second derivative of the Jacobian, at the specified quadrature point, pushed forward to the real cell coordinates, i.e. <img class="formulaInl" alt="$G_{ijkl}=\frac{d^2J_{iJ}}{d\hat x_K d\hat x_L} (J_{jJ})^{-1} (J_{kK})^{-1}(J_{lL})^{-1}$" src="form_746.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a6d5325e97f29cee53bff240dbcd077cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5325e97f29cee53bff240dbcd077cd">&#9670;&nbsp;</a></span>get_jacobian_pushed_forward_2nd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;4,spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_pushed_forward_2nd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_pushed_forward_2nd_derivatives().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a9b7c9dba799bbfa62304d77f68e3652a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7c9dba799bbfa62304d77f68e3652a">&#9670;&nbsp;</a></span>jacobian_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;4,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the fourth derivative of the transformation from unit to real cell, i.e. the third derivative of the Jacobian, at the specified quadrature point, i.e. <img class="formulaInl" alt="$G_{ijklm}=\frac{d^2J_{ij}}{d\hat x_k d\hat x_l d\hat x_m}$" src="form_747.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ab0a1a2eaa1ceebcead8153193e621e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a1a2eaa1ceebcead8153193e621e43">&#9670;&nbsp;</a></span>get_jacobian_3rd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;4,dim,spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_3rd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_3rd_derivatives().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a1cf1d14e92d838b8b4eebd3e609ec905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf1d14e92d838b8b4eebd3e609ec905">&#9670;&nbsp;</a></span>jacobian_pushed_forward_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;5,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_pushed_forward_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the fourth derivative of the transformation from unit to real cell, i.e. the third derivative of the Jacobian, at the specified quadrature point, pushed forward to the real cell coordinates, i.e. <img class="formulaInl" alt="$G_{ijklm}=\frac{d^3J_{iJ}}{d\hat x_K d\hat x_L d\hat x_M} (J_{jJ})^{-1} (J_{kK})^{-1} (J_{lL})^{-1} (J_{mM})^{-1}$" src="form_748.png"/>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ab7314862c9fe73c3904d541a15152a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7314862c9fe73c3904d541a15152a46">&#9670;&nbsp;</a></span>get_jacobian_pushed_forward_3rd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;5,spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_pushed_forward_3rd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_pushed_forward_3rd_derivatives().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a1a5962dd60e1d9fd85564350ca8e530d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5962dd60e1d9fd85564350ca8e530d">&#9670;&nbsp;</a></span>inverse_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1,spacedim,dim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::inverse_jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the inverse Jacobian of the transformation at the specified quadrature point, i.e. <img class="formulaInl" alt="$J_{ij}=d\hat x_i/dx_j$" src="form_749.png"/></p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_inverse_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a6c418078ee9299121efdb069d9e43a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c418078ee9299121efdb069d9e43a0f">&#9670;&nbsp;</a></span>get_inverse_jacobians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1,spacedim,dim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_inverse_jacobians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by <a class="el" href="classFEValuesBase.html#a1a5962dd60e1d9fd85564350ca8e530d">inverse_jacobian()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_inverse_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a8fd4fac1ac908ea671c96ef9ccccc81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd4fac1ac908ea671c96ef9ccccc81f">&#9670;&nbsp;</a></span>normal_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a face, return the outward normal vector to the cell at the <code>i</code>th quadrature point.</p>
<p>For a cell of codimension one, return the normal vector. There are of course two normal directions to a manifold in that case, and this function returns the "up" direction as induced by the numbering of the vertices.</p>
<p>The length of the vector is normalized to one.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_normal_vectors</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="af690a5a25a9517f7b3ae211b11f9b7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af690a5a25a9517f7b3ae211b11f9b7cb">&#9670;&nbsp;</a></span>get_all_normal_vectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_all_normal_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the normal vectors at the quadrature points. For a face, these are the outward normal vectors to the cell. For a cell of codimension one, the orientation is given by the numbering of vertices.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_normal_vectors</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information.</dd>
<dd>
This function should really be named <a class="el" href="classFEValuesBase.html#a16490a59a0207bb018a64c393bd6b961">get_normal_vectors()</a>, but this function already exists with a different return type that returns a vector of <a class="el" href="classPoint.html">Point</a> objects, rather than a vector of <a class="el" href="classTensor.html">Tensor</a> objects. This is a historical accident, but can not be fixed in a backward compatible style. That said, the <a class="el" href="classFEValuesBase.html#a16490a59a0207bb018a64c393bd6b961">get_normal_vectors()</a> function is now deprecated, will be removed in the next version, and the current function will then be renamed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03374">3374</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a16490a59a0207bb018a64c393bd6b961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16490a59a0207bb018a64c393bd6b961">&#9670;&nbsp;</a></span>get_normal_vectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_normal_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the normal vectors at the quadrature points as a vector of <a class="el" href="classPoint.html">Point</a> objects. This function is deprecated because normal vectors are correctly represented by rank-1 <a class="el" href="classTensor.html">Tensor</a> objects, not <a class="el" href="classPoint.html">Point</a> objects. Use <a class="el" href="classFEValuesBase.html#af690a5a25a9517f7b3ae211b11f9b7cb">get_all_normal_vectors()</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_normal_vectors</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03385">3385</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aa8ac6f931ae9bf4321d0c12271ffeba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ac6f931ae9bf4321d0c12271ffeba1">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a>&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform a set of vectors, one for each quadrature point. The <code>mapping</code> can be any of the ones defined in MappingType.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use the various <a class="el" href="classMapping.html#a3ce74638006ce574195c55a69aa48d79">Mapping::transform()</a> functions instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03403">3403</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="acb2e7a5b351659b96ec7098566171d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2e7a5b351659b96ec7098566171d15">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a particular scalar component of the possibly vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a id="a1df920e7dfa235492a3d4c3b9f974703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df920e7dfa235492a3d4c3b9f974703">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a set of <code>dim</code> scalar components (i.e. a vector) of the vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a id="a6861b7033c01434829ff37114b7c8c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6861b7033c01434829ff37114b7c8c7c">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const FEValuesViews::SymmetricTensor&lt;2,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a set of <code>(dim*dim + dim)/2</code> scalar components (i.e. a symmetric 2nd order tensor) of the vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a id="a0aa8be17963dbb8be9ba7fedcf1c6646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa8be17963dbb8be9ba7fedcf1c6646">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const FEValuesViews::Tensor&lt;2,dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a set of <code>(dim*dim)</code> scalar components (i.e. a 2nd order tensor) of the vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a id="a4af6380946790416bf9476050709662a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af6380946790416bf9476050709662a">&#9670;&nbsp;</a></span>get_mapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_mapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant reference to the selected mapping object. </p>

</div>
</div>
<a id="ac036b6304c3dbf98eabb14fd390fe1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac036b6304c3dbf98eabb14fd390fe1be">&#9670;&nbsp;</a></span>get_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim,spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_fe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant reference to the selected finite element object. </p>

</div>
</div>
<a id="a55b258a1619829f7ec03a184ffb8e556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b258a1619829f7ec03a184ffb8e556">&#9670;&nbsp;</a></span>get_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the update flags set for this object. </p>

</div>
</div>
<a id="a9d3a1c53c139e2553b672de682d6233e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3a1c53c139e2553b672de682d6233e">&#9670;&nbsp;</a></span>get_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a triangulation iterator to the current cell. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03365">3365</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a808af56bde1d82893b88875dc651e749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808af56bde1d82893b88875dc651e749">&#9670;&nbsp;</a></span>get_cell_similarity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_cell_similarity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the relation of the current cell to the previous cell. This allows re-use of some cell data (like local matrices for equations with constant coefficients) if the result is <code><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13a4f8507015c458575753e0a45e0c3544a">CellSimilarity::translation</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03571">3571</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a821f21ed0d993cae6df69f41d99f68a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821f21ed0d993cae6df69f41d99f68a2">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03416">3416</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aaf01126d2e3b926fecbaf122357add53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf01126d2e3b926fecbaf122357add53">&#9670;&nbsp;</a></span>invalidate_present_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::invalidate_present_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that is connected to the triangulation in order to reset the stored 'present_cell' iterator to an invalid one whenever the triangulation is changed and the iterator consequently becomes invalid. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03454">3454</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aed652da6ec16e368e27da4085b4281bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed652da6ec16e368e27da4085b4281bb">&#9670;&nbsp;</a></span>maybe_invalidate_previous_present_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::maybe_invalidate_previous_present_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called by the various reinit() functions in derived classes. Given the cell indicated by the argument, test whether we have to throw away the previously stored present_cell argument because it would require us to compare cells from different triangulations. In checking all this, also make sure that we have tria_listener connected to the triangulation to which we will set present_cell right after calling this function. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03472">3472</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aa1352ba7f04525e175d2c6fa552a1c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1352ba7f04525e175d2c6fa552a1c6a">&#9670;&nbsp;</a></span>compute_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::compute_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize some update flags. Called from the <code>initialize</code> functions of derived classes, which are in turn called from their constructors.</p>
<p>Basically, this function finds out using the finite element and mapping object already stored which flags need to be set to compute everything the user wants, as expressed through the flags passed as argument. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03436">3436</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a5c38a7d7c3a6b384ad5b46f38248524d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c38a7d7c3a6b384ad5b46f38248524d">&#9670;&nbsp;</a></span>check_cell_similarity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::check_cell_similarity </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that checks whether the new cell is similar to the one previously used. Then, a significant amount of the data can be reused, e.g. the derivatives of the basis functions in real space, shape_grad. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03517">3517</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a48091346190d2c2c562bca0b5d6e73b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48091346190d2c2c562bca0b5d6e73b7">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValuesBase.html">FEValuesBase</a>&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. Since objects of this class are not copyable, we make it private, and also do not implement it. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="abd66d1380ef2e58a1e433bc1626c324e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd66d1380ef2e58a1e433bc1626c324e">&#9670;&nbsp;</a></span>FEValuesViews::Scalar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the view classes friends of this class, since they access internal data. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02757">2757</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afd889a38bbce8ea33d46d152f14abdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd889a38bbce8ea33d46d152f14abdd3">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension in which this object operates. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l01442">1442</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a6541820cb52f78a4d43de18be0352002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6541820cb52f78a4d43de18be0352002">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension of the space in which this object operates. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l01447">1447</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a807c3049bfe81743fc0f237dfc2fbdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807c3049bfe81743fc0f237dfc2fbdea">&#9670;&nbsp;</a></span>n_quadrature_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::n_quadrature_points</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of quadrature points. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l01452">1452</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a5b264d5b2fb6615f5dea7a21135ed1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b264d5b2fb6615f5dea7a21135ed1a5">&#9670;&nbsp;</a></span>dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dofs_per_cell</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of shape functions per cell. If we use this base class to evaluate a finite element on faces of cells, this is still the number of degrees of freedom per cell, not per face. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l01459">1459</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="acf87f79b7e82e60650bc9227deb6aeb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf87f79b7e82e60650bc9227deb6aeb9">&#9670;&nbsp;</a></span>present_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const CellIteratorBase&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::present_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the cell selected last time the reinit() function was called. This is necessary for the <code>get_function_*</code> functions as well as the functions of same name in the extractor classes. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02620">2620</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="aa7274f2ea9bbe0ea61bd983c5746ffef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7274f2ea9bbe0ea61bd983c5746ffef">&#9670;&nbsp;</a></span>tria_listener_refinement</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::tria_listener_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A signal connection we use to ensure we get informed whenever the triangulation changes by refinement. We need to know about that because it invalidates all cell iterators and, as part of that, the 'present_cell' iterator we keep around between subsequent calls to reinit() in order to compute the cell similarity. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02636">2636</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a2f853782c9ba1f6c4093f64ede145253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f853782c9ba1f6c4093f64ede145253">&#9670;&nbsp;</a></span>tria_listener_mesh_transform</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::tria_listener_mesh_transform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A signal connection we use to ensure we get informed whenever the triangulation changes by mesh transformations. We need to know about that because it invalidates all cell iterators and, as part of that, the 'present_cell' iterator we keep around between subsequent calls to reinit() in order to compute the cell similarity. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02645">2645</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a8fb1d5f367902df6b2b598d9da1b0398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb1d5f367902df6b2b598d9da1b0398">&#9670;&nbsp;</a></span>mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;,<a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim,spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the mapping object associated with this <a class="el" href="classFEValues.html">FEValues</a> object. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02669">2669</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a7cfe490ab7d47719d8624cf8074316ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfe490ab7d47719d8624cf8074316ff">&#9670;&nbsp;</a></span>mapping_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;typename <a class="el" href="classMapping.html">Mapping</a>&lt;dim,spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the internal data object of mapping, obtained from <a class="el" href="classMapping.html#a32ec2960edbcf550baf4eade254e941f">Mapping::get_data()</a>, <a class="el" href="classMapping.html#a8e679601d9927b8096e88b64acd00920">Mapping::get_face_data()</a>, or <a class="el" href="classMapping.html#a2b696ccfd041ad95801bf2c4152f3c96">Mapping::get_subface_data()</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02676">2676</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="aa9f83245158720fa8d386ad44608d77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f83245158720fa8d386ad44608d77b">&#9670;&nbsp;</a></span>mapping_output</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt;dim, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping_output</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An object into which the <a class="el" href="classMapping.html#a66184bd60355f99a7c549552c9365d52">Mapping::fill_fe_values()</a> and similar functions place their output. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02682">2682</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="aeb05cc9511ff887438f3e6cf036a3134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb05cc9511ff887438f3e6cf036a3134">&#9670;&nbsp;</a></span>fe</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim,spacedim&gt;,<a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim,spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the finite element object associated with this <a class="el" href="classFEValues.html">FEValues</a> object. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02689">2689</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a9ea8d393398e95d8a421c1513c7c8454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea8d393398e95d8a421c1513c7c8454">&#9670;&nbsp;</a></span>fe_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim,spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the internal data object of finite element, obtained from <a class="el" href="classFiniteElement.html#af02bc483fe9b867cc9643501bd586811">FiniteElement::get_data()</a>, <a class="el" href="classMapping.html#a8e679601d9927b8096e88b64acd00920">Mapping::get_face_data()</a>, or <a class="el" href="classFiniteElement.html#a43b7aabb6513cfc15a7db7242a5eaa55">FiniteElement::get_subface_data()</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02696">2696</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a3931ad13b4e3b9f87a49e81e74a40443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3931ad13b4e3b9f87a49e81e74a40443">&#9670;&nbsp;</a></span>finite_element_output</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1FEValues_1_1FiniteElementRelatedData.html">internal::FEValues::FiniteElementRelatedData</a>&lt;dim, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::finite_element_output</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An object into which the <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a> and similar functions place their output. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02702">2702</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a63ed91bcc8004390e372704d63177162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ed91bcc8004390e372704d63177162">&#9670;&nbsp;</a></span>update_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::update_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Original update flags handed to the constructor of <a class="el" href="classFEValues.html">FEValues</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02708">2708</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a096d4ea9edea6618e23f5f13ab40784c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096d4ea9edea6618e23f5f13ab40784c">&#9670;&nbsp;</a></span>cell_similarity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::cell_similarity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enum variable that can store different states of the current cell in comparison to the previously visited cell. If wanted, additional states can be checked here and used in one of the methods used during reinit. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02725">2725</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a7cf406ac2334ec378cdbaed4b836cc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf406ac2334ec378cdbaed4b836cc45">&#9670;&nbsp;</a></span>fe_values_views_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="structinternal_1_1FEValuesViews_1_1Cache.html">internal::FEValuesViews::Cache</a>&lt;dim,spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe_values_views_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A cache for all possible <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> objects. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02751">2751</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/fe/<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a></li>
<li>deal.II/fe/<a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/fe/<a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
