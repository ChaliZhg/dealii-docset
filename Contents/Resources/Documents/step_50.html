<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-50 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-50 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeLaplaceProblemcodeclasstemplate">The <code>LaplaceProblem</code> class template</a>
        <li><a href="#Nonconstantcoefficients">Nonconstant coefficients</a>
        <li><a href="#ThecodeLaplaceProblemcodeclassimplementation">The <code>LaplaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#LaplaceProblemLaplaceProblem">LaplaceProblem::LaplaceProblem</a>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#Postprocessing">Postprocessing</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibleextensions"> Possible extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program has evolved from a version originally written by Guido Kanschat in 2003. It has undergone significant revisions by B&auml;rbel Janssen, Guido Kanschat and Wolfgang Bangerth in 2009 and 2010 to demonstrate multigrid algorithms on adaptively refined meshes. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This example shows the basic usage of the multilevel functions in deal.II. It solves the same problem as used in <a class="el" href="step_6.html">step-6</a>, but demonstrating the things one has to provide when using multigrid as a preconditioner. In particular, this requires that we define a hierarchy of levels, provide transfer operators from one level to the next and back, and provide representations of the Laplace operator on each level.</p>
<p>In order to allow sufficient flexibility in conjunction with systems of differential equations and block preconditioners, quite a few different objects have to be created before starting the multilevel method, although most of what needs to be done is provided by deal.II itself. These are </p><ul>
<li>
An the object handling transfer between grids; we use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class for this that does almost all of the work inside the library. </li>
<li>
The solver on the coarsest level; here, we use <a class="el" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder</a>. </li>
<li>
The smoother on all other levels, which in our case will be the <a class="el" href="classMGSmootherRelaxation.html">MGSmootherRelaxation</a> class using SOR as the underlying method </li>
<li>
And <a class="el" href="classmg_1_1Matrix.html">mg::Matrix</a>, a class having a special level multiplication, i.e. we basically store one matrix per grid level and allow multiplication with it. </li>
</ul>
<p>Most of these objects will only be needed inside the function that actually solves the linear system. There, these objects are combined in an object of type <a class="el" href="classMultigrid.html">Multigrid</a>, containing the implementation of the V-cycle, which is in turn used by the preconditioner <a class="el" href="classPreconditionMG.html">PreconditionMG</a>, ready for plug-in into a linear solver of the LAC library.</p>
<p>The multilevel method in deal.II follows in many respects the outlines of the various publications by James Bramble, Joseph Pasciak and Jinchao Xu (i.e. the "BPX" framework). In order to understand many of the options, a rough familiarity with their work is quite helpful.</p>
<p>However, in comparison to this framework, the implementation in deal.II has to take into account the fact that we want to solve linear systems on adaptively refined meshes. This leads to the complication that it isn't quite as clear any more what exactly a "level" in a multilevel hierarchy of a mesh is. The following image shows what we consider to be a "level":</p>
<div class="image">
<img src="hanging_nodes.png" alt="hanging_nodes.png"/>
</div>
<p>In other words, the fine level in this mesh consists only of the degrees of freedom that are defined on the refined cells, but does not extend to that part of the domain that is not refined. While this guarantees that the overall effort grows as <img class="formulaInl" alt="${\cal O}(N)$" src="form_106.png"/> as necessary for optimal multigrid complexity, it leads to problems when defining where to smooth and what boundary conditions to pose for the operators defined on individual levels if the level boundary is not an external boundary. These questions are discussed in detail in the <a class="el" href="DEALGlossary.html#mg_paper">Multigrid paper by Janssen and Kanschat</a> that describes the implementation in deal.II.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is exactly the same as in <a class="el" href="step_6.html">step-6</a>, the only difference being the solver we use here. You may want to look there for a definition of what we solve, right hand side and boundary conditions. Obviously, the program would also work if we changed the geometry and other pieces of data that defines this particular problem.</p>
<p>The things that are new are all those parts that concern the multigrid. In particular, this includes the following members of the main class:</p><ul>
<li><code>LaplaceProblem::mg_dof_handler</code></li>
<li><code>LaplaceProblem::mg_sparsity</code></li>
<li><code>LaplaceProblem::mg_matrices</code></li>
<li><code>LaplaceProblem::mg_interface_matrices_up</code></li>
<li><code>LaplaceProblem::assemble_multigrid ()</code></li>
<li><code>LaplaceProblem::solve ()</code> Take a look at these functions. <a class="anchor" id="CommProg"></a> <h1>The commented program</h1>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>: This a work in progress example of parallel geometric multigrid. Some parts are still in heavy development.</dd></dl>
<p>This program is a parallel version of <a class="el" href="step_16.html">step-16</a> with a slightly different problem setup.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Again, the first few include files are already known, so we won't comment on them:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_gmres.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_constrained_dofs.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/multigrid.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_transfer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_coarse.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_smoother.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_matrix.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/generic_linear_algebra.h&gt;</span></div></div><!-- fragment --><p>#define USE_PETSC_LA PETSc is not quite supported yet</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LA</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">  <span class="keyword">using namespace </span>::<a class="code" href="namespaceLinearAlgebraPETSc.html">LinearAlgebraPETSc</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="keyword">using namespace </span>::<a class="code" href="namespaceLinearAlgebraTrilinos.html">LinearAlgebraTrilinos</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step50</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceProblem</code> class template</h3>
<p>This main class is very similar to <a class="el" href="step_16.html">step-16</a>, except that we are storing a parallel <a class="el" href="classTriangulation.html">Triangulation</a> and parallel versions of matrices and vectors.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg);</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_multigrid ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> refine_grid ();</div><div class="line">  <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a>                        pcout;</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    mg_dof_handler;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> LA::MPI::SparseMatrix matrix_t;</div><div class="line">  <span class="keyword">typedef</span> LA::MPI::Vector vector_t;</div><div class="line"></div><div class="line">  matrix_t system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_set;</div><div class="line"></div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line"></div><div class="line">  vector_t       solution;</div><div class="line">  vector_t       system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div></div><!-- fragment --><p>Finally we are storing the various parallel multigrid matrices. Our problem is self-adjoint, so the interface matrices are the transpose of each other, so we only need to compute/store them once.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;matrix_t&gt;</a> mg_matrices;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;matrix_t&gt;</a> mg_interface_matrices;</div></div><!-- fragment --><div class="fragment"><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                    mg_constrained_dofs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Nonconstantcoefficients"></a> </p><h3>Nonconstant coefficients</h3>
<p>The implementation of nonconstant coefficients is copied verbatim from <a class="el" href="step_5.html">step-5</a> and <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Coefficient () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#afb9d62ccc1281bc38335c91769d8642d">value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#afc0acd3155a0c854dee816a096d88165">value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                           std::vector&lt;double&gt;            &amp;values,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component = 0) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>() &lt; 0.5*0.5)</div><div class="line">    <span class="keywordflow">return</span> 5;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                   std::vector&lt;double&gt;            &amp;values,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.size();</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.size() == n_points,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.size(), n_points));</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component == 0,</div><div class="line">          <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_points; ++i)</div><div class="line">    values[i] = Coefficient&lt;dim&gt;::value (points[i]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclassimplementation"></a> </p><h3>The <code>LaplaceProblem</code> class implementation</h3>
<p><a class="anchor" id="LaplaceProblemLaplaceProblem"></a> </p><h4>LaplaceProblem::LaplaceProblem</h4>
<p>The constructor is left mostly unchanged. We take the polynomial degree of the finite elements to be used as a constructor argument and store it in a member variable.</p>
<p>By convention, all adaptively refined triangulations in deal.II never change by more than one level across a face between cells. For our multigrid algorithms, however, we need a slightly stricter guarantee, namely that the mesh also does not change by more than refinement level across vertices that might connect two cells. In other words, we must prevent the following situation:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p>This is achieved by passing the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">Triangulation::limit_level_difference_at_vertices</a> flag to the constructor of the triangulation class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  :</div><div class="line">  pcout (<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">         (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD)</div><div class="line">          == 0)),</div><div class="line">  triangulation (MPI_COMM_WORLD,<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::</div><div class="line">                 limit_level_difference_at_vertices,</div><div class="line">                 <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::construct_multigrid_hierarchy),</div><div class="line">  fe (degree),</div><div class="line">  mg_dof_handler (triangulation),</div><div class="line">  degree(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>The following function extends what the corresponding one in <a class="el" href="step_6.html">step-6</a> did. The top part, apart from the additional output, does the same:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  mg_dof_handler.distribute_dofs (fe);</div><div class="line">  mg_dof_handler.distribute_mg_dofs (fe);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (mg_dof_handler,</div><div class="line">                                           locally_relevant_set);</div><div class="line"></div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(mg_dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(mg_dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div></div><!-- fragment --><p>But it starts to be a wee bit different here, although this still doesn't have anything to do with multigrid methods. <a class="el" href="step_6.html">step-6</a> took care of boundary values and hanging nodes in a separate step after assembling the global matrix from local contributions. This works, but the same can be done in a slightly simpler way if we already take care of these constraints at the time of copying local contributions into the global matrix. To this end, we here do not just compute the constraints do to hanging nodes, but also due to zero boundary conditions. We will use this set of constraints later on to help us copy local contributions correctly into the global linear system right away, without the need for a later clean-up stage:</p>
<div class="fragment"><div class="line">constraints.reinit (locally_relevant_set);</div><div class="line"><a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (mg_dof_handler, constraints);</div><div class="line"></div><div class="line">std::set&lt;types::boundary_id&gt;         dirichlet_boundary_ids;</div><div class="line"><span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>      dirichlet_boundary;</div><div class="line"><a class="code" href="classConstantFunction.html">ConstantFunction&lt;dim&gt;</a>                    homogeneous_dirichlet_bc (1.0);</div><div class="line">dirichlet_boundary_ids.insert(0);</div><div class="line">dirichlet_boundary[0] = &amp;homogeneous_dirichlet_bc;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (mg_dof_handler,</div><div class="line">                                          dirichlet_boundary,</div><div class="line">                                          constraints);</div><div class="line">constraints.close ();</div><div class="line"></div><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(mg_dof_handler.n_dofs(), mg_dof_handler.n_dofs());</div><div class="line"><a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (mg_dof_handler, dsp, constraints);</div><div class="line">system_matrix.reinit (mg_dof_handler.locally_owned_dofs(), dsp, MPI_COMM_WORLD, <span class="keyword">true</span>);</div></div><!-- fragment --><p>The multigrid constraints have to be initialized. They need to know about the boundary values as well, so we pass the <code>dirichlet_boundary</code> here as well.</p>
<div class="fragment"><div class="line">mg_constrained_dofs.clear();</div><div class="line">mg_constrained_dofs.initialize(mg_dof_handler);</div><div class="line">mg_constrained_dofs.make_zero_boundary_constraints(mg_dof_handler, dirichlet_boundary_ids);</div></div><!-- fragment --><p>Now for the things that concern the multigrid data structures. First, we resize the multilevel objects to hold matrices and sparsity patterns for every level. The coarse level is zero (this is mandatory right now but may change in a future revision). Note that these functions take a complete, inclusive range here (not a starting index and size), so the finest level is <code>n_levels-1</code>. We first have to resize the container holding the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> classes, since they have to release their <a class="el" href="classSparsityPattern.html">SparsityPattern</a> before the can be destroyed upon resizing.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line"></div><div class="line">mg_interface_matrices.<a class="code" href="classMGLevelObject.html#aa5f20ef946fe83c93356c792e3f79b1c">resize</a>(0, n_levels-1);</div><div class="line">mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a893309bf2277dd46c003787f29de59e4">clear_elements</a> ();</div><div class="line">mg_matrices.resize(0, n_levels-1);</div><div class="line">mg_matrices.clear_elements ();</div></div><!-- fragment --><p>Now, we have to provide a matrix on each level. To this end, we first use the <a class="el" href="namespaceMGTools.html#a55f23cddd7838e62ea54cae140fe54e9">MGTools::make_sparsity_pattern</a> function to first generate a preliminary compressed sparsity pattern on each level (see the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module for more information on this topic) and then copy it over to the one we really want. The next step is to initialize both kinds of level matrices with these sparsity patterns.</p>
<p>It may be worth pointing out that the interface matrices only have entries for degrees of freedom that sit at or next to the interface between coarser and finer levels of the mesh. They are therefore even sparser than the matrices on the individual levels of our multigrid hierarchy. If we were more concerned about memory usage (and possibly the speed with which we can multiply with these matrices), we should use separate and different sparsity patterns for these two kinds of matrices.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;n_levels; ++level)</div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(mg_dof_handler.n_dofs(level),</div><div class="line">                                 mg_dof_handler.n_dofs(level));</div><div class="line">      <a class="code" href="namespaceMGTools.html#a55f23cddd7838e62ea54cae140fe54e9">MGTools::make_sparsity_pattern</a>(mg_dof_handler, dsp, level);</div><div class="line"></div><div class="line">      mg_matrices[level].reinit(mg_dof_handler.locally_owned_mg_dofs(level),</div><div class="line">                                mg_dof_handler.locally_owned_mg_dofs(level),</div><div class="line">                                dsp,</div><div class="line">                                MPI_COMM_WORLD, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      mg_interface_matrices[level].reinit(mg_dof_handler.locally_owned_mg_dofs(level),</div><div class="line">                                          mg_dof_handler.locally_owned_mg_dofs(level),</div><div class="line">                                          dsp,</div><div class="line">                                          MPI_COMM_WORLD, <span class="keyword">true</span>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4>LaplaceProblem::assemble_system</h4>
<p>The following function assembles the linear system on the finest level of the mesh. It is almost exactly the same as in <a class="el" href="step_6.html">step-6</a>, with the exception that we don't eliminate hanging nodes and boundary values after assembling, but while copying local contributions into the global matrix. This is not only simpler but also more efficient for large problems.</p>
<p>This latter trick is something that only found its way into deal.II over time and wasn't used in the initial version of this tutorial program. There is, however, a discussion of this function in the introduction of <a class="el" href="step_27.html">step-27</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(degree+1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div><div class="line">  std::vector&lt;double&gt;    coefficient_values (n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = mg_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = mg_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">  <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                coefficient_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                cell_matrix(i,j) += (coefficient_values[q_point] *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                              10.0 *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global (cell_matrix, cell_rhs,</div><div class="line">                                                local_dof_indices,</div><div class="line">                                                system_matrix, system_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">  system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#ad581edc4d3b86a88c4277117c4fae57a">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_multigrid"></a> </p><h4>LaplaceProblem::assemble_multigrid</h4>
<p>The next function is the one that builds the linear operators (matrices) that define the multigrid method on each level of the mesh. The integration core is the same as above, but the loop below will go over all existing cells instead of just the active ones, and the results must be entered into the correct matrix. Note also that since we only do multilevel preconditioning, no right-hand side needs to be assembled here.</p>
<p>Before we go there, however, we have to take care of a significant amount of book keeping:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid ()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(1+degree);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div><div class="line">  std::vector&lt;double&gt;    coefficient_values (n_q_points);</div></div><!-- fragment --><p>Next a few things that are specific to building the multigrid data structures (since we only need them in the current function, rather than also elsewhere, we build them here instead of the <code>setup_system</code> function). Some of the following may be a bit obscure if you're not familiar with the algorithm actually implemented in deal.II to support multilevel algorithms on adaptive meshes; if some of the things below seem strange, take a look at the <a class="el" href="DEALGlossary.html#mg_paper">mg_paper</a>.</p>
<p>Our first job is to identify those degrees of freedom on each level that are located on interfaces between adaptively refined levels, and those that lie on the interface but also on the exterior boundary of the domain. The <code><a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a></code> already computed the information for us when we called initialize in</p>
<p><code>setup_system()</code>. of type <a class="el" href="classIndexSet.html">IndexSet</a> on each level (get_refinement_edge_indices(),</p>
<p>The indices just identified will later be used to decide where the assembled value has to be added into on each level. On the other hand, we also have to impose zero boundary conditions on the external boundary of each level. But this the <code><a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a></code> knows it. So we simply ask for them by calling <code>get_boundary_indices ()</code>. The third step is to construct constraints on all those degrees of freedom: their value should be zero after each application of the level operators. To this end, we construct <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> objects for each level, and add to each of these constraints for each degree of freedom. Due to the way the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> stores its data, the function to add a constraint on a single degree of freedom and force it to be zero is called <a class="el" href="classConstraintMatrix.html#a24eb022f65797389badbb6d21da5b708">ConstraintMatrix::add_line()</a>; doing so for several degrees of freedom at once can be done using <a class="el" href="classConstraintMatrix.html#ab97f0436882283ec56368f4b8a9bf85e">ConstraintMatrix::add_lines()</a>:</p>
<div class="fragment"><div class="line">std::vector&lt;ConstraintMatrix&gt; boundary_constraints (triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>());</div><div class="line"><a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> empty_constraints;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>(); ++level)</div><div class="line">  {</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> dofset;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a311c1d316f9da52567319c3f12e4e054">DoFTools::extract_locally_relevant_level_dofs</a> (mg_dof_handler, level, dofset);</div><div class="line">    boundary_constraints[level].reinit(dofset);</div><div class="line">    boundary_constraints[level].add_lines (mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">    boundary_constraints[level].add_lines (mg_constrained_dofs.get_boundary_indices(level));</div><div class="line"></div><div class="line">    boundary_constraints[level].close ();</div><div class="line">  }</div></div><!-- fragment --><p>Now that we're done with most of our preliminaries, let's start the integration loop. It looks mostly like the loop in <code>assemble_system</code>, with two exceptions: (i) we don't need a right hand side, and more significantly (ii) we don't just loop over all active cells, but in fact all cells, active or not. Consequently, the correct iterator to use is <a class="el" href="group__Iterators.html#ga5cda850f6fb2dd1f2e473bac5cb1ed2a">DoFHandler::cell_iterator</a> rather than <a class="el" href="group__Iterators.html#ga37f5b9b4b270a8cea857dbdbd9218562">DoFHandler::active_cell_iterator</a>. Let's go about it:</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> cell = mg_dof_handler.<a class="code" href="classDoFHandler.html#a6af050921f3f1c3f2e6e20679a07f49b">begin</a>(),</div><div class="line">                                        endc = mg_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;level_subdomain_id()==triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>())</div><div class="line">    {</div><div class="line">      cell_matrix = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">      coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                              coefficient_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            cell_matrix(i,j) += (coefficient_values[q_point] *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div></div><!-- fragment --><p>The rest of the assembly is again slightly different. This starts with a gotcha that is easily forgotten: The indices of global degrees of freedom we want here are the ones for current level, not for the global matrix. We therefore need the function MGDoFAccessorLLget_mg_dof_indices, not MGDoFAccessor::get_dof_indices as used in the assembly of the global system:</p>
<div class="fragment"><div class="line">cell-&gt;get_mg_dof_indices (local_dof_indices);</div></div><!-- fragment --><p>Next, we need to copy local contributions into the level objects. We can do this in the same way as in the global assembly, using a constraint object that takes care of constrained degrees (which here are only boundary nodes, as the individual levels have no hanging node constraints). Note that the <code>boundary_constraints</code> object makes sure that the level matrices contains no contributions from degrees of freedom at the interface between cells of different refinement level.</p>
<div class="fragment"><div class="line">boundary_constraints[cell-&gt;level()]</div><div class="line">.distribute_local_to_global (cell_matrix,</div><div class="line">                             local_dof_indices,</div><div class="line">                             mg_matrices[cell-&gt;level()]);</div></div><!-- fragment --><p>The next step is again slightly more obscure (but explained in the <a class="el" href="DEALGlossary.html#mg_paper">mg_paper</a>): We need the remainder of the operator that we just copied into the <code>mg_matrices</code> object, namely the part on the interface between cells at the current level and cells one level coarser. This matrix exists in two directions: for interior DoFs (index <img class="formulaInl" alt="$i$" src="form_90.png"/>) of the current level to those sitting on the interface (index <img class="formulaInl" alt="$j$" src="form_513.png"/>), and the other way around. Of course, since we have a symmetric operator, one of these matrices is the transpose of the other.</p>
<p>The way we assemble these matrices is as follows: since the are formed from parts of the local contributions, we first delete all those parts of the local contributions that we are not interested in, namely all those elements of the local matrix for which not <img class="formulaInl" alt="$i$" src="form_90.png"/> is an interface DoF and <img class="formulaInl" alt="$j$" src="form_513.png"/> is not. The result is one of the two matrices that we are interested in, and we then copy it into the <code>mg_interface_matrices</code> object. The <code>boundary_interface_constraints</code> object at the same time makes sure that we delete contributions from all degrees of freedom that are not only on the interface but also on the external boundary of the domain.</p>
<p>The last part to remember is how to get the other matrix. Since it is only the transpose, we will later (in the <code>solve()</code> function) be able to just pass the transpose matrix where necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;interface_dofs_on_level</div><div class="line">  = mg_constrained_dofs.get_refinement_edge_indices(cell-&gt;level());</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lvl = cell-&gt;level();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">    <span class="keywordflow">if</span> (interface_dofs_on_level.<a class="code" href="classIndexSet.html#a66c79fc7f17b2eeff0f0fb757e77e0c3">is_element</a>(local_dof_indices[i])   <span class="comment">// at_refinement_edge(i)</span></div><div class="line">        &amp;&amp;</div><div class="line">        !interface_dofs_on_level.<a class="code" href="classIndexSet.html#a66c79fc7f17b2eeff0f0fb757e77e0c3">is_element</a>(local_dof_indices[j])   <span class="comment">// !at_refinement_edge(j)</span></div><div class="line">        &amp;&amp;</div><div class="line">        (</div><div class="line">          (!mg_constrained_dofs.is_boundary_index(lvl, local_dof_indices[i])</div><div class="line">           &amp;&amp;</div><div class="line">           !mg_constrained_dofs.is_boundary_index(lvl, local_dof_indices[j])</div><div class="line">          ) <span class="comment">// ( !boundary(i) &amp;&amp; !boundary(j) )</span></div><div class="line">          ||</div><div class="line">          (</div><div class="line">            mg_constrained_dofs.is_boundary_index(lvl, local_dof_indices[i])</div><div class="line">            &amp;&amp;</div><div class="line">            local_dof_indices[i]==local_dof_indices[j]</div><div class="line">          ) <span class="comment">// ( boundary(i) &amp;&amp; boundary(j) &amp;&amp; i==j )</span></div><div class="line">        )</div><div class="line">       )</div><div class="line">      {</div></div><!-- fragment --><p>do nothing, so add entries to interface matrix</p>
<div class="fragment"><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                cell_matrix(i,j) = 0;</div><div class="line">              }</div><div class="line"></div><div class="line"></div><div class="line">        empty_constraints</div><div class="line">        .distribute_local_to_global (cell_matrix,</div><div class="line">                                     local_dof_indices,</div><div class="line">                                     mg_interface_matrices[cell-&gt;level()]);</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>(); ++i)</div><div class="line">    {</div><div class="line">      mg_matrices[i].compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">      mg_interface_matrices[i].compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>This is the other function that is significantly different in support of the multigrid solver (or, in fact, the preconditioner for which we use the multigrid method).</p>
<p>Let us start out by setting up two of the components of multilevel methods: transfer operators between levels, and a solver on the coarsest level. In finite element methods, the transfer operators are derived from the finite element function spaces involved and can often be computed in a generic way independent of the problem under consideration. In that case, we can use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class that, given the constraints on the global level and an <a class="el" href="classDoFHandler.html">DoFHandler</a> object computes the matrices corresponding to these transfer operators.</p>
<p>The second part of the following lines deals with the coarse grid solver. Since our coarse grid is very coarse indeed, we decide for a direct solver (a <a class="el" href="classHouseholder.html">Householder</a> decomposition of the coarsest level matrix), even if its implementation is not particularly sophisticated. If our coarse mesh had many more cells than the five we have here, something better suited would obviously be necessary here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div><div class="line">{</div></div><!-- fragment --><p>Create the object that deals with the transfer between different refinement levels.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;vector_t&gt;</a> mg_transfer(mg_constrained_dofs);</div></div><!-- fragment --><p>Now the prolongation matrix has to be built.</p>
<div class="fragment"><div class="line">mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a2302c0b6ee91b59d006b21c7d3f00025">build_matrices</a>(mg_dof_handler);</div><div class="line"></div><div class="line">matrix_t &amp;coarse_matrix = mg_matrices[0];</div><div class="line"></div><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> coarse_solver_control (1000, 1e-10, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;vector_t&gt;</a> coarse_solver(coarse_solver_control);</div><div class="line"><a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a> id;</div><div class="line"><a class="code" href="classMGCoarseGridLACIteration.html">MGCoarseGridLACIteration&lt;SolverCG&lt;vector_t&gt;</a>,vector_t&gt; coarse_grid_solver(coarse_solver,</div><div class="line">    coarse_matrix,</div><div class="line">    <span class="keywordtype">id</span>);</div></div><!-- fragment --><p>The next component of a multilevel solver or preconditioner is that we need a smoother on each level. A common choice for this is to use the application of a relaxation method (such as the SOR, Jacobi or Richardson method). The <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a> class provides support for this kind of smoother. Here, we opt for the application of a single SOR iteration. To this end, we define an appropriate <code>typedef</code> and then setup a smoother object.</p>
<p>The last step is to initialize the smoother object with our level matrices and to set some smoothing parameters. The <code>initialize()</code> function can optionally take additional arguments that will be passed to the smoother object on each level. In the current case for the SOR smoother, this could, for example, include a relaxation parameter. However, we here leave these at their default values. The call to <code>set_steps()</code> indicates that we will use two pre- and two post-smoothing steps on each level; to use a variable number of smoother steps on different levels, more options can be set in the constructor call to the <code>mg_smoother</code> object.</p>
<p>The last step results from the fact that we use the SOR method as a smoother - which is not symmetric - but we use the conjugate gradient iteration (which requires a symmetric preconditioner) below, we need to let the multilevel preconditioner make sure that we get a symmetric operator even for nonsymmetric smoothers:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> LA::MPI::PreconditionJacobi Smoother;</div><div class="line"><a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition&lt;matrix_t, Smoother, vector_t&gt;</a> mg_smoother;</div><div class="line">mg_smoother.<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, Smoother::AdditionalData(0.5));</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div></div><!-- fragment --><p>mg_smoother.set_symmetric(false);</p>
<p>The next preparatory step is that we must wrap our level and interface matrices in an object having the required multiplication functions. We will create two objects for the interface objects going from coarse to fine and the other way around; the multigrid algorithm will later use the transpose operator for the latter operation, allowing us to initialize both up and down versions of the operator with the matrices we already built:</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;vector_t&gt;</a> mg_matrix(mg_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;vector_t&gt;</a> mg_interface_up(mg_interface_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;vector_t&gt;</a> mg_interface_down(mg_interface_matrices);</div></div><!-- fragment --><p>Now, we are ready to set up the V-cycle operator and the multilevel preconditioner.</p>
<div class="fragment"><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;vector_t &gt;</a> <a class="code" href="namespacemg.html">mg</a>(mg_dof_handler,</div><div class="line">                        mg_matrix,</div><div class="line">                        coarse_grid_solver,</div><div class="line">                        mg_transfer,</div><div class="line">                        mg_smoother,</div><div class="line">                        mg_smoother);</div></div><!-- fragment --><p>mg.set_debug(6);</p>
<div class="fragment"><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, vector_t, MGTransferPrebuilt&lt;vector_t&gt;</a> &gt;</div><div class="line">preconditioner(mg_dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>With all this together, we can finally get about solving the linear system in the usual way:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control (500, 1e-8*system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>(), <span class="keyword">false</span>);</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;vector_t&gt;</a> solver (solver_control);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<span class="keyword">false</span>)</div><div class="line">  {</div><div class="line">    / *</div></div><!-- fragment --><p>code to optionally compare to Trilinos ML</p>
<div class="fragment"><div class="line">TrilinosWrappers::PreconditionAMG prec;</div><div class="line"></div><div class="line"><a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> Amg_data;</div></div><!-- fragment --><p>Amg_data.constant_modes = constant_modes;</p>
<div class="fragment"><div class="line">Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a> = <span class="keyword">true</span>;</div><div class="line">Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a8bb24e061826fbdfb49aeb24f80e02fd">higher_order_elements</a> = <span class="keyword">true</span>;</div><div class="line">Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a> = 2;</div><div class="line">Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 0.02;</div></div><!-- fragment --><p>Amg_data.symmetric = true;</p>
<div class="fragment"><div class="line">       prec.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a> (system_matrix,</div><div class="line">                        Amg_data);</div><div class="line">       solver.solve (system_matrix, solution, system_rhs, prec);</div><div class="line">      * /</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      solver.solve (system_matrix, solution, system_rhs,</div><div class="line">                    preconditioner);</div><div class="line">    }</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   CG converged in &quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constraints.distribute (solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessing"></a> </p><h4>Postprocessing</h4>
<p>The following two functions postprocess a solution once it is computed. In particular, the first one refines the mesh at the beginning of each cycle while the second one outputs results at the end of each such cycle. The <code>refine_grid()</code> method is almost unchanged from <a class="el" href="step_6.html">step-6</a>: the only substantial difference is that this method uses a distributed grid refinement function instead of a serial one. The <code>output_results()</code> method is quite different since each processor writes only part of the overall graphical output.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid ()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  LA::MPI::Vector temp_solution;</div><div class="line">  temp_solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(locally_relevant_set, MPI_COMM_WORLD);</div><div class="line">  temp_solution = solution;</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (<span class="keyword">static_cast&lt;</span><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>&amp;<span class="keyword">&gt;</span>(mg_dof_handler),</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(degree+1),</div><div class="line">                                      <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                      temp_solution,</div><div class="line">                                      estimated_error_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#a8fe97b1fc8f61b09d6a7c398a8b975ff">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#a8fe97b1fc8f61b09d6a7c398a8b975ff">  refine_and_coarsen_fixed_fraction</a> (triangulation,</div><div class="line">                                     estimated_error_per_cell,</div><div class="line">                                     0.3, 0.0);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  LA::MPI::Vector temp_solution;</div><div class="line">  temp_solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(locally_relevant_set, MPI_COMM_WORLD);</div><div class="line">  temp_solution = solution;</div><div class="line"></div><div class="line"></div><div class="line">  LA::MPI::Vector temp = solution;</div><div class="line">  system_matrix.residual(temp,solution,system_rhs);</div><div class="line">  LA::MPI::Vector res_ghosted = temp_solution;</div><div class="line">  res_ghosted = temp;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (mg_dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (temp_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (res_ghosted, <span class="stringliteral">&quot;res&quot;</span>);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;subdomain.size(); ++i)</div><div class="line">    subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> (0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 5) +</div><div class="line">                                <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="line">                                (triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4) +</div><div class="line">                                <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  std::ofstream output (filename.c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;std::string&gt; filenames;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD); ++i)</div><div class="line">        filenames.push_back (std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 5) +</div><div class="line">                             <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i, 4) +</div><div class="line">                             <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">      <span class="keyword">const</span> std::string</div><div class="line">      pvtu_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                              <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 5) +</div><div class="line">                              <span class="stringliteral">&quot;.pvtu&quot;</span>);</div><div class="line">      std::ofstream pvtu_master (pvtu_master_filename.c_str());</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (pvtu_master, filenames);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string</div><div class="line">      visit_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 5) +</div><div class="line">                               <span class="stringliteral">&quot;.visit&quot;</span>);</div><div class="line">      std::ofstream visit_master (visit_master_filename.c_str());</div><div class="line">      <a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a> (visit_master, filenames);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   wrote &quot;</span> &lt;&lt; pvtu_master_filename &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>Like several of the functions above, this is almost exactly a copy of of the corresponding function in <a class="el" href="step_6.html">step-6</a>. The only difference is the call to <code>assemble_multigrid</code> that takes care of forming the matrices on every level that we need in the multigrid method.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;15; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation);</div><div class="line"></div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (4);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid ();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system ();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; mg_dof_handler.n_dofs()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>(); ++level)</div><div class="line">          pcout &lt;&lt; mg_dof_handler.n_dofs(level)</div><div class="line">                &lt;&lt; (level == triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>()-1</div><div class="line">                    ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line">        assemble_multigrid ();</div><div class="line"></div><div class="line">        solve ();</div><div class="line">        output_results (cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is again the same function as in <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">::Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step50;</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1/ *degree* /);</div><div class="line">      laplace_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">throw</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output that this program generates is, of course, the same as that of <a class="el" href="step_6.html">step-6</a>, so you may see there for more results. On the other hand, since no tutorial program is a good one unless it has at least one colorful picture, here is, again, the solution:</p>
<p>When run, the output of this program is </p><pre>
Cycle 0:
   Number of active cells:       20
   Number of degrees of freedom: 25 (by level: 8, 25)
   7 CG iterations needed to obtain convergence.
Cycle 1:
   Number of active cells:       44
   Number of degrees of freedom: 57 (by level: 8, 25, 48)
   8 CG iterations needed to obtain convergence.
Cycle 2:
   Number of active cells:       92
   Number of degrees of freedom: 117 (by level: 8, 25, 80, 60)
   9 CG iterations needed to obtain convergence.
Cycle 3:
   Number of active cells:       188
   Number of degrees of freedom: 221 (by level: 8, 25, 80, 200)
   12 CG iterations needed to obtain convergence.
Cycle 4:
   Number of active cells:       416
   Number of degrees of freedom: 485 (by level: 8, 25, 89, 288, 280)
   13 CG iterations needed to obtain convergence.
Cycle 5:
   Number of active cells:       800
   Number of degrees of freedom: 925 (by level: 8, 25, 89, 288, 784, 132)
   14 CG iterations needed to obtain convergence.
Cycle 6:
   Number of active cells:       1628
   Number of degrees of freedom: 1865 (by level: 8, 25, 89, 304, 1000, 1164, 72)
   14 CG iterations needed to obtain convergence.
Cycle 7:
   Number of active cells:       3194
   Number of degrees of freedom: 3603 (by level: 8, 25, 89, 328, 1032, 2200, 1392)
   16 CG iterations needed to obtain convergence.
</pre><p> That's not perfect &mdash; we would have hoped for a constant number of iterations rather than one that increases as we get more and more degrees of freedom &mdash; but it is also not far away. The reason for this is easy enough to understand, however: since we have a strongly varying coefficient, the operators that we assembly by quadrature on the lower levels become worse and worse approximations of the operator on the finest level. Consequently, even if we had perfect solvers on the coarser levels, they would not be good preconditioners on the finest level. This theory is easily tested by comparing results when we use a constant coefficient: in that case, the number of iterations remains constant at 9 after the first three or four refinement steps.</p>
<p>We can also compare what this program produces with how <a class="el" href="step_5.html">step-5</a> performed. To solve the same problem as in <a class="el" href="step_5.html">step-5</a>, the only two changes that are necessary are (i) to replace the body of the function <code>LaplaceProblem::refine_grid</code> by a call to <code>triangulation.refine_global(1)</code>, and (ii) to use the same <a class="el" href="classSolverControl.html">SolverControl</a> object and tolerance as in <a class="el" href="step_5.html">step-5</a> &mdash; the rest of the program remains unchanged. In that case, here is how the solvers used in <a class="el" href="step_5.html">step-5</a> and the multigrid solver used in the current program compare: </p><table align="center">
<tr>
<th>cells</th><th><a class="el" href="step_5.html">step-5</a></th><th><a class="el" href="step_16.html">step-16</a> </th></tr>
<tr>
<td>20 </td><td>13 </td><td>6  </td></tr>
<tr>
<td>80 </td><td>17 </td><td>7  </td></tr>
<tr>
<td>320 </td><td>29 </td><td>9  </td></tr>
<tr>
<td>1280 </td><td>51 </td><td>10  </td></tr>
<tr>
<td>5120 </td><td>94 </td><td>11  </td></tr>
<tr>
<td>20480</td><td>180</td><td>13 </td></tr>
</table>
<p>This isn't only fewer iterations than in <a class="el" href="step_5.html">step-5</a> (each of which is, however, much more expensive) but more importantly, the number of iterations also grows much more slowly under mesh refinement (again, it would be almost constant if the coefficient was constant rather than strongly varying as chosen here). This justifies the common observation that, whenever possible, multigrid methods should be used for second order problems.</p>
<p><a class="anchor" id="Possibleextensions"></a></p><h3>Possible extensions </h3>
<p>A close inspection of this program's performance shows that it is mostly dominated by matrix-vector operations. <a class="el" href="step_37.html">step-37</a> shows one way how this can be avoided by working with matrix-free methods.</p>
<p>Another avenue would be to use algebraic multigrid methods. The geometric multigrid method used here can at times be a bit awkward to implement because it needs all those additional data structures, and it becomes even more difficult if the program is to run in parallel on machines coupled through MPI, for example. In that case, it would be simpler if one could use a black-box preconditioner that uses some sort of multigrid hierarchy for good performance but can figure out level matrices and similar things out by itself. Algebraic multigrid methods do exactly this, and we will use them in <a class="el" href="step_31.html">step-31</a> for the solution of a Stokes problem. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2003 - 2017 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Guido Kanschat and Timo Heister</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/conditional_ostream.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_gmres.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_refinement.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_boundary_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/error_estimator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/index_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/distributed/grid_refinement.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_constrained_dofs.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/multigrid.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_transfer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_coarse.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_smoother.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/multigrid/mg_matrix.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/generic_linear_algebra.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>LA</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">  <span class="keyword">using namespace </span>::<a class="code" href="namespaceLinearAlgebraPETSc.html">LinearAlgebraPETSc</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  <span class="keyword">using namespace </span>::<a class="code" href="namespaceLinearAlgebraTrilinos.html">LinearAlgebraTrilinos</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step50</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> deg);</div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_multigrid ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> refine_grid ();</div><div class="line">    <span class="keywordtype">void</span> output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a>                        pcout;</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    mg_dof_handler;</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> LA::MPI::SparseMatrix matrix_t;</div><div class="line">    <span class="keyword">typedef</span> LA::MPI::Vector vector_t;</div><div class="line"></div><div class="line">    matrix_t system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_set;</div><div class="line"></div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     constraints;</div><div class="line"></div><div class="line">    vector_t       solution;</div><div class="line">    vector_t       system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;matrix_t&gt;</a> mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;matrix_t&gt;</a> mg_interface_matrices;</div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                    mg_constrained_dofs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Coefficient () : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;() {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   &amp;p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  component = 0) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                             std::vector&lt;double&gt;            &amp;values,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>() &lt; 0.5*0.5)</div><div class="line">      <span class="keywordflow">return</span> 5;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt;            &amp;values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_points = points.size();</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.size() == n_points,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.size(), n_points));</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (component == 0,</div><div class="line">            <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a> (component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_points; ++i)</div><div class="line">      values[i] = Coefficient&lt;dim&gt;::value (points[i]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    :</div><div class="line">    pcout (<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">           (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD)</div><div class="line">            == 0)),</div><div class="line">    triangulation (MPI_COMM_WORLD,<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::</div><div class="line">                   limit_level_difference_at_vertices,</div><div class="line">                   <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::construct_multigrid_hierarchy),</div><div class="line">    fe (degree),</div><div class="line">    mg_dof_handler (triangulation),</div><div class="line">    degree(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    mg_dof_handler.distribute_dofs (fe);</div><div class="line">    mg_dof_handler.distribute_mg_dofs (fe);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceDoFTools.html#af0eef74bf66f0bfa8847f66fe6c8908d">DoFTools::extract_locally_relevant_dofs</a> (mg_dof_handler,</div><div class="line">                                             locally_relevant_set);</div><div class="line"></div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(mg_dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(mg_dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    constraints.reinit (locally_relevant_set);</div><div class="line">    <a class="code" href="group__constraints.html#ga3eaa31a679484e80c193e74e8a967dc8">DoFTools::make_hanging_node_constraints</a> (mg_dof_handler, constraints);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt;         dirichlet_boundary_ids;</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>      dirichlet_boundary;</div><div class="line">    <a class="code" href="classConstantFunction.html">ConstantFunction&lt;dim&gt;</a>                    homogeneous_dirichlet_bc (1.0);</div><div class="line">    dirichlet_boundary_ids.insert(0);</div><div class="line">    dirichlet_boundary[0] = &amp;homogeneous_dirichlet_bc;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (mg_dof_handler,</div><div class="line">                                              dirichlet_boundary,</div><div class="line">                                              constraints);</div><div class="line">    constraints.close ();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(mg_dof_handler.n_dofs(), mg_dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (mg_dof_handler, dsp, constraints);</div><div class="line">    system_matrix.reinit (mg_dof_handler.locally_owned_dofs(), dsp, MPI_COMM_WORLD, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(mg_dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(mg_dof_handler, dirichlet_boundary_ids);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line"></div><div class="line">    mg_interface_matrices.<a class="code" href="classMGLevelObject.html#aa5f20ef946fe83c93356c792e3f79b1c">resize</a>(0, n_levels-1);</div><div class="line">    mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a893309bf2277dd46c003787f29de59e4">clear_elements</a> ();</div><div class="line">    mg_matrices.resize(0, n_levels-1);</div><div class="line">    mg_matrices.clear_elements ();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;n_levels; ++level)</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(mg_dof_handler.n_dofs(level),</div><div class="line">                                   mg_dof_handler.n_dofs(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a55f23cddd7838e62ea54cae140fe54e9">MGTools::make_sparsity_pattern</a>(mg_dof_handler, dsp, level);</div><div class="line"></div><div class="line">        mg_matrices[level].reinit(mg_dof_handler.locally_owned_mg_dofs(level),</div><div class="line">                                  mg_dof_handler.locally_owned_mg_dofs(level),</div><div class="line">                                  dsp,</div><div class="line">                                  MPI_COMM_WORLD, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        mg_interface_matrices[level].reinit(mg_dof_handler.locally_owned_mg_dofs(level),</div><div class="line">                                            mg_dof_handler.locally_owned_mg_dofs(level),</div><div class="line">                                            dsp,</div><div class="line">                                            MPI_COMM_WORLD, <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(degree+1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>    |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>  |  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_rhs (dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div><div class="line">    std::vector&lt;double&gt;    coefficient_values (n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = mg_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = mg_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell_matrix = 0;</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">          coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                  coefficient_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                  cell_matrix(i,j) += (coefficient_values[q_point] *</div><div class="line">                                       fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                       fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point) *</div><div class="line">                                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                10.0 *</div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">          constraints.distribute_local_to_global (cell_matrix, cell_rhs,</div><div class="line">                                                  local_dof_indices,</div><div class="line">                                                  system_matrix, system_rhs);</div><div class="line">        }</div><div class="line"></div><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#ad581edc4d3b86a88c4277117c4fae57a">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(1+degree);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>   | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell   = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div><div class="line">    std::vector&lt;double&gt;    coefficient_values (n_q_points);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;ConstraintMatrix&gt; boundary_constraints (triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>());</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a> empty_constraints;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>(); ++level)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> dofset;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a311c1d316f9da52567319c3f12e4e054">DoFTools::extract_locally_relevant_level_dofs</a> (mg_dof_handler, level, dofset);</div><div class="line">        boundary_constraints[level].reinit(dofset);</div><div class="line">        boundary_constraints[level].add_lines (mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">        boundary_constraints[level].add_lines (mg_constrained_dofs.get_boundary_indices(level));</div><div class="line"></div><div class="line">        boundary_constraints[level].close ();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> cell = mg_dof_handler.<a class="code" href="classDoFHandler.html#a6af050921f3f1c3f2e6e20679a07f49b">begin</a>(),</div><div class="line">                                            endc = mg_dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;level_subdomain_id()==triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>())</div><div class="line">        {</div><div class="line">          cell_matrix = 0;</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">          coefficient.value_list (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                  coefficient_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                cell_matrix(i,j) += (coefficient_values[q_point] *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point) *</div><div class="line">                                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">          cell-&gt;get_mg_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">          boundary_constraints[cell-&gt;level()]</div><div class="line">          .distribute_local_to_global (cell_matrix,</div><div class="line">                                       local_dof_indices,</div><div class="line">                                       mg_matrices[cell-&gt;level()]);</div><div class="line"></div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;interface_dofs_on_level</div><div class="line">            = mg_constrained_dofs.get_refinement_edge_indices(cell-&gt;level());</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lvl = cell-&gt;level();</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              <span class="keywordflow">if</span> (interface_dofs_on_level.<a class="code" href="classIndexSet.html#a66c79fc7f17b2eeff0f0fb757e77e0c3">is_element</a>(local_dof_indices[i])   <span class="comment">// at_refinement_edge(i)</span></div><div class="line">                  &amp;&amp;</div><div class="line">                  !interface_dofs_on_level.<a class="code" href="classIndexSet.html#a66c79fc7f17b2eeff0f0fb757e77e0c3">is_element</a>(local_dof_indices[j])   <span class="comment">// !at_refinement_edge(j)</span></div><div class="line">                  &amp;&amp;</div><div class="line">                  (</div><div class="line">                    (!mg_constrained_dofs.is_boundary_index(lvl, local_dof_indices[i])</div><div class="line">                     &amp;&amp;</div><div class="line">                     !mg_constrained_dofs.is_boundary_index(lvl, local_dof_indices[j])</div><div class="line">                    ) <span class="comment">// ( !boundary(i) &amp;&amp; !boundary(j) )</span></div><div class="line">                    ||</div><div class="line">                    (</div><div class="line">                      mg_constrained_dofs.is_boundary_index(lvl, local_dof_indices[i])</div><div class="line">                      &amp;&amp;</div><div class="line">                      local_dof_indices[i]==local_dof_indices[j]</div><div class="line">                    ) <span class="comment">// ( boundary(i) &amp;&amp; boundary(j) &amp;&amp; i==j )</span></div><div class="line">                  )</div><div class="line">                 )</div><div class="line">                {</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                  cell_matrix(i,j) = 0;</div><div class="line">                }</div><div class="line"></div><div class="line"></div><div class="line">          empty_constraints</div><div class="line">          .distribute_local_to_global (cell_matrix,</div><div class="line">                                       local_dof_indices,</div><div class="line">                                       mg_interface_matrices[cell-&gt;level()]);</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>(); ++i)</div><div class="line">      {</div><div class="line">        mg_matrices[i].compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">        mg_interface_matrices[i].compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;vector_t&gt;</a> mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.<a class="code" href="classMGTransferPrebuilt.html#a2302c0b6ee91b59d006b21c7d3f00025">build_matrices</a>(mg_dof_handler);</div><div class="line"></div><div class="line">    matrix_t &amp;coarse_matrix = mg_matrices[0];</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> coarse_solver_control (1000, 1e-10, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;vector_t&gt;</a> coarse_solver(coarse_solver_control);</div><div class="line">    <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a> id;</div><div class="line">    <a class="code" href="classMGCoarseGridLACIteration.html">MGCoarseGridLACIteration&lt;SolverCG&lt;vector_t&gt;</a>,vector_t&gt; coarse_grid_solver(coarse_solver,</div><div class="line">        coarse_matrix,</div><div class="line">        <span class="keywordtype">id</span>);</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> LA::MPI::PreconditionJacobi Smoother;</div><div class="line">    <a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition&lt;matrix_t, Smoother, vector_t&gt;</a> mg_smoother;</div><div class="line">    mg_smoother.<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, Smoother::AdditionalData(0.5));</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;vector_t&gt;</a> mg_matrix(mg_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;vector_t&gt;</a> mg_interface_up(mg_interface_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;vector_t&gt;</a> mg_interface_down(mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;vector_t &gt;</a> <a class="code" href="namespacemg.html">mg</a>(mg_dof_handler,</div><div class="line">                            mg_matrix,</div><div class="line">                            coarse_grid_solver,</div><div class="line">                            mg_transfer,</div><div class="line">                            mg_smoother,</div><div class="line">                            mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, vector_t, MGTransferPrebuilt&lt;vector_t&gt;</a> &gt;</div><div class="line">    preconditioner(mg_dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (500, 1e-8*system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>(), <span class="keyword">false</span>);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;vector_t&gt;</a> solver (solver_control);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         TrilinosWrappers::PreconditionAMG prec;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">         TrilinosWrappers::PreconditionAMG::AdditionalData Amg_data;</span></div><div class="line"><span class="comment">         Amg_data.elliptic = true;</span></div><div class="line"><span class="comment">         Amg_data.higher_order_elements = true;</span></div><div class="line"><span class="comment">         Amg_data.smoother_sweeps = 2;</span></div><div class="line"><span class="comment">         Amg_data.aggregation_threshold = 0.02;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">         prec.initialize (system_matrix,</span></div><div class="line"><span class="comment">                          Amg_data);</span></div><div class="line"><span class="comment">         solver.solve (system_matrix, solution, system_rhs, prec);</span></div><div class="line"><span class="comment">        */</span></div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        solver.solve (system_matrix, solution, system_rhs,</div><div class="line">                      preconditioner);</div><div class="line">      }</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   CG converged in &quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints.distribute (solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    LA::MPI::Vector temp_solution;</div><div class="line">    temp_solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(locally_relevant_set, MPI_COMM_WORLD);</div><div class="line">    temp_solution = solution;</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#a971b0bfe57fa21867ed3c06794487e4b">KellyErrorEstimator&lt;dim&gt;::estimate</a> (<span class="keyword">static_cast&lt;</span><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>&amp;<span class="keyword">&gt;</span>(mg_dof_handler),</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(degree+1),</div><div class="line">                                        <span class="keyword">typename</span> <a class="code" href="structFunctionMap.html#a6bb95bc991dd3337330f1c725f59b008">FunctionMap&lt;dim&gt;::type</a>(),</div><div class="line">                                        temp_solution,</div><div class="line">                                        estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#a8fe97b1fc8f61b09d6a7c398a8b975ff">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#a8fe97b1fc8f61b09d6a7c398a8b975ff">    refine_and_coarsen_fixed_fraction</a> (triangulation,</div><div class="line">                                       estimated_error_per_cell,</div><div class="line">                                       0.3, 0.0);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    LA::MPI::Vector temp_solution;</div><div class="line">    temp_solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(locally_relevant_set, MPI_COMM_WORLD);</div><div class="line">    temp_solution = solution;</div><div class="line"></div><div class="line"></div><div class="line">    LA::MPI::Vector temp = solution;</div><div class="line">    system_matrix.residual(temp,solution,system_rhs);</div><div class="line">    LA::MPI::Vector res_ghosted = temp_solution;</div><div class="line">    res_ghosted = temp;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (mg_dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (temp_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (res_ghosted, <span class="stringliteral">&quot;res&quot;</span>);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;subdomain.size(); ++i)</div><div class="line">      subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> (0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                  <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 5) +</div><div class="line">                                  <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                                  <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="line">                                  (triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(), 4) +</div><div class="line">                                  <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    std::ofstream output (filename.c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (output);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">      {</div><div class="line">        std::vector&lt;std::string&gt; filenames;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD); ++i)</div><div class="line">          filenames.push_back (std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 5) +</div><div class="line">                               <span class="stringliteral">&quot;.&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i, 4) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">        <span class="keyword">const</span> std::string</div><div class="line">        pvtu_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 5) +</div><div class="line">                                <span class="stringliteral">&quot;.pvtu&quot;</span>);</div><div class="line">        std::ofstream pvtu_master (pvtu_master_filename.c_str());</div><div class="line">        data_out.<a class="code" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (pvtu_master, filenames);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::string</div><div class="line">        visit_master_filename = (<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (cycle, 5) +</div><div class="line">                                 <span class="stringliteral">&quot;.visit&quot;</span>);</div><div class="line">        std::ofstream visit_master (visit_master_filename.c_str());</div><div class="line">        <a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a> (visit_master, filenames);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   wrote &quot;</span> &lt;&lt; pvtu_master_filename &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;15; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a> (triangulation);</div><div class="line"></div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (4);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid ();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a573a50ba4c08a38f41c0edb9a9006e40">n_global_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system ();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; mg_dof_handler.n_dofs()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level=0; level&lt;triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>(); ++level)</div><div class="line">          pcout &lt;&lt; mg_dof_handler.n_dofs(level)</div><div class="line">                &lt;&lt; (level == triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>()-1</div><div class="line">                    ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system ();</div><div class="line">        assemble_multigrid ();</div><div class="line"></div><div class="line">        solve ();</div><div class="line">        output_results (cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">::Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step50;</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1<span class="comment">/*degree*/</span>);</div><div class="line">      laplace_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">throw</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
