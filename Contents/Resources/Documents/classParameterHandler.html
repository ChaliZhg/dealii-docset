<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ParameterHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classParameterHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ParameterHandler Class Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__input.html">Input</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="parameter__handler_8h_source.html">deal.II/base/parameter_handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ParameterHandler:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParameterHandler__inherit__graph.svg" width="170" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8364dda711b93753c6809eefe2a8e827"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> { <br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">Text</a> = 1, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37">LaTeX</a> = 2, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a">Description</a> = 3, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">XML</a> = 4, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c">JSON</a> = 5, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7">ShortText</a> = 193
<br />
 }</td></tr>
<tr class="separator:a8364dda711b93753c6809eefe2a8e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7aebc6956ea423d376c5fe881b8d5c4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a7aebc6956ea423d376c5fe881b8d5c4d">ParameterHandler</a> ()</td></tr>
<tr class="separator:a7aebc6956ea423d376c5fe881b8d5c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb238df795f2c2a788048a688f468fcf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb238df795f2c2a788048a688f468fcf">~ParameterHandler</a> ()</td></tr>
<tr class="separator:afb238df795f2c2a788048a688f468fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4fe419ccc4b128ec2bad5e0dec62ac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#abc4fe419ccc4b128ec2bad5e0dec62ac">read_input</a> (std::istream &amp;input, const std::string &amp;filename=&quot;input file&quot;, const std::string &amp;last_line=&quot;&quot;) 1</td></tr>
<tr class="separator:abc4fe419ccc4b128ec2bad5e0dec62ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f067f0a84ac392fe26d553aea50541b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (std::istream &amp;input, const std::string &amp;filename=&quot;input file&quot;, const std::string &amp;last_line=&quot;&quot;)</td></tr>
<tr class="separator:a4f067f0a84ac392fe26d553aea50541b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298fa0d7fee37560299f7169c30d2614"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a298fa0d7fee37560299f7169c30d2614">read_input</a> (const std::string &amp;filename, const bool optional=false, const bool write_stripped_file=false, const std::string &amp;last_line=&quot;&quot;) 1</td></tr>
<tr class="separator:a298fa0d7fee37560299f7169c30d2614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030e84298d59cfea765f43d8600dee48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a030e84298d59cfea765f43d8600dee48">parse_input</a> (const std::string &amp;filename, const std::string &amp;last_line=&quot;&quot;)</td></tr>
<tr class="separator:a030e84298d59cfea765f43d8600dee48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed008fd0c025700d02a46b8a8765669"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4ed008fd0c025700d02a46b8a8765669">read_input_from_string</a> (const char *s, const std::string &amp;last_line=&quot;&quot;)</td></tr>
<tr class="separator:a4ed008fd0c025700d02a46b8a8765669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f47346d2bb71a940fb7a63608316ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a50f47346d2bb71a940fb7a63608316ae">parse_input_from_string</a> (const char *s, const std::string &amp;last_line=&quot;&quot;)</td></tr>
<tr class="separator:a50f47346d2bb71a940fb7a63608316ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f285cc4f3d23b92307d5d3c4b8396d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af8f285cc4f3d23b92307d5d3c4b8396d">read_input_from_xml</a> (std::istream &amp;input) 1</td></tr>
<tr class="separator:af8f285cc4f3d23b92307d5d3c4b8396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739af0d987ea80704f0d322c9723ba84"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a739af0d987ea80704f0d322c9723ba84">parse_input_from_xml</a> (std::istream &amp;input)</td></tr>
<tr class="separator:a739af0d987ea80704f0d322c9723ba84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6184baed4eba575e422161dc86ed12e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6184baed4eba575e422161dc86ed12e3">clear</a> ()</td></tr>
<tr class="separator:a6184baed4eba575e422161dc86ed12e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb951f101e0969416f7f47d24c03bcfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (const std::string &amp;entry, const std::string &amp;default_value, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern=<a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(), const std::string &amp;documentation=std::string())</td></tr>
<tr class="separator:afb951f101e0969416f7f47d24c03bcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f3996003757093fb0e050a6729e81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action</a> (const std::string &amp;entry, const std::function&lt; void(const std::string &amp;value)&gt; &amp;action)</td></tr>
<tr class="separator:a59f3996003757093fb0e050a6729e81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb847561585089c4c7fcf51eddece16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (const std::string &amp;existing_entry_name, const std::string &amp;alias_name, const bool alias_is_deprecated=false)</td></tr>
<tr class="separator:aecb847561585089c4c7fcf51eddece16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c20cde6d44186806d559beb468696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (const std::string &amp;subsection)</td></tr>
<tr class="separator:af29c20cde6d44186806d559beb468696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599462cacd492e2f712bf7369507dcff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ()</td></tr>
<tr class="separator:a599462cacd492e2f712bf7369507dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cfbaca954f444047302446a4e87125"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a91cfbaca954f444047302446a4e87125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf3c7846747695b1f327677e3716ec5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:aeaf3c7846747695b1f327677e3716ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb45dc67787e3fab7882461929b5fbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:a6bb45dc67787e3fab7882461929b5fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6418ea655b1b550b9dcf63513030196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> (const std::string &amp;entry_name, const std::string &amp;new_value)</td></tr>
<tr class="separator:aa6418ea655b1b550b9dcf63513030196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af288e1fe38ac1a1baf1cef3058b63ce1">set</a> (const std::string &amp;entry_name, const char *new_value)</td></tr>
<tr class="separator:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb43df4f2325707a82201071793e4fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aabb43df4f2325707a82201071793e4fa">set</a> (const std::string &amp;entry_name, const long int &amp;new_value)</td></tr>
<tr class="separator:aabb43df4f2325707a82201071793e4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d8a002b574cb451240ecf723ab0fa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a03d8a002b574cb451240ecf723ab0fa8">set</a> (const std::string &amp;entry_name, const double &amp;new_value)</td></tr>
<tr class="separator:a03d8a002b574cb451240ecf723ab0fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcee5b1f5f7c6745e8c7b66dcf34104d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#adcee5b1f5f7c6745e8c7b66dcf34104d">set</a> (const std::string &amp;entry_name, const bool &amp;new_value)</td></tr>
<tr class="separator:adcee5b1f5f7c6745e8c7b66dcf34104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5f6dff73abcca2b6abca8d8a18afa1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters</a> (std::ostream &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style)</td></tr>
<tr class="separator:a5d5f6dff73abcca2b6abca8d8a18afa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49597e3b087e9021491630ac15c383ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a49597e3b087e9021491630ac15c383ec">print_parameters_section</a> (std::ostream &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style, const unsigned int indent_level, const bool include_top_level_elements=false)</td></tr>
<tr class="separator:a49597e3b087e9021491630ac15c383ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f4db3ea6cd9414cc39d926a0a0959e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af2f4db3ea6cd9414cc39d926a0a0959e">log_parameters</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out)</td></tr>
<tr class="separator:af2f4db3ea6cd9414cc39d926a0a0959e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade326782f2aca595c273f3674294bb1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ade326782f2aca595c273f3674294bb1e">log_parameters_section</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out)</td></tr>
<tr class="separator:ade326782f2aca595c273f3674294bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0342139603da3b30b132446d94a17b25"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a0342139603da3b30b132446d94a17b25">memory_consumption</a> () const</td></tr>
<tr class="separator:a0342139603da3b30b132446d94a17b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5df38ff67c1c8352e04de490e0c0a39e">save</a> (Archive &amp;ar, const unsigned int version) const</td></tr>
<tr class="separator:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a09fd2ee6d01b78079f894893aacd6c4c">load</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede1a749bba8ee11876fd114a16c4f3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aede1a749bba8ee11876fd114a16c4f3e">operator==</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm2) const</td></tr>
<tr class="separator:aede1a749bba8ee11876fd114a16c4f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga55b48a9b5ced390a0c292e8103afdf91">ExcEntryAlreadyExists</a> (std::string arg1)</td></tr>
<tr class="separator:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b16bc7be372c9270121d278858a672f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8b16bc7be372c9270121d278858a672f">ExcValueDoesNotMatchPattern</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga8b16bc7be372c9270121d278858a672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9213c9ff33bbb3d167b67fa890a6d9ce">ExcAlreadyAtTopLevel</a> ()</td></tr>
<tr class="separator:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2ab8cc9a7fa6a9c6114a207b795007d5">ExcEntryUndeclared</a> (std::string arg1)</td></tr>
<tr class="separator:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a05434eefbd2de0314b0a483247d96d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0a05434eefbd2de0314b0a483247d96d">ExcUnbalancedSubsections</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga0a05434eefbd2de0314b0a483247d96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8136031b245c5a29ddac3940090f0ac"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad8136031b245c5a29ddac3940090f0ac">ExcNoSubsection</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gad8136031b245c5a29ddac3940090f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa620e44b3aa3cf356feaa424a516086e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa620e44b3aa3cf356feaa424a516086e">ExcCannotParseLine</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gaa620e44b3aa3cf356feaa424a516086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad3cb505bbdd65d21ef66e3ef7e383bab">ExcInvalidEntryForPattern</a> (int arg1, std::string arg2, std::string arg3, std::string arg4, std::string arg5)</td></tr>
<tr class="separator:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga43bb6588e469c2e12a430fb7ea316da1">ExcInvalidXMLParameterFile</a> ()</td></tr>
<tr class="separator:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95317771f403222f9592ba25fae14d4d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga95317771f403222f9592ba25fae14d4d">ExcInvalidEntryForPatternXML</a> (std::string arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:ga95317771f403222f9592ba25fae14d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2febc2a5dd0328f971093085bf9b4fa">ExcCannotOpenIncludeStatementFile</a> (int arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afb9589874569e5442840fe2f5d016924"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb9589874569e5442840fe2f5d016924">ParameterHandler</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;)</td></tr>
<tr class="separator:afb9589874569e5442840fe2f5d016924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad144b3d53732e7ac72fdacc0223e6ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ad144b3d53732e7ac72fdacc0223e6ef6">operator=</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;)</td></tr>
<tr class="separator:ad144b3d53732e7ac72fdacc0223e6ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309a5cd29993c8070462ec3ac70564cc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a309a5cd29993c8070462ec3ac70564cc">get_current_path</a> () const</td></tr>
<tr class="separator:a309a5cd29993c8070462ec3ac70564cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae05819ce1de5de30ad92322fc8fc8da"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aae05819ce1de5de30ad92322fc8fc8da">get_current_full_path</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:aae05819ce1de5de30ad92322fc8fc8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4430cca40a4e918a09de37350c1d1cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4430cca40a4e918a09de37350c1d1cdf">scan_line</a> (std::string line, const std::string &amp;input_filename, const unsigned int current_line_n)</td></tr>
<tr class="separator:a4430cca40a4e918a09de37350c1d1cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aab5c45bef2e688478b44c3323b6733f6"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aab5c45bef2e688478b44c3323b6733f6">mangle</a> (const std::string &amp;s)</td></tr>
<tr class="separator:aab5c45bef2e688478b44c3323b6733f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703dcf499d53f99829a9bc1b0e408a97"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a703dcf499d53f99829a9bc1b0e408a97">demangle</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a703dcf499d53f99829a9bc1b0e408a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae3c753f43844f2c1196d4ef939048bb0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; boost::property_tree::ptree &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae3c753f43844f2c1196d4ef939048bb0">entries</a></td></tr>
<tr class="separator:ae3c753f43844f2c1196d4ef939048bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae1e63c7ad972211d55ea21a203073a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aeae1e63c7ad972211d55ea21a203073a">patterns</a></td></tr>
<tr class="separator:aeae1e63c7ad972211d55ea21a203073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf71c4d2431f2296710cd910da7f6eb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::function&lt; void(const std::string &amp;)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aebf71c4d2431f2296710cd910da7f6eb">actions</a></td></tr>
<tr class="separator:aebf71c4d2431f2296710cd910da7f6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa5b69fc4d1d56dd6bc90e2dcf24d56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aefa5b69fc4d1d56dd6bc90e2dcf24d56">subsection_path</a></td></tr>
<tr class="separator:aefa5b69fc4d1d56dd6bc90e2dcf24d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a009fb8cb45463ac3a57f8cb371fbc82b"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a009fb8cb45463ac3a57f8cb371fbc82b">path_separator</a> = '.'</td></tr>
<tr class="separator:a009fb8cb45463ac3a57f8cb371fbc82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6cb3efd46790a1d4b58f5ffe7bb66c06"><td class="memItemLeft" align="right" valign="top"><a id="a6cb3efd46790a1d4b58f5ffe7bb66c06"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MultipleParameterLoop</b></td></tr>
<tr class="separator:a6cb3efd46790a1d4b58f5ffe7bb66c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classParameterHandler.html">ParameterHandler</a> class provides a standard interface to an input file which provides at run-time for program parameters such as time step sizes, geometries, right hand sides etc. The input for the program is given in files, streams or strings in memory using text like </p><div class="fragment"><div class="line"><span class="keyword">set</span> Time step size = 0.3</div><div class="line">set Geometry       = [0,1]x[0,3]</div></div><!-- fragment --><p> Input may be sorted into subsection trees in order to give the input a logical structure, and input files may include other files.</p>
<p>The <a class="el" href="classParameterHandler.html">ParameterHandler</a> class is discussed in detail in the <a class="el" href="step_19.html">step-19</a> example program, and is used in more realistic situations in <a class="el" href="step_29.html">step-29</a>, <a class="el" href="step_33.html">step-33</a> and <a class="el" href="step_34.html">step-34</a>.</p>
<h3>Declaring entries</h3>
<p>In order to use the facilities of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object, one first has to make known the different entries the input file may or may not contain. This is done in the following way:</p>
<div class="fragment"><div class="line">...</div><div class="line">ParameterHandler prm;</div><div class="line">prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Time step size&quot;</span>,</div><div class="line">                  <span class="stringliteral">&quot;0.2&quot;</span>,</div><div class="line">                  <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                  <span class="stringliteral">&quot;Some documentation&quot;</span>);</div><div class="line">prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Geometry&quot;</span>,</div><div class="line">                  <span class="stringliteral">&quot;[0,1]x[0,1]&quot;</span>,</div><div class="line">                  <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>());</div><div class="line">...</div></div><!-- fragment --><p> Each entry is declared using the function <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry()</a>. The first parameter is the name of the entry (in short: the entry). The second is the default answer to be taken in case the entry is not specified in the input file. The third parameter is a regular expression which the input (and the default answer) has to match. Several such regular expressions are defined in <a class="el" href="namespacePatterns.html">Patterns</a>. This parameter can be omitted, in which case it will default to <a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>, i.e. a pattern that matches every input string. The fourth parameter can be used to document the intent or expected format of an entry; its value is printed as a comment when writing all entries of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object using the <a class="el" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters()</a> function to allow for easier understanding of a parameter file. It can be omitted as well, in which case no such documentation will be printed.</p>
<p>Entries may be located in subsections which form a kind of input tree. For example input parameters for linear solver routines should be classified in a subsection named <code>Linear solver</code> or any other suitable name. This is accomplished in the following way: </p><div class="fragment"><div class="line">...</div><div class="line">  LinEq eq;</div><div class="line">  eq.declare_parameters (prm);</div><div class="line">...</div><div class="line"></div><div class="line">void LinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Solver&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;CG&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|GMRES|GaussElim&quot;</span>),</div><div class="line">                       <span class="stringliteral">&quot;Name of a linear solver for the inner iteration&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;20&quot;</span>,</div><div class="line">                       ParameterHandler::RegularExpressions::Integer());</div><div class="line">    ...</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p>Subsections may be nested. For example a nonlinear solver may have a linear solver as member object. Then the function call tree would be something like (if the class <code>NonLinEq</code> has a member variables <code>eq</code> of type <code>LinEq</code>): </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Nonlinear method&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;Newton-Raphson&quot;</span>,</div><div class="line">                       ParameterHandler::RegularExpressions::Anything());</div><div class="line">    eq.declare_parameters (prm);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p>For class member functions which declare the different entries we propose to use the common name <code>declare_parameters</code>. In normal cases this method can be <code>static</code> since the entries will not depend on any previous knowledge. Classes for which entries should logically be grouped into subsections should declare these subsections themselves. If a class has two or more member variables of the same type both of which should have their own parameters, this parent class' method <code>declare_parameters</code> is responsible to group them into different subsections: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver 1&quot;</span>);</div><div class="line">    {</div><div class="line">      eq1.declare_parameters (prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver 2&quot;</span>);</div><div class="line">    {</div><div class="line">      eq2.declare_parameters (prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><h3>Input files and special characters</h3>
<p>For the first example above the input file would look like the following: </p><div class="fragment"><div class="line">...</div><div class="line">subsection Nonlinear solver</div><div class="line">  <span class="keyword">set</span> Nonlinear method = Gradient</div><div class="line"><span class="preprocessor">  # this is a comment</span></div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classSolver.html">Solver</a>                       = CG</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 30</div><div class="line">  end</div><div class="line">end</div><div class="line">...                       # other stuff</div></div><!-- fragment --><p> The words <code>subsection</code>, <code>set</code> and <code>end</code> may be either written in lowercase or uppercase letters. Leading and trailing whitespace is removed, multiple whitespace is condensed into only one. Since the latter applies also to the name of an entry, an entry name will not be recognized if in the declaration multiple whitespace is used.</p>
<p>In entry names and values the following characters are not allowed: <code>#</code>, <code>{</code>, <code>}</code>, <code>|</code>. Their use is reserved for the <a class="el" href="classMultipleParameterLoop.html">MultipleParameterLoop</a> class.</p>
<p>Comments starting with # are skipped.</p>
<p>Continuation lines are allowed by means of the character <code>\</code>, which must be the last character (aside from whitespace, which is ignored) of the line. When a line is a continuation (i.e., the previous line ended in a <code>\</code>), then, unlike the default behavior of the <code>C</code> preprocessor, all whitespace at the beginning of the line is ignored.</p>
<p>We propose to use the following scheme to name entries: start the first word with a capital letter and use lowercase letters further on. The same applies to the possible entry values to the right of the <code>=</code> sign.</p>
<h3>Including other input files</h3>
<p>An input file can include other include files using the syntax </p><div class="fragment"><div class="line">...</div><div class="line">include some_other_file.prm</div><div class="line">...</div></div><!-- fragment --><p> The file so referenced is searched for relative to the current directory (not relative to the directory in which the including parameter file is located, since this is not known to all three versions of the <a class="el" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input()</a> function).</p>
<h3>Reading data from input sources</h3>
<p>In order to read input there are three possibilities: reading from an <code>std::istream</code> object, reading from a file of which the name is given and reading from a string in memory in which the lines are separated by <code>\n</code> characters. These possibilities are used as follows: </p><div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">...</div><div class="line"><span class="comment">// declaration of entries</span></div><div class="line">...</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (std::cin); <span class="comment">// read input from standard in,</span></div><div class="line"><span class="comment">// or</span></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (<span class="stringliteral">&quot;simulation.prm&quot;</span>);</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="keywordtype">char</span> *in = <span class="stringliteral">&quot;set Time step size = 0.3 \n ...&quot;</span>;</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a50f47346d2bb71a940fb7a63608316ae">parse_input_from_string</a> (in);</div><div class="line">...</div></div><!-- fragment --><p> You can use several sources of input successively. Entries which are changed more than once will be overwritten every time they are used.</p>
<p>You should not try to declare entries using <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry()</a> and <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> with as yet unknown subsection names after using <a class="el" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input()</a>. The results in this case are unspecified.</p>
<p>If an error occurs upon reading the input, error messages are written to <code>std::cerr</code> and the reader function returns with a return value of <code>false</code>. This is opposed to almost all other functions in deal.II, which would normally throw an exception if an error occurs; this difference in behavior is a relic of the fact that this class predates deal.II and had previously been written for a different project.</p>
<h3>Using the ParameterHandler Graphical User Interface</h3>
<p>An alternative to using the hand-written input files shown above is to use the graphical user interface (GUI) that accompanies this class.</p>
<p>See <a href="https://github.com/dealii/parameter_gui">the parameter_gui github repository</a> for further details.</p>
<h3>Getting entry values out of a ParameterHandler object</h3>
<p>Each class gets its data out of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object by calling the <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get()</a> member functions like this: </p><div class="fragment"><div class="line"> <span class="keywordtype">void</span> NonLinEq::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm) {</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  std::string method = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Nonlinear method&quot;</span>);</div><div class="line">  eq.get_parameters (prm);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p> <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get()</a> returns the value of the given entry. If the entry was not specified in the input source(s), the default value is returned. You have to enter and leave subsections exactly as you did when declaring subsection. You may chose the order in which to transverse the subsection tree.</p>
<p>It is guaranteed that only entries matching the given regular expression are returned, i.e. an input entry value which does not match the regular expression is not stored.</p>
<p>You can use <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get()</a> to retrieve the parameter in text form, <a class="el" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer()</a> to get an integer or <a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double()</a> to get a double. You can also use <a class="el" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool()</a>. It will cause an internal error if the string could not be converted to an integer, double or a bool. This should, though, not happen if you correctly specified the regular expression for this entry; you should not try to get out an integer or a double from an entry for which no according regular expression was set. The internal error is raised through the <a class="el" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert()</a> macro family which only works in debug mode.</p>
<p>If you want to print out all user selectable features, use the <a class="el" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters()</a> function. It is generally a good idea to print all parameters at the beginning of a log file, since this way input and output are together in one file which makes matching at a later time easier. Additionally, the function also print those entries which have not been modified in the input file and are thus set to default values; since default values may change in the process of program development, you cannot know the values of parameters not specified in the input file.</p>
<h3>Adding Actions to Parameters</h3>
<p>It is often convenient to have something happen as soon as a parameter value is read. This could be a check that it is valid &ndash; say, that a file that is listed in the parameter file exists &ndash; or to initiate something else in response, such as setting a variable outside the <a class="el" href="classParameterHandler.html">ParameterHandler</a> (as in the example shown below). In almost all cases, this "action" could also be initiated once all parameters are read via <a class="el" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input()</a>, but it is sometimes <em>convenient</em> to do it right away.</p>
<p>This is facilitated by the <a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action()</a> function that can be called after declaring a parameter via <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry()</a>. "Actions" are in essence pointers to functions that will be called for parameters that have associated actions. These functions take the value of a parameter as argument, and can then do whatever they want with it &ndash; e.g., save it somewhere outside the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object. (Exactly when the action is called is described in the documentation of the <a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action()</a> function.) Of course, in C++ one doesn't usually pass around the address of a function, but an action can be a function-like object (taking a string as argument) that results from calling <code>std::bind</code>, or more conveniently, it can be a <a href="http://en.cppreference.com/w/cpp/language/lambda">lambda function</a> that has the form </p><div class="fragment"><div class="line">[] (<span class="keyword">const</span> std::string &amp;value) { ... <span class="keywordflow">do</span> something with the value ... }</div></div><!-- fragment --><p> and that is attached to a specific parameter.</p>
<p>A typical example of such an action would be as follows: let's assume that you have a program that declares a parameter for the number of iterations it is going to run, say </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyAlgorithm</div><div class="line">{</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line">   <span class="keyword">private</span>:</div><div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations;</div><div class="line">};</div></div><!-- fragment --><p> then one could obtain this parameter from a parameter file using a code snippet in <code>run()</code> as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAlgorithm::run ()</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>,  <span class="comment">// name of parameter</span></div><div class="line">                     <span class="stringliteral">&quot;10&quot;</span>,                    <span class="comment">// default value</span></div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1,100),<span class="comment">// allowed values: 1...100</span></div><div class="line">                     <span class="stringliteral">&quot;The number of ...&quot;</span>);    <span class="comment">// some documentation, to be completed</span></div><div class="line"></div><div class="line">  <span class="comment">// next read the parameter from an input file...</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (<span class="stringliteral">&quot;my_algorithm.prm&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// ...and finally get the value for use in the program:</span></div><div class="line">  n_iterations = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>);</div><div class="line"></div><div class="line">  ... actual code doing something useful follows here...</div></div><!-- fragment --><p>This two-step process &ndash; first declaring the parameter, and later reading it &ndash; is a bit cumbersome because one has to first declare <em>all</em> parameters and at a later time retrieve them from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object. In large programs, these two things also often happen in different functions.</p>
<p>To avoid this, it would be nice if we could put both the declaration and the retrieval into the same place. This can be done via actions, and the function would then look like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyAlgorithm::run ()</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>,  <span class="comment">// name of parameter</span></div><div class="line">                     <span class="stringliteral">&quot;10&quot;</span>,                    <span class="comment">// default value</span></div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1,100),<span class="comment">// allowed values: 1...100</span></div><div class="line">                     <span class="stringliteral">&quot;The number of ...&quot;</span>);    <span class="comment">// some documentation, to be completed</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>,</div><div class="line">                  [&amp;](<span class="keyword">const</span> std::string &amp;value) {</div><div class="line">                    this-&gt;n_iterations = <a class="code" href="namespaceUtilities.html#af7e8ff146c677d8a2408b88e4936f57d">Utilities::string_to_int</a>(value);</div><div class="line">                  });</div><div class="line"></div><div class="line">  <span class="comment">// next read the parameter from an input file...</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (<span class="stringliteral">&quot;my_algorithm.prm&quot;</span>);</div><div class="line"></div><div class="line">  ... actual code doing something useful follows here...</div></div><!-- fragment --><p> Here, the action consists of a lambda function that takes the value for this parameter as a string, and then converts it to an integer to store in the variable where it belongs. This action is executed inside the call to <code>prm.parse_input()</code>, and so there is now no longer a need to extract the parameter's value at a later time. Furthermore, the code that sets the member variable is located right next to the place where the parameter is actually declared, so we no longer need to have two separate parts of the code base that deal with input parameters.</p>
<p>Of course, it is possible to execute far more involved actions than just setting a member variable as shown above, even though that is a typical case.</p>
<h3>Style guide for data retrieval</h3>
<p>We propose that every class which gets data out of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object provides a function named <code>get_parameters</code>. This should be declared <code>virtual</code>. <code>get_parameters</code> functions in derived classes should call the <code>BaseClass::get_parameters</code> function.</p>
<h3>Experience with large parameter lists</h3>
<p>Experience has shown that in programs defining larger numbers of parameters (more than, say, fifty) it is advantageous to define an additional class holding these parameters. This class is more like a C-style structure, having a large number of variables, usually public. It then has at least two functions, which declare and parse the parameters. In the main program, the main class has an object of this parameter class and delegates declaration and parsing of parameters to this object.</p>
<p>The advantage of this approach is that you can keep out the technical details (declaration and parsing) out of the main class and additionally don't clutter up your main class with dozens or more variables denoting the parameters.</p>
<h3>Worked Example</h3>
<p>This is the code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"><span class="keyword">class </span>LinearEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">  <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::string method;</div><div class="line">  <span class="keywordtype">int</span>         max_iterations;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>Problem</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  LinearEquation eq1, eq2;</div><div class="line">  std::string matrix1, matrix2;</div><div class="line">  std::string outfile;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">  <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> do_something ();</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearEquation::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  <span class="comment">// declare parameters for the linear solver in a subsection</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Solver&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;CG&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|BiCGStab|GMRES&quot;</span>),</div><div class="line">                       <span class="stringliteral">&quot;Name of a linear solver for the inner iteration&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;20&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearEquation::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    method         = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">    max_iterations = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  LinearEquation: method=&quot;</span> &lt;&lt; method</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, max_iterations=&quot;</span> &lt;&lt; max_iterations</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Problem::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  <span class="comment">// first some global parameter entries</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Output file&quot;</span>,</div><div class="line">                     <span class="stringliteral">&quot;out&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                     <span class="stringliteral">&quot;Name of the output file, either relative to the present &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;path or absolute&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>,</div><div class="line">                     <span class="stringliteral">&quot;Laplace&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                     <span class="stringliteral">&quot;String identifying the equation we want to solve&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>,</div><div class="line">                     <span class="stringliteral">&quot;Elasticity&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>());</div><div class="line"></div><div class="line">  <span class="comment">// declare parameters for the first equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;Sparse&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;Full|Sparse|Diagonal&quot;</span>),</div><div class="line">                       <span class="stringliteral">&quot;Type of the matrix to be used, either full, &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;sparse, or diagonal&quot;</span>);</div><div class="line">    LinearEquation::declare_parameters (prm);  <span class="comment">// for eq1</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">  <span class="comment">// declare parameters for the second equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 2 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;Sparse&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;Full|Sparse|Diagonal&quot;</span>));</div><div class="line">    LinearEquation::declare_parameters (prm);  <span class="comment">// for eq2</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Problem::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  <span class="comment">// entries of the problem class</span></div><div class="line">  outfile = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Output file&quot;</span>);</div><div class="line">  std::string equation1 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>),</div><div class="line">              equation2 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// get parameters for the first equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    matrix1 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>);</div><div class="line">    eq1.get_parameters (prm); <span class="comment">// for eq1</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">  <span class="comment">// get parameters for the second equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 2 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    matrix2 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>);</div><div class="line">    eq2.get_parameters (prm); <span class="comment">// for eq2</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Problem: outfile=&quot;</span> &lt;&lt; outfile &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;           eq1=&quot;</span>     &lt;&lt; equation1 &lt;&lt; <span class="stringliteral">&quot;, eq2=&quot;</span> &lt;&lt; equation2 &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;           matrix1=&quot;</span> &lt;&lt; matrix1 &lt;&lt; <span class="stringliteral">&quot;, matrix2=&quot;</span> &lt;&lt; matrix2</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Problem::do_something ()</div><div class="line">{</div><div class="line">  <span class="comment">// While this example does nothing here, at this point in the program</span></div><div class="line">  <span class="comment">// all of the parameters are known so we can start doing computations.</span></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  Problem p;</div><div class="line">  p.declare_parameters (prm);</div><div class="line">  <span class="comment">// read input from &quot;prmtest.prm&quot;; giving argv[1] would also be a</span></div><div class="line">  <span class="comment">// good idea</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (<span class="stringliteral">&quot;prmtest.prm&quot;</span>);</div><div class="line">  <span class="comment">// print parameters to std::cout as ASCII text</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters</a> (std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line">  <span class="comment">// get parameters into the program</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;Getting parameters:&quot;</span> &lt;&lt; std::endl;</div><div class="line">  p.get_parameters (prm);</div><div class="line">  <span class="comment">// now run the program with these input parameters</span></div><div class="line">  p.do_something ();</div><div class="line">}</div></div><!-- fragment --><p>This is the input file (named "prmtest.prm"): </p><div class="fragment"><div class="line"><span class="preprocessor"># first declare the types of equations</span></div><div class="line"><span class="keyword">set</span> Equation 1 = Poisson</div><div class="line"><span class="keyword">set</span> Equation 2 = Stokes</div><div class="line"></div><div class="line">subsection Equation 1 Settings</div><div class="line">  <span class="keyword">set</span> Matrix type = Sparse</div><div class="line">  subsection Linear solver # parameters <span class="keywordflow">for</span> linear solver 1</div><div class="line">    <span class="keyword">set</span> Solver                       = Gauss-Seidel</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 40</div><div class="line">  end</div><div class="line">end</div><div class="line"></div><div class="line">subsection Equation 2 Settings</div><div class="line">  <span class="keyword">set</span> Matrix type = Full</div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 100</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>And here is the output of the program: </p><div class="fragment"><div class="line">Line &lt;8&gt; of file &lt;prmtest.prm&gt;:</div><div class="line">    The entry value</div><div class="line">        Gauss-Seidel</div><div class="line">    <span class="keywordflow">for</span> the entry named</div><div class="line">        Solver</div><div class="line">    does not match the given pattern</div><div class="line">        [Selection CG|BiCGStab|GMRES ]</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line"><span class="preprocessor"># String identifying the equation we want to solve</span></div><div class="line"><span class="keyword">set</span> Equation 1  = Poisson # <span class="keywordflow">default</span>: Laplace</div><div class="line"><span class="keyword">set</span> Equation 2  = Stokes  # <span class="keywordflow">default</span>: Elasticity</div><div class="line"></div><div class="line"><span class="preprocessor"># Name of the output file, either relative to the present path or absolute</span></div><div class="line"><span class="keyword">set</span> Output file = out</div><div class="line"></div><div class="line"></div><div class="line">subsection Equation 1 Settings</div><div class="line"><span class="preprocessor">  # Type of the matrix to be used, either full, sparse, or diagonal</span></div><div class="line">  <span class="keyword">set</span> Matrix type = Sparse</div><div class="line"></div><div class="line"></div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 40 # <span class="keywordflow">default</span>: 20</div><div class="line"><span class="preprocessor">    # Name of a linear solver for the inner iteration</span></div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">  end</div><div class="line"></div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line">subsection Equation 2 Settings</div><div class="line">  <span class="keyword">set</span> Matrix type = Full # <span class="keywordflow">default</span>: Sparse</div><div class="line"></div><div class="line"></div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 100 # <span class="keywordflow">default</span>: 20</div><div class="line"><span class="preprocessor">    # Name of a linear solver for the inner iteration</span></div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">  end</div><div class="line"></div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Getting parameters:</div><div class="line">  LinearEquation: method=CG, max_iterations=40</div><div class="line">  LinearEquation: method=CG, max_iterations=100</div><div class="line">  Problem: outfile=out</div><div class="line">           eq1=Poisson, eq2=Stokes</div><div class="line">           matrix1=Sparse, matrix2=Full</div></div><!-- fragment --><h3>Representation of Parameters</h3>
<p>Here is some more internal information about the representation of parameters:</p>
<p>Logically, parameters and the nested sections they are arranged in can be thought of as a hierarchical directory structure, or a tree. Take, for example, the following code declaring a set of parameters and sections they live in: </p><div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Maximal number of iterations&quot;</span>,</div><div class="line">                   <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                   <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1, 1000),</div><div class="line">                   <span class="stringliteral">&quot;A parameter that describes the maximal number of &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;iterations the CG method is to take before giving &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;up on a matrix.&quot;</span>);</div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Preconditioner&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Kind&quot;</span>,</div><div class="line">                     <span class="stringliteral">&quot;SSOR&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a> (<span class="stringliteral">&quot;SSOR|Jacobi&quot;</span>),</div><div class="line">                     <span class="stringliteral">&quot;A string that describes the kind of preconditioner &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;to use.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a> (<span class="stringliteral">&quot;Relaxation factor&quot;</span>,</div><div class="line">                     <span class="stringliteral">&quot;1.0&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0, 1),</div><div class="line">                     <span class="stringliteral">&quot;The numerical value (between zero and one) for the &quot;</span></div><div class="line">                     <span class="stringliteral">&quot;relaxation factor to use in the preconditioner.&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div></div><!-- fragment --><p>We can think of the parameters so arranged as a file system in which every parameter is a directory. The name of this directory is the name of the parameter, and in this directory lie files that describe the parameter. These files are at the time of writing this documentation (other fields, such as those indicating "actions" may also exist in each directory):</p>
<ul>
<li><code>value</code>: The content of this file is the current value of this parameter; initially, the content of the file equals the default value of the parameter.</li>
<li><code>default_value</code>: The content of this file is the default value value of the parameter.</li>
<li><code>pattern</code>: A textual representation of the pattern that describes the parameter's possible values.</li>
<li><code>pattern_index</code>: A number that indexes the <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> object that is used to describe the parameter.</li>
<li><code>documentation</code>: The content of this file is the documentation given for a parameter as the last argument of the <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">ParameterHandler::declare_entry</a> call. With the exception of the <code>value</code> file, the contents of files are never changed after declaration of a parameter.</li>
</ul>
<p>Alternatively, a directory in this file system may not have a file called <code>value</code> in it. In that case, the directory represents a subsection as declared above, and the directory's name will correspond to the name of the subsection. It will then have no files in it at all, but it may have further directories in it: some of these directories will be parameters (indicates by the presence of files) or further nested subsections.</p>
<p>Given this explanation, the code above will lead to a hierarchical representation of data that looks like this (the content of files is indicated at the right in a different font):</p>
<div class="image">
<img src="parameter_handler.png" alt="parameter_handler.png"/>
</div>
<p>Once parameters have been read in, the contents of the <code>value</code> "files" may be different while the other files remain untouched.</p>
<p>Using the <a class="el" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">ParameterHandler::print_parameters()</a> function with <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">ParameterHandler::XML</a> as second argument, we can get a complete representation of this data structure in XML. It will look like this: </p><div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;utf-8&quot;</span>?&gt;</div><div class="line">&lt;<a class="code" href="classParameterHandler.html">ParameterHandler</a>&gt;</div><div class="line">  &lt;Maximal_20number_20of_20iterations&gt;</div><div class="line">    &lt;value&gt;10&lt;/value&gt;</div><div class="line">    &lt;default_value&gt;10&lt;/default_value&gt;</div><div class="line">    &lt;documentation&gt;A parameter that describes the maximal number of iterations the CG method is to take before giving up on a matrix.&lt;/documentation&gt;</div><div class="line">    &lt;pattern&gt;0&lt;/pattern&gt;</div><div class="line">    &lt;pattern_description&gt;[Integer range 1...1000 (inclusive)]&lt;/pattern_description&gt;</div><div class="line">  &lt;/Maximal_20number_20of_20iterations&gt;</div><div class="line">  &lt;Preconditioner&gt;</div><div class="line">    &lt;Kind&gt;&lt;value&gt;SSOR&lt;/value&gt;</div><div class="line">      &lt;default_value&gt;SSOR&lt;/default_value&gt;</div><div class="line">      &lt;documentation&gt;A <span class="keywordtype">string</span> that describes the kind of preconditioner to use.&lt;/documentation&gt;</div><div class="line">      &lt;pattern&gt;1&lt;/pattern&gt;</div><div class="line">      &lt;pattern_description&gt;SSOR|Jacobi&lt;/pattern_description&gt;</div><div class="line">    &lt;/Kind&gt;</div><div class="line">    &lt;Relaxation_20factor&gt;</div><div class="line">      &lt;value&gt;1.0&lt;/value&gt;</div><div class="line">      &lt;default_value&gt;1.0&lt;/default_value&gt;</div><div class="line">      &lt;documentation&gt;The numerical value (between zero and one) <span class="keywordflow">for</span> the relaxation factor to use in the preconditioner.&lt;/documentation&gt;</div><div class="line">      &lt;pattern&gt;2&lt;/pattern&gt;</div><div class="line">      &lt;pattern_description&gt;[Floating <a class="code" href="namespaceOpenCASCADE.html#a7e8e544997e65b29b37a43e82e2afcbc">point</a> range 0...1 (inclusive)]&lt;/pattern_description&gt;</div><div class="line">    &lt;/Relaxation_20factor&gt;</div><div class="line">  &lt;/Preconditioner&gt;</div><div class="line">&lt;<a class="code" href="classParameterHandler.html">ParameterHandler</a>&gt;</div></div><!-- fragment --><p> This representation closely resembles the directory/file structure discussed above. The only difference is that directory and file names are mangled: since they should only contain letters and numbers, every character in their names that is not a letter or number is replaced by an underscore followed by its two-digit hexadecimal representation. In addition, the special name "value" is mangled when used as the name of a parameter, given that this name is also used to name special files in the hierarchy structure. Finally, the entire tree is wrapped into a tag <code>ParameterHandler</code> to satisfy the XML requirement that there be only a single top-level construct in each file.</p>
<p>The tree structure (and its XML representation) is what the graphical user interface (see above) uses to represent parameters like a directory/file collection.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, October 1997, revised February 1998, 2010, 2011, 2017 </dd>
<dd>
Alberto Sartori, 2015 </dd>
<dd>
David Wells, 2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01665">1665</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8364dda711b93753c6809eefe2a8e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8364dda711b93753c6809eefe2a8e827">&#9670;&nbsp;</a></span>OutputStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of possible output formats.</p>
<p>The formats down the list with prefix <em>Short</em> and bit 6 and 7 set reproduce the old behavior of not writing comments or original values to the files. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365"></a>Text&#160;</td><td class="fielddoc"><p>Write human readable output suitable to be read by <a class="el" href="classParameterHandler.html">ParameterHandler</a> again. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37"></a>LaTeX&#160;</td><td class="fielddoc"><p>Write parameters as a LaTeX table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a"></a>Description&#160;</td><td class="fielddoc"><p>Write out declared parameters with description and possible values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510"></a>XML&#160;</td><td class="fielddoc"><p>Write out everything as an <a href="http://en.wikipedia.org/wiki/XML">XML</a> file.</p>
<p>See the general documentation of this class for an example of output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c"></a>JSON&#160;</td><td class="fielddoc"><p>Write out everything as a <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7"></a>ShortText&#160;</td><td class="fielddoc"><p>Write input for <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01686">1686</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afb9589874569e5442840fe2f5d016924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9589874569e5442840fe2f5d016924">&#9670;&nbsp;</a></span>ParameterHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParameterHandler::ParameterHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inhibit automatic CopyConstructor. </p>

</div>
</div>
<a id="a7aebc6956ea423d376c5fe881b8d5c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebc6956ea423d376c5fe881b8d5c4d">&#9670;&nbsp;</a></span>ParameterHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParameterHandler::ParameterHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01374">1374</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="afb238df795f2c2a788048a688f468fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb238df795f2c2a788048a688f468fcf">&#9670;&nbsp;</a></span>~ParameterHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParameterHandler::~ParameterHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Declare this only to have a virtual destructor, which is safer as we have virtual functions. It actually does nothing spectacular. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01381">1381</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad144b3d53732e7ac72fdacc0223e6ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad144b3d53732e7ac72fdacc0223e6ef6">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParameterHandler.html">ParameterHandler</a>&amp; ParameterHandler::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inhibit automatic assignment operator. </p>

</div>
</div>
<a id="abc4fe419ccc4b128ec2bad5e0dec62ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4fe419ccc4b128ec2bad5e0dec62ac">&#9670;&nbsp;</a></span>read_input() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParameterHandler::read_input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;input&#160;file&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read input from a stream until the stream returns the <code>eof</code> condition or error. The second argument can be used to denote the name of the file (if that's what the input stream represents) we are reading from; this is only used when creating output for error messages.</p>
<p>If non-empty <code>last_line</code> is provided, the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will stop parsing lines after encountering <code>last_line</code> . This is handy when adding extra data that shall be parsed manually.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>This function has been deprecated in favor of the replacement <a class="el" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">ParameterHandler::parse_input</a>, which raises exceptions to indicate errors instead of returning an error code. </dd></dl>

<p>Reimplemented in <a class="el" href="classMultipleParameterLoop.html#ad9154694fd90cb9f9609ebb8ef1379b5">MultipleParameterLoop</a>.</p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01616">1616</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a4f067f0a84ac392fe26d553aea50541b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f067f0a84ac392fe26d553aea50541b">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;input&#160;file&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse each line from a stream until the stream returns the <code>eof</code> condition or error to provide values for known parameter fields. The second argument can be used to denote the name of the file (if that's what the input stream represents) we are reading from; this is only used when creating output for exceptions.</p>
<p>If non-empty <code>last_line</code> is provided, the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will stop parsing lines after encountering <code>last_line</code> . This is handy when adding extra data that shall be parsed manually. </p>

<p>Reimplemented in <a class="el" href="classMultipleParameterLoop.html#a568513bbaec2590025e1d0839e299b36">MultipleParameterLoop</a>.</p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01641">1641</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a298fa0d7fee37560299f7169c30d2614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298fa0d7fee37560299f7169c30d2614">&#9670;&nbsp;</a></span>read_input() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParameterHandler::read_input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>optional</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>write_stripped_file</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read input from a file the name of which is given. The <a class="el" href="classPathSearch.html">PathSearch</a> class "PARAMETERS" is used to find the file.</p>
<p>Unless <code>optional</code> is <code>true</code>, this function will automatically generate the requested file with default values if the file did not exist. This file will not contain additional comments if <code>write_stripped_file</code> is <code>true</code>.</p>
<p>If non-empty <code>last_line</code> is provided, the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will stop parsing lines after encountering <code>last_line</code> . This is handy when adding extra data that shall be parsed manually.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>This function has been deprecated in favor of the replacement <a class="el" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">ParameterHandler::parse_input</a>, which raises exceptions to indicate errors instead of returning an error code. <a class="el" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">ParameterHandler::parse_input</a> does not have the capability to write default values to a file on failure: if you wish to duplicate that old behavior then you should catch the <a class="el" href="group__Exceptions.html#gaf1129b80f170fb81152ac42a2a2e2b27">PathSearch::ExcFileNotFound</a> exception and then call <a class="el" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">ParameterHandler::print_parameters</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01744">1744</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a030e84298d59cfea765f43d8600dee48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030e84298d59cfea765f43d8600dee48">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse the given file to provide values for known parameter fields. The <a class="el" href="classPathSearch.html">PathSearch</a> class "PARAMETERS" is used to find the file.</p>
<p>If non-empty <code>last_line</code> is provided, the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will stop parsing lines after encountering <code>last_line</code> . This is handy when adding extra data that shall be parsed manually. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01777">1777</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a4ed008fd0c025700d02a46b8a8765669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed008fd0c025700d02a46b8a8765669">&#9670;&nbsp;</a></span>read_input_from_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParameterHandler::read_input_from_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read input from a string in memory. The lines in memory have to be separated by <code>\n</code> characters.</p>
<p>If non-empty <code>last_line</code> is provided, the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will stop parsing lines after encountering <code>last_line</code> . This is handy when adding extra data that shall be parsed manually.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>This function has been deprecated in favor of the replacement <a class="el" href="classParameterHandler.html#a50f47346d2bb71a940fb7a63608316ae">ParameterHandler::parse_input_from_string</a>, which raises exceptions to indicate errors instead of returning an error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01790">1790</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a50f47346d2bb71a940fb7a63608316ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f47346d2bb71a940fb7a63608316ae">&#9670;&nbsp;</a></span>parse_input_from_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from a string to populate known parameter fields. The lines in the string must be separated by <code>\n</code> characters.</p>
<p>If non-empty <code>last_line</code> is provided, the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will stop parsing lines after encountering <code>last_line</code> . This is handy when adding extra data that shall be parsed manually. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01815">1815</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af8f285cc4f3d23b92307d5d3c4b8396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f285cc4f3d23b92307d5d3c4b8396d">&#9670;&nbsp;</a></span>read_input_from_xml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ParameterHandler::read_input_from_xml </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a parameter file in XML format. This could be from a file originally written by the <a class="el" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters()</a> function using the XML output style and then modified by hand as necessary; or from a file written using this method and then modified by the graphical parameter GUI (see the general documentation of this class).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>This function has been deprecated in favor of the replacement <a class="el" href="classParameterHandler.html#a739af0d987ea80704f0d322c9723ba84">ParameterHandler::parse_input_from_xml</a>, which raises exceptions to indicate errors instead of returning an error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01908">1908</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a739af0d987ea80704f0d322c9723ba84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739af0d987ea80704f0d322c9723ba84">&#9670;&nbsp;</a></span>parse_input_from_xml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_xml </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from an XML stream to populate known parameter fields. This could be from a file originally written by the <a class="el" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters()</a> function using the XML output style and then modified by hand as necessary, or from a file written using this method and then modified by the graphical parameter GUI (see the general documentation of this class). </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01928">1928</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6184baed4eba575e422161dc86ed12e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6184baed4eba575e422161dc86ed12e3">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all contents. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01981">1981</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="afb951f101e0969416f7f47d24c03bcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb951f101e0969416f7f47d24c03bcfa">&#9670;&nbsp;</a></span>declare_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code><a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a new entry with name <code>entry</code>, default and for which any input has to match the <code>pattern</code> (default: any pattern).</p>
<p>The last parameter defaulting to an empty string is used to add a documenting text to each entry which will be printed as a comment when this class is asked to write out all declarations to a stream using the <a class="el" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters()</a> function.</p>
<p>The function generates an exception of type ExcValueDoesNotMatchPattern if the default value doesn't match the given pattern, using the C++ throw mechanism. However, this exception is only generated <em>after</em> the entry has been created; if you have code where no sensible default value for a parameter is possible, you can then catch and ignore this exception.</p>
<dl class="section note"><dt>Note</dt><dd>An entry can be declared more than once without generating an error, for example to override an earlier default value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01989">1989</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a59f3996003757093fb0e050a6729e81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f3996003757093fb0e050a6729e81b">&#9670;&nbsp;</a></span>add_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::add_action </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const std::string &amp;value)&gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach an action to the parameter with name <code>entry</code> in the current section. The action needs to be a function-like object that takes the value of the parameter as a (string) argument. See the general documentation of this class for a longer description of actions, as well as examples.</p>
<p>The action is executed in three different circumstances:</p><ul>
<li>With the default value of the parameter with name <code>name</code>, at the end of the current function. This is useful because it allows for the action to execute whatever it needs to do at least once for each parameter, even those that are not actually specified in the input file (and thus remain at their default values).</li>
<li>Within the <a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">ParameterHandler::set()</a> functions that explicitly set a value for a parameter.</li>
<li>Within the <a class="el" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input()</a> function and similar functions such as <a class="el" href="classParameterHandler.html#a50f47346d2bb71a940fb7a63608316ae">parse_input_from_string()</a>. Here, the action is executed whenever the parameter with which it is associated is read from the input, after it has been established that the value so read matches the pattern that corresponds to this parameter, and before the value is actually saved.</li>
</ul>
<p>It is valid to add multiple actions to the same parameter. They will in that case be executed in the same order in which they were added.</p>
<dl class="section note"><dt>Note</dt><dd>Actions may modify all sorts of variables in their scope. The only thing an action should not modify is the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object it is attached to. In other words, it is not allowed to enter or leave sections of the current <a class="el" href="classParameterHandler.html">ParameterHandler</a> object. It is, in principle, acceptable to call <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">ParameterHandler::get()</a> and related functions on other parameters in the current section, but since there is no guarantee about the order in which they will be read from an input file, you will not want to rely on the values these functions would return. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02026">2026</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aecb847561585089c4c7fcf51eddece16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb847561585089c4c7fcf51eddece16">&#9670;&nbsp;</a></span>declare_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_alias </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>existing_entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alias_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>alias_is_deprecated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an alias for an existing entry. This provides a way to refer to a parameter in the input file using an alternate name. The alias will be in the current section, and the referenced entry needs to be an existing entry in the current section.</p>
<p>The primary purpose of this function is to allow for a backward compatible way of changing names in input files of applications for which backward compatibility is important. This can be achieved by changing the name of the parameter in the call to <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry()</a>, and then creating an alias that maps the old name to the new name. This way, old input files can continue to refer to parameters under the old name, and they will automatically be mapped to the new parameter name.</p>
<p>It is valid to set the same parameter multiple times in an input file. The value that will ultimately be chosen in such cases is simply the last value set. This rule also applies to aliases, where the final value of a parameter is the last value set either through the current name of the parameter or through any of its possible multiple aliases. For example, if you have an input file that looks like </p><div class="fragment"><div class="line"><span class="keyword">set</span> parm1       = 1</div><div class="line"><span class="keyword">set</span> parm1_alias = 2</div></div><!-- fragment --><p> where <code>parm1_alias</code> is an alias declared via </p><div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (<span class="stringliteral">&quot;parm1&quot;</span>, <span class="stringliteral">&quot;parm1_alias&quot;</span>);</div></div><!-- fragment --><p> then the final value for the parameter called <code>parm1</code> will be 2, not 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">existing_entry_name</td><td>The name of an existing parameter in the current section that the alias should refer to. </td></tr>
    <tr><td class="paramname">alias_name</td><td>An alternate name for the parameter referenced by the first argument. </td></tr>
    <tr><td class="paramname">alias_is_deprecated</td><td>If true, mark the alias as deprecated. This will then be listed in the description of the alias if you call <a class="el" href="classParameterHandler.html#a5d5f6dff73abcca2b6abca8d8a18afa1">print_parameters()</a>, and you will get a warning on the screen when reading an input file that contains this deprecated alias. The purpose of this argument is to be able to allow the use of an old name for a parameter (see above) but make it clear that this old name will eventually be removed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02063">2063</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af29c20cde6d44186806d559beb468696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29c20cde6d44186806d559beb468696">&#9670;&nbsp;</a></span>enter_subsection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::enter_subsection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subsection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enter a subsection. If it does not yet exist, create it. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02121">2121</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a599462cacd492e2f712bf7369507dcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599462cacd492e2f712bf7369507dcff">&#9670;&nbsp;</a></span>leave_subsection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::leave_subsection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave present subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02134">2134</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a91cfbaca954f444047302446a4e87125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cfbaca954f444047302446a4e87125">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code>. If the entry was changed, then the changed value is returned, otherwise the default value. If the value of an undeclared entry is required, an exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02147">2147</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a61fa98fdc0c52980a5b1de0ee1fc5bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fa98fdc0c52980a5b1de0ee1fc5bb2">&#9670;&nbsp;</a></span>get_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code> as <code>long int</code>. (A long int is chosen so that even very large unsigned values can be returned by this function). </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02163">2163</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aeaf3c7846747695b1f327677e3716ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf3c7846747695b1f327677e3716ec5">&#9670;&nbsp;</a></span>get_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>double</code>. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02183">2183</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6bb45dc67787e3fab7882461929b5fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb45dc67787e3fab7882461929b5fbe">&#9670;&nbsp;</a></span>get_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>bool</code>. The entry may be "true" or "yes" for <code>true</code>, "false" or "no" for <code>false</code> respectively. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02203">2203</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa6418ea655b1b550b9dcf63513030196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6418ea655b1b550b9dcf63513030196">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02223">2223</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af288e1fe38ac1a1baf1cef3058b63ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af288e1fe38ac1a1baf1cef3058b63ce1">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but an overload where the second argument is a character pointer. This is necessary, since otherwise the call to <code>set("abc","def")</code> will be mapped to the function taking one string and a bool as arguments, which is certainly not what is most often intended.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02269">2269</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aabb43df4f2325707a82201071793e4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb43df4f2325707a82201071793e4fa">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long int &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02293">2293</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a03d8a002b574cb451240ecf723ab0fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d8a002b574cb451240ecf723ab0fa8">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>For internal purposes, the new value needs to be converted to a string. This is done using 16 digits of accuracy, so the set value and the one you can get back out using <a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double()</a> may differ in the 16th digit.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02278">2278</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="adcee5b1f5f7c6745e8c7b66dcf34104d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcee5b1f5f7c6745e8c7b66dcf34104d">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02307">2307</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5d5f6dff73abcca2b6abca8d8a18afa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5f6dff73abcca2b6abca8d8a18afa1">&#9670;&nbsp;</a></span>print_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print all parameters with the given style to <code>out</code>. Presently only <code>Text</code>, <code>LaTeX</code> and <code>XML</code> are implemented.</p>
<p>In <code>Text</code> format, the output is formatted in such a way that it is possible to use it for later input again. This is most useful to record the parameters for a specific run, since if you output the parameters using this function into a log file, you can always recover the results by simply copying the output to your input file.</p>
<p>Besides the name and value of each entry, the output also contains the default value of entries if it is different from the actual value, as well as the documenting string given to the <a class="el" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry()</a> function if available.</p>
<p>In <code>XML</code> format, the output starts with one root element <code><a class="el" href="classParameterHandler.html">ParameterHandler</a></code> in order to get a valid XML document and all subsections under it.</p>
<p>In <code>LaTeX</code> format, the output contains the same information but in a format so that the resulting file can be input into a latex document such as a manual for the code for which this object handles run-time parameters. The various sections of parameters are then represented by latex section and subsection commands as well as by nested enumerations.</p>
<p>In addition, all parameter names are listed with <code>\index</code> statements in two indices called <code>prmindex</code> (where the name of each parameter is listed in the index) and <code>prmindexfull</code> where parameter names are listed sorted by the section in which they exist. By default, the LaTeX program ignores these <code>\index</code> commands, but they can be used to generate an index by using the following commands in the preamble of the latex file : </p><div class="fragment"><div class="line">\usepackage{imakeidx}</div><div class="line">\makeindex[name=prmindex, title=Index of <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a>-time parameter <a class="code" href="classParameterHandler.html#ae3c753f43844f2c1196d4ef939048bb0">entries</a>]</div><div class="line">\makeindex[name=prmindexfull, title=Index of <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a>-time parameters with section names]</div></div><!-- fragment --><p> and at the end of the file this: </p><div class="fragment"><div class="line">\printindex[prmindex]</div><div class="line">\printindex[prmindexfull]</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02319">2319</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a49597e3b087e9021491630ac15c383ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49597e3b087e9021491630ac15c383ec">&#9670;&nbsp;</a></span>print_parameters_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::print_parameters_section </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>indent_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>include_top_level_elements</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print out the parameters of the present subsection as given by the <code>subsection_path</code> member variable. This variable is controlled by entering and leaving subsections through the <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> and <a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection()</a> functions.</p>
<p>If <code>include_top_level_elements</code> is <code>true</code>, also the higher subsection elements are printed. In <code>XML</code> format this is required to get a valid XML document and output starts with one root element <code><a class="el" href="classParameterHandler.html">ParameterHandler</a></code>.</p>
<p>In most cases, you will not want to use this function directly, but have it called recursively by the previous function. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02408">2408</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af2f4db3ea6cd9414cc39d926a0a0959e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f4db3ea6cd9414cc39d926a0a0959e">&#9670;&nbsp;</a></span>log_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print parameters to a logstream. This function allows to print all parameters into a log-file. Sections will be indented in the usual log- file style. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02911">2911</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ade326782f2aca595c273f3674294bb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade326782f2aca595c273f3674294bb1e">&#9670;&nbsp;</a></span>log_parameters_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log parameters in the present subsection. The subsection is determined by the <code>subsection_path</code> member variable. This variable is controlled by entering and leaving subsections through the <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> and <a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection()</a> functions.</p>
<p>In most cases, you will not want to use this function directly, but have it called recursively by the previous function. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02924">2924</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a0342139603da3b30b132446d94a17b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0342139603da3b30b132446d94a17b25">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ParameterHandler::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l03145">3145</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5df38ff67c1c8352e04de490e0c0a39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df38ff67c1c8352e04de490e0c0a39e">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02809">2809</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="a09fd2ee6d01b78079f894893aacd6c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fd2ee6d01b78079f894893aacd6c4c">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02829">2829</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aede1a749bba8ee11876fd114a16c4f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede1a749bba8ee11876fd114a16c4f3e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ParameterHandler::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l03154">3154</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aab5c45bef2e688478b44c3323b6733f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5c45bef2e688478b44c3323b6733f6">&#9670;&nbsp;</a></span>mangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::mangle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mangle a string so that it doesn't contain any special characters or spaces. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01387">1387</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a703dcf499d53f99829a9bc1b0e408a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703dcf499d53f99829a9bc1b0e408a97">&#9670;&nbsp;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::demangle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unmangle a string into its original form. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01426">1426</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a309a5cd29993c8070462ec3ac70564cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309a5cd29993c8070462ec3ac70564cc">&#9670;&nbsp;</a></span>get_current_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the string that identifies the current path into the property tree. This is only a path, i.e. it is not terminated by the path_separator character. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01584">1584</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aae05819ce1de5de30ad92322fc8fc8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae05819ce1de5de30ad92322fc8fc8da">&#9670;&nbsp;</a></span>get_current_full_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_full_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the name of an entry as argument, the function computes a full path into the parameter tree using the current subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01603">1603</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a4430cca40a4e918a09de37350c1d1cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4430cca40a4e918a09de37350c1d1cdf">&#9670;&nbsp;</a></span>scan_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::scan_line </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>current_line_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scan one line of input. <code>input_filename</code> and <code>current_line_n</code> are the name of the input file and the number of the line presently scanned (these are used in exception messages to show where parse errors occurred). This function will raise an exception if the line contains an undeclared subsection or entry, if the line's entry does not match its given pattern, or if the line could not be understood as a valid parameter file expression.</p>
<p>The function modifies its argument, but also takes it by value, so the caller's variable is not changed. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02959">2959</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a009fb8cb45463ac3a57f8cb371fbc82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009fb8cb45463ac3a57f8cb371fbc82b">&#9670;&nbsp;</a></span>path_separator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char ParameterHandler::path_separator = '.'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The separator used when accessing elements of a path into the parameter tree. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02294">2294</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="ae3c753f43844f2c1196d4ef939048bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c753f43844f2c1196d4ef939048bb0">&#9670;&nbsp;</a></span>entries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;boost::property_tree::ptree&gt; ParameterHandler::entries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The complete tree of sections and entries. See the general documentation of this class for a description how data is stored in this variable.</p>
<p>The variable is a pointer so that we can use an incomplete type, rather than having to include all of the property_tree stuff from boost. This works around a problem with gcc 4.5. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02304">2304</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aeae1e63c7ad972211d55ea21a203073a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae1e63c7ad972211d55ea21a203073a">&#9670;&nbsp;</a></span>patterns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a>&gt; &gt; ParameterHandler::patterns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of patterns that are used to describe the parameters of this object. Every nodes in the property tree corresponding to a parameter stores an index into this array. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02311">2311</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aebf71c4d2431f2296710cd910da7f6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf71c4d2431f2296710cd910da7f6eb">&#9670;&nbsp;</a></span>actions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::function&lt;void (const std::string &amp;)&gt; &gt; ParameterHandler::actions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of actions that are associated with parameters. These are added by the <a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action()</a> function. Nodes in the property tree corresponding to individual parameters store indices into this array in order to reference specific actions. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02319">2319</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aefa5b69fc4d1d56dd6bc90e2dcf24d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa5b69fc4d1d56dd6bc90e2dcf24d56">&#9670;&nbsp;</a></span>subsection_path</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; ParameterHandler::subsection_path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Path of presently selected subsections; empty list means top level </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02335">2335</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/base/<a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/base/<a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
