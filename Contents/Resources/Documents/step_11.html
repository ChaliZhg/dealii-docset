<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-11 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-11 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The problem we will be considering is the solution of Laplace's problem with Neumann boundary conditions only: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\Delta u &amp;=&amp; f \qquad \mathrm{in}\ \Omega, \\ \partial_n u &amp;=&amp; g \qquad \mathrm{on}\ \partial\Omega. \end{eqnarray*}" src="form_1426.png"/>
</p>
<p> It is well known that if this problem is to have a solution, then the forces need to satisfy the compatibility condition </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_\Omega f\; dx + \int_{\partial\Omega} g\; ds = 0. \]" src="form_1427.png"/>
</p>
<p> We will consider the special case that <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> is the circle of radius 1 around the origin, and <img class="formulaInl" alt="$f=-2$" src="form_1428.png"/>, <img class="formulaInl" alt="$g=1$" src="form_1429.png"/>. This choice satisfies the compatibility condition.</p>
<p>The compatibility condition allows a solution of the above equation, but it nevertheless retains an ambiguity: since only derivatives of the solution appear in the equations, the solution is only determined up to a constant. For this reason, we have to pose another condition for the numerical solution, which fixes this constant.</p>
<p>For this, there are various possibilities: </p><ol>
<li>
<p class="startli">Fix one node of the discretization to zero or any other fixed value. This amounts to an additional condition <img class="formulaInl" alt="$u_h(x_0)=0$" src="form_1430.png"/>. Although this is common practice, it is not necessarily a good idea, since we know that the solutions of Laplace's equation are only in <img class="formulaInl" alt="$H^1$" src="form_38.png"/>, which does not allow for the definition of point values because it is not a subset of the continuous functions. Therefore, even though fixing one node is allowed for discretized functions, it is not for continuous functions, and one can often see this in a resulting error spike at this point in the numerical solution.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Fixing the mean value over the domain to zero or any other value. This is allowed on the continuous level, since <img class="formulaInl" alt="$H^1(\Omega)\subset L^1(\Omega)$" src="form_1431.png"/> by Sobolev's inequality, and thus also on the discrete level since we there only consider subsets of <img class="formulaInl" alt="$H^1$" src="form_38.png"/>.</p>
<p class="endli"></p>
</li>
<li>
Fixing the mean value over the boundary of the domain to zero or any other value. This is also allowed on the continuous level, since <img class="formulaInl" alt="$H^{1/2}(\partial\Omega)\subset L^1(\partial\Omega)$" src="form_1432.png"/>, again by Sobolev's inequality. </li>
</ol>
<p>We will choose the last possibility, since we want to demonstrate another technique with it.</p>
<p>While this describes the problem to be solved, we still have to figure out how to implement it. Basically, except for the additional mean value constraint, we have solved this problem several times, using Dirichlet boundary values, and we only need to drop the treatment of Dirichlet boundary nodes. The use of higher order mappings is also rather trivial and will be explained at the various places where we use it; in almost all conceivable cases, you will only consider the objects describing mappings as a black box which you need not worry about, because their only uses seem to be to be passed to places deep inside the library where functions know how to handle them (i.e. in the <code><a class="el" href="classFEValues.html">FEValues</a></code> classes and their descendants).</p>
<p>The tricky point in this program is the use of the mean value constraint. Fortunately, there is a class in the library which knows how to handle such constraints, and we have used it quite often already, without mentioning its generality. Note that if we assume that the boundary nodes are spaced equally along the boundary, then the mean value constraint </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\partial \Omega} u(x) \; ds = 0 \]" src="form_1433.png"/>
</p>
<p> can be written as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i\in\partial\Omega_h} u_i = 0, \]" src="form_1434.png"/>
</p>
<p> where the sum shall run over all degree of freedom indices which are located on the boundary of the computational domain. Let us denote by <img class="formulaInl" alt="$i_0$" src="form_1435.png"/> that index on the boundary with the lowest number (or any other conveniently chosen index), then the constraint can also be represented by </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ u_{i_0} = \sum_{i\in\partial\Omega_h\backslash i_0} -u_i. \]" src="form_1436.png"/>
</p>
<p> This, luckily, is exactly the form of constraints for which the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class was designed. Note that we have used this class in several previous examples for the representation of hanging nodes constraints, which also have this form: there, the middle vertex shall have the mean of the values of the adjacent vertices. In general, the <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> class is designed to handle homogeneous constraints of the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ CU = 0 \]" src="form_1437.png"/>
</p>
<p> where <img class="formulaInl" alt="$C$" src="form_43.png"/> denotes a matrix, and <img class="formulaInl" alt="$U$" src="form_203.png"/> the vector of nodal values.</p>
<p>In this example, the mean value along the boundary allows just such a representation, with <img class="formulaInl" alt="$C$" src="form_43.png"/> being a matrix with just one row (i.e. there is only one constraint). In the implementation, we will create a <a class="el" href="classConstraintMatrix.html">ConstraintMatrix</a> object, add one constraint (i.e. add another row to the matrix) referring to the first boundary node <img class="formulaInl" alt="$i_0$" src="form_1435.png"/>, and insert the weights with which all the other nodes contribute, which in this example happens to be just <img class="formulaInl" alt="$-1$" src="form_248.png"/>.</p>
<p>Later, we will use this object to eliminate the first boundary node from the linear system of equations, reducing it to one which has a solution without the ambiguity of the constant shift value. One of the problems of the implementation will be that the explicit elimination of this node results in a number of additional elements in the matrix, of which we do not know in advance where they are located and how many additional entries will be in each of the rows of the matrix. We will show how we can use an intermediate object to work around this problem.</p>
<p>But now on to the implementation of the program solving this problem... <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>As usual, the program starts with a rather long list of include files which you are probably already used to by now:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/table_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div></div><!-- fragment --><p>Just this one is new: it declares a class <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, which we will use and explain further down below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div></div><!-- fragment --><p>We will make use of the std::find algorithm of the C++ standard library, so we have to include the following file for its declaration:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step11</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>Then we declare a class which represents the solution of a Laplace problem. As this example program is based on <a class="el" href="step_5.html">step-5</a>, the class looks rather the same, with the sole structural difference that the functions <code>assemble_system</code> now calls <code>solve</code> itself, and is thus called <code>assemble_and_solve</code>, and that the output function was dropped since the solution function is so boring that it is not worth being viewed.</p>
<p>The only other noteworthy change is that the constructor takes a value representing the polynomial degree of the mapping to be used later on, and that it has another member variable representing exactly this mapping. In general, this variable will occur in real applications at the same places where the finite element is declared or used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_and_solve ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line">  <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a>        mapping;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     mean_value_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a>         output_table;</div><div class="line">};</div></div><!-- fragment --><p>Construct such an object, by initializing the variables. Here, we use linear finite elements (the argument to the <code>fe</code> variable denotes the polynomial degree), and mappings of given order. Print to screen what we are about to do.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree) :</div><div class="line">  fe (1),</div><div class="line">  dof_handler (triangulation),</div><div class="line">  mapping (mapping_degree)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Using mapping with degree &quot;</span> &lt;&lt; mapping_degree &lt;&lt; <span class="stringliteral">&quot;:&quot;</span></div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;============================&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The first task is to set up the variables for this problem. This includes generating a valid <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object, as well as the sparsity patterns for the matrix, and the object representing the constraints that the mean value of the degrees of freedom on the boundary be zero.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div><div class="line">{</div></div><!-- fragment --><p>The first task is trivial: generate an enumeration of the degrees of freedom, and initialize solution and right hand side vector to their correct sizes:</p>
<div class="fragment"><div class="line">dof_handler.distribute_dofs (fe);</div><div class="line">solution.reinit (dof_handler.n_dofs());</div><div class="line">system_rhs.reinit (dof_handler.n_dofs());</div></div><!-- fragment --><p>Next task is to construct the object representing the constraint that the mean value of the degrees of freedom on the boundary shall be zero. For this, we first want a list of those nodes which are actually at the boundary. The <code><a class="el" href="namespaceDoFTools.html">DoFTools</a></code> namespace has a function that returns an array of Boolean values where <code>true</code> indicates that the node is at the boundary. The second argument denotes a mask selecting which components of vector valued finite elements we want to be considered. This sort of information is encoded using the <a class="el" href="classComponentMask.html">ComponentMask</a> class (see also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). Since we have a scalar finite element anyway, this mask in reality should have only one entry with a <code>true</code> value. However, the <a class="el" href="classComponentMask.html">ComponentMask</a> class has semantics that allow it to represents a mask of indefinite size whose every element equals <code>true</code> when one just default constructs such an object, so this is what we'll do here.</p>
<div class="fragment"><div class="line">std::vector&lt;bool&gt; boundary_dofs (dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a86d1b6b9571b70286f536f150ee9cb9b">DoFTools::extract_boundary_dofs</a> (dof_handler,</div><div class="line">                                 <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                 boundary_dofs);</div></div><!-- fragment --><p>Now first for the generation of the constraints: as mentioned in the introduction, we constrain one of the nodes on the boundary by the values of all other DoFs on the boundary. So, let us first pick out the first boundary node from this list. We do that by searching for the first <code>true</code> value in the array (note that <code>std::find</code> returns an iterator to this element), and computing its distance to the overall first element in the array to get its index:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> first_boundary_dof</div><div class="line">  = std::distance (boundary_dofs.begin(),</div><div class="line">                   std::find (boundary_dofs.begin(),</div><div class="line">                              boundary_dofs.end(),</div><div class="line">                              <span class="keyword">true</span>));</div></div><!-- fragment --><p>Then generate a constraints object with just this one constraint. First clear all previous content (which might reside there from the previous computation on a once coarser grid), then add this one line constraining the <code>first_boundary_dof</code> to the sum of other boundary DoFs each with weight -1. Finally, close the constraints object, i.e. do some internal bookkeeping on it for faster processing of what is to come later:</p>
<div class="fragment"><div class="line">mean_value_constraints.clear ();</div><div class="line">mean_value_constraints.add_line (first_boundary_dof);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=first_boundary_dof+1; i&lt;dof_handler.n_dofs(); ++i)</div><div class="line">  <span class="keywordflow">if</span> (boundary_dofs[i] == <span class="keyword">true</span>)</div><div class="line">    mean_value_constraints.add_entry (first_boundary_dof,</div><div class="line">                                      i, -1);</div><div class="line">mean_value_constraints.close ();</div></div><!-- fragment --><p>Next task is to generate a sparsity pattern. This is indeed a tricky task here. Usually, we just call <code><a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a></code> and condense the result using the hanging node constraints. We have no hanging node constraints here (since we only refine globally in this example), but we have this global constraint on the boundary. This poses one severe problem in this context: the <code><a class="el" href="classSparsityPattern.html">SparsityPattern</a></code> class wants us to state beforehand the maximal number of entries per row, either for all rows or for each row separately. There are functions in the library which can tell you this number in case you just have hanging node constraints (namely <code>DoFHandler::max_coupling_between_dofs</code>), but how is this for the present case? The difficulty arises because the elimination of the constrained degree of freedom requires a number of additional entries in the matrix at places that are not so simple to determine. We would therefore have a problem had we to give a maximal number of entries per row here.</p>
<p>Since this can be so difficult that no reasonable answer can be given that allows allocation of only a reasonable amount of memory, there is a class <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, that can help us out here. It does not require that we know in advance how many entries rows could have, but allows just about any length. It is thus significantly more flexible in case you do not have good estimates of row lengths, however at the price that building up such a pattern is also significantly more expensive than building up a pattern for which you had information in advance. Nevertheless, as we have no other choice here, we'll just build such an object by initializing it with the dimensions of the matrix and calling another function <code><a class="el" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a></code> to get the sparsity pattern due to the differential operator, then condense it with the constraints object which adds those positions in the sparsity pattern that are required for the elimination of the constraint.</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.n_dofs(),</div><div class="line">                            dof_handler.n_dofs());</div><div class="line"><a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">mean_value_constraints.condense (dsp);</div></div><!-- fragment --><p>Finally, once we have the full pattern, we can initialize an object of type <code><a class="el" href="classSparsityPattern.html">SparsityPattern</a></code> from it and in turn initialize the matrix with it. Note that this is actually necessary, since the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> is so inefficient compared to the <code><a class="el" href="classSparsityPattern.html">SparsityPattern</a></code> class due to the more flexible data structures it has to use, that we can impossibly base the sparse matrix class on it, but rather need an object of type <code><a class="el" href="classSparsityPattern.html">SparsityPattern</a></code>, which we generate by copying from the intermediate object.</p>
<p>As a further sidenote, you will notice that we do not explicitly have to <code>compress</code> the sparsity pattern here. This, of course, is due to the fact that the <code>copy_from</code> function generates a compressed object right from the start, to which you cannot add new entries anymore. The <code>compress</code> call is therefore implicit in the <code>copy_from</code> call.</p>
<div class="fragment"><div class="line">  sparsity_pattern.copy_from (dsp);</div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p>The next function then assembles the linear system of equations, solves it, and evaluates the solution. This then makes three actions, and we will put them into eight true statements (excluding declaration of variables, and handling of temporary vectors). Thus, this function is something for the very lazy. Nevertheless, the functions called are rather powerful, and through them this function uses a good deal of the whole library. But let's look at each of the steps.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_and_solve ()</div><div class="line">{</div></div><!-- fragment --><p>First, we have to assemble the matrix and the right hand side. In all previous examples, we have investigated various ways how to do this manually. However, since the Laplace matrix and simple right hand sides appear so frequently in applications, the library provides functions for actually doing this for you, i.e. they perform the loop over all cells, setting up the local matrices and vectors, and putting them together for the end result.</p>
<p>The following are the two most commonly used ones: creation of the Laplace matrix and creation of a right hand side vector from body or boundary forces. They take the mapping object, the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object representing the degrees of freedom and the finite element in use, a quadrature formula to be used, and the output object. The function that creates a right hand side vector also has to take a function object describing the (continuous) right hand side function.</p>
<p>Let us look at the way the matrix and body forces are integrated:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gauss_degree</div><div class="line">  = std::max (static_cast&lt;unsigned int&gt;(std::ceil(1.*(mapping.get_degree()+1)/2)),</div><div class="line">              2U);</div><div class="line">MatrixTools::create_laplace_matrix (mapping, dof_handler,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(gauss_degree),</div><div class="line">                                    system_matrix);</div><div class="line"><a class="code" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">VectorTools::create_right_hand_side</a> (mapping, dof_handler,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(gauss_degree),</div><div class="line">                                     <a class="code" href="classConstantFunction.html">ConstantFunction&lt;dim&gt;</a>(-2),</div><div class="line">                                     system_rhs);</div></div><!-- fragment --><p>That's quite simple, right?</p>
<p>Two remarks are in order, though: First, these functions are used in a lot of contexts. Maybe you want to create a Laplace or mass matrix for a vector values finite element; or you want to use the default Q1 mapping; or you want to assembled the matrix with a coefficient in the Laplace operator. For this reason, there are quite a large number of variants of these functions in the <code><a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a></code> and <code><a class="el" href="namespaceMatrixTools.html">MatrixTools</a></code> namespaces. Whenever you need a slightly different version of these functions than the ones called above, it is certainly worthwhile to take a look at the documentation and to check whether something fits your needs.</p>
<p>The second remark concerns the quadrature formula we use: we want to integrate over bilinear shape functions, so we know that we have to use at least an order two Gauss quadrature formula. On the other hand, we want the quadrature rule to have at least the order of the boundary approximation. Since the order of Gauss rule with <img class="formulaInl" alt="$r$" src="form_267.png"/> points is <img class="formulaInl" alt="$2r - 1$" src="form_1438.png"/>, and the order of the boundary approximation using polynomials of degree <img class="formulaInl" alt="$p$" src="form_202.png"/> is <img class="formulaInl" alt="$p+1$" src="form_353.png"/>, we know that <img class="formulaInl" alt="$2r \geq p$" src="form_1439.png"/>. Since r has to be an integer and (as mentioned above) has to be at least <img class="formulaInl" alt="$2$" src="form_1440.png"/>, this makes up for the formula above computing <code>gauss_degree</code>.</p>
<p>Since the generation of the body force contributions to the right hand side vector was so simple, we do that all over again for the boundary forces as well: allocate a vector of the right size and call the right function. The boundary function has constant values, so we can generate an object from the library on the fly, and we use the same quadrature formula as above, but this time of lower dimension since we integrate over faces now instead of cells:</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (system_rhs.size());</div><div class="line"><a class="code" href="namespaceVectorTools.html#afdeb976be4183ae259c4390f14e9eca0">VectorTools::create_boundary_right_hand_side</a> (mapping, dof_handler,</div><div class="line">                                              <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(gauss_degree),</div><div class="line">                                              <a class="code" href="classConstantFunction.html">ConstantFunction&lt;dim&gt;</a>(1),</div><div class="line">                                              tmp);</div></div><!-- fragment --><p>Then add the contributions from the boundary to those from the interior of the domain:</p>
<div class="fragment"><div class="line">system_rhs += tmp;</div></div><!-- fragment --><p>For assembling the right hand side, we had to use two different vector objects, and later add them together. The reason we had to do so is that the <code><a class="el" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">VectorTools::create_right_hand_side</a></code> and <code><a class="el" href="namespaceVectorTools.html#afdeb976be4183ae259c4390f14e9eca0">VectorTools::create_boundary_right_hand_side</a></code> functions first clear the output vector, rather than adding up their results to previous contents. This can reasonably be called a design flaw in the library made in its infancy, but unfortunately things are as they are for some time now and it is difficult to change such things that silently break existing code, so we have to live with that.</p>
<p>Now, the linear system is set up, so we can eliminate the one degree of freedom which we constrained to the other DoFs on the boundary for the mean value constraint from matrix and right hand side vector, and solve the system. After that, distribute the constraints again, which in this case means setting the constrained degree of freedom to its proper value</p>
<div class="fragment"><div class="line">mean_value_constraints.condense (system_matrix);</div><div class="line">mean_value_constraints.condense (system_rhs);</div><div class="line"></div><div class="line">solve ();</div><div class="line">mean_value_constraints.distribute (solution);</div></div><!-- fragment --><p>Finally, evaluate what we got as solution. As stated in the introduction, we are interested in the H1 semi-norm of the solution. Here, as well, we have a function in the library that does this, although in a slightly non-obvious way: the <code><a class="el" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a></code> function integrates the norm of the difference between a finite element function and a continuous function. If we therefore want the norm of a finite element field, we just put the continuous function to zero. Note that this function, just as so many other ones in the library as well, has at least two versions, one which takes a mapping as argument (which we make us of here), and the one which we have used in previous examples which implicitly uses <code><a class="el" href="classMappingQ1.html">MappingQ1</a></code>. Also note that we take a quadrature formula of one degree higher, in order to avoid superconvergence effects where the solution happens to be especially close to the exact solution at certain points (we don't know whether this might be the case here, but there are cases known of this, and we just want to make sure):</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> norm_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (mapping, dof_handler,</div><div class="line">                                   solution,</div><div class="line">                                   <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                   norm_per_cell,</div><div class="line">                                   <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(gauss_degree+1),</div><div class="line">                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div></div><!-- fragment --><p>Then, the function just called returns its results as a vector of values each of which denotes the norm on one cell. To get the global norm, we do the following:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a4cee9f4ad877f0d0c471a72affe91df7">norm</a> = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                      norm_per_cell,</div><div class="line">                                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div></div><!-- fragment --><p>Last task &ndash; generate output:</p>
<div class="fragment"><div class="line">  output_table.add_value (<span class="stringliteral">&quot;cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  output_table.add_value (<span class="stringliteral">&quot;|u|_1&quot;</span>, norm);</div><div class="line">  output_table.add_value (<span class="stringliteral">&quot;error&quot;</span>, std::fabs(norm-std::sqrt(3.14159265358/2)));</div><div class="line">}</div></div><!-- fragment --><p>The following function solving the linear system of equations is copied from <a class="el" href="step_5.html">step-5</a> and is explained there in some detail:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">  cg.solve (system_matrix, solution, system_rhs,</div><div class="line">            preconditioner);</div><div class="line">}</div></div><!-- fragment --><p>Finally the main function controlling the different steps to be performed. Its content is rather straightforward, generating a triangulation of a circle, associating a boundary to it, and then doing several cycles on subsequently finer grids. Note again that we have put mesh refinement into the loop header; this may be something for a test program, but for real applications you should consider that this implies that the mesh is refined after the loop is executed the last time since the increment clause (the last part of the three-parted loop header) is executed before the comparison part (the second one), which may be rather costly if the mesh is already quite refined. In that case, you should arrange code such that the mesh is not further refined after the last loop run (or you should do it at the beginning of each run except for the first one).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a0a81f736ef95164a9d9bf0f844ac682b">GridGenerator::hyper_ball</a> (triangulation);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> boundary;</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, boundary);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle, triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1))</div><div class="line">    {</div><div class="line">      setup_system ();</div><div class="line">      assemble_and_solve ();</div><div class="line">    };</div></div><!-- fragment --><p>After all the data is generated, write a table of results to the screen:</p>
<div class="fragment"><div class="line">    output_table.set_precision(<span class="stringliteral">&quot;|u|_1&quot;</span>, 6);</div><div class="line">    output_table.set_precision(<span class="stringliteral">&quot;error&quot;</span>, 6);</div><div class="line">    output_table.write_text (std::cout);</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Finally the main function. It's structure is the same as that used in several of the previous examples, so probably needs no more explanation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      std::cout.precision(5);</div></div><!-- fragment --><p>This is the main loop, doing the computations with mappings of linear through cubic mappings. Note that since we need the object of type <code>LaplaceProblem&lt;2&gt;</code> only once, we do not even name it, but create an unnamed such object and call the <code>run</code> function of it, subsequent to which it is immediately destroyed again.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree=1; mapping_degree&lt;=3; ++mapping_degree)</div><div class="line">        Step11::LaplaceProblem&lt;2&gt;(mapping_degree).run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>This is what the program outputs: </p><div class="fragment"><div class="line">Using mapping with degree 1:</div><div class="line">============================</div><div class="line">cells  |u|_1    error   </div><div class="line">    5 0.680402 0.572912 </div><div class="line">   20 1.085518 0.167796 </div><div class="line">   80 1.208981 0.044334 </div><div class="line">  320 1.242041 0.011273 </div><div class="line"> 1280 1.250482 0.002832 </div><div class="line"> 5120 1.252605 0.000709 </div><div class="line"></div><div class="line">Using mapping with degree 2:</div><div class="line">============================</div><div class="line">cells  |u|_1    error   </div><div class="line">    5 1.050963 0.202351 </div><div class="line">   20 1.199642 0.053672 </div><div class="line">   80 1.239913 0.013401 </div><div class="line">  320 1.249987 0.003327 </div><div class="line"> 1280 1.252486 0.000828 </div><div class="line"> 5120 1.253108 0.000206 </div><div class="line"></div><div class="line">Using mapping with degree 3:</div><div class="line">============================</div><div class="line">cells  |u|_1    error   </div><div class="line">    5 1.086161 0.167153 </div><div class="line">   20 1.204349 0.048965 </div><div class="line">   80 1.240502 0.012812 </div><div class="line">  320 1.250059 0.003255 </div><div class="line"> 1280 1.252495 0.000819 </div><div class="line"> 5120 1.253109 0.000205 </div></div><!-- fragment --><p> As we expected, the convergence order for each of the different mappings is clearly quadratic in the mesh size. What <em>is</em> interesting, though, is that the error for a bilinear mapping (i.e. degree 1) is more than three times larger than that for the higher order mappings; it is therefore clearly advantageous in this case to use a higher order mapping, not because it improves the order of convergence but just to reduce the constant before the convergence order. On the other hand, using a cubic mapping only improves the result further insignificantly, except for the case of very coarse grids. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2001 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 2001</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/table_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/solver_cg.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/precondition.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/constraint_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/mapping_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step11</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream.html#a0c5d332d74a4df80784140218896b169">run</a> ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_and_solve ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   triangulation;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>            fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>      dof_handler;</div><div class="line">    <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a>        mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classConstraintMatrix.html">ConstraintMatrix</a>     mean_value_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       solution;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTableHandler.html">TableHandler</a>         output_table;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree) :</div><div class="line">    fe (1),</div><div class="line">    dof_handler (triangulation),</div><div class="line">    mapping (mapping_degree)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Using mapping with degree &quot;</span> &lt;&lt; mapping_degree &lt;&lt; <span class="stringliteral">&quot;:&quot;</span></div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;============================&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs (fe);</div><div class="line">    solution.reinit (dof_handler.n_dofs());</div><div class="line">    system_rhs.reinit (dof_handler.n_dofs());</div><div class="line"></div><div class="line">    std::vector&lt;bool&gt; boundary_dofs (dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a86d1b6b9571b70286f536f150ee9cb9b">DoFTools::extract_boundary_dofs</a> (dof_handler,</div><div class="line">                                     <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                     boundary_dofs);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> first_boundary_dof</div><div class="line">      = std::distance (boundary_dofs.begin(),</div><div class="line">                       std::find (boundary_dofs.begin(),</div><div class="line">                                  boundary_dofs.end(),</div><div class="line">                                  <span class="keyword">true</span>));</div><div class="line"></div><div class="line">    mean_value_constraints.clear ();</div><div class="line">    mean_value_constraints.add_line (first_boundary_dof);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=first_boundary_dof+1; i&lt;dof_handler.n_dofs(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (boundary_dofs[i] == <span class="keyword">true</span>)</div><div class="line">        mean_value_constraints.add_entry (first_boundary_dof,</div><div class="line">                                          i, -1);</div><div class="line">    mean_value_constraints.close ();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp (dof_handler.n_dofs(),</div><div class="line">                                dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">    mean_value_constraints.condense (dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.copy_from (dsp);</div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_and_solve ()</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gauss_degree</div><div class="line">      = std::max (static_cast&lt;unsigned int&gt;(std::ceil(1.*(mapping.get_degree()+1)/2)),</div><div class="line">                  2U);</div><div class="line">    MatrixTools::create_laplace_matrix (mapping, dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(gauss_degree),</div><div class="line">                                        system_matrix);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ad18037ddbd9cc65a77ffca01ddc347f5">VectorTools::create_right_hand_side</a> (mapping, dof_handler,</div><div class="line">                                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(gauss_degree),</div><div class="line">                                         <a class="code" href="classConstantFunction.html">ConstantFunction&lt;dim&gt;</a>(-2),</div><div class="line">                                         system_rhs);</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (system_rhs.size());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#afdeb976be4183ae259c4390f14e9eca0">VectorTools::create_boundary_right_hand_side</a> (mapping, dof_handler,</div><div class="line">                                                  <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a>(gauss_degree),</div><div class="line">                                                  <a class="code" href="classConstantFunction.html">ConstantFunction&lt;dim&gt;</a>(1),</div><div class="line">                                                  tmp);</div><div class="line">    system_rhs += tmp;</div><div class="line"></div><div class="line">    mean_value_constraints.condense (system_matrix);</div><div class="line">    mean_value_constraints.condense (system_rhs);</div><div class="line"></div><div class="line">    solve ();</div><div class="line">    mean_value_constraints.distribute (solution);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> norm_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac092dccd5ef1349dc207353450b58af1">VectorTools::integrate_difference</a> (mapping, dof_handler,</div><div class="line">                                       solution,</div><div class="line">                                       <a class="code" href="classZeroFunction.html">ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                       norm_per_cell,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(gauss_degree+1),</div><div class="line">                                       <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> norm = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                          norm_per_cell,</div><div class="line">                                                          <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">    output_table.add_value (<span class="stringliteral">&quot;cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    output_table.add_value (<span class="stringliteral">&quot;|u|_1&quot;</span>, norm);</div><div class="line">    output_table.add_value (<span class="stringliteral">&quot;error&quot;</span>, std::fabs(norm-std::sqrt(3.14159265358/2)));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>           solver_control (1000, 1e-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a>              cg (solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;&gt;</a> preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2);</div><div class="line"></div><div class="line">    cg.solve (system_matrix, solution, system_rhs,</div><div class="line">              preconditioner);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a0a81f736ef95164a9d9bf0f844ac682b">GridGenerator::hyper_ball</a> (triangulation);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> boundary;</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, boundary);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle=0; cycle&lt;6; ++cycle, triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1))</div><div class="line">      {</div><div class="line">        setup_system ();</div><div class="line">        assemble_and_solve ();</div><div class="line">      };</div><div class="line"></div><div class="line">    output_table.set_precision(<span class="stringliteral">&quot;|u|_1&quot;</span>, 6);</div><div class="line">    output_table.set_precision(<span class="stringliteral">&quot;error&quot;</span>, 6);</div><div class="line">    output_table.write_text (std::cout);</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      std::cout.precision(5);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mapping_degree=1; mapping_degree&lt;=3; ++mapping_degree)</div><div class="line">        Step11::LaplaceProblem&lt;2&gt;(mapping_degree).run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
