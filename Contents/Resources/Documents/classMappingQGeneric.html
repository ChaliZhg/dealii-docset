<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MappingQGeneric&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMappingQGeneric-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MappingQGeneric&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__mapping.html">Mappings between reference and real cell</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mapping__q__generic_8h_source.html">deal.II/fe/mapping_q_generic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MappingQGeneric&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMappingQGeneric__inherit__graph.svg" width="803" height="238"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric_1_1InternalData.html">InternalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee0be7d2834d4d5fd2004c5dd986b689"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#aee0be7d2834d4d5fd2004c5dd986b689">MappingQGeneric</a> (const unsigned int <a class="el" href="classMappingQGeneric.html#ad003bfed73fda03fa261b3c10f64da15">polynomial_degree</a>)</td></tr>
<tr class="separator:aee0be7d2834d4d5fd2004c5dd986b689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baa8ee5dbef2db30620cfe49bc72c33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a9baa8ee5dbef2db30620cfe49bc72c33">MappingQGeneric</a> (const <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt; &amp;mapping)</td></tr>
<tr class="separator:a9baa8ee5dbef2db30620cfe49bc72c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2e6acc6c6aed5af45bb5563ad254fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a0d2e6acc6c6aed5af45bb5563ad254fa">clone</a> () const</td></tr>
<tr class="separator:a0d2e6acc6c6aed5af45bb5563ad254fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1990c7922dbb8ec6ddd2ff58514d501b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a1990c7922dbb8ec6ddd2ff58514d501b">get_degree</a> () const</td></tr>
<tr class="separator:a1990c7922dbb8ec6ddd2ff58514d501b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c54836387403977d79c06fe3a508ff"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a44c54836387403977d79c06fe3a508ff">preserves_vertex_locations</a> () const</td></tr>
<tr class="separator:a44c54836387403977d79c06fe3a508ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapping points between reference and real cells</div></td></tr>
<tr class="memitem:a0be969518a739b8a25985838562424a1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a0be969518a739b8a25985838562424a1">transform_unit_to_real_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a0be969518a739b8a25985838562424a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d2de8231cc82320efd73e81fdb4561"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a18d2de8231cc82320efd73e81fdb4561">transform_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:a18d2de8231cc82320efd73e81fdb4561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to transform tensors from reference to real coordinates</div></td></tr>
<tr class="memitem:a135247564b3f3e143c68c1647af43601"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a135247564b3f3e143c68c1647af43601">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;input, const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a> type, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;output) const</td></tr>
<tr class="separator:a135247564b3f3e143c68c1647af43601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83384b0236a81dac299e62b5d6686077"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a83384b0236a81dac299e62b5d6686077">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt; &gt; &amp;input, const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a> type, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;output) const</td></tr>
<tr class="separator:a83384b0236a81dac299e62b5d6686077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0ec0311773bd695a95063f033715a0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a9d0ec0311773bd695a95063f033715a0">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &amp;input, const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a> type, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;output) const</td></tr>
<tr class="separator:a9d0ec0311773bd695a95063f033715a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace31a815948d81a67a4296399f85e2c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ace31a815948d81a67a4296399f85e2c2">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt; &gt; &amp;input, const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a> type, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &gt; &amp;output) const</td></tr>
<tr class="separator:ace31a815948d81a67a4296399f85e2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad004f040f84238d506e700fa30e838b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#aad004f040f84238d506e700fa30e838b">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; &gt; &amp;input, const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a> type, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &gt; &amp;output) const</td></tr>
<tr class="separator:aad004f040f84238d506e700fa30e838b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interface with FEValues</div></td></tr>
<tr class="memitem:abfbdd06849b017c0352b5885e4034717"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#abfbdd06849b017c0352b5885e4034717">requires_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const</td></tr>
<tr class="separator:abfbdd06849b017c0352b5885e4034717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd3a3951a0c737db624d8130eb8beac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMappingQGeneric_1_1InternalData.html">InternalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature) const</td></tr>
<tr class="separator:a5cd3a3951a0c737db624d8130eb8beac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ba29890ddf6cae379f048fbea3765d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMappingQGeneric_1_1InternalData.html">InternalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a40ba29890ddf6cae379f048fbea3765d">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature) const</td></tr>
<tr class="separator:a40ba29890ddf6cae379f048fbea3765d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71492951b0eb0912539c2a4e0d1ac36"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMappingQGeneric_1_1InternalData.html">InternalData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ac71492951b0eb0912539c2a4e0d1ac36">get_subface_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature) const</td></tr>
<tr class="separator:ac71492951b0eb0912539c2a4e0d1ac36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55d922ed15d4d53ae126426c28ab823"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:ae55d922ed15d4d53ae126426c28ab823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94e9446e73a4bebd9c7d8f7151b7c63"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ad94e9446e73a4bebd9c7d8f7151b7c63">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned int face_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:ad94e9446e73a4bebd9c7d8f7151b7c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bcbbd83ca6364488c9fa996e86d4a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a43bcbbd83ca6364488c9fa996e86d4a9">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned int face_no, const unsigned int subface_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a43bcbbd83ca6364488c9fa996e86d4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classMapping"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classMapping')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classMapping.html">Mapping&lt; dim, spacedim &gt;</a></td></tr>
<tr class="memitem:a7444ce51c635a3b39baaab526022014a inherit pub_methods_classMapping"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a7444ce51c635a3b39baaab526022014a">~Mapping</a> ()</td></tr>
<tr class="separator:a7444ce51c635a3b39baaab526022014a inherit pub_methods_classMapping"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1a3d331d1ed2134f6b665ad6140b20 inherit pub_methods_classMapping"><td class="memItemLeft" align="right" valign="top">virtual std::array&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a7d1a3d331d1ed2134f6b665ad6140b20">get_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:a7d1a3d331d1ed2134f6b665ad6140b20 inherit pub_methods_classMapping"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dcd3cd0ebe3e9c688475693d89e02a inherit pub_methods_classMapping"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim-1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#ab4dcd3cd0ebe3e9c688475693d89e02a">project_real_point_to_unit_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned int &amp;face_no, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:ab4dcd3cd0ebe3e9c688475693d89e02a inherit pub_methods_classMapping"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#ae5541017c0966b0af345db75895106f2">Subscriptor</a> ()</td></tr>
<tr class="separator:ae5541017c0966b0af345db75895106f2 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a367fce3122075f05f168d14f114b4c65">Subscriptor</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a367fce3122075f05f168d14f114b4c65 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a784c7e88d73f34092db1073065285a74">Subscriptor</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:a784c7e88d73f34092db1073065285a74 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af70e597a147c532012a3115cf12ef53c">~Subscriptor</a> ()</td></tr>
<tr class="separator:af70e597a147c532012a3115cf12ef53c inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5099175b75089cdc5cf4e7e64829f739">operator=</a> (const <a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;)</td></tr>
<tr class="separator:a5099175b75089cdc5cf4e7e64829f739 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#afb0bb2af06c0bba1c0c077b5bbb9a63b">operator=</a> (<a class="el" href="classSubscriptor.html">Subscriptor</a> &amp;&amp;)</td></tr>
<tr class="separator:afb0bb2af06c0bba1c0c077b5bbb9a63b inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a2e2361483105cd1b8a795bfe4a112c05">subscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a2e2361483105cd1b8a795bfe4a112c05 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a86aa7c5a8ecd9ecdd37cf556c3432417">unsubscribe</a> (const char *identifier=nullptr) const</td></tr>
<tr class="separator:a86aa7c5a8ecd9ecdd37cf556c3432417 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38 inherit pub_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a30567734a9cfb887bd36d7c0216187fd"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a30567734a9cfb887bd36d7c0216187fd">compute_mapping_support_points</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:a30567734a9cfb887bd36d7c0216187fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5c1ec190e6d300c5379ab4c6171241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a0c5c1ec190e6d300c5379ab4c6171241">transform_real_to_unit_cell_internal</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;initial_p_unit) const</td></tr>
<tr class="separator:a0c5c1ec190e6d300c5379ab4c6171241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae72af38999e52d2cb91ce67db37b4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a3ae72af38999e52d2cb91ce67db37b4f">add_line_support_points</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;a) const</td></tr>
<tr class="separator:a3ae72af38999e52d2cb91ce67db37b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0b6cc1cf814fa38cc87a239b71fa44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a7e0b6cc1cf814fa38cc87a239b71fa44">add_quad_support_points</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;a) const</td></tr>
<tr class="separator:a7e0b6cc1cf814fa38cc87a239b71fa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interface with FEValues</div></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad003bfed73fda03fa261b3c10f64da15"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ad003bfed73fda03fa261b3c10f64da15">polynomial_degree</a></td></tr>
<tr class="separator:ad003bfed73fda03fa261b3c10f64da15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d3c66105c695d441e4053641f44862"><td class="memItemLeft" align="right" valign="top">const std::unique_ptr&lt; <a class="el" href="classFE__Q.html">FE_Q</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a12d3c66105c695d441e4053641f44862">fe_q</a></td></tr>
<tr class="separator:a12d3c66105c695d441e4053641f44862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae7e52c89fa786c131cad80ee1d30d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#abae7e52c89fa786c131cad80ee1d30d8">support_point_weights_perimeter_to_interior</a></td></tr>
<tr class="separator:abae7e52c89fa786c131cad80ee1d30d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140f4ae6369f6692312dfde765058d94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a140f4ae6369f6692312dfde765058d94">support_point_weights_cell</a></td></tr>
<tr class="separator:a140f4ae6369f6692312dfde765058d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a42293d07f83fabc8a6891ef5fc8d7f36"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:a42293d07f83fabc8a6891ef5fc8d7f36"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a42293d07f83fabc8a6891ef5fc8d7f36">MappingQ</a></td></tr>
<tr class="separator:a42293d07f83fabc8a6891ef5fc8d7f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classMapping"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classMapping')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classMapping.html">Mapping&lt; dim, spacedim &gt;</a></td></tr>
<tr class="memitem:gaf5f5ee163bb21b7b164077a60df8de68 inherit pub_static_methods_classMapping"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5f5ee163bb21b7b164077a60df8de68">ExcInvalidData</a> ()</td></tr>
<tr class="separator:gaf5f5ee163bb21b7b164077a60df8de68 inherit pub_static_methods_classMapping"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d73c62039509e0f04c04102ace3071a inherit pub_static_methods_classMapping"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9d73c62039509e0f04c04102ace3071a">ExcTransformationFailed</a> ()</td></tr>
<tr class="separator:ga9d73c62039509e0f04c04102ace3071a inherit pub_static_methods_classMapping"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ccd424cc06737b3bdc77bbb7df09ff inherit pub_static_methods_classMapping"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa1ccd424cc06737b3bdc77bbb7df09ff">ExcDistortedMappedCell</a> (<a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; arg1, double arg2, int arg3)</td></tr>
<tr class="separator:gaa1ccd424cc06737b3bdc77bbb7df09ff inherit pub_static_methods_classMapping"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSubscriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSubscriptor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSubscriptor.html">Subscriptor</a></td></tr>
<tr class="memitem:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa411bb134ecadcb6b1923cea2f8fa5c6">ExcInUse</a> (int arg1, char *arg2, std::string &amp;arg3)</td></tr>
<tr class="separator:gaa411bb134ecadcb6b1923cea2f8fa5c6 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36f6678dfb5521614fab8bb38f5179a1">ExcNoSubscriber</a> (char *arg1, char *arg2)</td></tr>
<tr class="separator:ga36f6678dfb5521614fab8bb38f5179a1 inherit pub_static_methods_classSubscriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class MappingQGeneric&lt; dim, spacedim &gt;</h3>

<p>This class implements the functionality for polynomial mappings <img class="formulaInl" alt="$Q_p$" src="form_175.png"/> of polynomial degree <img class="formulaInl" alt="$p$" src="form_202.png"/> that will be used on all cells of the mesh. The <a class="el" href="classMappingQ1.html">MappingQ1</a> and <a class="el" href="classMappingQ.html">MappingQ</a> classes specialize this behavior slightly.</p>
<p>The class is poorly named. It should really have been called <a class="el" href="classMappingQ.html">MappingQ</a> because it consistently uses <img class="formulaInl" alt="$Q_p$" src="form_175.png"/> mappings on all cells of a triangulation. However, the name <a class="el" href="classMappingQ.html">MappingQ</a> was already taken when we rewrote the entire class hierarchy for mappings. One might argue that one should always use <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> over the existing class <a class="el" href="classMappingQ.html">MappingQ</a> (which, unless explicitly specified during the construction of the object, only uses mappings of degree <img class="formulaInl" alt="$p$" src="form_202.png"/> <em>on cells at the boundary of the domain</em>). On the other hand, there are good reasons to use <a class="el" href="classMappingQ.html">MappingQ</a> in many situations: in many situations, curved domains are only provided with information about how exactly edges at the boundary are shaped, but we do not know anything about internal edges. Thus, in the absence of other information, we can only assume that internal edges are straight lines, and in that case internal cells may as well be treated is bilinear quadrilaterals or trilinear hexahedra. (An example of how such meshes look is shown in <a class="el" href="step_1.html">step-1</a> already, but it is also discussed in the "Results" section of <a class="el" href="step_6.html">step-6</a>.) Because bi-/trilinear mappings are significantly cheaper to compute than higher order mappings, it is advantageous in such situations to use the higher order mapping only on cells at the boundary of the domain &ndash; i.e., the behavior of <a class="el" href="classMappingQ.html">MappingQ</a>. Of course, <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> also uses bilinear mappings for interior cells as long as it has no knowledge about curvature of interior edges, but it implements this the expensive way: as a general <img class="formulaInl" alt="$Q_p$" src="form_175.png"/> mapping where the mapping support points just <em>happen</em> to be arranged along linear or bilinear edges or faces.</p>
<p>There are a number of special cases worth considering:</p><ul>
<li>If you really want to use a higher order mapping for all cells, you can do this using the current class, but this only makes sense if you can actually provide information about how interior edges and faces of the mesh should be curved. This is typically done by associating a <a class="el" href="classManifold.html">Manifold</a> with interior cells and edges. A simple example of this is discussed in the "Results" section of <a class="el" href="step_6.html">step-6</a>; a full discussion of manifolds is provided in <a class="el" href="step_53.html">step-53</a>.</li>
<li>If you are working on meshes that describe a (curved) manifold embedded in higher space dimensions, i.e., if dim!=spacedim, then every cell is at the boundary of the domain you will likely already have attached a manifold object to all cells that can then also be used by the mapping classes for higher order mappings.</li>
</ul>
<h4>Behavior along curved boundaries and with different manifolds</h4>
<p>As described above, one often only knows a manifold description of a surface but not the interior of the computational domain. In such a case, a <a class="el" href="classStraightBoundary.html">StraightBoundary</a> object will be assigned to the interior entities that describes a usual planar coordinate system where the additional points for the higher order mapping are placed exactly according to a bi-/trilinear mapping. When combined with a non-flat manifold on the boundary, for example a circle bulging into the interior of a square cell, the two manifold descriptions are in general incompatible. For example, a <a class="el" href="classFlatManifold.html">FlatManifold</a> defined solely through the cell's vertices would put an interior point located at some small distance epsilon away from the boundary along a straight line and thus in general outside the concave part of a circle. If the polynomial degree of <a class="el" href="classMappingQ.html">MappingQ</a> is sufficiently high, the transformation from the reference cell to such a cell would in general contain inverted regions close to the boundary.</p>
<p>In order to avoid this situation, this class applies a smoothing on cells adjacent to the boundary by using so-called Laplace smoothing by default. In the algorithm that computes additional points, the <a class="el" href="classMappingQGeneric.html#a30567734a9cfb887bd36d7c0216187fd">compute_mapping_support_points()</a> method, all the entities of the cells are passed through hierarchically, starting from the lines to the quads and finally hexes. Points on objects higher up in the hierarchy are obtained from the manifold associated with that object, taking into account all the points previously computed by the manifolds associated with the lower-dimensional objects, not just the vertices. If only a line is assigned a curved boundary but the adjacent quad is on a flat manifold, the flat manifold on the quad will take the points on the deformed line into account when interpolating the position of the additional points inside the quad and thus always result in a well-defined transformation.</p>
<p>While the smoothing approach works well for filling holes or avoiding inversions with low and medium convergence orders up to approximately three to four, there is nonetheless an inherent shortcoming when switching from a curved manifold to a flat manifold over a face (and the associated smoothing). The finite element theory (see e.g. Strang and Fix, 1973, Sections 2.2 and 3.3 and in particular Theorem 3.6) requires the transformation to be globally C^0 continuous also over several elements and to be uniform as the mesh is refined. Even though the Laplace smoothing fixes the discontinuity within one layer of cells, it cannot provide uniformity as the change is always within one layer of elements only. For example, the convergence rates for solving the Laplacian on a circle where only the boundary is deformed and the above mesh smoothing algorithm is applied will typically not exceed 3.5 (or 3 in the elements adjacent to the boundary), even for fourth or fifth degree polynomials. In such a case, the curved manifold needs to be switched to a flat manifold in a smooth way that does not depend on the mesh size and eventually covers a region of cells instead of only those that are immediately adjacent to the circular boundary.</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2015, Martin Kronbichler, 2017 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00136">136</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aee0be7d2834d4d5fd2004c5dd986b689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0be7d2834d4d5fd2004c5dd986b689">&#9670;&nbsp;</a></span>MappingQGeneric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>polynomial_degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. <code>polynomial_degree</code> denotes the polynomial degree of the polynomials that are used to map cells from the reference to the real cell. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01252">1252</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a9baa8ee5dbef2db30620cfe49bc72c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baa8ee5dbef2db30620cfe49bc72c33">&#9670;&nbsp;</a></span>MappingQGeneric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01267">1267</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0d2e6acc6c6aed5af45bb5563ad254fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2e6acc6c6aed5af45bb5563ad254fa">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; * <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to a copy of the present object. The caller of this copy then assumes ownership of it.</p>
<p>The function is declared abstract virtual in this base class, and derived classes will have to implement it.</p>
<p>This function is mainly used by the <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a> class. </p>

<p>Implements <a class="el" href="classMapping.html#a75966d88035c79a7fb8902721c608144">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classMappingQ1Eulerian.html#a2ed488d53964bb81103bb286f5956bb0">MappingQ1Eulerian&lt; dim, VectorType, spacedim &gt;</a>, and <a class="el" href="classMappingQ1.html#abcae73468cf70a57c479826196a6dd6b">MappingQ1&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01281">1281</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a1990c7922dbb8ec6ddd2ff58514d501b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1990c7922dbb8ec6ddd2ff58514d501b">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::get_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the degree of the mapping, i.e. the value which was passed to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01291">1291</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a44c54836387403977d79c06fe3a508ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c54836387403977d79c06fe3a508ff">&#9670;&nbsp;</a></span>preserves_vertex_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::preserves_vertex_locations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Always returns <code>true</code> because the default implementation of functions in this class preserves vertex locations. </p>

<p>Implements <a class="el" href="classMapping.html#accdebb05aa5f08dda54941868ce9fbe8">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classMappingQ1Eulerian.html#a7794a816b74402bd8517cec82eeeed65">MappingQ1Eulerian&lt; dim, VectorType, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a0be969518a739b8a25985838562424a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be969518a739b8a25985838562424a1">&#9670;&nbsp;</a></span>transform_unit_to_real_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform_unit_to_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps the point <code>p</code> on the unit cell to the corresponding point on the real cell <code>cell</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Iterator to the cell that will be used to define the mapping. </td></tr>
    <tr><td class="paramname">p</td><td>Location of a point on the reference cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The location of the reference point mapped to real space using the mapping defined by the class derived from the current one that implements the mapping, and the coordinates of the cell identified by the first argument. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#ae5df63553eb8ed170c3b90524853dd48">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01301">1301</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a18d2de8231cc82320efd73e81fdb4561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d2de8231cc82320efd73e81fdb4561">&#9670;&nbsp;</a></span>transform_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps the point <code>p</code> on the real <code>cell</code> to the corresponding point on the unit cell, and return its coordinates. This function provides the inverse of the mapping provided by <a class="el" href="classMappingQGeneric.html#a0be969518a739b8a25985838562424a1">transform_unit_to_real_cell()</a>.</p>
<p>In the codimension one case, this function returns the normal projection of the real point <code>p</code> on the curve or surface identified by the <code>cell</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Polynomial mappings from the reference (unit) cell coordinates to the coordinate system of a real cell are not always invertible if the point for which the inverse mapping is to be computed lies outside the cell's boundaries. In such cases, the current function may fail to compute a point on the reference cell whose image under the mapping equals the given point <code>p</code>. If this is the case then this function throws an exception of type <a class="el" href="group__Exceptions.html#ga9d73c62039509e0f04c04102ace3071a">Mapping::ExcTransformationFailed</a> . Whether the given point <code>p</code> lies outside the cell can therefore be determined by checking whether the returned reference coordinates lie inside or outside the reference cell (e.g., using <a class="el" href="structGeometryInfo.html#ace2d235da3d7459096d535d360bcf3d3">GeometryInfo::is_inside_unit_cell()</a>) or whether the exception mentioned above has been thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Iterator to the cell that will be used to define the mapping. </td></tr>
    <tr><td class="paramname">p</td><td>Location of a point on the given cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference cell location of the point that when mapped to real space equals the coordinates given by the second argument. This mapping uses the mapping defined by the class derived from the current one that implements the mapping, and the coordinates of the cell identified by the first argument. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01825">1825</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a135247564b3f3e143c68c1647af43601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135247564b3f3e143c68c1647af43601">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a field of vectors or 1-differential forms according to the selected MappingType.</p>
<dl class="section note"><dt>Note</dt><dd>Normally, this function is called by a finite element, filling <a class="el" href="classFEValues.html">FEValues</a> objects. For this finite element, there should be an alias MappingType like <code>mapping_bdm</code>, <code>mapping_nedelec</code>, etc. This alias should be preferred to using the types below.</dd></dl>
<p>The mapping types currently implemented by derived classes are: </p><ul>
<li>
<p class="startli"><code>mapping_contravariant:</code> maps a vector field on the reference cell to the physical cell through the Jacobian: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})\hat{\mathbf u}(\hat{\mathbf x}). \]" src="form_774.png"/>
</p>
<p> In physics, this is usually referred to as the contravariant transformation. Mathematically, it is the push forward of a vector field.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>mapping_covariant:</code> maps a field of one-forms on the reference cell to a field of one-forms on the physical cell. (Theoretically this would refer to a DerivativeForm&lt;1,dim,1&gt; but we canonically identify this type with a <a class="el" href="classTensor.html">Tensor&lt;1,dim&gt;</a>). Mathematically, it is the pull back of the differential form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}\hat{\mathbf u}(\hat{\mathbf x}). \]" src="form_775.png"/>
</p>
<p> Gradients of scalar differentiable functions are transformed this way.</p>
<p>In the case when dim=spacedim the previous formula reduces to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})^{-T}\hat{\mathbf u}(\hat{\mathbf x}) \]" src="form_776.png"/>
</p>
<p> because we assume that the mapping <img class="formulaInl" alt="$\mathbf F_K$" src="form_55.png"/> is always invertible, and consequently its Jacobian <img class="formulaInl" alt="$J$" src="form_777.png"/> is an invertible matrix.</p>
<p class="endli"></p>
</li>
<li>
<code>mapping_piola:</code> A field of <em>dim-1</em>-forms on the reference cell is also represented by a vector field, but again transforms differently, namely by the Piola transform <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\mathbf x)} J(\mathbf x) \hat{\mathbf u}(\mathbf x). \]" src="form_778.png"/>
</p>
 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a>, <a class="el" href="classMappingQGeneric.html#a40ba29890ddf6cae379f048fbea3765d">get_face_data()</a>, or <a class="el" href="classMappingQGeneric.html#ac71492951b0eb0912539c2a4e0d1ac36">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a>, <a class="el" href="classMappingQGeneric.html#ad94e9446e73a4bebd9c7d8f7151b7c63">fill_fe_face_values()</a>, or <a class="el" href="classMappingQGeneric.html#a43bcbbd83ca6364488c9fa996e86d4a9">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. (Note that the array view is <code>const</code>, but the tensors it points to are not.) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a3ce74638006ce574195c55a69aa48d79">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03433">3433</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a83384b0236a81dac299e62b5d6686077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83384b0236a81dac299e62b5d6686077">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a field of differential forms from the reference cell to the physical cell. It is useful to think of <img class="formulaInl" alt="$\mathbf{T} = \nabla \mathbf u$" src="form_779.png"/> and <img class="formulaInl" alt="$\hat{\mathbf T} = \hat \nabla \hat{\mathbf u}$" src="form_780.png"/>, with <img class="formulaInl" alt="$\mathbf u$" src="form_220.png"/> a vector field. The mapping types currently implemented by derived classes are: </p><ul>
<li>
<p class="startli"><code>mapping_covariant:</code> maps a field of forms on the reference cell to a field of forms on the physical cell. Mathematically, it is the pull back of the differential form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf T(\mathbf x) = \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]" src="form_781.png"/>
</p>
<p> Jacobians of spacedim-vector valued differentiable functions are transformed this way.</p>
<p class="endli">In the case when dim=spacedim the previous formula reduces to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf T(\mathbf x) = \hat{\mathbf u}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]" src="form_782.png"/>
</p>
 </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>It would have been more reasonable to make this transform a template function with the rank in <code><a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, dim, rank&gt;</code>. Unfortunately C++ does not allow templatized virtual functions. This is why we identify <code><a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, dim, 1&gt;</code> with a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> when using <a class="el" href="group__mapping.html#ggaf0a4d6be70322c742c12da1edccbb74da35d1e9fba325e2d103c1fea732fc05b1">mapping_covariant()</a> in the function <a class="el" href="classMappingQGeneric.html#a135247564b3f3e143c68c1647af43601">transform()</a> above this one.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a>, <a class="el" href="classMappingQGeneric.html#a40ba29890ddf6cae379f048fbea3765d">get_face_data()</a>, or <a class="el" href="classMappingQGeneric.html#ac71492951b0eb0912539c2a4e0d1ac36">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a>, <a class="el" href="classMappingQGeneric.html#ad94e9446e73a4bebd9c7d8f7151b7c63">fill_fe_face_values()</a>, or <a class="el" href="classMappingQGeneric.html#a43bcbbd83ca6364488c9fa996e86d4a9">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. (Note that the array view is <code>const</code>, but the tensors it points to are not.) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#aeb9f5b92acb083dcebc3fb18f09724fb">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03446">3446</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a9d0ec0311773bd695a95063f033715a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0ec0311773bd695a95063f033715a0">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a tensor field from the reference cell to the physical cell. These tensors are usually the Jacobians in the reference cell of vector fields that have been pulled back from the physical cell. The mapping types currently implemented by derived classes are: </p><ul>
<li>
<code>mapping_contravariant_gradient:</code> it assumes <img class="formulaInl" alt="$\mathbf u(\mathbf x) = J \hat{\mathbf u}$" src="form_783.png"/> so that <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]" src="form_784.png"/>
</p>
 </li>
<li>
<code>mapping_covariant_gradient:</code> it assumes <img class="formulaInl" alt="$\mathbf u(\mathbf x) = J^{-T} \hat{\mathbf u}$" src="form_785.png"/> so that <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x})^{-T} \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]" src="form_786.png"/>
</p>
 </li>
<li>
<code>mapping_piola_gradient:</code> it assumes <img class="formulaInl" alt="$\mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\mathbf x)} J(\mathbf x) \hat{\mathbf u}(\mathbf x)$" src="form_787.png"/> so that <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf T(\mathbf x) = \frac{1}{\text{det}\;J(\mathbf x)} J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]" src="form_788.png"/>
</p>
 </li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo:</a></b></dt><dd>The formulas for mapping_covariant_gradient, mapping_contravariant_gradient and mapping_piola_gradient are only true as stated for linear mappings. If, for example, the mapping is bilinear (or has a higher order polynomial degree) then there is a missing term associated with the derivative of <img class="formulaInl" alt="$J$" src="form_777.png"/>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a>, <a class="el" href="classMappingQGeneric.html#a40ba29890ddf6cae379f048fbea3765d">get_face_data()</a>, or <a class="el" href="classMappingQGeneric.html#ac71492951b0eb0912539c2a4e0d1ac36">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a>, <a class="el" href="classMappingQGeneric.html#ad94e9446e73a4bebd9c7d8f7151b7c63">fill_fe_face_values()</a>, or <a class="el" href="classMappingQGeneric.html#a43bcbbd83ca6364488c9fa996e86d4a9">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. (Note that the array view is <code>const</code>, but the tensors it points to are not.) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#abc32cce6d5845f877c20543e8473568d">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03459">3459</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="ace31a815948d81a67a4296399f85e2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace31a815948d81a67a4296399f85e2c2">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a tensor field from the reference cell to the physical cell. This tensors are most of times the hessians in the reference cell of vector fields that have been pulled back from the physical cell.</p>
<p>The mapping types currently implemented by derived classes are: </p><ul>
<li>
<p class="startli"><code>mapping_covariant_gradient:</code> maps a field of forms on the reference cell to a field of forms on the physical cell. Mathematically, it is the pull back of the differential form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf T_{ijk}(\mathbf x) = \hat{\mathbf T}_{iJK}(\hat{\mathbf x}) J_{jJ}^{\dagger} J_{kK}^{\dagger}\]" src="form_789.png"/>
</p>
<p>,</p>
<p class="endli">where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ J^{\dagger} = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]" src="form_790.png"/>
</p>
 </li>
</ul>
<p>Hessians of spacedim-vector valued differentiable functions are transformed this way (After subtraction of the product of the derivative with the Jacobian gradient).</p>
<p>In the case when dim=spacedim the previous formula reduces to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[J^{\dagger} = J^{-1}\]" src="form_791.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a>, <a class="el" href="classMappingQGeneric.html#a40ba29890ddf6cae379f048fbea3765d">get_face_data()</a>, or <a class="el" href="classMappingQGeneric.html#ac71492951b0eb0912539c2a4e0d1ac36">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a>, <a class="el" href="classMappingQGeneric.html#ad94e9446e73a4bebd9c7d8f7151b7c63">fill_fe_face_values()</a>, or <a class="el" href="classMappingQGeneric.html#a43bcbbd83ca6364488c9fa996e86d4a9">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. (Note that the array view is <code>const</code>, but the tensors it points to are not.) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#aa8eb9c907f7f8d7e076be4c9fed5792d">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03485">3485</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="aad004f040f84238d506e700fa30e838b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad004f040f84238d506e700fa30e838b">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gaf0a4d6be70322c742c12da1edccbb74d">MappingType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a field of 3-differential forms from the reference cell to the physical cell. It is useful to think of <img class="formulaInl" alt="$\mathbf{T}_{ijk} = D^2_{jk} \mathbf u_i$" src="form_792.png"/> and <img class="formulaInl" alt="$\mathbf{\hat T}_{IJK} = \hat D^2_{JK} \mathbf{\hat u}_I$" src="form_793.png"/>, with <img class="formulaInl" alt="$\mathbf u_i$" src="form_794.png"/> a vector field.</p>
<p>The mapping types currently implemented by derived classes are: </p><ul>
<li>
<code>mapping_contravariant_hessian:</code> it assumes <img class="formulaInl" alt="$\mathbf u_i(\mathbf x) = J_{iI} \hat{\mathbf u}_I$" src="form_795.png"/> so that <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf T_{ijk}(\mathbf x) = J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]" src="form_796.png"/>
</p>
 </li>
<li>
<code>mapping_covariant_hessian:</code> it assumes <img class="formulaInl" alt="$\mathbf u_i(\mathbf x) = J_{iI}^{-T} \hat{\mathbf u}_I$" src="form_797.png"/> so that <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf T_{ijk}(\mathbf x) = J_iI(\hat{\mathbf x})^{-1} \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]" src="form_798.png"/>
</p>
 </li>
<li>
<code>mapping_piola_hessian:</code> it assumes <img class="formulaInl" alt="$\mathbf u_i(\mathbf x) = \frac{1}{\text{det}\;J(\mathbf x)} J_{iI}(\mathbf x) \hat{\mathbf u}(\mathbf x)$" src="form_799.png"/> so that <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf T_{ijk}(\mathbf x) = \frac{1}{\text{det}\;J(\mathbf x)} J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]" src="form_800.png"/>
</p>
 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a>, <a class="el" href="classMappingQGeneric.html#a40ba29890ddf6cae379f048fbea3765d">get_face_data()</a>, or <a class="el" href="classMappingQGeneric.html#ac71492951b0eb0912539c2a4e0d1ac36">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a>, <a class="el" href="classMappingQGeneric.html#ad94e9446e73a4bebd9c7d8f7151b7c63">fill_fe_face_values()</a>, or <a class="el" href="classMappingQGeneric.html#a43bcbbd83ca6364488c9fa996e86d4a9">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#afbc1697a494b4f150068453bcfc6b895">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03534">3534</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="abfbdd06849b017c0352b5885e4034717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbdd06849b017c0352b5885e4034717">&#9670;&nbsp;</a></span>requires_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of update flags, compute which other quantities <em>also</em> need to be computed in order to satisfy the request by the given flags. Then return the combination of the original set of flags and those just computed.</p>
<p>As an example, if <code>update_flags</code> contains update_JxW_values (i.e., the product of the determinant of the Jacobian and the weights provided by the quadrature formula), a mapping may require the computation of the full Jacobian matrix in order to compute its determinant. They would then return not just update_JxW_values, but also update_jacobians. (This is not how it is actually done internally in the derived classes that compute the JxW values &ndash; they set update_contravariant_transformation instead, from which the determinant can also be computed &ndash; but this does not take away from the instructiveness of the example.)</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a4c62b5a55ca40e2b38c6a3a1f460d540">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01965">1965</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a5cd3a3951a0c737db624d8130eb8beac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd3a3951a0c737db624d8130eb8beac">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::<a class="el" href="classMappingQGeneric_1_1InternalData.html">InternalData</a> * <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create and return a pointer to an object into which mappings can store data that only needs to be computed once but that can then be used whenever the mapping is applied to a concrete cell (e.g., in the various <a class="el" href="classMappingQGeneric.html#a135247564b3f3e143c68c1647af43601">transform()</a> functions, as well as in the <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a>, <a class="el" href="classMappingQGeneric.html#ad94e9446e73a4bebd9c7d8f7151b7c63">fill_fe_face_values()</a> and <a class="el" href="classMappingQGeneric.html#a43bcbbd83ca6364488c9fa996e86d4a9">fill_fe_subface_values()</a> that form the interface of mappings with the <a class="el" href="classFEValues.html">FEValues</a> class).</p>
<p>Derived classes will return pointers to objects of a type derived from <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> (see there for more information) and may pre- compute some information already (in accordance with what will be asked of the mapping in the future, as specified by the update flags) and for the given quadrature object. Subsequent calls to <a class="el" href="classMappingQGeneric.html#a135247564b3f3e143c68c1647af43601">transform()</a> or <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a> and friends will then receive back the object created here (with the same set of update flags and for the same quadrature object). Derived classes can therefore pre-compute some information in their <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a> function and store it in the internal data object.</p>
<p>The mapping classes do not keep track of the objects created by this function. Ownership will therefore rest with the caller.</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>A set of flags that define what is expected of the mapping class in future calls to <a class="el" href="classMappingQGeneric.html#a135247564b3f3e143c68c1647af43601">transform()</a> or the <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a> group of functions. This set of flags may contain flags that mappings do not know how to deal with (e.g., for information that is in fact computed by the finite element classes, such as UpdateFlags::update_values). Derived classes will need to store these flags, or at least that subset of flags that will require the mapping to perform any actions in <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a>, in <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>The quadrature object for which mapping information will have to be computed. This includes the locations and weights of quadrature points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a newly created object of type InternalDataBase (or a derived class). Ownership of this object passes to the calling function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++ allows that virtual functions in derived classes may return pointers to objects not of type InternalDataBase but in fact pointers to objects of classes <em>derived</em> from InternalDataBase. (This feature is called "covariant return types".) This is useful in some contexts where the calling is within the derived class and will immediately make use of the returned object, knowing its real (derived) type. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a32ec2960edbcf550baf4eade254e941f">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l02025">2025</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a40ba29890ddf6cae379f048fbea3765d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ba29890ddf6cae379f048fbea3765d">&#9670;&nbsp;</a></span>get_face_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::<a class="el" href="classMappingQGeneric_1_1InternalData.html">InternalData</a> * <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a>, but in preparation for later calls to <a class="el" href="classMappingQGeneric.html#a135247564b3f3e143c68c1647af43601">transform()</a> or <a class="el" href="classMappingQGeneric.html#ad94e9446e73a4bebd9c7d8f7151b7c63">fill_fe_face_values()</a> that will need information about mappings from the reference face to a face of a concrete cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>A set of flags that define what is expected of the mapping class in future calls to <a class="el" href="classMappingQGeneric.html#a135247564b3f3e143c68c1647af43601">transform()</a> or the <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a> group of functions. This set of flags may contain flags that mappings do not know how to deal with (e.g., for information that is in fact computed by the finite element classes, such as UpdateFlags::update_values). Derived classes will need to store these flags, or at least that subset of flags that will require the mapping to perform any actions in <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a>, in <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>The quadrature object for which mapping information will have to be computed. This includes the locations and weights of quadrature points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a newly created object of type InternalDataBase (or a derived class). Ownership of this object passes to the calling function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++ allows that virtual functions in derived classes may return pointers to objects not of type InternalDataBase but in fact pointers to objects of classes <em>derived</em> from InternalDataBase. (This feature is called "covariant return types".) This is useful in some contexts where the calling is within the derived class and will immediately make use of the returned object, knowing its real (derived) type. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a8e679601d9927b8096e88b64acd00920">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l02038">2038</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="ac71492951b0eb0912539c2a4e0d1ac36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71492951b0eb0912539c2a4e0d1ac36">&#9670;&nbsp;</a></span>get_subface_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::<a class="el" href="classMappingQGeneric_1_1InternalData.html">InternalData</a> * <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a> and <a class="el" href="classMappingQGeneric.html#a40ba29890ddf6cae379f048fbea3765d">get_face_data()</a>, but in preparation for later calls to <a class="el" href="classMappingQGeneric.html#a135247564b3f3e143c68c1647af43601">transform()</a> or <a class="el" href="classMappingQGeneric.html#a43bcbbd83ca6364488c9fa996e86d4a9">fill_fe_subface_values()</a> that will need information about mappings from the reference face to a child of a face (i.e., subface) of a concrete cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>A set of flags that define what is expected of the mapping class in future calls to <a class="el" href="classMappingQGeneric.html#a135247564b3f3e143c68c1647af43601">transform()</a> or the <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a> group of functions. This set of flags may contain flags that mappings do not know how to deal with (e.g., for information that is in fact computed by the finite element classes, such as UpdateFlags::update_values). Derived classes will need to store these flags, or at least that subset of flags that will require the mapping to perform any actions in <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a>, in <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>The quadrature object for which mapping information will have to be computed. This includes the locations and weights of quadrature points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a newly created object of type InternalDataBase (or a derived class). Ownership of this object passes to the calling function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++ allows that virtual functions in derived classes may return pointers to objects not of type InternalDataBase but in fact pointers to objects of classes <em>derived</em> from InternalDataBase. (This feature is called "covariant return types".) This is useful in some contexts where the calling is within the derived class and will immediately make use of the returned object, knowing its real (derived) type. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a2b696ccfd041ad95801bf2c4152f3c96">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l02053">2053</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="ae55d922ed15d4d53ae126426c28ab823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55d922ed15d4d53ae126426c28ab823">&#9670;&nbsp;</a></span>fill_fe_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute information about the mapping from the reference cell to the real cell indicated by the first argument to this function. Derived classes will have to implement this function based on the kind of mapping they represent. It is called by <a class="el" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">FEValues::reinit()</a>.</p>
<p>Conceptually, this function's represents the application of the mapping <img class="formulaInl" alt="$\mathbf x=\mathbf F_K(\hat {\mathbf x})$" src="form_770.png"/> from reference coordinates <img class="formulaInl" alt="$\mathbf\in [0,1]^d$" src="form_771.png"/> to real space coordinates <img class="formulaInl" alt="$\mathbf x$" src="form_751.png"/> for a given cell <img class="formulaInl" alt="$K$" src="form_57.png"/>. Its purpose is to compute the following kinds of data:</p>
<ul>
<li>Data that results from the application of the mapping itself, e.g., computing the location <img class="formulaInl" alt="$\mathbf x_q = \mathbf F_K(\hat{\mathbf x}_q)$" src="form_772.png"/> of quadrature points on the real cell, and that is directly useful to users of <a class="el" href="classFEValues.html">FEValues</a>, for example during assembly.</li>
<li>Data that is necessary for finite element implementations to compute their shape functions on the real cell. To this end, the <a class="el" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">FEValues::reinit()</a> function calls <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a> after the current function, and the output of this function serves as input to <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a>. Examples of information that needs to be computed here for use by the finite element classes is the Jacobian of the mapping, <img class="formulaInl" alt="$\hat\nabla \mathbf F_K(\hat{\mathbf x})$" src="form_773.png"/> or its inverse, for example to transform the gradients of shape functions on the reference cell to the gradients of shape functions on the real cell.</li>
</ul>
<p>The information computed by this function is used to fill the various member variables of the output argument of this function. Which of the member variables of that structure should be filled is determined by the update flags stored in the <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> object passed to this function.</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_similarity</td><td>Whether or not the cell given as first argument is simply a translation, rotation, etc of the cell for which this function was called the most recent time. This information is computed simply by matching the vertices (as stored by the <a class="el" href="classTriangulation.html">Triangulation</a>) between the previous and the current cell. The value passed here may be modified by implementations of this function and should then be returned (see the discussion of the return value of this function). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The object is used both to map the location of quadrature points, as well as to compute the JxW values for each quadrature point (which involves the quadrature weights). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>A reference to an object previously created by <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>internal_data</code> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An updated value of the <code>cell_similarity</code> argument to this function. The returned value will be used for the corresponding argument when <a class="el" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">FEValues::reinit()</a> calls <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a>. In most cases, derived classes will simply want to return the value passed for <code>cell_similarity</code>. However, implementations of this function may downgrade the level of cell similarity. This is, for example, the case for classes that take not only into account the locations of the vertices of a cell (as reported by the <a class="el" href="classTriangulation.html">Triangulation</a>), but also other information specific to the mapping. The purpose is that <a class="el" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">FEValues::reinit()</a> can compute whether a cell is similar to the previous one only based on the cell's vertices, whereas the mapping may also consider displacement fields (e.g., in the <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a> and <a class="el" href="classMappingFEField.html">MappingFEField</a> classes). In such cases, the mapping may conclude that the previously computed cell similarity is too optimistic, and invalidate it for subsequent use in <a class="el" href="classFiniteElement.html#aa1bb7b495d2e578d58d6858430369fd2">FiniteElement::fill_fe_values()</a> by returning a less optimistic cell similarity value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classFEValues.html">FEValues</a> ensures that this function is always called with the same pair of <code>internal_data</code> and <code>output_data</code> objects. In other words, if an implementation of this function knows that it has written a piece of data into the output argument in a previous call, then there is no need to copy it there again in a later call if the implementation knows that this is the same value. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a66184bd60355f99a7c549552c9365d52">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l02614">2614</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="ad94e9446e73a4bebd9c7d8f7151b7c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94e9446e73a4bebd9c7d8f7151b7c63">&#9670;&nbsp;</a></span>fill_fe_face_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the equivalent to <a class="el" href="classMapping.html#a66184bd60355f99a7c549552c9365d52">Mapping::fill_fe_values()</a>, but for faces of cells. See there for an extensive discussion of its purpose. It is called by <a class="el" href="classFEFaceValues.html#af6e079ca7429d54433343d50bd334c3c">FEFaceValues::reinit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>The number of the face of the given cell for which information is requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The object is used both to map the location of quadrature points, as well as to compute the JxW values for each quadrature point (which involves the quadrature weights). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>A reference to an object previously created by <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>internal_data</code> object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#adf2c7688080ec3dada06ecfb674c62e4">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03022">3022</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a43bcbbd83ca6364488c9fa996e86d4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bcbbd83ca6364488c9fa996e86d4a9">&#9670;&nbsp;</a></span>fill_fe_subface_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>subface_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValues_1_1MappingRelatedData.html">internal::FEValues::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the equivalent to <a class="el" href="classMapping.html#a66184bd60355f99a7c549552c9365d52">Mapping::fill_fe_values()</a>, but for subfaces (i.e., children of faces) of cells. See there for an extensive discussion of its purpose. It is called by <a class="el" href="classFESubfaceValues.html#a31715f7c441dd083cc02ea72859fb9a3">FESubfaceValues::reinit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>The number of the face of the given cell for which information is requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subface_no</td><td>The number of the child of a face of the given cell for which information is requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The object is used both to map the location of quadrature points, as well as to compute the JxW values for each quadrature point (which involves the quadrature weights). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>A reference to an object previously created by <a class="el" href="classMappingQGeneric.html#a5cd3a3951a0c737db624d8130eb8beac">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>internal_data</code> object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a65697226ba5af97f43ded0df5320f735">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03066">3066</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a30567734a9cfb887bd36d7c0216187fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30567734a9cfb887bd36d7c0216187fd">&#9670;&nbsp;</a></span>compute_mapping_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::compute_mapping_support_points </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the locations of support points for the mapping. For example, for <img class="formulaInl" alt="$Q_1$" src="form_37.png"/> mappings these are the vertices, and for higher order polynomial mappings they are the vertices plus interior points on edges, faces, and the cell interior that are placed in consultation with the <a class="el" href="classManifold.html">Manifold</a> description of the domain and its boundary. However, other classes may override this function differently. In particular, the <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a> class does exactly this by not computing the support points from the geometry of the current cell but instead evaluating an externally given displacement field in addition to the geometry of the cell.</p>
<p>The default implementation of this function is appropriate for most cases. It takes the locations of support points on the boundary of the cell from the underlying manifold. Interior support points (ie. support points in quads for 2d, in hexes for 3d) are then computed using the solution of a Laplace equation with the position of the outer support points as boundary values, in order to make the transformation as smooth as possible.</p>
<p>The function works its way from the vertices (which it takes from the given cell) via the support points on the line (for which it calls the <a class="el" href="classMappingQGeneric.html#a3ae72af38999e52d2cb91ce67db37b4f">add_line_support_points()</a> function) and the support points on the quad faces (in 3d, for which it calls the <a class="el" href="classMappingQGeneric.html#a7e0b6cc1cf814fa38cc87a239b71fa44">add_quad_support_points()</a> function). It then adds interior support points that are either computed by interpolation from the surrounding points using weights computed by solving a Laplace equation, or if dim&lt;spacedim, it asks the underlying manifold for the locations of interior points. </p>

<p>Reimplemented in <a class="el" href="classMappingQEulerian_1_1MappingQEulerianGeneric.html#a1a67c256a85e3ce633f966809a1b660b">MappingQEulerian&lt; dim, VectorType, spacedim &gt;::MappingQEulerianGeneric</a>, and <a class="el" href="classMappingQ1Eulerian.html#a8ad7040ae57673d4a7c5e9ea7a8247f4">MappingQ1Eulerian&lt; dim, VectorType, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03784">3784</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a0c5c1ec190e6d300c5379ab4c6171241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5c1ec190e6d300c5379ab4c6171241">&#9670;&nbsp;</a></span>transform_real_to_unit_cell_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform_real_to_unit_cell_internal </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_p_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the point <code>p</code> on the real cell to the corresponding point on the unit cell <code>cell</code> by a Newton iteration. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01669">1669</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a3ae72af38999e52d2cb91ce67db37b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae72af38999e52d2cb91ce67db37b4f">&#9670;&nbsp;</a></span>add_line_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::add_line_support_points </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For <code>dim=2,3</code>. Append the support points of all shape functions located on bounding lines of the given cell to the vector <code>a</code>. Points located on the vertices of a line are not included.</p>
<p>Needed by the <code>compute_support_points()</code> function. For <code>dim=1</code> this function is empty. The function uses the underlying manifold object of the line (or, if none is set, of the cell) for the location of the requested points.</p>
<p>This function is made virtual in order to allow derived classes to choose shape function support points differently than the present class, which chooses the points as interpolation points on the boundary. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03578">3578</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a7e0b6cc1cf814fa38cc87a239b71fa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0b6cc1cf814fa38cc87a239b71fa44">&#9670;&nbsp;</a></span>add_quad_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::add_quad_support_points </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For <code>dim=3</code>. Append the support points of all shape functions located on bounding faces (quads in 3d) of the given cell to the vector <code>a</code>. Points located on the vertices or lines of a quad are not included.</p>
<p>Needed by the <code>compute_support_points()</code> function. For <code>dim=1</code> and <code>dim=2</code> this function is empty. The function uses the underlying manifold object of the quad (or, if none is set, of the cell) for the location of the requested points.</p>
<p>This function is made virtual in order to allow derived classes to choose shape function support points differently than the present class, which chooses the points as interpolation points on the boundary. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l03773">3773</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a42293d07f83fabc8a6891ef5fc8d7f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42293d07f83fabc8a6891ef5fc8d7f36">&#9670;&nbsp;</a></span>MappingQ</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classMappingQ.html">MappingQ</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make <a class="el" href="classMappingQ.html">MappingQ</a> a friend since it needs to call the <a class="el" href="classMappingQGeneric.html#ae55d922ed15d4d53ae126426c28ab823">fill_fe_values()</a> functions on its <a class="el" href="classMappingQGeneric.html">MappingQGeneric(1)</a> sub-object. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00692">692</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad003bfed73fda03fa261b3c10f64da15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad003bfed73fda03fa261b3c10f64da15">&#9670;&nbsp;</a></span>polynomial_degree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::polynomial_degree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The degree of the polynomials used as shape functions for the mapping of cells. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00554">554</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<a id="a12d3c66105c695d441e4053641f44862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d3c66105c695d441e4053641f44862">&#9670;&nbsp;</a></span>fe_q</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unique_ptr&lt;<a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt; &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::fe_q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An <a class="el" href="classFE__Q.html">FE_Q</a> object which is only needed in 3D, since it knows how to reorder shape functions/DoFs on non-standard faces. This is used to reorder support points in the same way. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00572">572</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<a id="abae7e52c89fa786c131cad80ee1d30d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae7e52c89fa786c131cad80ee1d30d8">&#9670;&nbsp;</a></span>support_point_weights_perimeter_to_interior</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTable.html">Table</a>&lt;2,double&gt; &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::support_point_weights_perimeter_to_interior</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector of tables of weights by which we multiply the locations of the support points on the perimeter of an object (line, quad, hex) to get the location of interior support points.</p>
<p>Access into this table is by <code></code>[structdim-1], i.e., use 0 to access the support point weights on a line (i.e., the interior points of the GaussLobatto quadrature), use 1 to access the support point weights from to perimeter to the interior of a quad, and use 2 to access the support point weights from the perimeter to the interior of a hex.</p>
<p>The table itself contains as many columns as there are surrounding points to a particular object (2 for a line, <code>4 + 4*(degree-1)</code> for a quad, <code>8 + 12*(degree-1) + 6*(degree-1)*(degree-1)</code> for a hex) and as many rows as there are strictly interior points.</p>
<p>For the definition of this table see equation (8) of the `mapping' report. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00593">593</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<a id="a140f4ae6369f6692312dfde765058d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140f4ae6369f6692312dfde765058d94">&#9670;&nbsp;</a></span>support_point_weights_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;2,double&gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::support_point_weights_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A table of weights by which we multiply the locations of the vertex points of the cell to get the location of all additional support points, both on lines, quads, and hexes (as appropriate). This data structure is used when we fill all support points at once, which is the case if the same manifold is attached to all sub-entities of a cell. This way, we can avoid some of the overhead in transforming data for mappings.</p>
<p>The table has as many rows as there are vertices to the cell (2 in 1D, 4 in 2D, 8 in 3D), and as many rows as there are additional support points in the mapping, i.e., <code>(degree+1)^dim - 2^dim</code>. </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00607">607</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deal.II/fe/<a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a></li>
<li>/Users/xywei/Workspace/dealii/source/fe/<a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
