<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-29 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2017 by the deal.II authors"></meta>
<meta name="deal.II-version" content="9.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 9.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-29 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemsetting">Problem setting</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeDirichletBoundaryValuescodeclass">The <code>DirichletBoundaryValues</code> class</a>
        <li><a href="#ThecodeParameterReadercodeclass">The <code>ParameterReader</code> class</a>
      <ul>
        <li><a href="#codeParameterReaderdeclare_parameterscode"><code>ParameterReader::declare_parameters</code></a>
        <li><a href="#codeParameterReaderread_parameterscode"><code>ParameterReader::read_parameters</code></a>
      </ul>
        <li><a href="#ThecodeComputeIntensitycodeclass">The <code>ComputeIntensity</code> class</a>
        <li><a href="#ThecodeUltrasoundProblemcodeclass">The <code>UltrasoundProblem</code> class</a>
      <ul>
        <li><a href="#codeUltrasoundProblemmake_gridcode"><code>UltrasoundProblem::make_grid</code></a>
        <li><a href="#codeUltrasoundProblemsetup_systemcode"><code>UltrasoundProblem::setup_system</code></a>
        <li><a href="#codeUltrasoundProblemassemble_systemcode"><code>UltrasoundProblem::assemble_system</code></a>
        <li><a href="#codeUltrasoundProblemsolvecode"><code>UltrasoundProblem::solve</code></a>
        <li><a href="#codeUltrasoundProblemoutput_resultscode"><code>UltrasoundProblem::output_results</code></a>
        <li><a href="#codeUltrasoundProblemruncode"><code>UltrasoundProblem::run</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Moritz Allmaras at Texas A&amp;M University. Some of the work on this tutorial program has been funded by NSF under grant DMS-0604778. </em></p>
<p><b>Note:</b> In order to run this program, deal.II must be configured to use the UMFPACK sparse direct solver. Refer to the <a href="../../readme.html#umfpack">ReadMe</a> for instructions how to do this.</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>A question that comes up frequently is how to solve problems involving complex valued functions with deal.II. For many problems, instead of working with complex valued finite elements directly, which are not readily available in the library, it is often much more convenient to split complex valued functions into their real and imaginary parts and use separate scalar finite element fields for discretizing each one of them. Basically this amounts to viewing a single complex valued equation as a system of two real valued equations. This short example demonstrates how this can be implemented in deal.II by using an <code>FE_system</code> object to stack two finite element fields representing real and imaginary parts. We also revisit the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class first used in <a class="el" href="step_19.html">step-19</a>, which provides a convenient way for reading parameters from a configuration file at runtime without the need to recompile the program code.</p>
<p>The equations covered here fall into the class of vector-valued problems. A toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module.</p>
<p><a class="anchor" id="Problemsetting"></a></p><h3>Problem setting</h3>
<p>The original purpose of this program is to simulate the focussing properties of an ultrasound wave generated by a transducer lens with variable geometry. Recent applications in medical imaging use ultrasound waves not only for imaging purposes, but also to excite certain local effects in a material, like changes in optical properties, that can then be measured by other imaging techniques. A vital ingredient for these methods is the ability to focus the intensity of the ultrasound wave in a particular part of the material, ideally in a point, to be able to examine the properties of the material at that particular location.</p>
<p>To derive a model for this problem, we think of ultrasound as a pressure wave governed by the wave equation: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial^2 U}{\partial t^2} - c^2 \Delta U = 0 \]" src="form_2403.png"/>
</p>
<p> where <img class="formulaInl" alt="$c$" src="form_257.png"/> is the wave speed (that for simplicity we assume to be constant), <img class="formulaInl" alt="$U = U(x,t),\;x \in \Omega,\;t\in\mathrm{R}$" src="form_2404.png"/>. The boundary <img class="formulaInl" alt="$\Gamma=\partial\Omega$" src="form_1444.png"/> is divided into two parts <img class="formulaInl" alt="$\Gamma_1$" src="form_2405.png"/> and <img class="formulaInl" alt="$\Gamma_2=\Gamma\setminus\Gamma_1$" src="form_2406.png"/>, with <img class="formulaInl" alt="$\Gamma_1$" src="form_2405.png"/> representing the transducer lens and <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/> an absorbing boundary (that is, we want to choose boundary conditions on <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/> in such a way that they imitate a larger domain). On <img class="formulaInl" alt="$\Gamma_1$" src="form_2405.png"/>, the transducer generates a wave of constant frequency <img class="formulaInl" alt="${\omega}&gt;0$" src="form_2408.png"/> and constant amplitude (that we chose to be 1 here): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ U(x,t) = \cos{\omega t}, \qquad x\in \Gamma_1 \]" src="form_2409.png"/>
</p>
<p>If there are no other (interior or boundary) sources, and since the only source has frequency <img class="formulaInl" alt="$\omega$" src="form_2410.png"/>, then the solution admits a separation of variables of the form <img class="formulaInl" alt="$U(x,t) = \textrm{Re}\left(u(x)\,e^{i\omega t})\right)$" src="form_2411.png"/>. The complex-valued function <img class="formulaInl" alt="$u(x)$" src="form_2412.png"/> describes the spatial dependency of amplitude and phase (relative to the source) of the waves of frequency <img class="formulaInl" alt="${\omega}$" src="form_2413.png"/>, with the amplitude being the quantity that we are interested in. By plugging this form of the solution into the wave equation, we see that for <img class="formulaInl" alt="$u$" src="form_256.png"/> we have </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\omega^2 u(x) - c^2\Delta u(x) &amp;=&amp; 0, \qquad x\in\Omega,\\ u(x) &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}" src="form_2414.png"/>
</p>
<p>For finding suitable conditions on <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/> that model an absorbing boundary, consider a wave of the form <img class="formulaInl" alt="$V(x,t)=e^{i(k\cdot x -\omega t)}$" src="form_2415.png"/> with frequency <img class="formulaInl" alt="${\omega}$" src="form_2413.png"/> traveling in direction <img class="formulaInl" alt="$k\in {\mathrm{R}^2}$" src="form_2416.png"/>. In order for <img class="formulaInl" alt="$V$" src="form_204.png"/> to solve the wave equation, <img class="formulaInl" alt="$|k|={\frac{\omega}{c}}$" src="form_2417.png"/> must hold. Suppose that this wave hits the boundary in <img class="formulaInl" alt="$x_0\in\Gamma_2$" src="form_2418.png"/> at a right angle, i.e. <img class="formulaInl" alt="$n=\frac{k}{|k|}$" src="form_2419.png"/> with <img class="formulaInl" alt="$n$" src="form_73.png"/> denoting the outer unit normal of <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> in <img class="formulaInl" alt="$x_0$" src="form_32.png"/>. Then at <img class="formulaInl" alt="$x_0$" src="form_32.png"/>, this wave satisfies the equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ c (n\cdot\nabla V) + \frac{\partial V}{\partial t} = (i\, c\, |k| - i\, \omega) V = 0. \]" src="form_2420.png"/>
</p>
<p> Hence, by enforcing the boundary condition </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ c (n\cdot\nabla U) + \frac{\partial U}{\partial t} = 0, \qquad x\in\Gamma_2, \]" src="form_2421.png"/>
</p>
<p> waves that hit the boundary <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/> at a right angle will be perfectly absorbed. On the other hand, those parts of the wave field that do not hit a boundary at a right angle do not satisfy this condition and enforcing it as a boundary condition will yield partial reflections, i.e. only parts of the wave will pass through the boundary as if it wasn't here whereas the remaining fraction of the wave will be reflected back into the domain.</p>
<p>If we are willing to accept this as a sufficient approximation to an absorbing boundary we finally arrive at the following problem for <img class="formulaInl" alt="$u$" src="form_256.png"/>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\omega^2 u - c^2\Delta u &amp;=&amp; 0, \qquad x\in\Omega,\\ c (n\cdot\nabla u) + i\,\omega\,u &amp;=&amp;0, \qquad x\in\Gamma_2,\\ u &amp;=&amp; 1, \qquad x\in\Gamma_1. \end{eqnarray*}" src="form_2422.png"/>
</p>
<p> This is a Helmholtz equation (similar to the one in <a class="el" href="step_7.html">step-7</a>, but this time with ''the bad sign'') with Dirichlet data on <img class="formulaInl" alt="$\Gamma_1$" src="form_2405.png"/> and mixed boundary conditions on <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/>. Because of the condition on <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/>, we cannot just treat the equations for real and imaginary parts of <img class="formulaInl" alt="$u$" src="form_256.png"/> separately. What we can do however is to view the PDE for <img class="formulaInl" alt="$u$" src="form_256.png"/> as a system of two PDEs for the real and imaginary parts of <img class="formulaInl" alt="$u$" src="form_256.png"/>, with the boundary condition on <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/> representing the coupling terms between the two components of the system. This works along the following lines: Let <img class="formulaInl" alt="$v=\textrm{Re}\;u,\; w=\textrm{Im}\;u$" src="form_2423.png"/>, then in terms of <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/> we have the following system: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left.\begin{array}{ccc} -\omega^2 v - c^2\Delta v &amp;=&amp; 0 \quad\\ -\omega^2 w - c^2\Delta w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Omega, \\ \left.\begin{array}{ccc} c (n\cdot\nabla v) - \omega\,w &amp;=&amp; 0 \quad\\ c (n\cdot\nabla w) + \omega\,v &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_2, \\ \left.\begin{array}{ccc} v &amp;=&amp; 1 \quad\\ w &amp;=&amp; 0 \quad \end{array}\right\} &amp;\;&amp; x\in\Gamma_1. \end{eqnarray*}" src="form_2424.png"/>
</p>
<p>For test functions <img class="formulaInl" alt="$\phi,\psi$" src="form_2425.png"/> with <img class="formulaInl" alt="$\phi|_{\Gamma_1}=\psi|_{\Gamma_1}=0$" src="form_2426.png"/>, after the usual multiplication, integration over <img class="formulaInl" alt="$\Omega$" src="form_205.png"/> and applying integration by parts, we get the weak formulation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} -\omega^2 \langle \phi, v \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi, \nabla v \rangle_{\mathrm{L}^2(\Omega)} - c \omega \langle \phi, w \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0, \\ -\omega^2 \langle \psi, w \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi, \nabla w \rangle_{\mathrm{L}^2(\Omega)} + c \omega \langle \psi, v \rangle_{\mathrm{L}^2(\Gamma_2)} &amp;=&amp; 0. \end{eqnarray*}" src="form_2427.png"/>
</p>
<p>We choose finite element spaces <img class="formulaInl" alt="$V_h$" src="form_79.png"/> and <img class="formulaInl" alt="$W_h$" src="form_2428.png"/> with bases <img class="formulaInl" alt="$\{\phi_j\}_{j=1}^n, \{\psi_j\}_{j=1}^n$" src="form_2429.png"/> and look for approximate solutions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ v_h = \sum_{j=1}^n \alpha_j \phi_j, \;\; w_h = \sum_{j=1}^n \beta_j \psi_j. \]" src="form_2430.png"/>
</p>
<p> Plugging into the variational form yields the equation system </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \renewcommand{\arraystretch}{2.0} \left.\begin{array}{ccc} \sum_{j=1}^n \left(-\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} +c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)}\right)\alpha_j - \left(c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)}\right)\beta_j &amp;=&amp; 0 \\ \sum_{j=1}^n \left(-\omega^2 \langle \psi_i, \psi_j \rangle_{\mathrm{L}^2(\Omega)} +c^2 \langle \nabla \psi_i, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)}\right)\beta_j + \left(c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)}\right)\alpha_j &amp;=&amp; 0 \end{array}\right\}\;\;\forall\; i =1,\ldots,n. \]" src="form_2431.png"/>
</p>
<p> In matrix notation: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \renewcommand{\arraystretch}{2.0} \left( \begin{array}{cc} -\omega^2 \langle \phi_i, \phi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \phi_i, \nabla \phi_j \rangle_{\mathrm{L}^2(\Omega)} &amp; -c\omega \langle \phi_i,\psi_j\rangle_{\mathrm{L}^2(\Gamma_2)} \\ c\omega \langle \psi_i,\phi_j\rangle_{\mathrm{L}^2(\Gamma_2)} &amp; -\omega^2 \langle \psi_{i}, \psi_j \rangle_{\mathrm{L}^2(\Omega)} + c^2 \langle \nabla \psi_{i}, \nabla \psi_j \rangle_{\mathrm{L}^2(\Omega)} \end{array} \right) \left( \begin{array}{c} \alpha \\ \beta \end{array} \right) = \left( \begin{array}{c} 0 \\ 0 \end{array} \right) \]" src="form_2432.png"/>
</p>
<p> (One should not be fooled by the right hand side being zero here, that is because we haven't included the Dirichlet boundary data yet.) Because of the alternating sign in the off-diagonal blocks, we can already see that this system is non-symmetric, in fact it is even indefinite. Of course, there is no necessity to choose the spaces <img class="formulaInl" alt="$V_h$" src="form_79.png"/> and <img class="formulaInl" alt="$W_h$" src="form_2428.png"/> to be the same. However, we expect real and imaginary part of the solution to have similar properties and will therefore indeed take <img class="formulaInl" alt="$V_h=W_h$" src="form_2433.png"/> in the implementation, and also use the same basis functions <img class="formulaInl" alt="$\phi_i = \psi_i$" src="form_2434.png"/> for both spaces. The reason for the notation using different symbols is just that it allows us to distinguish between shape functions for <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/>, as this distinction plays an important role in the implementation.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>For the computations, we will consider wave propagation in the unit square, with ultrasound generated by a transducer lens that is shaped like a segment of the circle with center at <img class="formulaInl" alt="$(0.5, d)$" src="form_2435.png"/> and a radius slightly greater than <img class="formulaInl" alt="$d$" src="form_301.png"/>; this shape should lead to a focusing of the sound wave at the center of the circle. Varying <img class="formulaInl" alt="$d$" src="form_301.png"/> changes the "focus" of the lens and affects the spatial distribution of the intensity of <img class="formulaInl" alt="$u$" src="form_256.png"/>, where our main concern is how well <img class="formulaInl" alt="$|u|=\sqrt{v^2+w^2}$" src="form_2436.png"/> is focussed.</p>
<p>In the program below, we will implement the complex-valued Helmholtz equations using the formulation with split real and imaginary parts. We will also discuss how to generate a domain that looks like a square with a slight bulge simulating the transducer (in the <code>UltrasoundProblem&lt;dim&gt;::make_grid()</code> function), and how to generate graphical output that not only contains the solution components <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/>, but also the magnitude <img class="formulaInl" alt="$\sqrt{v^2+w^2}$" src="form_2437.png"/> directly in the output file (in <code>UltrasoundProblem&lt;dim&gt;::output_results()</code>). Finally, we use the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class to easily read parameters like the focal distance <img class="formulaInl" alt="$d$" src="form_301.png"/>, wave speed <img class="formulaInl" alt="$c$" src="form_257.png"/>, frequency <img class="formulaInl" alt="$\omega$" src="form_2410.png"/>, and a number of other parameters from an input file at run-time, rather than fixing those parameters in the source code where we would have to re-compile every time we want to change parameters. <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The following header files are unchanged from <a class="el" href="step_7.html">step-7</a> and have been discussed before:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>This header file contains the necessary declarations for the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class that we will use to read our parameters from a configuration file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div></div><!-- fragment --><p>For solving the linear system, we'll use the sparse LU-decomposition provided by UMFPACK (see the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class), for which the following header file is needed. Note that in order to compile this tutorial program, the deal.II-library needs to be built with UMFPACK support, which is enabled by default:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div></div><!-- fragment --><p>The <a class="el" href="classFESystem.html">FESystem</a> class allows us to stack several FE-objects to one compound, vector-valued finite element field. The necessary declarations for this class are provided in this header file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div></div><!-- fragment --><p>Finally, include the header file that declares the <a class="el" href="classTimer.html">Timer</a> class that we will use to determine how much time each of the operations of our program takes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div></div><!-- fragment --><p>As the last step at the beginning of this program, we put everything that is in this program into its namespace and, within it, make everything that is in the deal.II namespace globally available, without the need to prefix everything with <code>dealii</code><code>::</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step29</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeDirichletBoundaryValuescodeclass"></a> </p><h3>The <code>DirichletBoundaryValues</code> class</h3>
<p>First we define a class for the function representing the Dirichlet boundary values. This has been done many times before and therefore does not need much explanation.</p>
<p>Since there are two values <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/> that need to be prescribed at the boundary, we have to tell the base class that this is a vector-valued function with two components, and the <code>vector_value</code> function and its cousin <code>vector_value_list</code> must return vectors with two entries. In our case the function is very simple, it just returns 1 for the real part <img class="formulaInl" alt="$v$" src="form_987.png"/> and 0 for the imaginary part <img class="formulaInl" alt="$w$" src="form_859.png"/> regardless of the point where it is evaluated.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  DirichletBoundaryValues() : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (2) {};</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ab82f495e6e2f2cc59b7173a2d804e986">vector_value</a> (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#affaffa06986e55c66f71b8117087a0b6">vector_value_list</a> (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                  std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">inline</span></div><div class="line"><span class="keywordtype">void</span> DirichletBoundaryValues&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;/ *p* /,</div><div class="line">                                                 <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), 2));</div><div class="line"></div><div class="line">  values(0) = 1;</div><div class="line">  values(1) = 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> DirichletBoundaryValues&lt;dim&gt;::vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                                      std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == points.size(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">    DirichletBoundaryValues&lt;dim&gt;::vector_value (points[p], value_list[p]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeParameterReadercodeclass"></a> </p><h3>The <code>ParameterReader</code> class</h3>
<p>The next class is responsible for preparing the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and reading parameters from an input file. It includes a function <code>declare_parameters</code> that declares all the necessary parameters and a <code>read_parameters</code> function that is called from outside to initiate the parameter reading process.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">  <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> declare_parameters();</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line">};</div></div><!-- fragment --><p>The constructor stores a reference to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to it:</p>
<div class="fragment"><div class="line">ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div><div class="line">  :</div><div class="line">  prm(paramhandler)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeParameterReaderdeclare_parameterscode"></a> </p><h4><code>ParameterReader::declare_parameters</code></h4>
<p>The <code>declare_parameters</code> function declares all the parameters that our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will be able to read from input files, along with their types, range conditions and the subsections they appear in. We will wrap all the entries that go into a section in a pair of braces to force the editor to indent them by one level, making it simpler to read which entries together form a section:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::declare_parameters()</div><div class="line">{</div></div><!-- fragment --><p>Parameters for mesh and geometry include the number of global refinement steps that are applied to the initial coarse mesh and the focal distance <img class="formulaInl" alt="$d$" src="form_301.png"/> of the transducer lens. For the number of refinement steps, we allow integer values in the range <img class="formulaInl" alt="$[0,\infty)$" src="form_2438.png"/>, where the omitted second argument to the <a class="el" href="classPatterns_1_1Integer.html">Patterns::Integer</a> object denotes the half-open interval. For the focal distance any number greater than zero is accepted:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>, <span class="stringliteral">&quot;0.3&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div></div><!-- fragment --><p>The next subsection is devoted to the physical parameters appearing in the equation, which are the frequency <img class="formulaInl" alt="$\omega$" src="form_2410.png"/> and wave speed <img class="formulaInl" alt="$c$" src="form_257.png"/>. Again, both need to lie in the half-open interval <img class="formulaInl" alt="$[0,\infty)$" src="form_2438.png"/> represented by calling the <a class="el" href="classPatterns_1_1Double.html">Patterns::Double</a> class with only the left end-point as argument:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Wave speed&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Frequency&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div></div><!-- fragment --><p>Last but not least we would like to be able to change some properties of the output, like filename and format, through entries in the configuration file, which is the purpose of the last subsection:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Output file&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div></div><!-- fragment --><p>Since different output formats may require different parameters for generating output (like for example, postscript output needs viewpoint angles, line widths, colors etc), it would be cumbersome if we had to declare all these parameters by hand for every possible output format supported in the library. Instead, each output format has a <code>FormatFlags::declare_parameters</code> function, which declares all the parameters specific to that format in an own subsection. The following call of <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> executes <code>declare_parameters</code> for all available output formats, so that for each format an own subsection will be created with parameters declared for that particular output format. (The actual value of the template parameter in the call, <code>&lt;1&gt;</code> above, does not matter here: the function does the same work independent of the dimension, but happens to be in a template-parameter-dependent class.) To find out what parameters there are for which output format, you can either consult the documentation of the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> class, or simply run this program without a parameter file present. It will then create a file with all declared parameters set to their default values, which can conveniently serve as a starting point for setting the parameters to the values you desire.</p>
<div class="fragment"><div class="line">    <a class="code" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> (prm);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeParameterReaderread_parameterscode"></a> </p><h4><code>ParameterReader::read_parameters</code></h4>
<p>This is the main function in the ParameterReader class. It gets called from outside, first declares all the parameters, and then reads them from the input file whose filename is provided by the caller. After the call to this function is complete, the <code>prm</code> object can be used to retrieve the values of the parameters read in from the file :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ParameterReader::read_parameters (<span class="keyword">const</span> std::string parameter_file)</div><div class="line">{</div><div class="line">  declare_parameters();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (parameter_file);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeComputeIntensitycodeclass"></a> </p><h3>The <code>ComputeIntensity</code> class</h3>
<p>As mentioned in the introduction, the quantity that we are really after is the spatial distribution of the intensity of the ultrasound wave, which corresponds to <img class="formulaInl" alt="$|u|=\sqrt{v^2+w^2}$" src="form_2436.png"/>. Now we could just be content with having <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/> in our output, and use a suitable visualization or postprocessing tool to derive <img class="formulaInl" alt="$|u|$" src="form_2439.png"/> from the solution we computed. However, there is also a way to output data derived from the solution in deal.II, and we are going to make use of this mechanism here.</p>
<p>So far we have always used the <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut::add_data_vector</a> function to add vectors containing output data to a <a class="el" href="classDataOut.html">DataOut</a> object. There is a special version of this function that in addition to the data vector has an additional argument of type <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>. What happens when this function is used for output is that at each point where output data is to be generated, the <a class="el" href="classDataPostprocessor.html#acf197b51f7557e327888be579531750c">DataPostprocessor::evaluate_scalar_field()</a> or <a class="el" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">DataPostprocessor::evaluate_vector_field()</a> function of the specified <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> object is invoked to compute the output quantities from the values, the gradients and the second derivatives of the finite element function represented by the data vector (in the case of face related data, normal vectors are available as well). Hence, this allows us to output any quantity that can locally be derived from the values of the solution and its derivatives. Of course, the ultrasound intensity <img class="formulaInl" alt="$|u|$" src="form_2439.png"/> is such a quantity and its computation doesn't even involve any derivatives of <img class="formulaInl" alt="$v$" src="form_987.png"/> or <img class="formulaInl" alt="$w$" src="form_859.png"/>.</p>
<p>In practice, the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class only provides an interface to this functionality, and we need to derive our own class from it in order to implement the functions specified by the interface. In the most general case one has to implement several member functions but if the output quantity is a single scalar then some of this boilerplate code can be handled by a more specialized class, <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> and we can derive from that one instead. This is what the <code>ComputeIntensity</code> class does:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ComputeIntensity ();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  <a class="code" href="classDataPostprocessor.html#ac907e98f8f03ea7e6ac25237271dc7b7">evaluate_vector_field</a></div><div class="line">  (<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;               &amp;computed_quantities) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>In the constructor, we need to call the constructor of the base class with two arguments. The first denotes the name by which the single scalar quantity computed by this class should be represented in output files. In our case, the postprocessor has <img class="formulaInl" alt="$|u|$" src="form_2439.png"/> as output, so we use "Intensity".</p>
<p>The second argument is a set of flags that indicate which data is needed by the postprocessor in order to compute the output quantities. This can be any subset of update_values, update_gradients and update_hessians (and, in the case of face data, also update_normal_vectors), which are documented in UpdateFlags. Of course, computation of the derivatives requires additional resources, so only the flags for data that are really needed should be given here, just as we do when we use <a class="el" href="classFEValues.html">FEValues</a> objects. In our case, only the function values of <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/> are needed to compute <img class="formulaInl" alt="$|u|$" src="form_2439.png"/>, so we're good with the update_values flag.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ComputeIntensity&lt;dim&gt;::ComputeIntensity ()</div><div class="line">  :</div><div class="line">  <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt; (<span class="stringliteral">&quot;Intensity&quot;</span>,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">{}</div></div><!-- fragment --><p>The actual postprocessing happens in the following function. Its input is an object that stores values of the function (which is here vector-valued) representing the data vector given to <a class="el" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">DataOut::add_data_vector</a>, evaluated at all evaluation points where we generate output, and some tensor objects representing derivatives (that we don't use here since <img class="formulaInl" alt="$|u|$" src="form_2439.png"/> is computed from just <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/>). The derived quantities are returned in the <code>computed_quantities</code> vector. Remember that this function may only use data for which the respective update flag is specified by <code>get_needed_update_flags</code>. For example, we may not use the derivatives here, since our implementation of <code>get_needed_update_flags</code> requests that only function values are provided.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">ComputeIntensity&lt;dim&gt;::evaluate_vector_field</div><div class="line">(<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line"> std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;               &amp;computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (computed_quantities.size(), inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div></div><!-- fragment --><p>The computation itself is straightforward: We iterate over each entry in the output vector and compute <img class="formulaInl" alt="$|u|$" src="form_2439.png"/> from the corresponding values of <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/>:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;computed_quantities.size(); i++)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (computed_quantities[i].size(), 1));</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div><div class="line"></div><div class="line">      computed_quantities[i](0)</div><div class="line">        = std::sqrt(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0)*inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0)</div><div class="line">                    + inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1)*inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeUltrasoundProblemcodeclass"></a> </p><h3>The <code>UltrasoundProblem</code> class</h3>
<p>Finally here is the main class of this program. It's member functions are very similar to the previous examples, in particular <a class="el" href="step_4.html">step-4</a>, and the list of member variables does not contain any major surprises either. The <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that is passed to the constructor is stored as a reference to allow easy access to the parameters from all functions of the class. Since we are working with vector valued finite elements, the FE object we are using is of type <a class="el" href="classFESystem.html">FESystem</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>UltrasoundProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  UltrasoundProblem (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">  ~UltrasoundProblem ();</div><div class="line">  <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid ();</div><div class="line">  <span class="keywordtype">void</span> setup_system ();</div><div class="line">  <span class="keywordtype">void</span> assemble_system ();</div><div class="line">  <span class="keywordtype">void</span> solve ();</div><div class="line">  <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a>      &amp;prm;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>     triangulation;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>        dof_handler;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>          fe;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>        sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>   system_matrix;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>         solution, system_rhs;</div><div class="line">};</div></div><!-- fragment --><p>The constructor takes the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and stores it in a reference. It also initializes the DoF-Handler and the finite element system, which consists of two copies of the scalar Q1 field, one for <img class="formulaInl" alt="$v$" src="form_987.png"/> and one for <img class="formulaInl" alt="$w$" src="form_859.png"/>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">UltrasoundProblem&lt;dim&gt;::UltrasoundProblem (<a class="code" href="classParameterHandler.html">ParameterHandler</a>  &amp;param)</div><div class="line">  :</div><div class="line">  prm(param),</div><div class="line">  dof_handler(triangulation),</div><div class="line">  fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">UltrasoundProblem&lt;dim&gt;::~UltrasoundProblem ()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemmake_gridcode"></a> </p><h4><code>UltrasoundProblem::make_grid</code></h4>
<p>Here we setup the grid for our domain. As mentioned in the exposition, the geometry is just a unit square (in 2d) with the part of the boundary that represents the transducer lens replaced by a sector of a circle.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid ()</div><div class="line">{</div></div><!-- fragment --><p>First we generate some logging output and start a timer so we can compute execution time when this function is done:</p>
<div class="fragment"><div class="line">deallog &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div><div class="line"><a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div></div><!-- fragment --><p>Then we query the values for the focal distance of the transducer lens and the number of mesh refinement steps from our <a class="el" href="classParameterHandler.html">ParameterHandler</a> object:</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>                focal_distance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_refinements  = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div></div><!-- fragment --><p>Next, two points are defined for position and focal point of the transducer lens, which is the center of the circle whose segment will form the transducer part of the boundary. Notice that this is the only point in the program where things are slightly different in 2D and 3D. Even though this tutorial only deals with the 2D case, the necessary additions to make this program functional in 3D are so minimal that we opt for including them:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>    transducer = (dim == 2) ?</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (0.5, 0.0) :</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (0.5, 0.5, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   focal_point = (dim == 2) ?</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (0.5, focal_distance) :</div><div class="line">                                 <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (0.5, 0.5, focal_distance);</div></div><!-- fragment --><p>As initial coarse grid we take a simple unit square with 5 subdivisions in each direction. The number of subdivisions is chosen so that the line segment <img class="formulaInl" alt="$[0.4,0.6]$" src="form_2440.png"/> that we want to designate as the transducer boundary is spanned by a single face. Then we step through all cells to find the faces where the transducer is to be located, which in fact is just the single edge from 0.4 to 0.6 on the x-axis. This is where we want the refinements to be made according to a circle shaped boundary, so we mark this edge with a different manifold indicator. Since we will Dirichlet boundary conditions on the transducer, we also change its boundary indicator.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">GridGenerator::subdivided_hyper_cube</a> (triangulation, 5, 0, 1);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line">cell = triangulation.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a> (),</div><div class="line">endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">    <span class="keywordflow">if</span> ( cell-&gt;face(face)-&gt;at_boundary() &amp;&amp;</div><div class="line">         ((cell-&gt;face(face)-&gt;center() - transducer).norm_square() &lt; 0.01) )</div><div class="line">      {</div><div class="line"></div><div class="line">        cell-&gt;face(face)-&gt;set_boundary_id (1);</div><div class="line">        cell-&gt;face(face)-&gt;set_manifold_id (1);</div><div class="line">      }</div></div><!-- fragment --><p>For the circle part of the transducer lens, a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object is used (which, of course, in 2D just represents a circle), with center computed as above. By marking this object as <code>static</code>, we ensure that it lives until the end of the program and thereby longer than the triangulation object we will associate with it. We then assign this boundary-object to the part of the boundary with boundary indicator 1:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> boundary(focal_point);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, boundary);</div></div><!-- fragment --><p>Now global refinement is executed. Cells near the transducer location will be automatically refined according to the circle shaped boundary of the transducer lens:</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (n_refinements);</div></div><!-- fragment --><p>Lastly, we generate some more logging output. We stop the timer and query the number of CPU seconds elapsed since the beginning of the function:</p>
<div class="fragment"><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">          &lt;&lt; timer()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsetup_systemcode"></a> </p><h4><code>UltrasoundProblem::setup_system</code></h4>
<p>Initialization of the system matrix, sparsity patterns and vectors are the same as in previous examples and therefore do not need further comment. As in the previous function, we also output the run time of what we do here:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system ()</div><div class="line">{</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">  timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit (sparsity_pattern);</div><div class="line">  system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">          &lt;&lt; timer()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span></div><div class="line">          &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemassemble_systemcode"></a> </p><h4><code>UltrasoundProblem::assemble_system</code></h4>
<p>As before, this function takes care of assembling the system matrix and right hand side vector:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system ()</div><div class="line">{</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">  timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div></div><!-- fragment --><p>First we query wavespeed and frequency from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object and store them in local variables, as they will be used frequently throughout this function.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;omega&quot;</span>),</div><div class="line">             c     = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c&quot;</span>);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div></div><!-- fragment --><p>As usual, for computing integrals ordinary Gauss quadrature rule is used. Since our bilinear form involves boundary integrals on <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/>, we also need a quadrature rule for surface integration on the faces, which are <img class="formulaInl" alt="$dim-1$" src="form_2441.png"/> dimensional:</p>
<div class="fragment"><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>    quadrature_formula(2);</div><div class="line"><a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt;  face_quadrature_formula(2);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points       = quadrature_formula.size(),</div><div class="line">                   n_face_q_points  = face_quadrature_formula.size(),</div><div class="line">                   dofs_per_cell    = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div></div><!-- fragment --><p>The <a class="el" href="classFEValues.html">FEValues</a> objects will evaluate the shape functions for us. For the part of the bilinear form that involves integration on <img class="formulaInl" alt="$\Omega$" src="form_205.png"/>, we'll need the values and gradients of the shape functions, and of course the quadrature weights. For the terms involving the boundary integrals, only shape function values and the quadrature weights are necessary.</p>
<div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>  fe_values (fe, quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe, face_quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div></div><!-- fragment --><p>As usual, the system matrix is assembled cell by cell, and we need a matrix for storing the local cell contributions as well as an index vector to transfer the cell contributions to the appropriate location in the global system matrix after.</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div></div><!-- fragment --><p>On each cell, we first need to reset the local contribution matrix and request the <a class="el" href="classFEValues.html">FEValues</a> object to compute the shape functions for the current cell:</p>
<div class="fragment"><div class="line">cell_matrix = 0;</div><div class="line">fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">      {</div></div><!-- fragment --><p>At this point, it is important to keep in mind that we are dealing with a finite element system with two components. Due to the way we constructed this <a class="el" href="classFESystem.html">FESystem</a>, namely as the Cartesian product of two scalar finite element fields, each shape function has only a single nonzero component (they are, in deal.II lingo, <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a>). Hence, each shape function can be viewed as one of the <img class="formulaInl" alt="$\phi$" src="form_643.png"/>'s or <img class="formulaInl" alt="$\psi$" src="form_2442.png"/>'s from the introduction, and similarly the corresponding degrees of freedom can be attributed to either <img class="formulaInl" alt="$\alpha$" src="form_114.png"/> or <img class="formulaInl" alt="$\beta$" src="form_414.png"/>. As we iterate through all the degrees of freedom on the current cell however, they do not come in any particular order, and so we cannot decide right away whether the DoFs with index <img class="formulaInl" alt="$i$" src="form_90.png"/> and <img class="formulaInl" alt="$j$" src="form_513.png"/> belong to the real or imaginary part of our solution. On the other hand, if you look at the form of the system matrix in the introduction, this distinction is crucial since it will determine to which block in the system matrix the contribution of the current pair of DoFs will go and hence which quantity we need to compute from the given two shape functions. Fortunately, the <a class="el" href="classFESystem.html">FESystem</a> object can provide us with this information, namely it has a function <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FESystem::system_to_component_index</a>, that for each local DoF index returns a pair of integers of which the first indicates to which component of the system the DoF belongs. The second integer of the pair indicates which index the DoF has in the scalar base finite element field, but this information is not relevant here. If you want to know more about this function and the underlying scheme behind primitive vector valued elements, take a look at <a class="el" href="step_8.html">step-8</a> or the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module, where these topics are explained in depth.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first ==</div><div class="line">    fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first)</div><div class="line">  {</div></div><!-- fragment --><p>If both DoFs <img class="formulaInl" alt="$i$" src="form_90.png"/> and <img class="formulaInl" alt="$j$" src="form_513.png"/> belong to same component, i.e. their shape functions are both <img class="formulaInl" alt="$\phi$" src="form_643.png"/>'s or both <img class="formulaInl" alt="$\psi$" src="form_2442.png"/>'s, the contribution will end up in one of the diagonal blocks in our system matrix, and since the corresponding entries are computed by the same formula, we do not bother if they actually are <img class="formulaInl" alt="$\phi$" src="form_643.png"/> or <img class="formulaInl" alt="$\psi$" src="form_2442.png"/> shape functions. We can simply compute the entry by iterating over all quadrature points and adding up their contributions, where values and gradients of the shape functions are supplied by our <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">  cell_matrix(i,j) += (((fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point)) *</div><div class="line">                        (- omega * omega)</div><div class="line">                        +</div><div class="line">                        (fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point)) *</div><div class="line">                        c * c) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div></div><!-- fragment --><p>You might think that we would have to specify which component of the shape function we'd like to evaluate when requesting shape function values or gradients from the <a class="el" href="classFEValues.html">FEValues</a> object. However, as the shape functions are primitive, they have only one nonzero component, and the <a class="el" href="classFEValues.html">FEValues</a> class is smart enough to figure out that we are definitely interested in this one nonzero component.</p>
<div class="fragment"><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>We also have to add contributions due to boundary terms. To this end, we loop over all faces of the current cell and see if first it is at the boundary, and second has the correct boundary indicator associated with <img class="formulaInl" alt="$\Gamma_2$" src="form_2407.png"/>, the part of the boundary where we have absorbing boundary conditions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary() &amp;&amp;</div><div class="line">      (cell-&gt;face(face)-&gt;boundary_id() == 0) )</div><div class="line">    {</div></div><!-- fragment --><p>These faces will certainly contribute to the off-diagonal blocks of the system matrix, so we ask the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object to provide us with the shape function values on this face:</p>
<div class="fragment"><div class="line">fe_face_values.reinit (cell, face);</div></div><!-- fragment --><p>Next, we loop through all DoFs of the current cell to find pairs that belong to different components and both have support on the current face:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">    <span class="keywordflow">if</span> ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first !=</div><div class="line">         fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first) &amp;&amp;</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face) &amp;&amp;</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(j, face))</div></div><!-- fragment --><p>The check whether shape functions have support on a face is not strictly necessary: if we don't check for it we would simply add up terms to the local cell matrix that happen to be zero because at least one of the shape functions happens to be zero. However, we can save that work by adding the checks above.</p>
<p>In either case, these DoFs will contribute to the boundary integrals in the off-diagonal blocks of the system matrix. To compute the integral, we loop over all the quadrature points on the face and sum up the contribution weighted with the quadrature weights that the face quadrature rule provides. In contrast to the entries on the diagonal blocks, here it does matter which one of the shape functions is a <img class="formulaInl" alt="$\psi$" src="form_2442.png"/> and which one is a <img class="formulaInl" alt="$\phi$" src="form_643.png"/>, since that will determine the sign of the entry. We account for this by a simple conditional statement that determines the correct sign. Since we already checked that DoF <img class="formulaInl" alt="$i$" src="form_90.png"/> and <img class="formulaInl" alt="$j$" src="form_513.png"/> belong to different components, it suffices here to test for one of them to which component it belongs.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">          cell_matrix(i,j) += ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first == 0) ? -1 : 1) *</div><div class="line">                              fe_face_values.shape_value(i,q_point) *</div><div class="line">                              fe_face_values.shape_value(j,q_point) *</div><div class="line">                              c *</div><div class="line">                              omega *</div><div class="line">                              fe_face_values.JxW(q_point);</div><div class="line">}</div></div><!-- fragment --><p>Now we are done with this cell and have to transfer its contributions from the local to the global system matrix. To this end, we first get a list of the global indices of the this cells DoFs...</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_indices (local_dof_indices);</div></div><!-- fragment --><p>...and then add the entries to the system matrix one by one:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">      system_matrix.add (local_dof_indices[i],</div><div class="line">                         local_dof_indices[j],</div><div class="line">                         cell_matrix(i,j));</div><div class="line">}</div></div><!-- fragment --><p>The only thing left are the Dirichlet boundary values on <img class="formulaInl" alt="$\Gamma_1$" src="form_2405.png"/>, which is characterized by the boundary indicator 1. The Dirichlet values are provided by the <code>DirichletBoundaryValues</code> class we defined above:</p>
<div class="fragment"><div class="line">  std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                            1,</div><div class="line">                                            DirichletBoundaryValues&lt;dim&gt;(),</div><div class="line">                                            boundary_values);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                      system_matrix,</div><div class="line">                                      solution,</div><div class="line">                                      system_rhs);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">          &lt;&lt; timer()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemsolvecode"></a> </p><h4><code>UltrasoundProblem::solve</code></h4>
<p>As already mentioned in the introduction, the system matrix is neither symmetric nor definite, and so it is not quite obvious how to come up with an iterative solver and a preconditioner that do a good job on this matrix. We chose instead to go a different way and solve the linear system with the sparse LU decomposition provided by UMFPACK. This is often a good first choice for 2D problems and works reasonably well even for a large number of DoFs. The deal.II interface to UMFPACK is given by the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class, which is very easy to use and allows us to solve our linear system with just 3 lines of code.</p>
<p>Note again that for compiling this example program, you need to have the deal.II library built with UMFPACK support.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">  timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div></div><!-- fragment --><p>The code to solve the linear system is short: First, we allocate an object of the right type. The following <code>initialize</code> call provides the matrix that we would like to invert to the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object, and at the same time kicks off the LU-decomposition. Hence, this is also the point where most of the computational work in this program happens.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>  A_direct;</div><div class="line">A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div></div><!-- fragment --><p>After the decomposition, we can use <code>A_direct</code> like a matrix representing the inverse of our system matrix, so to compute the solution we just have to multiply with the right hand side vector:</p>
<div class="fragment"><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a> (solution, system_rhs);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">          &lt;&lt; timer ()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemoutput_resultscode"></a> </p><h4><code>UltrasoundProblem::output_results</code></h4>
<p>Here we output our solution <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/> as well as the derived quantity <img class="formulaInl" alt="$|u|$" src="form_2439.png"/> in the format specified in the parameter file. Most of the work for deriving <img class="formulaInl" alt="$|u|$" src="form_2439.png"/> from <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/> was already done in the implementation of the <code>ComputeIntensity</code> class, so that the output routine is rather straightforward and very similar to what is done in the previous tutorials.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">  timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div></div><!-- fragment --><p>Define objects of our <code>ComputeIntensity</code> class and a <a class="el" href="classDataOut.html">DataOut</a> object:</p>
<div class="fragment"><div class="line">ComputeIntensity&lt;dim&gt; intensities;</div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div></div><!-- fragment --><p>Next we query the output-related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. The <a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">DataOut::parse_parameters</a> call acts as a counterpart to the <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> call in <code>ParameterReader::declare_parameters</code>. It collects all the output format related parameters from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and sets the corresponding properties of the <a class="el" href="classDataOut.html">DataOut</a> object accordingly.</p>
<div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::string output_file    = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Output file&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div></div><!-- fragment --><p>Now we put together the filename from the base name provided by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and the suffix which is provided by the <a class="el" href="classDataOut.html">DataOut</a> class (the default suffix is set to the right type that matches the one set in the .prm file through parse_parameters()):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string filename = output_file +</div><div class="line">                             data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>();</div><div class="line"></div><div class="line">std::ofstream output (filename.c_str());</div></div><!-- fragment --><p>The solution vectors <img class="formulaInl" alt="$v$" src="form_987.png"/> and <img class="formulaInl" alt="$w$" src="form_859.png"/> are added to the <a class="el" href="classDataOut.html">DataOut</a> object in the usual way:</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names;</div><div class="line">solution_names.push_back (<span class="stringliteral">&quot;Re_u&quot;</span>);</div><div class="line">solution_names.push_back (<span class="stringliteral">&quot;Im_u&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, solution_names);</div></div><!-- fragment --><p>For the intensity, we just call <code>add_data_vector</code> again, but this with our <code>ComputeIntensity</code> object as the second argument, which effectively adds <img class="formulaInl" alt="$|u|$" src="form_2439.png"/> to the output data:</p>
<div class="fragment"><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, intensities);</div></div><!-- fragment --><p>The last steps are as before. Note that the actual output format is now determined by what is stated in the input file, i.e. one can change the output format without having to re-compile this program:</p>
<div class="fragment"><div class="line">  data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a> (output);</div><div class="line"></div><div class="line">  timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">  deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">          &lt;&lt; timer()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeUltrasoundProblemruncode"></a> </p><h4><code>UltrasoundProblem::run</code></h4>
<p>Here we simply execute our functions one after the other:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid ();</div><div class="line">    setup_system ();</div><div class="line">    assemble_system ();</div><div class="line">    solve ();</div><div class="line">    output_results ();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h4>The <code>main</code> function</h4>
<p>Finally the <code>main</code> function of the program. It has the same structure as in almost all of the other tutorial programs. The only exception is that we define <a class="el" href="classParameterHandler.html">ParameterHandler</a> and <code>ParameterReader</code> objects, and let the latter read in the parameter values from a textfile called <code><a class="el" href="step_29.html">step-29</a>.prm</code>. The values so read are then handed over to an instance of the UltrasoundProblem class:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step29;</div><div class="line"></div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(5);</div><div class="line"></div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a>  prm;</div><div class="line">      ParameterReader   param(prm);</div><div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div><div class="line"></div><div class="line">      UltrasoundProblem&lt;2&gt;  ultrasound_problem (prm);</div><div class="line">      ultrasound_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The current program reads its run-time parameters from an input file called <code>step-29.prm</code> that looks like this: </p><div class="fragment"><div class="line">subsection Mesh &amp; geometry parameters</div><div class="line"><span class="preprocessor">  # Distance of the focal point of the lens to the x-axis</span></div><div class="line">  <span class="keyword">set</span> Focal distance        = 0.3</div><div class="line"></div><div class="line">  # Number of global mesh refinement steps applied to <a class="code" href="namespaceAlgorithms_1_1Events.html#a15a12dfdadd39a026d192ad96cb6207b">initial</a> coarse grid</div><div class="line">  <span class="keyword">set</span> Number of refinements = 5</div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line">subsection Physical constants</div><div class="line"><span class="preprocessor">  # Wave speed</span></div><div class="line">  <span class="keyword">set</span> c     = 1.5e5</div><div class="line"></div><div class="line"><span class="preprocessor">  # Frequency</span></div><div class="line">  <span class="keyword">set</span> omega = 3.0e7</div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line">subsection Output parameters</div><div class="line"><span class="preprocessor">  # Name of the output file (without extension)</span></div><div class="line">  <span class="keyword">set</span> Output file   = solution</div><div class="line"></div><div class="line"><span class="preprocessor">  # A name for the output format to be used</span></div><div class="line">  <span class="keyword">set</span> Output format = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line">end</div></div><!-- fragment --><p>As can be seen, we set <img class="formulaInl" alt="$d=0.3$" src="form_2443.png"/>, which amounts to a focus of the transducer lens at <img class="formulaInl" alt="$x=0.5$" src="form_2444.png"/>, <img class="formulaInl" alt="$y=0.3$" src="form_2445.png"/>. The coarse mesh is refined 5 times, resulting in 160x160 cells, and the output is written in vtu format. The parameter reader understands many more parameters pertaining in particular to the generation of output, see the explanation in <a class="el" href="step_19.html">step-19</a>, but we need none of these parameters here and therefore stick with their default values.</p>
<p>Here's the console output of the program in debug mode:</p>
<div class="fragment"><div class="line">examples/step-29&gt; make run</div><div class="line">============================ Running step-29</div><div class="line">DEAL::Generating grid... done (1.11607s)</div><div class="line">DEAL::  Number of active cells:  25600</div><div class="line">DEAL::Setting up system... done (1.10807s)</div><div class="line">DEAL::  Number of degrees of freedom: 51842</div><div class="line">DEAL::Assembling system matrix... done (6.50841s)</div><div class="line">DEAL::Solving linear system... done (2.89218s)</div><div class="line">DEAL::Generating output... done (4.52428s)</div></div><!-- fragment --><p>(Of course, execution times will differ if you run the program locally.) The fact that most of the time is spent on assembling the system matrix and generating output is due to the many assertion that need to be checked in debug mode. In release mode these parts of the program run much faster whereas solving the linear system is hardly sped up at all:</p>
<div class="fragment"><div class="line">============================ Running step-29</div><div class="line">DEAL::Generating grid... done (0.0280020s)</div><div class="line">DEAL::  Number of active cells:  25600</div><div class="line">DEAL::Setting up system... done (0.112007s)</div><div class="line">DEAL::  Number of degrees of freedom: 51842</div><div class="line">DEAL::Assembling system matrix... done (0.160010s)</div><div class="line">DEAL::Solving linear system... done (2.21614s)</div><div class="line">DEAL::Generating output... done (0.880055s)</div></div><!-- fragment --><p>The graphical output of the program looks as follows:</p>
<table align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.v.png" alt="v = Re(u)"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.w.png" alt="w = Im(u)"/>
</div>
  <p class="endtd"></p>
</td></tr>
<tr>
<td colspan="2"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.intensity.png" alt="|u|"/>
</div>
   </td></tr>
</table>
<p>The first two pictures show the real and imaginary parts of <img class="formulaInl" alt="$u$" src="form_256.png"/>, whereas the last shows the intensity <img class="formulaInl" alt="$|u|$" src="form_2439.png"/>. One can clearly see that the intensity is focussed around the focal point of the lens (0.5, 0.3), and that the focus is rather sharp in <img class="formulaInl" alt="$x$" src="form_9.png"/>-direction but more blurred in <img class="formulaInl" alt="$y$" src="form_10.png"/>-direction, which is a consequence of the geometry of the focusing lens, its finite aperture, and the wave nature of the problem.</p>
<p>Because colorful graphics are always fun, and to stress the focusing effects some more, here is another set of images highlighting how well the intensity is actually focused in <img class="formulaInl" alt="$x$" src="form_9.png"/>-direction:</p>
<table align="center" border="1" cellspacing="3" cellpadding="3">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.surface.png" alt="|u|"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-29.contours.png" alt="|u|"/>
</div>
   </td></tr>
</table>
<p>As a final note, the structure of the program makes it easy to determine which parts of the program scale nicely as the mesh is refined and which parts don't. Here are the run times for 5, 6, and 7 global refinements:</p>
<div class="fragment"><div class="line">DEAL::Generating grid... done (0.0320020s)</div><div class="line">DEAL::  Number of active cells:  25600</div><div class="line">DEAL::Setting up system... done (0.104006s)</div><div class="line">DEAL::  Number of degrees of freedom: 51842</div><div class="line">DEAL::Assembling system matrix... done (0.164011s)</div><div class="line">DEAL::Solving linear system... done (2.23214s)</div><div class="line">DEAL::Generating output... done (0.900056s)</div><div class="line"></div><div class="line">DEAL::Generating grid... done (0.132009s)</div><div class="line">DEAL::  Number of active cells:  102400</div><div class="line">DEAL::Setting up system... done (0.408025s)</div><div class="line">DEAL::  Number of degrees of freedom: 206082</div><div class="line">DEAL::Assembling system matrix... done (0.656041s)</div><div class="line">DEAL::Solving linear system... done (14.8849s)</div><div class="line">DEAL::Generating output... done (3.57222s)</div><div class="line"></div><div class="line">DEAL::Generating grid... done (0.504031s)</div><div class="line">DEAL::  Number of active cells:  409600</div><div class="line">DEAL::Setting up system... done (1.72011s)</div><div class="line">DEAL::  Number of degrees of freedom: 821762</div><div class="line">DEAL::Assembling system matrix... done (2.63216s)</div><div class="line">DEAL::Solving linear system... done (117.811s)</div><div class="line">DEAL::Generating output... done (15.1489s)</div></div><!-- fragment --><p>Each time we refine the mesh once, so the number of cells and degrees of freedom roughly quadruples from each step to the next. As can be seen, generating the grid, setting up degrees of freedom, assembling the linear system, and generating output scale pretty closely to linear, whereas solving the linear system is an operation that requires 8 times more time each time the number of degrees of freedom is increased by a factor of 4, i.e. it is <img class="formulaInl" alt="${\cal O}(N^{3/2})$" src="form_2446.png"/>. This can be explained by the fact that (using optimal ordering) the bandwidth of a finite element matrix is <img class="formulaInl" alt="$B={\cal O}(N^{(dim-1)/dim})$" src="form_2447.png"/>, and the effort to solve a banded linear system using LU decomposition is <img class="formulaInl" alt="${\cal O}(BN)$" src="form_2448.png"/>. This also explains why the program does run in 3d as well (after changing the dimension on the <code>UltrasoundProblem</code> object), but scales very badly and takes extraordinary patience before it finishes solving the linear system on a mesh with appreciable resolution, even though all the other parts of the program scale very nicely.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>An obvious possible extension for this program is to run it in 3d &mdash; after all, the world around us is three-dimensional, and ultrasound beams propagate in three-dimensional media. You can try this by simply changing the template parameter of the principal class in <code>main()</code> and running it. This won't get you very far, though: certainly not if you do 5 global refinement steps as set in the parameter file. You'll simply run out of memory as both the mesh (with its <img class="formulaInl" alt="$(2^5)^3 \cdot 5^3=2^{15}\cdot 125 \approx 4\cdot 10^6$" src="form_2449.png"/> cells) and in particular the sparse direct solver take too much memory. You can solve with 3 global refinement steps, however, if you have a bit of time: in early 2011, the direct solve takes about half an hour. What you'll notice, however, is that the solution is completely wrong: the mesh size is simply not small enough to resolve the solution's waves accurately, and you can see this in plots of the solution. Consequently, this is one of the cases where adaptivity is indispensable if you don't just want to throw a bigger (presumably parallel) machine at the problem. <a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2007 - 2016 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Moritz Allmaras, Texas A&amp;M University, 2007</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/quadrature_lib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/logstream.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/full_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/grid_generator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/tria_iterator.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/grid/manifold_lib.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_handler.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_accessor.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/dofs/dof_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_q.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_values.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/matrix_tools.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/data_out.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/numerics/vector_tools.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/parameter_handler.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/sparse_direct.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/fe/fe_system.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;deal.II/base/timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step29</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>DirichletBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    DirichletBoundaryValues() : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; (2) {};</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">inline</span></div><div class="line">  <span class="keywordtype">void</span> DirichletBoundaryValues&lt;dim&gt;::vector_value (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;<span class="comment">/*p*/</span>,</div><div class="line">                                                   <a class="code" href="classVector.html">Vector&lt;double&gt;</a>   &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>() == 2, <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (values.<a class="code" href="classVector.html#a8005bf1ec399c608c3755c1d22960add">size</a>(), 2));</div><div class="line"></div><div class="line">    values(0) = 1;</div><div class="line">    values(1) = 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> DirichletBoundaryValues&lt;dim&gt;::vector_value_list (<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &gt; &amp;points,</div><div class="line">                                                        std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;   &amp;value_list)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (value_list.size() == points.size(),</div><div class="line">            <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (value_list.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p=0; p&lt;points.size(); ++p)</div><div class="line">      DirichletBoundaryValues&lt;dim&gt;::vector_value (points[p], value_list[p]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>ParameterReader : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">    <span class="keywordtype">void</span> read_parameters(<span class="keyword">const</span> std::string);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> declare_parameters();</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm;</div><div class="line">  };</div><div class="line"></div><div class="line">  ParameterReader::ParameterReader(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;paramhandler)</div><div class="line">    :</div><div class="line">    prm(paramhandler)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> ParameterReader::declare_parameters()</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Number of global mesh refinement steps &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;applied to initial coarse grid&quot;</span>);</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>, <span class="stringliteral">&quot;0.3&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Distance of the focal point of the lens &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;to the x-axis&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;1.5e5&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Wave speed&quot;</span>);</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;omega&quot;</span>, <span class="stringliteral">&quot;5.0e7&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;Frequency&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#afb951f101e0969416f7f47d24c03bcfa">declare_entry</a>(<span class="stringliteral">&quot;Output file&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                        <span class="stringliteral">&quot;Name of the output file (without extension)&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">DataOutInterface&lt;1&gt;::declare_parameters</a> (prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> ParameterReader::read_parameters (<span class="keyword">const</span> std::string parameter_file)</div><div class="line">  {</div><div class="line">    declare_parameters();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a4f067f0a84ac392fe26d553aea50541b">parse_input</a> (parameter_file);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComputeIntensity : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComputeIntensity ();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    evaluate_vector_field</div><div class="line">    (<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">     std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;               &amp;computed_quantities) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComputeIntensity&lt;dim&gt;::ComputeIntensity ()</div><div class="line">    :</div><div class="line">    <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt; (<span class="stringliteral">&quot;Intensity&quot;</span>,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  ComputeIntensity&lt;dim&gt;::evaluate_vector_field</div><div class="line">  (<span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">   std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &gt;               &amp;computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (computed_quantities.size(), inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;computed_quantities.size(); i++)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[i].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (computed_quantities[i].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a> (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i].size(), 2));</div><div class="line"></div><div class="line">        computed_quantities[i](0)</div><div class="line">          = std::sqrt(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0)*inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](0)</div><div class="line">                      + inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1)*inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[i](1));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>UltrasoundProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    UltrasoundProblem (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;);</div><div class="line">    ~UltrasoundProblem ();</div><div class="line">    <span class="keywordtype">void</span> run ();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid ();</div><div class="line">    <span class="keywordtype">void</span> setup_system ();</div><div class="line">    <span class="keywordtype">void</span> assemble_system ();</div><div class="line">    <span class="keywordtype">void</span> solve ();</div><div class="line">    <span class="keywordtype">void</span> output_results () <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a>      &amp;prm;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>     triangulation;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>        dof_handler;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>          fe;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>        sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>   system_matrix;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>         solution, system_rhs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  UltrasoundProblem&lt;dim&gt;::UltrasoundProblem (<a class="code" href="classParameterHandler.html">ParameterHandler</a>  &amp;param)</div><div class="line">    :</div><div class="line">    prm(param),</div><div class="line">    dof_handler(triangulation),</div><div class="line">    fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), 2)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  UltrasoundProblem&lt;dim&gt;::~UltrasoundProblem ()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::make_grid ()</div><div class="line">  {</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Generating grid... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">    timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Mesh &amp; geometry parameters&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                focal_distance = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Focal distance&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_refinements  = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Number of refinements&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>    transducer = (dim == 2) ?</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (0.5, 0.0) :</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (0.5, 0.5, 0.0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>   focal_point = (dim == 2) ?</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (0.5, focal_distance) :</div><div class="line">                                     <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> (0.5, 0.5, focal_distance);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#adc5d7022d456db0356f11427473f4f76">GridGenerator::subdivided_hyper_cube</a> (triangulation, 5, 0, 1);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line">    cell = triangulation.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a> (),</div><div class="line">    endc = triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">        <span class="keywordflow">if</span> ( cell-&gt;face(face)-&gt;at_boundary() &amp;&amp;</div><div class="line">             ((cell-&gt;face(face)-&gt;center() - transducer).norm_square() &lt; 0.01) )</div><div class="line">          {</div><div class="line"></div><div class="line">            cell-&gt;face(face)-&gt;set_boundary_id (1);</div><div class="line">            cell-&gt;face(face)-&gt;set_manifold_id (1);</div><div class="line">          }</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> boundary(focal_point);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, boundary);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (n_refinements);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">            &lt;&lt; timer()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:  &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::setup_system ()</div><div class="line">  {</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Setting up system... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">    timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a> (fe);</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#ga38d88a1a559e9fc65d60f3e168921ba5">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a> (dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit (sparsity_pattern);</div><div class="line">    system_rhs.reinit (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">            &lt;&lt; timer()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::assemble_system ()</div><div class="line">  {</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Assembling system matrix... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">    timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div><div class="line"></div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Physical constants&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;omega&quot;</span>),</div><div class="line">                 c     = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>    quadrature_formula(2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim-1&gt;  face_quadrature_formula(2);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points       = quadrature_formula.size(),</div><div class="line">                       n_face_q_points  = face_quadrature_formula.size(),</div><div class="line">                       dofs_per_cell    = fe.<a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>  fe_values (fe, quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values (fe, face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix (dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">    cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">    endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">      {</div><div class="line"></div><div class="line">        cell_matrix = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#aec8f5b8b3e4c5dcf35dfd029a1ecbbd0">reinit</a> (cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first ==</div><div class="line">                    fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first)</div><div class="line">                  {</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">                      cell_matrix(i,j) += (((fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i,q_point) *</div><div class="line">                                             fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j,q_point)) *</div><div class="line">                                            (- omega * omega)</div><div class="line">                                            +</div><div class="line">                                            (fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(i,q_point) *</div><div class="line">                                             fe_values.<a class="code" href="classFEValuesBase.html#a07e7840de879ca71f64e6a371e3c66bb">shape_grad</a>(j,q_point)) *</div><div class="line">                                            c * c) *</div><div class="line">                                           fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;face(face)-&gt;at_boundary() &amp;&amp;</div><div class="line">              (cell-&gt;face(face)-&gt;boundary_id() == 0) )</div><div class="line">            {</div><div class="line"></div><div class="line"></div><div class="line">              fe_face_values.<a class="code" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (cell, face);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">                  <span class="keywordflow">if</span> ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first !=</div><div class="line">                       fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(j).first) &amp;&amp;</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(i, face) &amp;&amp;</div><div class="line">                      fe.<a class="code" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">has_support_on_face</a>(j, face))</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_face_q_points; ++q_point)</div><div class="line">                      cell_matrix(i,j) += ((fe.<a class="code" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a>(i).first == 0) ? -1 : 1) *</div><div class="line">                                          fe_face_values.shape_value(i,q_point) *</div><div class="line">                                          fe_face_values.shape_value(j,q_point) *</div><div class="line">                                          c *</div><div class="line">                                          omega *</div><div class="line">                                          fe_face_values.JxW(q_point);</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            system_matrix.add (local_dof_indices[i],</div><div class="line">                               local_dof_indices[j],</div><div class="line">                               cell_matrix(i,j));</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index,double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a187aeb575be07bc47cb3dea1a47aaf88">VectorTools::interpolate_boundary_values</a> (dof_handler,</div><div class="line">                                              1,</div><div class="line">                                              DirichletBoundaryValues&lt;dim&gt;(),</div><div class="line">                                              boundary_values);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a> (boundary_values,</div><div class="line">                                        system_matrix,</div><div class="line">                                        solution,</div><div class="line">                                        system_rhs);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">            &lt;&lt; timer()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::solve ()</div><div class="line">  {</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Solving linear system... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">    timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>  A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line"></div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a> (solution, system_rhs);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">            &lt;&lt; timer ()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;Generating output... &quot;</span>;</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line">    timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a> ();</div><div class="line"></div><div class="line">    ComputeIntensity&lt;dim&gt; intensities;</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ac1eb26168177faa30ffbcf9cbb9c3cd5">attach_dof_handler</a> (dof_handler);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Output parameters&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string output_file    = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Output file&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a>(prm);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = output_file +</div><div class="line">                                 data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>();</div><div class="line"></div><div class="line">    std::ofstream output (filename.c_str());</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names;</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;Re_u&quot;</span>);</div><div class="line">    solution_names.push_back (<span class="stringliteral">&quot;Im_u&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, solution_names);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#ace4b76e565ba0701c4d32c26075ed3b9">add_data_vector</a> (solution, intensities);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a5eb51872b8736849bb7e8d2007fae086">build_patches</a> ();</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a> (output);</div><div class="line"></div><div class="line">    timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a> ();</div><div class="line">    deallog &lt;&lt; <span class="stringliteral">&quot;done (&quot;</span></div><div class="line">            &lt;&lt; timer()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> UltrasoundProblem&lt;dim&gt;::run ()</div><div class="line">  {</div><div class="line">    make_grid ();</div><div class="line">    setup_system ();</div><div class="line">    assemble_system ();</div><div class="line">    solve ();</div><div class="line">    output_results ();</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step29;</div><div class="line"></div><div class="line">      deallog.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(5);</div><div class="line"></div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a>  prm;</div><div class="line">      ParameterReader   param(prm);</div><div class="line">      param.read_parameters(<span class="stringliteral">&quot;step-29.prm&quot;</span>);</div><div class="line"></div><div class="line">      UltrasoundProblem&lt;2&gt;  ultrasound_problem (prm);</div><div class="line">      ultrasound_problem.run ();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
